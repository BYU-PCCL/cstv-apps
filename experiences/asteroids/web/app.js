/******/ (function() { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

//HTML Modules

/***/ "./src/app.html":
/*!**********************!*\
  !*** ./src/app.html ***!
  \**********************/
/***/ (function(module) {

// Module
var code = "<header class=\"header\">\
  <Breadcrumb></Breadcrumb>\
  <AsteroidMenuTop></AsteroidMenuTop>\
  <Search></Search>\
</header>\
<HomeButton></HomeButton>\
<WatchPanel></WatchPanel>\
<AsteroidPanel></AsteroidPanel>\
<MissionPanel></MissionPanel>\
<FollowingPanel></FollowingPanel>\
<Story></Story>\
<div id=\"float-mid\" class=\"float-mid\"></div>\
<div id=\"float-mid-bottom\" class=\"float-mid-bottom\">\
	<div id=\"time-slider-container\" class=\"time-container\">\
		<ClockShortcut></ClockShortcut>\
		<Clock></Clock>\
		<TimeSlider></TimeSlider>\
	</div>\
	<AsteroidMenuBottom></AsteroidMenuBottom>\
</div>\
<div id=\"float-right-bottom\" class=\"float-right-bottom\">\
  <LayerPanel></LayerPanel>\
  <AsteroidsSettings></AsteroidsSettings>\
</div>\
<AsteroidModals></AsteroidModals>\
<DefinitionOverlay></DefinitionOverlay>\
<SplashScreen></SplashScreen>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/asteroid_modals/asteroid_modals.html":
/*!*************************************************************!*\
  !*** ./src/components/asteroid_modals/asteroid_modals.html ***!
  \*************************************************************/
/***/ (function(module) {

// Module
var code = "<div id=\"asteroid-modals\" class=\"{{isVisibleClass}}\">\
  <div class=\"asteroid-modals-backdrop\" onclick=\"close\"></div>\
  <div class=\"asteroid-modal\">\
    <div key=\"header\" class=\"asteroid-modal-header\">\
      <h3 class=\"asteroid-modal-title\">{{title}}</h3>\
      <div class=\"asteroid-modal-close\" onclick=\"close\">\
        <span class=\"icon icon-close clickable\"></span>\
      </div>\
      <div class=\"asteroid-modal-collapse\" onclick=\"close\">\
        <svg width=\"22\" height=\"22\" viewBox=\"0 0 22 22\" fill=\"none\">\
          <path\
            d=\"M14.234 8.4695L11 11.7035L7.766 8.4695L6.275 9.95L11 14.675L15.725 9.95L14.234 8.4695ZM11 0.5C5.204 0.5 0.5 5.204 0.5 11C0.5 16.796 5.204 21.5 11 21.5C16.796 21.5 21.5 16.796 21.5 11C21.5 5.204 16.796 0.5 11 0.5ZM11 19.4C6.359 19.4 2.6 15.641 2.6 11C2.6 6.359 6.359 2.6 11 2.6C15.641 2.6 19.4 6.359 19.4 11C19.4 15.641 15.641 19.4 11 19.4Z\"\
            fill=\"currentColor\" />\
        </svg>\
      </div>\
    </div>\
    <div class=\"asteroid-modal-content scrollable\">\
      <FiltersModal></FiltersModal>\
      <LearnModal></LearnModal>\
    </div>\
  </div>\
</div>";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/asteroid_modals/modals/filters_modal/filters_modal.html":
/*!********************************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/filters_modal/filters_modal.html ***!
  \********************************************************************************/
/***/ (function(module) {

// Module
var code = "<div key=\"filtersModal\" class=\"filters-modal {{isVisibleClass}}\">\
  <h4 class=\"filters-modal-description\">\
    Apply a variety of filters to visualize the different groups of astronomical\
    objects\
  </h4>\
  <div class=\"filters-modal-body\">\
    <div class=\"filters-section\">\
      <div class=\"filters-section-h\">Composition</div>\
      <div class=\"filters-section-content\">\
        <div class=\"filters-section-item\">\
          <div class=\"filters-section-h2\">\
            <div>\
              <div>Asteroids</div>\
              <div\
                class=\"filters-help\"\
                data-def=\"asteroid\"\
                onclick=\"handleHelp\"\
              >\
                <svg width=\"18\" height=\"18\" viewBox=\"0 0 14 14\" fill=\"none\">\
                  <path\
                    d=\"M7.8127 8.62501H6.1877C6.1877 7.00001 7.1627 6.51251 7.8127 6.18751C8.05645 6.10626 8.21895 6.02501 8.38144 5.86251C8.4627 5.78126 8.6252 5.61876 8.4627 5.29376C8.3002 4.88751 7.8127 4.48126 7.08145 4.48126C5.94395 4.48126 5.78145 5.45626 5.7002 5.70001L4.0752 5.45626C4.15645 4.56251 4.8877 2.85626 7.0002 2.85626C8.3002 2.85626 9.4377 3.58751 9.9252 4.64376C10.2502 5.53751 10.0877 6.43126 9.4377 7.08126C9.1127 7.40626 8.7877 7.56876 8.4627 7.65001C7.9752 7.97501 7.8127 7.81251 7.8127 8.62501Z\"\
                    fill=\"currentColor\"\
                  />\
                  <path\
                    d=\"M7 1.3125C10.1687 1.3125 12.6875 3.83125 12.6875 7C12.6875 10.1687 10.1687 12.6875 7 12.6875C3.83125 12.6875 1.3125 10.1687 1.3125 7C1.3125 3.83125 3.83125 1.3125 7 1.3125ZM7 0.5C3.425 0.5 0.5 3.425 0.5 7C0.5 10.575 3.425 13.5 7 13.5C10.575 13.5 13.5 10.575 13.5 7C13.5 3.425 10.575 0.5 7 0.5Z\"\
                    fill=\"currentColor\"\
                  />\
                  <path\
                    d=\"M6.10645 9.4375H7.73145V11.0625H6.10645V9.4375Z\"\
                    fill=\"currentColor\"\
                  />\
                </svg>\
              </div>\
            </div>\
            <div>Made up of rock, metals and dust</div>\
          </div>\
          <div>\
            <div class=\"eyes-checkbox\">\
              <input\
                type=\"checkbox\"\
                id=\"filters-asteroids-checkbox\"\
                onclick=\"handleAsteroidCheck\"\
              />\
              <label for=\"filters-asteroids-checkbox\"></label>\
            </div>\
          </div>\
        </div>\
\
        <div class=\"filters-section-item\">\
          <div class=\"filters-section-h2\">\
            <div>\
              <div>Comets</div>\
              <div class=\"filters-help\" data-def=\"comet\" onclick=\"handleHelp\">\
                <svg width=\"18\" height=\"18\" viewBox=\"0 0 14 14\" fill=\"none\">\
                  <path\
                    d=\"M7.8127 8.62501H6.1877C6.1877 7.00001 7.1627 6.51251 7.8127 6.18751C8.05645 6.10626 8.21895 6.02501 8.38144 5.86251C8.4627 5.78126 8.6252 5.61876 8.4627 5.29376C8.3002 4.88751 7.8127 4.48126 7.08145 4.48126C5.94395 4.48126 5.78145 5.45626 5.7002 5.70001L4.0752 5.45626C4.15645 4.56251 4.8877 2.85626 7.0002 2.85626C8.3002 2.85626 9.4377 3.58751 9.9252 4.64376C10.2502 5.53751 10.0877 6.43126 9.4377 7.08126C9.1127 7.40626 8.7877 7.56876 8.4627 7.65001C7.9752 7.97501 7.8127 7.81251 7.8127 8.62501Z\"\
                    fill=\"currentColor\"\
                  />\
                  <path\
                    d=\"M7 1.3125C10.1687 1.3125 12.6875 3.83125 12.6875 7C12.6875 10.1687 10.1687 12.6875 7 12.6875C3.83125 12.6875 1.3125 10.1687 1.3125 7C1.3125 3.83125 3.83125 1.3125 7 1.3125ZM7 0.5C3.425 0.5 0.5 3.425 0.5 7C0.5 10.575 3.425 13.5 7 13.5C10.575 13.5 13.5 10.575 13.5 7C13.5 3.425 10.575 0.5 7 0.5Z\"\
                    fill=\"currentColor\"\
                  />\
                  <path\
                    d=\"M6.10645 9.4375H7.73145V11.0625H6.10645V9.4375Z\"\
                    fill=\"currentColor\"\
                  />\
                </svg>\
              </div>\
            </div>\
            <div>Made up of rock, dust and frozen ices</div>\
          </div>\
          <div>\
            <div class=\"eyes-checkbox\">\
              <input\
                type=\"checkbox\"\
                id=\"filters-comets-checkbox\"\
                onclick=\"handleCometCheck\"\
              />\
              <label for=\"filters-comets-checkbox\"></label>\
            </div>\
          </div>\
        </div>\
      </div>\
    </div>\
    <div class=\"filters-section\">\
      <div class=\"filters-section-h\">Potential Threats</div>\
      <div class=\"filters-section-content\">\
        <div class=\"filters-section-item\">\
          <div class=\"filters-section-h2\">\
            <div>\
              <div>PHOs</div>\
              <div class=\"filters-help\" data-def=\"pho\" onclick=\"handleHelp\">\
                <svg width=\"18\" height=\"18\" viewBox=\"0 0 14 14\" fill=\"none\">\
                  <path\
                    d=\"M7.8127 8.62501H6.1877C6.1877 7.00001 7.1627 6.51251 7.8127 6.18751C8.05645 6.10626 8.21895 6.02501 8.38144 5.86251C8.4627 5.78126 8.6252 5.61876 8.4627 5.29376C8.3002 4.88751 7.8127 4.48126 7.08145 4.48126C5.94395 4.48126 5.78145 5.45626 5.7002 5.70001L4.0752 5.45626C4.15645 4.56251 4.8877 2.85626 7.0002 2.85626C8.3002 2.85626 9.4377 3.58751 9.9252 4.64376C10.2502 5.53751 10.0877 6.43126 9.4377 7.08126C9.1127 7.40626 8.7877 7.56876 8.4627 7.65001C7.9752 7.97501 7.8127 7.81251 7.8127 8.62501Z\"\
                    fill=\"currentColor\"\
                  />\
                  <path\
                    d=\"M7 1.3125C10.1687 1.3125 12.6875 3.83125 12.6875 7C12.6875 10.1687 10.1687 12.6875 7 12.6875C3.83125 12.6875 1.3125 10.1687 1.3125 7C1.3125 3.83125 3.83125 1.3125 7 1.3125ZM7 0.5C3.425 0.5 0.5 3.425 0.5 7C0.5 10.575 3.425 13.5 7 13.5C10.575 13.5 13.5 10.575 13.5 7C13.5 3.425 10.575 0.5 7 0.5Z\"\
                    fill=\"currentColor\"\
                  />\
                  <path\
                    d=\"M6.10645 9.4375H7.73145V11.0625H6.10645V9.4375Z\"\
                    fill=\"currentColor\"\
                  />\
                </svg>\
              </div>\
            </div>\
            <div>Potentially hazardous objects</div>\
          </div>\
          <div>\
            <div class=\"eyes-toggle\">\
              <input\
                type=\"checkbox\"\
                id=\"filters-phos-toggle\"\
                onclick=\"handlePHOToggle\"\
              />\
              <label for=\"filters-phos-toggle\"></label>\
            </div>\
          </div>\
        </div>\
      </div>\
    </div>\
  </div>\
\
  <div class=\"filters-modal-footer\">\
    <div class=\"filters-modal-count\"></div>\
    <button class=\"filters-modal-reset\" onclick=\"handleResetFilters\">\
      Clear all filters\
    </button>\
  </div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/asteroid_modals/modals/learn_modal/learn_modal.html":
/*!****************************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/learn_modal/learn_modal.html ***!
  \****************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"learn-modal {{isVisibleClass}}\">\
  <h4 class=\"learn-modal-description\">\
    Take a deeper dive into Asteroids with our interactive scrollable stories\
  </h4>\
  <div\
    key=\"asteroidLearnModalBody\"\
    id=\"asteroid-learn-modal-body\"\
    class=\"learn-modal-body\"\
  ></div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/countdown/countdown.html":
/*!*************************************************!*\
  !*** ./src/components/countdown/countdown.html ***!
  \*************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"countdown {{isVisibleClass}}\">\
	<span class=\"countdown-title small semi\">COUNTDOWN</span>\
	<div class=\"digits-container\">\
		<h5 class=\"digit t-text semi\">{{tText}}</h5>\
		<div class=\"digit-block days\">\
			<h3 class=\"digit\">{{numDays}}</h3>\
			<span class=\"digit-unit tiny semi\">DAYS</span>\
		</div>\
		<h4 class=\"digit digit-colon semi\">:</h4>\
		<div class=\"digit-block hours\">\
			<h3 class=\"digit\">{{numHours}}</h3>\
			<span class=\"digit-unit tiny semi\">HOURS</span>\
		</div>\
		<h4 class=\"digit digit-colon semi\">:</h4>\
		<div class=\"digit-block minutes\">\
			<h3 class=\"digit\">{{numMinutes}}</h3>\
			<span class=\"digit-unit tiny semi\">MINUTES</span>\
		</div>\
		<h4 class=\"digit digit-colon semi\">:</h4>\
		<div class=\"digit-block seconds\">\
			<h3 class=\"digit\">{{numSeconds}}</h3>\
			<span class=\"digit-unit tiny semi\">SECONDS</span>\
		</div>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/definition_overlay/definition_overlay.html":
/*!*******************************************************************!*\
  !*** ./src/components/definition_overlay/definition_overlay.html ***!
  \*******************************************************************/
/***/ (function(module) {

// Module
var code = "<div id=\"definition-overlay\" class=\"definition-overlay {{isVisibleClass}}\" onclick=\"_handleOutsideClick\">\
	<div class=\"definition-container\" onclick=\"_handleContainerClick\">\
		<div class=\"definition-header\">\
			<div class=\"definition-info\"><span class=\"icon icon-info\"></span></div>\
			<h4 class=\"definition-title\">{{title}}</h4>\
			<div class=\"definition-close\" onclick=\"_handleOutsideClick\"><span class=\"icon icon-close clickable\"></span></div>\
		</div>\
		<div class=\"definition-content os-host-flexbox scrollable\" key=\"contentEl\">{{content}}</div>\
		<div class=\"definition-footer\">\
			<div class=\"definition-divider\"><span class=\"x-small\">RELATED TERMS</span></div>\
			<div class=\"definition-related\" key=\"relatedEl\"></div>\
		</div>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/navigation/navigation.html":
/*!***************************************************!*\
  !*** ./src/components/navigation/navigation.html ***!
  \***************************************************/
/***/ (function(module) {

// Module
var code = "<nav key=\"list\" class=\"navigation menu-div {{position}} {{isVisibleClass}}\"></nav>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/splash_screen/splash_screen.html":
/*!*********************************************************!*\
  !*** ./src/components/splash_screen/splash_screen.html ***!
  \*********************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"splash-screen\" key=\"splashScreen\">\
	<div class=\"splash-screen-wrapper\">\
		<div class=\"splash-screen-stars1\" key=\"splashScreenStars1\"></div>\
		<div class=\"splash-screen-stars2\" key=\"splashScreenStars2\"></div>\
		<div class=\"splash-screen-asteroid\" key=\"splashScreenAsteroid\"></div>\
		<div class=\"splash-screen-logo\" key=\"splashScreenLogo\"></div>\
		<div class=\"splash-screen-text\" key=\"splashScreenText\">\
			<div key=\"splashScreenTextEyes\">Eyes</div>\
			<div key=\"splashScreenTextOn\">on</div>\
			<div key=\"splashScreenTextAsteroids\">Asteroids</div>\
		</div>\
		<div class=\"splash-screen-enter-background\" key=\"splashScreenEnterBackground\"></div>\
		<div class=\"splash-screen-enter\" key=\"splashScreenEnter\">\
			<div class=\"splash-screen-swipe\">\
				<div class=\"splash-screen-swipe-text\"></div>\
				<div class=\"splash-screen-swipe-arrow\" key=\"splashScreenSwipeArrow\">\
					<svg width=\"67\" height=\"31\" viewBox=\"0 0 67 31\" fill=\"none\">\
						<path d=\"M53.8254 1.02176C54.1822 0.794206 54.6633 0.666626 55.1646 0.666626C55.6659 0.666626 56.147 0.794206 56.5038 1.02176C56.6796 1.13365 56.8192 1.26703 56.9145 1.41413C57.0097 1.56122 57.0588 1.7191 57.0588 1.87857C57.0588 2.03804 57.0097 2.19592 56.9145 2.34302C56.8192 2.49011 56.6796 2.62349 56.5038 2.73539L34.8686 16.5823C34.5118 16.8099 34.0307 16.9375 33.5294 16.9375C33.0281 16.9375 32.547 16.8099 32.1902 16.5823L10.555 2.73539C10.3792 2.62349 10.2396 2.49011 10.1444 2.34302C10.0491 2.19592 10 2.03804 10 1.87857C10 1.7191 10.0491 1.56122 10.1444 1.41413C10.2396 1.26703 10.3792 1.13365 10.555 1.02176C10.9118 0.794206 11.3929 0.666626 11.8942 0.666626C12.3955 0.666626 12.8766 0.794206 13.2334 1.02176L33.5308 13.6502L53.8254 1.02176Z\" fill=\"currentColor\" fill-opacity=\"0.8\"/>\
						<path d=\"M61.8921 8.43787C62.3908 8.12383 63.0632 7.94775 63.7638 7.94775C64.4643 7.94775 65.1367 8.12383 65.6354 8.43787C65.881 8.5923 66.0761 8.77637 66.2093 8.97938C66.3424 9.18238 66.411 9.40027 66.411 9.62035C66.411 9.84044 66.3424 10.0583 66.2093 10.2613C66.0761 10.4643 65.881 10.6484 65.6354 10.8028L35.3989 29.9129C34.9002 30.227 34.2278 30.4031 33.5273 30.4031C32.8267 30.4031 32.1544 30.227 31.6557 29.9129L1.41921 10.8028C1.17355 10.6484 0.978457 10.4643 0.845295 10.2613C0.712132 10.0583 0.643555 9.84044 0.643555 9.62035C0.643555 9.40027 0.712132 9.18238 0.845295 8.97938C0.978457 8.77637 1.17355 8.5923 1.41921 8.43787C1.91791 8.12383 2.59028 7.94775 3.29082 7.94775C3.99137 7.94775 4.66374 8.12383 5.16244 8.43787L33.5292 25.8664L61.8921 8.43787Z\" fill=\"currentColor\"/>\
					</svg>\
				</div>\
			</div>\
		</div>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/time_slider/time_slider.html":
/*!*****************************************************!*\
  !*** ./src/components/time_slider/time_slider.html ***!
  \*****************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"time-slider\">\
	<button key=\"realtimeEl\" class=\"realtime {{realtimeVisibleClass}}\" onclick=\"_onRealtimeClick\"></button>\
	<div key=\"iconEl\" class=\"slider-icon\"></div>\
	<div key=\"lineEl\" class=\"slider-line\"></div>\
</div>;\
";
// Exports
module.exports = code;

/***/ }),

/***/ "./src/components/watch_panel/watch_card.html":
/*!****************************************************!*\
  !*** ./src/components/watch_panel/watch_card.html ***!
  \****************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"watch-card\">\
	<div class=\"text-group\">\
		<h3 class=\"semi\">{{title}}</h3>\
		<div class=\"date-block\">\
			<span class=\"date-label small\">DATE</span>\
			<div class=\"date-text\">\
				<h5 class=\"date-day semi\">{{date}}</h5>\
				<span class=\"date-time small\">{{time}}</span>\
			</div>\
\
		</div>\
		<div class=\"distance-block\">\
			<span class=\"distance-label small\">DISTANCE</span>\
			<div class=\"distance-text\">\
				<h5 class=\"distance-value semi\">{{distance}}</h5>\
				<h5 class=\"distance-unit\" onclick=\"handleToggleUnit\">{{distanceUnit}}</h5>\
			</div>\
\
		</div>\
	</div>\
	<div class=\"rock-group\">\
		<div class=\"icon rock\"></div>\
		<div class=\"icon ruler\"></div>\
		<div class=\"diameter-text\">\
			<span class=\"diameter-value small semi\">{{diameter}}</span>\
			<span class=\"diameter-unit small\" onclick=\"handleToggleUnit\">{{diameterUnit}}</span>\
			<span class=\"diameter-estimated\">{{diameterEstimatedText}}</span>\
		</div>\
\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/breadcrumb/breadcrumb.html":
/*!*********************************************************!*\
  !*** ../eyes/src/components/breadcrumb/breadcrumb.html ***!
  \*********************************************************/
/***/ (function(module) {

// Module
var code = "<nav class=\"breadcrumb semi\">\
	<nav key=\"static\" class=\"container clickable home {{isHomeActiveClass}}\" onclick=\"_goToHome\">\
		<span key=\"staticLogo\" class=\"icon icon-nasa-logo\"></span>\
		<h1 class=\"text uppercase\">{$title}</h1>\
	</nav>\
</nav>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/carousel/carousel.html":
/*!*****************************************************!*\
  !*** ../eyes/src/components/carousel/carousel.html ***!
  \*****************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"carousel-container {{isVisibleClass}} {{slideType}}\">\
	<div class=\"progress {{slideType}}\">\
		<span key=\"progress\" class=\"icon icon-triangle\"></span>\
	</div>\
	<div key=\"carousel\" class=\"carousel {{collapseClass}} {{isScrollingClass}} {{slideType}}\">\
		<div class=\"track\" key=\"track\"></div>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/carousel/slide_template.html":
/*!***********************************************************!*\
  !*** ../eyes/src/components/carousel/slide_template.html ***!
  \***********************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"slide hidden {$type}\">\
	<div class=\"container {{collapseClass}}\">\
		<div class=\"container-wrapper\">\
			<div class=\"mobile-hint small\">\
				<span class=\"icon icon-greater up clickable\" onclick=\"goToPrevSlide\"></span>\
				<span class=\"hint-text\">{$hintText}</span>\
				<span class=\"icon icon-greater down clickable\" onclick=\"goToNextSlide\"></span>\
			</div>\
			<div class=\"content-container\">\
				<div class=\"content-wrapper\">\
					<div class=\"content\"></div>\
				</div>\
			</div>\
		</div>\
	</div>\
	<div class=\"collapse-container {{collapseClass}}\">\
		<button class=\"mobile-collapse icon clickable {{collapseButtonClass}}\" onclick=\"_toggleCollapse\"></button>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/carousel_panel/carousel_panel.html":
/*!*****************************************************************!*\
  !*** ../eyes/src/components/carousel_panel/carousel_panel.html ***!
  \*****************************************************************/
/***/ (function(module) {

// Module
var code = "<section id=\"panel-container\" class=\"{{panelTypeClass}} {{isVisibleClass}} {{isExpandedClass}}\">\
\
	<!-- Simple panel (collapsed) -->\
	<div class=\"panel-simple clickable\" onclick=\"expand\">\
		<div class=\"expand-button\">\
			<div class=\"icon circle-arrow\"></div>\
		</div>\
		<h5 class=\"simple-pretitle\">{{preTitle}}</h5>\
		<h4 class=\"simple-title\">{{title}}</h4>\
	</div>\
\
	<!-- Main panel (expanded) -->\
	<div class=\"panel-main\">\
\
		<div class=\"panel-header\">\
			<div class=\"header-title\">\
				<div class=\"title-icon icon icon-large {{headerIconClass}}\"></div>\
				<h4 class=\"title-text\">{{title}}</h4>\
			</div>\
			<h5 class=\"header-caption {{captionClass}}\">{{caption}}</h5>\
		</div>\
\
		<!-- Carousel content -->\
		<div key=\"content\" class=\"panel-content\">\
			<nav key=\"tabsContainer\" class=\"tabs-container {{tabsVisibleClass}} {{tabNumClass}}\"></nav>\
			<div class=\"swiper {{carouselClass}}\">\
				<div key=\"swiperSlides\" class=\"swiper-wrapper\"></div>\
\
\
				<div class=\"swiper-pagination {{paginationClass}}\"></div>\
\
				<div class=\"swiper-button-prev icon prev-arrow {{prevButtonClass}} hidden-on-footron\"></div>\
				<div class=\"swiper-button-next icon next-arrow {{nextButtonClass}} hidden-on-footron\"></div>\
\
				<div key=\"bullets\" class=\"hidden-on-footron\"></div>\
\
			</div>\
		</div>\
\
	</div>\
\
\
\
</section>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/checkbox/checkbox.html":
/*!*****************************************************!*\
  !*** ../eyes/src/components/checkbox/checkbox.html ***!
  \*****************************************************/
/***/ (function(module) {

// Module
var code = "<li class=\"checkbox-option clickable {{checkboxClass}} {{isCheckedClass}}\">\
	<span key=\"icon\" class=\"icon checkbox bg-color {{iconCheckmarkClass}} {{colorClass}}\"></span>\
	<span key=\"text\" class=\"text {{textClass}}\">{{text}}</span>\
</li>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/clock/clock.html":
/*!***********************************************!*\
  !*** ../eyes/src/components/clock/clock.html ***!
  \***********************************************/
/***/ (function(module) {

// Module
var code = "<time class=\"clock {{isVisibleClass}}\">\
	<div class=\"datetime-container {{alert}}\">\
		<div key=\"displayContainer\" class=\"display-container\">\
			<div key=\"date\" class=\"date {{isDateVisibleClass}} monospace\" onclick=\"onDateTimeClick\">{{date}}</div>\
			<div key=\"time\" class=\"time {{isTimeVisibleClass}} monospace\" onclick=\"onDateTimeClick\">{{time}}</div>\
			<div key=\"meridiem\" class=\"meridiem {{isMeridiemVisibleClass}} monospace\" onclick=\"onDateTimeClick\">{{meridiem}}</div>\
		</div>\
		<form key=\"timeForm\" class=\"hidden\" method=\"post\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\">\
			<input key=\"timeInput\" type=\"text\" name=\"hour\" class=\"hour-input\" placeholder=\"hour\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" size=\"25\"></input>\
		</form>\
	</div>\
</time>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/clock_shortcut/clock_shortcut.html":
/*!*****************************************************************!*\
  !*** ../eyes/src/components/clock_shortcut/clock_shortcut.html ***!
  \*****************************************************************/
/***/ (function(module) {

// Module
var code = "<nav class=\"clock-shortcut shortcut {{isVisibleClass}}\">\
	<div class=\"{{replayClass}} replay-container clickable\" onclick=\"_replay\" key=\"replayContainer\">\
		<span class=\"icon {{replayIcon}}\" key=\"iconReplay\"></span>\
		<div class=\"replay text semi\" key=\"replay\">Replay</div>\
	</div>\
	<div class=\"{{liveContainerClass}} live-container container\" onclick=\"backToLive\" key=\"liveContainer\" data-tippy-content=\"Reset time to live.\">\
		<span class=\"icon {{liveIcon}}\" key=\"iconLive\"></span>\
		<div class=\"{{liveClass}} text\" key=\"live\">{{liveText}}</div>\
	</div>\
</nav>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/kiosk_base/kiosk_base.html":
/*!*********************************************************!*\
  !*** ../eyes/src/components/kiosk_base/kiosk_base.html ***!
  \*********************************************************/
/***/ (function(module) {

// Module
var code = "<div key=\"kioskContainer\" class='kiosk-container {{isVisibleClass}}' onclick=\"onWindowInteract\" ontouchstart=\"onWindowInteract\">\
	<div key=\"kioskLoadingText\" class='loading-text {{loadingTextVisibleClass}}'>\
		Starting experience...\
	</div>\
	<div key=\"kioskSessionEnd\" class=\"session-end-container {{sessionEndVisibleClass}}\">\
		<div key=\"sessionEndButtons\" class=\"session-end-buttons-container\">\
			<div class=\"session-ended-msg\">\
				This session has ended\
			</div>\
			<div key=\"kioskStartOverBtn\" class='kiosk-btn session-end-btn {{forceRestartClass}}' onclick=\"sessionStartOverButtonClick\" ontouchstart=\"sessionStartOverButtonClick\">\
				START OVER\
			</div>\
			<div key=\"kioskContinueBtn\" class='kiosk-btn session-end-btn {{continueButtonVisibleClass}}'>\
				CONTINUE\
			</div>\
		</div>\
	</div>\
	<div key=\"kioskAutoplay\" class=\"autoplay-container {{autoplayVisibleClass}}\">\
		<div class='kiosk-btn touch-to-start-btn'>\
			TOUCH TO START\
		</div>\
	</div>\
	<div key=\"kioskSessionTimer\" class=\"session-timer-container {{sessionTimerVisibleClass}}\">\
		<div class=\"session-countdown-timer\">Time left: </div>\
		<Clock id=\"kioskSessionClock\" class=\"session-countdown-timer {{isKioskCountdownClass}}\"></Clock>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/layer_panel/layer_panel.html":
/*!***********************************************************!*\
  !*** ../eyes/src/components/layer_panel/layer_panel.html ***!
  \***********************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"layer-panel {{isVisibleClass}}\" id=\"layer-panel\">\
	<div class=\"header\" onclick=\"hide\">\
		<h5 class=\"title\">Layers</h5>\
		<button class=\"icon icon-greater clickable close\"></button>\
	</div>\
	<div key=\"layerPanelBody\">\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/load_icon/load_icon.html":
/*!*******************************************************!*\
  !*** ../eyes/src/components/load_icon/load_icon.html ***!
  \*******************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"load-icon {{isVisibleClass}}\">\
	<div class=\"bg face\"></div>\
	<div class=\"front face\"></div>\
	<div class=\"left face\"></div>\
	<div class=\"top face\"></div>\
	<div class=\"right face\"></div>\
	<div class=\"bottom face\"></div>\
	<div class=\"text\">Loading</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/overlay/overlay.html":
/*!***************************************************!*\
  !*** ../eyes/src/components/overlay/overlay.html ***!
  \***************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"overlay-container\">\
	<button class=\"open-button icon icon-info clickable {{isOpenButtonVisibleClass}}\" onclick=\"show\"></button>\
	<div key=\"overlay\" class=\"overlay {{isVisibleClass}}\">\
		<div key=\"overlayContent\" class=\"container\"></div>\
		<button class=\"close-button icon icon-close clickable\" onclick=\"hide\"></button>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/search/search.html":
/*!*************************************************!*\
  !*** ../eyes/src/components/search/search.html ***!
  \*************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"search {{isVisibleClass}}\">\
	<span class=\"icon icon-search clickable {{magClass}}\" onclick=\"onIconClick\"></span>\
	<div class=\"{{searchClass}} {{focusedClass}}\">\
		<div class=\"cover\" onclick=\"reset\"></div>\
		<div key=\"container\" class=\"bar\">\
			<span class=\"icon icon-search clickable\"></span>\
			<input key=\"input\" type=\"text\" placeholder=\"{$placeholderText}\" autocomplete=\"off\" autocorrect=\"off\" autocapitalize=\"off\" spellcheck=\"false\" oninput=\"_find\" onfocus=\"onInputFocus\" onkeydown=\"keydown\"></input>\
			<span class=\"close icon icon-close clickable search-close-icon\" onclick=\"reset\"></span>\
			<div class=\"results-container\">\
				<div key=\"results\" class=\"scrollable results gradient\"></div>\
			</div>\
			<span class=\"search-info tiny {{allowInfoClass}}\">{{searchInfo}}</span>\
			<div class=\"featured gradient scrollable {{allowFeaturedClass}} {{isFeaturedVisibleClass}}\">\
				<ul key=\"featured\"></ul>\
			</div>\
		</div>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/settings/settings.html":
/*!*****************************************************!*\
  !*** ../eyes/src/components/settings/settings.html ***!
  \*****************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"settings {{isVisibleClass}} {{orientationClass}}\">\
	<div key=\"container\" class=\"container {{containerClass}}\">\
		<div key=\"content\" class=\"content\">\
			<button class=\"clickable icon icon-box {{allowInfoPanelClass}}\" onclick=\"toggleInfoPanel\" data-tippy-content=\"Show info panel\" aria-label=\"show info panel\">\
				<span class=\"icon {{infoButton}}\"></span>\
			</button>\
			<button class=\"clickable icon icon-layers {{allowLayersClass}}\" onclick=\"toggleLayers\" data-tippy-content=\"Toggle layers\" aria-label=\"toggle layers\"></button>\
			<button class=\"clickable icon {{unitButton}} {{allowToggleUnitClass}}\" onclick=\"toggleUnit\" data-tippy-content=\"Toggle between metric and imperial units\" aria-label=\"toggle between metric and imperial units\"></button>\
			<button class=\"clickable icon icon-hide {{photoModeClass}} {{allowPhotoModeClass}}\" onclick=\"togglePhotoMode\" data-tippy-content=\"Show or hide UI\" aria-label=\"show or hide UI\"></button>\
			<button class=\"clickable icon-bg zoom {{allowZoomClass}}\">\
				<span key=\"zoomInButton\" class=\"icon icon-plus\" data-tippy-content=\"Zoom in\" aria-label=\"zoom in\" role=\"button\"></span>\
				<div class=\"horizontal-line\"></div>\
				<span key=\"zoomOutButton\" class=\"icon icon-minus\" data-tippy-content=\"Zoom out\" aria-label=\"zoom out\" role=\"button\"></span>\
			</button>\
			<button key=\"lightToggle\" class=\"light-toggle clickable icon icon-box {{allowLightingClass}}\" onclick=\"toggleLight\" data-tippy-content=\"Toggle light modes\" aria-label=\"toggle light modes\">\
				<span class=\"icon {{lightClass}}\"></span>\
			</button>\
			<button class=\"clickable icon {{guidedClass}} {{allowGuidedCameraClass}}\" onclick=\"toggleGuidedCamera\" data-tippy-content=\"Toggle auto camera\" aria-label=\"toggle auto camera\"></button>\
			<div key=\"lightOptions\" class=\"lighting-option-container small {{showLightingOptionsClass}}\">\
				<button key=\"flood\" class=\"button lighting-option clickable\">\
					<span class=\"lighting-icon icon icon-flood-light\"></span>\
					<span class=\"title\">Flood Lighting</span>\
				</button>\
				<button key=\"shadow\" class=\"button lighting-option clickable\" value=\"shadow\">\
					<span class=\"lighting-icon icon icon-shadow-light\"></span>\
					<span class=\"title\">Shadow Lighting</span>\
				</button>\
				<button key=\"natural\" class=\"button lighting-option clickable\" value=\"natural\">\
					<span class=\"lighting-icon icon icon-natural-light\"></span>\
					<span class=\"title\">Natural Lighting</span>\
				</button>\
			</div>\
			<button class=\"clickable icon icon-fullscreen {{fullscreenClass}} {{allowFullscreenClass}}\" onclick=\"toggleFullscreen\" data-tippy-content=\"Toggle fullscreen\" aria-label=\"toggle fullscreen\"></button>\
		</div>\
	</div>\
	<button class=\"toggle clickable icon icon-controls {{isCollapsibleClass}}\" onclick=\"toggleCollapse\" data-tippy-content=\"Show or hide settings\" aria-label=\"show or hide settings\"></button>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/share_modal/share_modal.html":
/*!***********************************************************!*\
  !*** ../eyes/src/components/share_modal/share_modal.html ***!
  \***********************************************************/
/***/ (function(module) {

// Module
var code = "<div id=\"share-modal\" class=\"{{isVisibleClass}}\" onclick=\"handleClick\">\
	<article class=\"modal-main\" >\
		<header class=\"modal-header\">\
			<div class=\"modal-icon icon icon-share\"></div>\
			<h3 class=\"modal-title\">Share</h3>\
			<!-- Tab headers -->\
			<ul class=\"tab-headers\" onclick=\"handleTabClick\" key=\"tabHeaders\">\
				<li class=\"tab-header link\"><button class=\"clickable\">Link</button></li>\
				<li class=\"tab-header embed\"><button class=\"clickable\">Embed</button></li>\
			</ul>\
			<button class=\"modal-close clickable icon icon-close\" key=\"closeButton\"></button>\
		</header>\
		<section class=\"modal-content\">\
			 <!-- Tab content -->\
			<div class=\"tab-content\" key=\"tabContent\">\
				<div class=\"tab-pane link\" key=\"linkContainer\">\
					<!-- Content for Link tab -->\
					<img key=\"linkImage\">\
					<div class=\"link-container\">\
						<span>{{linkTitle}}</span>\
						<code class=\"scrollable\" key=\"linkCode\"></code>\
					</div>\
					<button class=\"copy-link clickable\" onclick=\"copyToClipboard\">\
						<div class=\"icon icon-copy\"></div>\
						<span>Copy Link</span>\
					</button>\
				</div>\
				<div class=\"tab-pane embed\" key=\"embedContainer\">\
					<!-- Content for Embed tab -->\
					<section class=\"main-section\">\
						<div class=\"preview-container {{previewDevice}} {{previewVisibleClass}}\">\
							<span>Interactive Preview</span>\
							<div class=\"preview\" key=\"embedPreviewParent\"></div>\
						</div>\
						<code class=\"scrollable\" key=\"embedCode\"></code>\
						<div class=\"input-container\">\
							<input class=\"clickable\" type=\"checkbox\" id=\"iframe-elements-checkbox\" onchange=\"toggleIframeElements\" checked />\
							<label class=\"clickable\" for=\"iframe-elements-checkbox\">Include i-frame elements</label>\
							<span class=\"clickable icon icon-help\" data-tippy-content=\"Include the iframe HTML tags in the embed code\" aria-label=\"Help: Include the iframe HTML tags in the embed code\" tabindex=\"0\"></span>\
						</div>\
\
						<button class=\"copy-link clickable\" onclick=\"copyToClipboard\">\
							<div class=\"icon icon-copy\"></div>\
							<span>Copy Embed Code</span>\
						</button>\
					</section>\
					<section class=\"options-section\">\
						<h5>Embed Options</h5>\
						<div class=\"options-container scrollable\">\
							<div class=\"options basic-options\" key=\"embedOptsContent\"></div>\
							<details class=\"advanced\">\
								<summary class=\"clickable\">Advanced Options</summary>\
								<div class=\"options embed-adv-container\" key=\"embedAdvOptsContent\"></div>\
							</details>\
						</div>\
\
					</section>\
				</div>\
			</div>\
\
		</section>\
		<h3 class=\"copied-overlay\" key=\"copiedOverlay\">Copied to clipboard!</h3>\
\
	</article>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/buttons_block/buttons_block.html":
/*!****************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/buttons_block/buttons_block.html ***!
  \****************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"buttons-block\">\
	<div class=\"block-title\">{$blockTitle}</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/checkbox_block/checkbox_block.html":
/*!******************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/checkbox_block/checkbox_block.html ***!
  \******************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"checkboxes-block\">\
	<div class=\"cb-block-title\">{$checkboxBlockTitle}</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/description_block/description_block.html":
/*!************************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/description_block/description_block.html ***!
  \************************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"description-block\">\
	<div key=\"header\" class=\"header\">\
		<h2 class=\"title\">{$title}</h2>\
		<h3 class=\"subtitle semi\">{$subtitle}</h3>\
	</div>\
	<div key=\"body\" class=\"body\">\
		<div class=\"description\">{$description}</div>\
		<span class=\"more-description {{moreClass}}\" >\
			{$more}\
		</span>\
		<span class=\"clickable more-toggle {{hasMoreClass}}\" onclick=\"toggleMore\">\
			<span class=\"x-small more-message\">\
				{{moreMessage}}\
			</span>\
			<span class=\"button clickable icon more-icon {{moreIcon}}\"></span>\
		</span>\
	</div>\
	<div key=\"footer\" class=\"footer\"></div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/hint_block/hint_block.html":
/*!**********************************************************************!*\
  !*** ../eyes/src/components/story/blocks/hint_block/hint_block.html ***!
  \**********************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"hint-block {$class}\">\
	<span class=\"icon before {{iconBefore}} {{isIconBeforeVisibleClass}}\"></span>\
	<span class=\"text\">{{text}}</span>\
	<span class=\"icon after {{iconAfter}} {{isIconAfterVisibleClass}}\"></span>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/image_block/image_block.html":
/*!************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/image_block/image_block.html ***!
  \************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"image-block\">\
	<img class=\"{$className}\" src=\"{$src}\" alt=\"{$alt}\">\
	<span class=\"title\">{$title}</span>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/replay_button_block/replay_button_block.html":
/*!****************************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/replay_button_block/replay_button_block.html ***!
  \****************************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"clickable replay-button-block\" onclick=\"onClick\">\
	<button>\
		<span class=\"icon icon-replay\"></span>\
		<span class=\"text semi\">{$text}</span>\
	</button>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/title_block/title_block.html":
/*!************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/title_block/title_block.html ***!
  \************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"title-block\">\
	<h1 class=\"title\">{$title}</h1>\
	<h2 class=\"subtitle\">{$subtitle}</h2>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/story/blocks/toggle_block/toggle_block.html":
/*!**************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/toggle_block/toggle_block.html ***!
  \**************************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"clickable toggle-block {{isSelectedClass}}\">\
	<button>\
		{$text}\
	</button>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/time_controller/time_controller.html":
/*!*******************************************************************!*\
  !*** ../eyes/src/components/time_controller/time_controller.html ***!
  \*******************************************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"time-controller {{isVisibleClass}}\">\
	<div class=\"rate-container\">\
		<button key=\"toggleBtn\" class=\"icon {{playClass}} clickable play-pause\" data-tippy-content=\"Pause / play\" onclick=\"togglePlayPause\"></button>\
		<label key=\"label\" class=\"rate-label\">rate</label>\
		<button key=\"decreaseBtn\" class=\"prev-rate clickable\" data-tippy-content=\"Decrease time rate\" onclick=\"decreaseRate\">\
			<span key=\"decreaseContainer\" class=\"container\">\
				<span class=\"icon icon-backward\"></span>\
			</span>\
		</button>\
		<div class=\"vertical-line\"></div>\
		<button key=\"increaseBtn\" class=\"next-rate clickable\" data-tippy-content=\"Increase time rate\" onclick=\"increaseRate\">\
			<span key=\"increaseContainer\" class=\"container\">\
				<span class=\"icon icon-forward\"></span>\
			</span>\
		</button>\
		<label key=\"rateDisplay\" class=\"rate-display-label\">{{rateDisplay}}</label>\
	</div>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/toast/toast.html":
/*!***********************************************!*\
  !*** ../eyes/src/components/toast/toast.html ***!
  \***********************************************/
/***/ (function(module) {

// Module
var code = "<div class=\"toast-container {{isVisibleClass}}\" role=\"alert\" aria-live=\"polite\" aria-atomic=\"true\">\
	<span class=\"icon {{iconClass}}\" aria-hidden=\"true\"></span>\
	<div key=\"toastContent\" class=\"toast-content\">{{toastContent}}</div>\
	<button type=\"button\" class=\"close clickable icon icon-close\" data-dismiss=\"toast\" aria-label=\"Close alert\" onclick=\"hide\"></button>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

/***/ "../eyes/src/components/tutorial_overlay/tutorial_overlay.html":
/*!*********************************************************************!*\
  !*** ../eyes/src/components/tutorial_overlay/tutorial_overlay.html ***!
  \*********************************************************************/
/***/ (function(module) {

// Module
var code = "<div id=\"tutorial-overlay\" class=\"{{isVisibleClass}} {{slideClass}}\">\
\
	<div class=\"swiper {{carouselClass}}\">\
		<div key=\"swiperSlides\" class=\"swiper-wrapper\"></div>\
\
		<div class=\"swiper-button-prev icon prev-arrow tutorial-carousel-prev\"></div>\
		<div class=\"swiper-button-next icon next-arrow tutorial-carousel-next\"></div>\
\
		<div key=\"bullets\" class=\"bullet-container\"></div>\
\
	</div>\
\
	<div class=\"dismiss-container\">\
		<button class=\"dismiss-button clickable\" onclick=\"close\">{{dismissText}}</button>\
	</div>\
\
\
	<footer>\
		<p class='tutorial-smallprint'>The data used to generate this visualization is from the <a href='https://cneos.jpl.nasa.gov' target='_blank'>Center for Near-Earth Object Studies</a> and JPL's <a href='https://ssd.jpl.nasa.gov' target='_blank'>Solar System Dynamics</a> website. Visit the <a href='https://www.nasa.gov/planetarydefense/overview' target='_blank'>Planetary Defense Coordination Office</a> for more information on how NASA monitors for potentially hazardous asteroids and comets.</p>\
	</footer>\
</div>\
";
// Exports
module.exports = code;

/***/ }),

//CSS Modules (These all seem empty and identical?)

/***/ "./src/assets/css/asteroid.css":
/*!*************************************!*\
  !*** ./src/assets/css/asteroid.css ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/clock.css":
/*!**********************************!*\
  !*** ./src/assets/css/clock.css ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/color.css":
/*!**********************************!*\
  !*** ./src/assets/css/color.css ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/font.css":
/*!*********************************!*\
  !*** ./src/assets/css/font.css ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/grid.css":
/*!*********************************!*\
  !*** ./src/assets/css/grid.css ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/icon.css":
/*!*********************************!*\
  !*** ./src/assets/css/icon.css ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/label.css":
/*!**********************************!*\
  !*** ./src/assets/css/label.css ***!
  \**********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/search.css":
/*!***********************************!*\
  !*** ./src/assets/css/search.css ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/settings.css":
/*!*************************************!*\
  !*** ./src/assets/css/settings.css ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/assets/css/viewport.css":
/*!*************************************!*\
  !*** ./src/assets/css/viewport.css ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/asteroid_modals/asteroid_modals.css":
/*!************************************************************!*\
  !*** ./src/components/asteroid_modals/asteroid_modals.css ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/asteroid_modals/modals/filters_modal/filters_modal.css":
/*!*******************************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/filters_modal/filters_modal.css ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/asteroid_modals/modals/learn_modal/learn_modal.css":
/*!***************************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/learn_modal/learn_modal.css ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/asteroid_panel/asteroid_panel.css":
/*!**********************************************************!*\
  !*** ./src/components/asteroid_panel/asteroid_panel.css ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/breadcrumb/breadcrumb.css":
/*!**************************************************!*\
  !*** ./src/components/breadcrumb/breadcrumb.css ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/countdown/countdown.css":
/*!************************************************!*\
  !*** ./src/components/countdown/countdown.css ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/definition_overlay/definition_overlay.css":
/*!******************************************************************!*\
  !*** ./src/components/definition_overlay/definition_overlay.css ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/following_panel/following_panel.css":
/*!************************************************************!*\
  !*** ./src/components/following_panel/following_panel.css ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/home_button/home_button.css":
/*!****************************************************!*\
  !*** ./src/components/home_button/home_button.css ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/mission_panel/mission_panel.css":
/*!********************************************************!*\
  !*** ./src/components/mission_panel/mission_panel.css ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/navigation/navigation.css":
/*!**************************************************!*\
  !*** ./src/components/navigation/navigation.css ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/splash_screen/splash_screen.css":
/*!********************************************************!*\
  !*** ./src/components/splash_screen/splash_screen.css ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/time_slider/time_slider.css":
/*!****************************************************!*\
  !*** ./src/components/time_slider/time_slider.css ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/watch_panel/watch_card.css":
/*!***************************************************!*\
  !*** ./src/components/watch_panel/watch_card.css ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "./src/components/watch_panel/watch_panel.css":
/*!****************************************************!*\
  !*** ./src/components/watch_panel/watch_panel.css ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/animation.css":
/*!********************************************!*\
  !*** ../eyes/src/assets/css/animation.css ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/camera_follow.css":
/*!************************************************!*\
  !*** ../eyes/src/assets/css/camera_follow.css ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/color.css":
/*!****************************************!*\
  !*** ../eyes/src/assets/css/color.css ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/components.css":
/*!*********************************************!*\
  !*** ../eyes/src/assets/css/components.css ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/font.css":
/*!***************************************!*\
  !*** ../eyes/src/assets/css/font.css ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/grid.css":
/*!***************************************!*\
  !*** ../eyes/src/assets/css/grid.css ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/grid_layout.css":
/*!**********************************************!*\
  !*** ../eyes/src/assets/css/grid_layout.css ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/icon.css":
/*!***************************************!*\
  !*** ../eyes/src/assets/css/icon.css ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/label.css":
/*!****************************************!*\
  !*** ../eyes/src/assets/css/label.css ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/layout.css":
/*!*****************************************!*\
  !*** ../eyes/src/assets/css/layout.css ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/scrollbar.css":
/*!********************************************!*\
  !*** ../eyes/src/assets/css/scrollbar.css ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/sprite.css":
/*!*****************************************!*\
  !*** ../eyes/src/assets/css/sprite.css ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/assets/css/style.css":
/*!****************************************!*\
  !*** ../eyes/src/assets/css/style.css ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/breadcrumb/breadcrumb.css":
/*!********************************************************!*\
  !*** ../eyes/src/components/breadcrumb/breadcrumb.css ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/carousel/carousel.css":
/*!****************************************************!*\
  !*** ../eyes/src/components/carousel/carousel.css ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/carousel_panel/carousel_panel.css":
/*!****************************************************************!*\
  !*** ../eyes/src/components/carousel_panel/carousel_panel.css ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/checkbox/checkbox.css":
/*!****************************************************!*\
  !*** ../eyes/src/components/checkbox/checkbox.css ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/clock/clock.css":
/*!**********************************************!*\
  !*** ../eyes/src/components/clock/clock.css ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/clock_shortcut/clock_shortcut.css":
/*!****************************************************************!*\
  !*** ../eyes/src/components/clock_shortcut/clock_shortcut.css ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/kiosk_base/kiosk_base.css":
/*!********************************************************!*\
  !*** ../eyes/src/components/kiosk_base/kiosk_base.css ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/layer_panel/layer_panel.css":
/*!**********************************************************!*\
  !*** ../eyes/src/components/layer_panel/layer_panel.css ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/load_icon/load_icon.css":
/*!******************************************************!*\
  !*** ../eyes/src/components/load_icon/load_icon.css ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/overlay/overlay.css":
/*!**************************************************!*\
  !*** ../eyes/src/components/overlay/overlay.css ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/search/search.css":
/*!************************************************!*\
  !*** ../eyes/src/components/search/search.css ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/settings/settings.css":
/*!****************************************************!*\
  !*** ../eyes/src/components/settings/settings.css ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/share_modal/share_modal.css":
/*!**********************************************************!*\
  !*** ../eyes/src/components/share_modal/share_modal.css ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/buttons_block/buttons_block.css":
/*!***************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/buttons_block/buttons_block.css ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/checkbox_block/checkbox_block.css":
/*!*****************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/checkbox_block/checkbox_block.css ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/description_block/description_block.css":
/*!***********************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/description_block/description_block.css ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/hint_block/hint_block.css":
/*!*********************************************************************!*\
  !*** ../eyes/src/components/story/blocks/hint_block/hint_block.css ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/image_block/image_block.css":
/*!***********************************************************************!*\
  !*** ../eyes/src/components/story/blocks/image_block/image_block.css ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/replay_button_block/replay_button_block.css":
/*!***************************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/replay_button_block/replay_button_block.css ***!
  \***************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/story_base_content_block/story_base_content_block.css":
/*!*************************************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/story_base_content_block/story_base_content_block.css ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/blocks/toggle_block/toggle_block.css":
/*!*************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/toggle_block/toggle_block.css ***!
  \*************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/story/story.css":
/*!**********************************************!*\
  !*** ../eyes/src/components/story/story.css ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/time_controller/time_controller.css":
/*!******************************************************************!*\
  !*** ../eyes/src/components/time_controller/time_controller.css ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/toast/toast.css":
/*!**********************************************!*\
  !*** ../eyes/src/components/toast/toast.css ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

/***/ "../eyes/src/components/tutorial_overlay/tutorial_overlay.css":
/*!********************************************************************!*\
  !*** ../eyes/src/components/tutorial_overlay/tutorial_overlay.css ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
// extracted by mini-css-extract-plugin


/***/ }),

//JS Modules (One of these is an odd recursive function that isn't explicitly a .js file)

/***/ "./src/app.js":
/*!********************!*\
  !*** ./src/app.js ***!
  \********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidsApp": function() { return /* binding */ AsteroidsApp; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./internal */ "./src/internal.js");
/* harmony import */ var _configs_components_info__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./configs/components_info */ "./src/configs/components_info.js");
/* harmony import */ var _data_heroes_json__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data/heroes.json */ "./src/data/heroes.json");
/* harmony import */ var _data_tutorials_json__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./data/tutorials.json */ "./src/data/tutorials.json");
/* harmony import */ var _configs_time_info_json__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./configs/time_info.json */ "./src/configs/time_info.json");
/* harmony import */ var _configs_scene_info_json__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./configs/scene_info.json */ "./src/configs/scene_info.json");
/* harmony import */ var _configs_view_info_json__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./configs/view_info.json */ "./src/configs/view_info.json");
/* harmony import */ var _configs_story_info_json__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./configs/story_info.json */ "./src/configs/story_info.json");
/* harmony import */ var _views__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./views */ "./src/views/index.js");
/* harmony import */ var _data_stories__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./data/stories */ "./src/data/stories/index.js");
/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./app.html */ "./src/app.html");
/* harmony import */ var _app_html__WEBPACK_IMPORTED_MODULE_14___default = /*#__PURE__*/__webpack_require__.n(_app_html__WEBPACK_IMPORTED_MODULE_14__);
















/**
 * Asteroids app class.
 * ToDo: It doesn't really make sense to store the _heroes and the _neos here.
 * Maybe they could be moved to an extended content manager
 */
class AsteroidsApp extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseApp {
	/**
	 * Constructor.
	 */
	constructor() {
		super(_internal__WEBPACK_IMPORTED_MODULE_4__.Types);

		/** @inheritdoc */
		this._timeInfo = _configs_time_info_json__WEBPACK_IMPORTED_MODULE_8__;

		/** @inheritdoc */
		this._sceneInfo = _configs_scene_info_json__WEBPACK_IMPORTED_MODULE_9__;

		/** @inheritdoc */
		this._viewClasses = { ..._views__WEBPACK_IMPORTED_MODULE_12__["default"] };

		/** @inheritdoc */
		this._viewInfo = _configs_view_info_json__WEBPACK_IMPORTED_MODULE_10__;

		/** @inheritdoc */
		this._componentInfo = _configs_components_info__WEBPACK_IMPORTED_MODULE_5__["default"];

		/**
		 * The hero asteroids
		 */
		this._heroes = _data_heroes_json__WEBPACK_IMPORTED_MODULE_6__;

		/**
		 * The NEO information objects.
		 * @type {Map<string, NEO>}
		 * @private
		 */
		this._neos = new Map();

		this._particleMatchFunctions = {};

		/**
		 * Off white colors for Pioneer
		 */
		this._colors = {
			neos: [0.823, 0.882, 0.909],
			spacecraft: [0.969, 0.957, 0.875]
		};

		/**
		 * Stored values to reset on leaving.
		 * @type {object}
		 */
		this._resetValues = {};

		this.tutorials = _data_tutorials_json__WEBPACK_IMPORTED_MODULE_7__;

		this.bindFunctions(['addParticleMatchFunction', 'removeParticleMatchFunction', 'createAsteroidParticles']);
	}

	/**
	 * Getters
	 */

	/**
	 * Returns hero asteroids
	 * @returns {object}
	 */
	get heroes() {
		return this._heroes;
	}

	/**
	 * Gets the NEOs data.
	 * @returns {Map}
	 */
	get neos() {
		return this._neos;
	}

	/**
	 * Set up routes.
	 * @override
	 */
	setUpRoutes() {
		this.getManager('router').addRoutes([
			{ route: this.getManager('router').homeRoute, view: 'home' },
			{ route: '/story/:id', view: 'story' },
			{ route: '/missions/:spacecraft', view: 'mission' },
			{ route: '/planets/:planet', view: 'following' },
			{ route: '/stars/:star', view: 'following' },
			{ route: '/moons/:moon', view: 'following' },
			{ route: '/watch', view: 'watch' },
			{ route: '/watch/:neoName', view: 'watch' },
			{ route: '/:spaceObject', view: 'asteroid' }
		]);
	}

	/**
	 * Set up scene.
	 * @override
	 */
	async setUpScene() {
		// Load the NEOs.
		this._neos = await _internal__WEBPACK_IMPORTED_MODULE_4__.NEOUtils.loadNEOs(this.pioneer);

		// Update the label manager icon map to adjusst icon classes.
		const labelManager = this.getManager('label');
		labelManager._iconMap.Asteroid = 'asteroid';
		labelManager._iconMap['Dwarf Planet'] = 'asteroid';
		labelManager._iconMap.Comet = 'comet';
		labelManager._iconMap.Spacecraft = 'spacecraft';
		labelManager._iconMap.Default = '';

		// Load up the main entities.
		await super.setUpScene();

		// Add in the hero asteroids, if they aren't already added.
		const scene = /** @type {Pioneer.Scene} */(this.scene);

		for (const name of Object.keys(this._heroes)) {
			if (scene.getEntity(name) === null && this._neos.has(name)) {
				const entity = _internal__WEBPACK_IMPORTED_MODULE_4__.NEOUtils.createEntity(this._neos.get(name), scene);
				this.setUpLabels(entity, { category: _data_heroes_json__WEBPACK_IMPORTED_MODULE_6__[name].category });
			}
		}

		/**
		 * Re-define label weight map and set label weights again.
		 * For asteroids, we want to prioritise comets, asteroids and missions, while making planet and moon clicking harder.
		 */
		labelManager._weightMap.Moon = '5';
		labelManager._weightMap.Planet = '10';
		labelManager._weightMap.Spacecraft = '15';
		labelManager._weightMap.Comet = '20';
		labelManager._weightMap.Asteroid = '20';
		labelManager._weightMap['Dwarf Planet'] = '20';
		labelManager._weightMap.Star = '30';
		labelManager._weightMap.Watch = '40';
		labelManager._weightMap.Focus = '50';

		labelManager.setWeights(this.getManager('content').getEntityList());

		// Create the asteroid orbital particles (after neos have loaded)
		if (this._neos.size) {
			this.createAsteroidParticles();
		}
		else {
			console.error('NEOs data could not be loaded.');
		}

		// Change planet trails
		const trailManager = this.getManager('trail');
		const defaultOpacity = trailManager._opacity.primary;

		const width = {
			default: [4, 4],
			hover: [5, 5]
		};
		const planets = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityNamesInGroup('planets');
		planets.forEach(id => {
			this._resetValues[id] = {};
		});

		// Add line of sight component
		const sun = this.scene.get('sun');
		if (!sun.get('orbiterLineOfSight')) {
			const lineOfSight = sun.addComponent('orbiterLineOfSight');
			lineOfSight.setEnabled(false);
		}

		// Create rings for Sun and Earth
		const sceneManager = this.getManager('scene');
		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.SceneHelpers.waitTillEntitiesInPlace(scene, ['earth']);
		sceneManager.createRing('sunRing', eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm * 1.3, 'sun', {
			orbitPlaneEntityName: 'earth',
			color: new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(1, 1, 1),
			labelText: '1.3 AU distance from Sun',
			isEnable: false
		});
		sceneManager.createTorus('sunTorus', 1.496e8 * 0.95 /* - 0.05 AU */, 1.496e8 * 1.05 /* + 0.05 AU */, 'sun', {
			orbitPlaneEntityName: 'earth',
			color: new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(1, 1, 1, 0.2),
			labelText: 'PHO boundary zone',
			isEnable: false
		});

		// Make these labels always show, also 'Earth' can always
		labelManager.addException('sunRingLabel');
		labelManager.addException('sunTorusLabel');
	}

	/**
	 * Setup labels.
	 * @param {Pioneer.Entity} entity
	 * @param {object} options - the options
	 * @param {string} [options.category = undefined] - optional category.
	 */
	setUpLabels(entity, { category = undefined } = {}) {
		const contentManager = this.getManager('content');
		const labelManager = this.getManager('label');

		// If it's a planet, set color labels
		const colorLabels = ['mercury', 'venus', 'earth', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune'];

		const handleMouseEnter = (_, entityName) => labelManager.triggerCallbacks('hoverchange', [entityName, true, colorLabels.includes(entityName)]);
		const handleMouseLeave = (e, entityName) => {
			// Determine if were hovering on a selected asteroids watch asteroid.
			if (e.target?.classList?.contains('selected') && e.target?.classList?.contains('asteroid-watch-label')) {
				return;
			}
			labelManager.triggerCallbacks('hoverchange', [entityName, false, colorLabels.includes(entityName)]);
		};

		labelManager.addEntity(entity);
		labelManager.setLabelProps({
			getLabelClass: entityName => `no-select ${colorLabels.includes(entityName) ? 'color' : ''} ${contentManager.getClassName(entityName, category) ?? ''}`,
			handleMouseEnter,
			handleMouseLeave,
			...category && { getIconClass: _ => category.toLowerCase() }
		}, [entity.getName()]);
	}

	/**
	 * Set up managers.
	 */
	setUpManagers() {
		super.setUpManagers();

		// Add managers
		this.addManager('watch', _internal__WEBPACK_IMPORTED_MODULE_4__.WatchManager);
		this.addManager('filters', _internal__WEBPACK_IMPORTED_MODULE_4__.FiltersManager, this._scene);
		this.addManager('neos', _internal__WEBPACK_IMPORTED_MODULE_4__.NEOsManager, this._scene);
		this.addManager('link', _internal__WEBPACK_IMPORTED_MODULE_4__.LinkManager);

		// Set up title manager and pparsing function.

		const titleManagerOptions = {
			...this._sceneInfo.title,
			parseFn: ({ url, params, query } = {}) => {
				const { spaceObject, spacecraft, planet, star, moon } = params;
				const entityName = spaceObject || spacecraft || planet || star || moon;

				if (query?.includes('=learn')) {
					return 'Learn';
				}
				if (query?.includes('=filters')) {
					return 'Filters';
				}
				if (url?.includes('/story') && params.id) {
					const story = _configs_story_info_json__WEBPACK_IMPORTED_MODULE_11__.find(({ path }) => path === params.id);
					if (story?.title) {
						return story.title;
					}
				}
				if (url?.includes('/watch')) {
					return 'Asteroid Watch';
				}
				if (entityName) {
					const entity = this.scene.get(entityName);
					const { innerText: label } = entity?.getComponentByType('div')?.getDiv() || {};
					if (label) {
						return label;
					}
				}
				return 'Home';
			}
		};

		const titleManagerClass = _internal__WEBPACK_IMPORTED_MODULE_4__.Types.get('TitleManager');
		const titleManager = this.addManager('title', titleManagerClass, titleManagerOptions);
	}

	/**
	 * Builds search database from the content managers entity list info and a list of exceptions.
	 * @returns {object}
	 */
	_buildSearchDatabase() {
		const entityInfo = eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.deepCopy(this.getManager('content').getEntityList());
		const entityList = this.scene._entities._itemsByName;

		const exceptions = ['observable_universe', 'milky_way'];
		const database = {};

		// Add entities to search database
		entityList.forEach(key => {
			const info = entityInfo[key];
			if (!exceptions.includes(key) && info) {
				// Add url to info
				info.url = `/${info.id}`;
				database[key] = info;
			}
		});

		// Add NEO to search database
		this._neos.forEach((value, key) => {
			if (key in database) {
				database[key].neo = value;
			}
			else {
				database[key] = {
					id: key,
					iauName: value.name,
					url: `/${key}`,
					neo: value
				};
			}
		});

		return database;
	}

	/**
	 * Set up components.
	 */
	async setUpComponents() {
		await super.setUpComponents();

		const entityInfo = this.getManager('content').getEntityList();

		// Update story list
		const contentManager = this.getManager('content');
		contentManager.setStoryList(_data_stories__WEBPACK_IMPORTED_MODULE_13__.STORY_LIST);
		contentManager.setStories(_data_stories__WEBPACK_IMPORTED_MODULE_13__.STORIES);

		// Build and set search database.
		const searchDatabase = this._buildSearchDatabase();
		this.getManager('search').setDatabase(searchDatabase);

		// Hero asteroids populate the featured search items (most popular).
		const featuredItems = Object.keys(this.heroes).map(heroName => {
			const heroEntity = entityInfo[heroName];
			if (!heroEntity) {
				const heroData = _data_heroes_json__WEBPACK_IMPORTED_MODULE_6__[heroName];

				if (heroData.iauName && heroData.id) {
					return {
						text: heroData.iauName,
						sortText: heroData.displayName || heroData.iauName,
						url: `/${heroData.id}`
					};
				}
				else {
					console.error(`No entity found for hero: ${heroName}`);
					return false;
				}
			}
			return {
				text: heroEntity.iauName,
				sortText: heroEntity.displayName || heroEntity.iauName,
				url: `/${heroEntity.id}`
			};
		});

		// Sort alphabetically by display name and set up.
		featuredItems.sort((a, b) => a.sortText > b.sortText ? 1 : -1);
		this.getComponent('search').setupFeaturedSuggestion(featuredItems);

		// Create filter array of the heroes to update trail colors.
		const trailManager = this.getManager('trail');
		const neoIds = ['73p_schwassmann_wachmann_3'];
		const spacecraftIds = [];

		this.scene._entities._items.forEach(entity => {
			const id = entity.getName();
			const { category } = entityInfo[id] || {};

			if (category === 'Asteroid' || category === 'Dwarf Planet' || category === 'Comet') neoIds.push(id);
			else if (category === 'Spacecraft') spacecraftIds.push(id);
		});
		// Set trail colors.
		trailManager.setColor(neoIds, new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(...this._colors.neos, 0.35));
		trailManager.setColor(spacecraftIds, new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(...this._colors.spacecraft, 0.5));

		// Enable layers
		const layerManager = this.getManager('layer');
		const layerPanel = this.getComponent('layerPanel');
		if (!layerManager.getLayer('asteroids').visible) {
			layerPanel.toggleLayer('asteroids');
		}
		if (!layerManager.getLayer('comets').visible) {
			layerPanel.toggleLayer('comets');
		}
		if (!layerManager.getLayer('dwarfPlanets').visible) {
			layerPanel.toggleLayer('dwarfPlanets');
		}
		layerManager.getLayer('starfield').toggleCallback[0](false);
	}

	/**
	 * Goes through tutorials to find and replace function calls between double braces {{}}
	 * Works in the same way as component's setVariables, but uses a function call instead.
	 * @param {Array<object>} allTutorials
	 * @returns {Array<object>}
	 */
	setTutorialVariables(allTutorials) {
		const allTutorialsStr = JSON.stringify(allTutorials);

		const replacedJsonString = allTutorialsStr.replace(/\{\{(.+?)\}\}/g, (match, functionName) => {
			if (this[functionName] && typeof this[functionName] === 'function') {
				return this[functionName]();
			}
			return match;
		});

		return JSON.parse(replacedJsonString);
	}

	/**
	 * Adds (or replaces) a createAsteroidParticles matchFunction
	 * @param {(neo: NEO) => boolean} matchFunction - A match function that returns true if the NEO should be shown.
	 * @param {string} functionId - matchFunction identifier
	 * @param {boolean?} andRun - whether to run createAsteroidParticles after
	 * @param {(orbitalElements: Pioneer.OrbitalElements[]) => null?} callback - if andRun, callback for createAsteroidParticles
	 */
	addParticleMatchFunction(matchFunction, functionId, andRun, callback) {
		this._particleMatchFunctions[functionId] = matchFunction;
		if (andRun) this.createAsteroidParticles(callback);
	}

	/**
	 * Removes a createAsteroidParticles matchFunction
	 * @param {string} functionId - matchFunction identifier
	 * @param {boolean?} andRun - whether to run createAsteroidParticles after
	 * @param {(orbitalElements: Pioneer.OrbitalElements[]) => null?} callback - if andRun, callback for createAsteroidParticles
	 */
	removeParticleMatchFunction(functionId, andRun, callback) {
		delete this._particleMatchFunctions[functionId];
		if (andRun) this.createAsteroidParticles(callback);
	}

	/**
	 * Creates the asteroids as a component of the sun.
	 * @param {(orbitalElements: Pioneer.OrbitalElements[]) => null} callback - Callback for when all orbitalElement are first captured
	 */
	createAsteroidParticles(callback) {
		// Get the sun.
		const sun = this.scene.getEntity('sun');

		// First remove the component if it already exists.
		if (sun.getComponentByType('orbitalParticles') !== null) {
			sun.removeComponent(sun.getComponentByType('orbitalParticles'));
		}

		// The colors of the asteroids will be random between these two shades.
		const minColor = new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(0, 0.25, 0.35);
		const maxColor = new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(0, 0.45, 0.65);

		// Brighten them up a bit.
		const white = new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color(1, 1, 1);
		minColor.lerp(minColor, white, 0.10);
		maxColor.lerp(maxColor, white, 0.15);

		// Add the component.
		const orbitalParticles = /** @type {Pioneer.OrbitalParticlesComponent} */(sun.addComponent('orbitalParticles'));
		orbitalParticles.setLoadFunction(async () => {
			const colors = /** @type {Pioneer.Color[]} */([]);
			const scales = /** @type {number[]} */([]);
			const orbitalElements = /** @type {Pioneer.OrbitalElements[]} */([]);
			// const viewportSize = this._pioneer.getViewport('main-viewport').getBounds().size;
			// const maxAspectRatio = Math.max(viewportSize.x / viewportSize.y, viewportSize.y / viewportSize.x);
			let shouldSkip;

			for (const neo of this._neos.values()) {
				// If the neo doesn't match, skip it.
				shouldSkip = false;
				for (const f in this._particleMatchFunctions) {
					if (!this._particleMatchFunctions[f](neo)) {
						shouldSkip = true;
						break;
					}
				}
				if (shouldSkip) continue;

				if (pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityOptions(neo.pioneerName) !== undefined) {
					continue;
				}

				// Set the color.
				const color = new pioneer__WEBPACK_IMPORTED_MODULE_3__.Color();
				if (neo.comet) {
					color.set(...this._colors.neos);
				}
				else {
					const u = Math.random();
					color.lerp(minColor, maxColor, u);
				}
				colors.push(color);

				// Set the scale.
				const scale = (neo.comet ? 1.3 : 1) * (neo.pho ? 1.5 : 1) * 3e-3 * Math.max(1.0, Math.log10(1.0 + neo.diameter));
				scales.push(scale);

				// Set the orbital elements.
				orbitalElements.push(neo.orbitalElements);
			}
			if (typeof callback === 'function') callback(orbitalElements);
			return {
				colors,
				scales,
				orbitalElements
			};
		});
		orbitalParticles.setResourcesLoadedCallback(() => {
			const material = /** @type {Pioneer.OrbitalParticlesComponent} */(this._pioneer.get('main', 'sun', 'orbitalParticles')).getThreeJsMaterials()[0];

			// Added master opacity uniform.
			material.uniforms['masterOpacity'] = new pioneer__WEBPACK_IMPORTED_MODULE_3__.THREE.Uniform(0.5);

			material.vertexShader = material.vertexShader.replace(
				'vec4 viewPosition = modelViewMatrix * vec4(offset, 1.0) + vec4(position, 0.0) * scale;',
				`
				vec4 viewOffset = modelViewMatrix * vec4(offset, 1.0);
				vec4 viewPosition = viewOffset + vec4(position, 0.0) * scale;
				`);
			material.vertexShader = material.vertexShader.replace(
				'gl_Position = projectionMatrix * viewPosition;',
				`
				float aspect_ratio_h = min(1.0, projectionMatrix[0][0] / projectionMatrix[2][1]);
				float aspect_ratio_v = min(1.0, projectionMatrix[2][1] / projectionMatrix[0][0]);
				gl_Position = projectionMatrix * viewOffset + vec4(position.x * viewOffset.y * scale * aspect_ratio_h, position.z * viewOffset.y * scale * aspect_ratio_v, 0, 0);
				`);
			material.vertexShader = material.vertexShader.replace(
				'fColor = color;',
				'fColor = color * clamp((length(viewPosition) - 21937.0) / 40000.0, 0.0, 1.0);'
			);

			material.fragmentShader = material.fragmentShader.replace(
				'varying vec2 fPosition;',
				`uniform float masterOpacity;
				varying vec2 fPosition;
				`);
			// including master opacity
			material.fragmentShader = material.fragmentShader.replace(
				'gl_FragColor = fColor * (1.0 - length(fPosition));',
				'gl_FragColor = fColor * (1.0 - step(1.0, length(fPosition))) * vec4(1.0, 1.0, 1.0, masterOpacity);'
			);
			material.needsUpdate = true;
			material.blending = pioneer__WEBPACK_IMPORTED_MODULE_3__.THREE.NormalBlending;
		});
	}

	/**
	 * Gets the total NEO count to maximumSignificantDigits.
	 * @param {number} maximumSignificantDigits
	 * @returns {string}
	 */
	getNeoTotal(maximumSignificantDigits = 2) {
		return this.neos?.size.toLocaleString(undefined, { maximumSignificantDigits, roundingMode: 'floor' });
	}
}

AsteroidsApp.html = (_app_html__WEBPACK_IMPORTED_MODULE_14___default());

AsteroidsApp.setAppClass();


/***/ }),

/***/ "./src/assets/index.js":
/*!*****************************!*\
  !*** ./src/assets/index.js ***!
  \*****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);












/***/ }),

/***/ "./src/components/asteroid_menu_bottom/asteroid_menu_bottom.js":
/*!*********************************************************************!*\
  !*** ./src/components/asteroid_menu_bottom/asteroid_menu_bottom.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidMenuBottom": function() { return /* binding */ AsteroidMenuBottom; }
/* harmony export */ });
/* harmony import */ var _navigation_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../navigation/navigation */ "./src/components/navigation/navigation.js");


/**
 * @inheritdoc
 * @extends Navigation
 */
class AsteroidMenuBottom extends _navigation_navigation__WEBPACK_IMPORTED_MODULE_0__.Navigation {
	/** @inheritdoc */
	init() {
		super.init();

		this.bindFunctions(['isFilteringChange']);
		this._callbackRegistry.push({
			emitter: this._app.getManager('filters'),
			event: 'isFilteringChange',
			callback: this.isFilteringChange
		});

		const param = {
			position: 'bottom',
			entry: [
				{
					title: 'Learn',
					svg: './assets/default/svg/learn.svg',
					onClick: () => {
						this._app.getManager('router').navigate({ modal: 'learn' });
					}
				},
				{
					title: 'Asteroid Watch',
					svg: './assets/svg/asteroid.svg',
					onClick: () => {
						this._app.getManager('watch').onWatchClick();
					}
				},
				{
					title: 'Filters',
					svg: './assets/svg/filter_inactive.svg',
					onClick: () => {
						this._app.getManager('router').navigate({ modal: 'filters' });
					}
				}
			]
		};
		super.setup(param);
	}

	/**
	 * Toggles the filters badge
	 * @param {boolean} isFiltering
	 */
	isFilteringChange(isFiltering) {
		super.toggleBadge('Filters', isFiltering);
	}
}


/***/ }),

/***/ "./src/components/asteroid_menu_top/asteroid_menu_top.js":
/*!***************************************************************!*\
  !*** ./src/components/asteroid_menu_top/asteroid_menu_top.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidMenuTop": function() { return /* binding */ AsteroidMenuTop; }
/* harmony export */ });
/* harmony import */ var _navigation_navigation__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../navigation/navigation */ "./src/components/navigation/navigation.js");


/**
 * @inheritdoc
 * @extends Navigation
 */
class AsteroidMenuTop extends _navigation_navigation__WEBPACK_IMPORTED_MODULE_0__.Navigation {
	/** @inheritdoc */
	init() {
		super.init();

		this.bindFunctions(['isFilteringChange']);
		this._callbackRegistry.push({
			emitter: this._app.getManager('filters'),
			event: 'isFilteringChange',
			callback: this.isFilteringChange
		});

		const currentRoute = this._app.getManager('router')._currentRoute;
		const query = currentRoute?.query || '';

		const param = {
			position: 'top',
			entry: [
				{
					title: 'Learn',
					svg: './assets/default/svg/learn.svg',
					active: query.includes('modal=learn'),
					onClick: () => {
						const router = this._app.getManager('router');
						router.navigate({ modal: 'learn' }, router.currentRoute.url);
					}
				},
				{
					title: 'Asteroid Watch',
					svg: './assets/svg/asteroid.svg',
					onClick: () => {
						this._app.getManager('watch').onWatchClick();
					},
					active: currentRoute.url?.includes('watch')
				},
				{
					title: 'Filters',
					svg: './assets/svg/filter_inactive.svg',
					active: query.includes('modal=filters'),
					onClick: () => {
						this._app.getManager('router').navigate({ modal: 'filters' });
					}
				}
			]
		};
		super.setup(param);
	}

	/**
	 * Called when the url get params change.
	 * @param {string} modal
	 */
	async onQueryChange({ modal } = {}) {
		super.toggleActive('Learn', modal === 'learn');
		super.toggleActive('Filters', modal === 'filters');
	}

	/**
	 * Toggles the filters badge
	 * @param {boolean} isFiltering
	 */
	isFilteringChange(isFiltering) {
		super.toggleBadge('Filters', isFiltering);
	}
}


/***/ }),

/***/ "./src/components/asteroid_modals/asteroid_modals.js":
/*!***********************************************************!*\
  !*** ./src/components/asteroid_modals/asteroid_modals.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidModals": function() { return /* binding */ AsteroidModals; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _modals__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modals */ "./src/components/asteroid_modals/modals/index.js");
/* harmony import */ var _asteroid_modals_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./asteroid_modals.html */ "./src/components/asteroid_modals/asteroid_modals.html");
/* harmony import */ var _asteroid_modals_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_asteroid_modals_html__WEBPACK_IMPORTED_MODULE_2__);






/**
 * A generic modal component.
 * @extends BaseComponent
 */
class AsteroidModals extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, null, {
			title: '',
			isVisible: false,
			...options
		});

		this._components = ['filtersModal', 'learnModal'];

		this._eventNames.push('overlay');
		this._initCallbacks();

		/**
		 * Stored values to reset on leaving.
		 * @type {Object<FiltersModal, LearnModal>}
		 * @private
		 */
		this._modals = {};

		/**
		 * Stored values to reset on leaving.
		 * @type {FiltersModal|LearnModal}
		 * @private
		 */
		this._activeModal = null;

		this.bindFunctions(['close']);
	}

	/**
	 * @override
	 */
	async init() {
		super.init();

		// Load modals
		this._modals.filters = await this._app.addComponentWithPlaceholder({ type: _modals__WEBPACK_IMPORTED_MODULE_1__.FiltersModal, name: 'filtersModal' }, this._element);
		this._modals.learn = await this._app.addComponentWithPlaceholder({ type: _modals__WEBPACK_IMPORTED_MODULE_1__.LearnModal, name: 'learnModal' }, this._element);

		// Create and store a reference to icon element.
		this._iconEl = document.createElement('img');
		this._children.header?.prepend(this._iconEl);
	}

	/**
	 * Execute actions on query change.
	 * @param {object} params
	 * @param {CancelToken} params.cancelToken
	 * @param {string} params.modal
	 */
	onQueryChange({ cancelToken, modal } = {}) {
		// Check if route was canceled
		if (cancelToken && cancelToken.isCanceled) {
			return;
		}

		const activeModal = this._modals[modal] ?? null;

		// If we're already at the activeModal or at no-modal (null), return early.
		if (this._activeModal === activeModal) {
			return;
		}

		// Set active modal.
		this._activeModal = activeModal;

		// Disable all modals by default.
		this._disableAllModals();

		if (this._activeModal) {
			const { _title: title, _svg: svg } = this._activeModal;

			// Set title state.
			this.setState({ title });

			// Set icon image properties.
			this._iconEl.src = svg ?? '';
			this._iconEl.alt = title ?? '';

			// Enable and show this main component.
			this.setEnabled(true);
			this.show();

			// Enable and show specific modal component.
			this._activeModal.setEnabled(true);
			this._activeModal.show();
		}
	}

	/**
	 * Updates the URL query to remove the modal parameter.
	 */
	close() {
		const router = this._app.getManager('router');
		router.navigate({ __remove: ['modal'] }, router.currentRoute.url, { keepTime: true });
	}

	/**
	 * Get the child components.
	 * @returns {string[]}
	 */
	get components() {
		return this._components;
	}

	/**
	 * Disables this, and all child components
	 */
	_disableAllModals() {
		Object.values(this._modals).forEach(modal => {
			modal.hide();
			modal.setEnabled(false);
		});

		this.hide();
		this.setEnabled(false);
	}
}

AsteroidModals.html = (_asteroid_modals_html__WEBPACK_IMPORTED_MODULE_2___default());


/***/ }),

/***/ "./src/components/asteroid_modals/modals/filters_modal/filters_modal.js":
/*!******************************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/filters_modal/filters_modal.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _filters_modal_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./filters_modal.html */ "./src/components/asteroid_modals/modals/filters_modal/filters_modal.html");
/* harmony import */ var _filters_modal_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_filters_modal_html__WEBPACK_IMPORTED_MODULE_1__);





/**
 * Filter modal component.
 * @extends BaseComponent
 */
class FiltersModal extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {import('eyes').Options} options
	 */
	constructor(app, options) {
		super(app, null, {
			...options
		});

		this.state = {
			asteroids: false,
			comets: false,
			phos: false
		};

		this._app = app;

		this._title = 'Filters';
		this._svg = './assets/svg/filter_inactive.svg';

		this._lastSize = null;

		this.bindFunctions([
			'_filterCallback'
		]);
	}

	/** @inheritdoc */
	init() {
		super.init();
		this.filtersManager = this._app.getManager('filters');
	}

	/**
	 * Called when the modal is opened
	 */
	onShow() {
		// Ensure checks and toggles match filter state
		const filters = this.filtersManager.getFilters();
		document.getElementById('filters-asteroids-checkbox').checked = filters.asteroids;
		document.getElementById('filters-comets-checkbox').checked = filters.comets;
		document.getElementById('filters-phos-toggle').checked = filters.phos;

		// Count the objects and update the indicator
		this._lastSize = this._lastSize != null ? this._lastSize : this._app.neos.size;
		document.getElementsByClassName('filters-modal-count')[0].innerHTML = `${this._lastSize != null ? `${this._lastSize.toLocaleString()}` : 'All'} objects`;
	}

	/**
	 * @override
	 */
	show() {
		this.onShow();
		super.show();
	}

	/**
	 * On asteroid checkbox change
	 * @param {Event} e - input event
	 */
	handleAsteroidCheck(e) {
		const checked = e.target.checked;
		this.filtersManager.setFilter('asteroids', checked, this._filterCallback);
	}

	/**
	 * On comet checkbox change
	 * @param {Event} e - input event
	 */
	handleCometCheck(e) {
		const checked = e.target.checked;
		this.filtersManager.setFilter('comets', checked, this._filterCallback);
	}

	/**
	 * On PHO toggle
	 * @param {Event} e - input event
	 */
	handlePHOToggle(e) {
		const checked = e.target.checked;
		this.filtersManager.setFilter('phos', checked, this._filterCallback);
	}

	/**
	 * Execute after filtering
	 * @param {number} size
	 */
	_filterCallback(size) {
		this._lastSize = size;
		document.getElementsByClassName('filters-modal-count')[0].innerHTML = `${this._lastSize?.toLocaleString()} objects`;
	}

	/**
	 * Clicked 'CLear all filters'
	 */
	handleResetFilters() {
		const filters = this.filtersManager.getFilters();

		if (filters.asteroids) document.getElementById('filters-asteroids-checkbox').click();
		if (filters.comets) document.getElementById('filters-comets-checkbox').click();
		if (filters.phos) document.getElementById('filters-phos-toggle').click();

		// Reset obj count label when filters are reset
		this._lastSize = this._app.neos.size;
	}

	/**
	 * Help ? clicked
	 * @param {Event} e - HTMLElement event
	 */
	handleHelp(e) {
		this._app.getComponent('definitionOverlay').navigateToDefinition(e.target?.dataset?.def);
	}
}

FiltersModal.html = (_filters_modal_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (FiltersModal);


/***/ }),

/***/ "./src/components/asteroid_modals/modals/filters_modal/index.js":
/*!**********************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/filters_modal/index.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _filters_modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filters_modal */ "./src/components/asteroid_modals/modals/filters_modal/filters_modal.js");



/* harmony default export */ __webpack_exports__["default"] = (_filters_modal__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./src/components/asteroid_modals/modals/index.js":
/*!********************************************************!*\
  !*** ./src/components/asteroid_modals/modals/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FiltersModal": function() { return /* reexport safe */ _filters_modal__WEBPACK_IMPORTED_MODULE_0__["default"]; },
/* harmony export */   "LearnModal": function() { return /* reexport safe */ _learn_modal__WEBPACK_IMPORTED_MODULE_1__["default"]; }
/* harmony export */ });
/* harmony import */ var _filters_modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./filters_modal */ "./src/components/asteroid_modals/modals/filters_modal/index.js");
/* harmony import */ var _learn_modal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./learn_modal */ "./src/components/asteroid_modals/modals/learn_modal/index.js");






/***/ }),

/***/ "./src/components/asteroid_modals/modals/learn_modal/index.js":
/*!********************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/learn_modal/index.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _learn_modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./learn_modal */ "./src/components/asteroid_modals/modals/learn_modal/learn_modal.js");



/* harmony default export */ __webpack_exports__["default"] = (_learn_modal__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "./src/components/asteroid_modals/modals/learn_modal/learn_modal.js":
/*!**************************************************************************!*\
  !*** ./src/components/asteroid_modals/modals/learn_modal/learn_modal.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _learn_modal_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./learn_modal.html */ "./src/components/asteroid_modals/modals/learn_modal/learn_modal.html");
/* harmony import */ var _learn_modal_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_learn_modal_html__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _configs_story_info_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../../configs/story_info.json */ "./src/configs/story_info.json");







/**
 * Learn modal component.
 * @extends BaseComponent
 */
class LearnModal extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {import('eyes').Options} options
	 */
	constructor(app, options) {
		super(app, null, {
			...options
		});

		this._title = 'Learn';
		this._svg = './assets/default/svg/learn.svg';
	}

	/**
	 * Navigates router to a story
	 * @param {object} story
	 */
	goToStory(story) {
		const router = this._app.getManager('router');
		document.getElementsByClassName('asteroid-modal-close')[0]?.click();
		// Use a 0.2s timeout to allow the modal to fade out cleanly
		// Otherwise returning from a story keeps the modal on screen for that brief second
		setTimeout(() => {
			router.navigate({ __remove: ['modal'] }, `/story/${story.path}`);
		}, 200);
	}

	/**
	 * Called when the modal is opened
	 */
	onShow() {
		const stories = _configs_story_info_json__WEBPACK_IMPORTED_MODULE_3__ || [];
		const modalBody = this._children.asteroidLearnModalBody;
		if (modalBody) {
			modalBody.textContent = '';
			stories.forEach(story => {
				const markup = [
					'<div class="learn-modal-story-card-hover"></div>',
					`<h3 class="learn-modal-story-card-title">${story.title}</h3>`,
					story.questions.map((q) => {
						return `<div class="learn-modal-story-card-question">${q}</div>`;
					}).join('\n')
				].join('\n');

				const card = document.createElement('div');
				card.className = 'learn-modal-story-card';
				card.innerHTML = markup;
				card.addEventListener('click', () => {
					this.goToStory(story);
				});

				modalBody.append(card);
			});
		}
	}

	/**
	 * @override
	 */
	show() {
		this.onShow();
		super.show();
	}
}

LearnModal.html = (_learn_modal_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (LearnModal);


/***/ }),

/***/ "./src/components/asteroid_panel/asteroid_panel.js":
/*!*********************************************************!*\
  !*** ./src/components/asteroid_panel/asteroid_panel.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidPanel": function() { return /* binding */ AsteroidPanel; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");





/**
 * AsteroidPanel extends CarouselPanel
 */
class AsteroidPanel extends eyes__WEBPACK_IMPORTED_MODULE_0__.CarouselPanel {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, {
			// Class names
			panelTypeClass: 'asteroid-panel',
			carouselClass: 'asteroid-carousel',
			prevButtonClass: 'asteroid-carousel-prev',
			nextButtonClass: 'asteroid-carousel-next',

			// Options
			title: 'Asteroid Panel',
			caption: '',
			headerIconClass: 'asteroid',

			...options
		});

		/**
		 * Boolean to say whether the panel is populated with data.
		 * @type {boolean}
		 * @private
		 */
		this._isPopulated = false;

		this._expandOnShow = true;
	}

	/**
	 * Compose the watch carousel slides
	 * @param {object} neoData
	 * @param {object} heroData
	 */
	populate(neoData, heroData) {
		// Set title and icon
		const icon = neoData.comet ? 'comet' : 'asteroid';
		this.setState({
			title: neoData.name,
			headerIconClass: icon
		});

		// Generate tab content.
		const allTabsContent = [];

		const essentialStats = this.getEssentialStats(neoData, heroData);
		essentialStats.length && allTabsContent.push({
			title: 'Essential stats',
			content: essentialStats
		});

		const orbitalPath = this.getOrbitalPath(neoData);
		orbitalPath.length && allTabsContent.push({
			title: 'Orbital path',
			content: orbitalPath
		});

		const closeApproach = this.getCloseApproach(neoData, heroData);
		closeApproach.length && allTabsContent.push({
			title: 'Close approach',
			content: closeApproach
		});

		// Create the tabs and init the swiper.
		this.createTabs(allTabsContent);

		// Set populated to true;
		this._isPopulated = true;
	}

	/**
	 * Return essential stats
	 * @param {object} neoData
	 * @param {object} heroData
	 * @returns {Array}
	 */
	getEssentialStats(neoData, heroData) {
		const { pioneerName, diameter, diameterEstimated, nextClosestApproachTime } = neoData;

		const neoEntity = this._app._scene.get(pioneerName);
		const earthEntity = this._app._scene.get('earth');
		const essentialStats = [];

		// Add discovery content.
		if (heroData?.stats?.discovery) {
			essentialStats.push({
				title: 'Discovery',
				content: heroData.stats.discovery
			});
		}

		// Add size content.
		if (diameter) {
			essentialStats.push({
				title: 'Size',
				content: `<p>Average ${diameterEstimated ? 'estimated' : ''} diameter</p>`,
				value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(diameter * 1000, 2)} m`
			});
		}

		// Add distance content.
		const posDifference = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
		neoEntity.getPositionRelativeToEntity(posDifference, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, earthEntity);
		const distanceKm = posDifference.magnitude();
		const distanceAU = distanceKm / eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm;

		if (!posDifference.isNaN()) {
			essentialStats.push({
				title: 'Distance',
				content: '<p>Current distance from Earth</p>',
				value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(distanceAU, 2)} <span class="clickable underline" data-def="au">AU</span>`
			});
		}

		// Add velocity.
		const asteroidVelocity = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
		neoEntity.getVelocityAtTime(asteroidVelocity, nextClosestApproachTime);

		const magnitude = asteroidVelocity.magnitude();
		if (magnitude) {
			essentialStats.push({
				title: 'Velocity',
				content: '<p>Current velocity relative to the Sun</p>',
				value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(magnitude, 2)} km/s`
			});
		}

		// Add rotation period.
		if (heroData?.stats?.rotation) {
			essentialStats.push({
				title: 'Period of Rotation',
				content: '<p>Time to complete one full rotation</p>',
				value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(heroData.stats.rotation, 2)} hours`
			});
		}

		return essentialStats;
	}

	/**
	 * Return orbital path
	 * @param {object} neoData
	 * @returns {Array}
	 */
	getOrbitalPath(neoData) {
		const { orbitalElements } = neoData;

		const orbitalPath = [];

		if (orbitalElements) {
			// Add orbital period.
			const period = orbitalElements.getPeriod();
			const days = Math.round(period / 86400); // seconds to days
			const years = days / 365;
			const time = years >= 1
				? `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(years, 2)} ${years === 1 ? 'year' : 'years'}`
				: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(days, 1)} ${days === 1 ? 'day' : 'days'}`;

			orbitalPath.push({
				title: 'Orbital Period',
				content: '<p>Time to complete one solar orbit</p>',
				value: time
			});

			// Add eccentricity.
			const { eccentricity } = orbitalElements;

			if (eccentricity) {
				orbitalPath.push({
					title: 'Eccentricity',
					content: '<p>Deviation from circular orbit</p>',
					value: eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(eccentricity, 3)
				});
			}

			// Perihelion, aphelion and inclination calculations.
			// The transformation from J2000Ecipse to J2000 coordinates.
			const eclipJ2000ToJ2000Rotation = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.9791532214288992, 0.2031230389823101, 0, 0);

			const orbitalElementsRelEcliptic = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			orbitalElementsRelEcliptic.copy(orbitalElements);
			orbitalElementsRelEcliptic.orbitOrientation.multInverseL(eclipJ2000ToJ2000Rotation, orbitalElementsRelEcliptic.orbitOrientation);

			const periapsisKm = orbitalElementsRelEcliptic.getPeriapsis();
			if (periapsisKm) {
				orbitalPath.push({
					title: 'Perihelion',
					content: '<p>Closest distance to the Sun<p/>',
					value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(periapsisKm / eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm, 2)} <span class="clickable underline" data-def="au">AU</span>`
				});
			}

			const apoapsisKm = orbitalElementsRelEcliptic.getApoapsis();
			if (apoapsisKm) {
				orbitalPath.push({
					title: 'Aphelion',
					content: '<p>Farthest distance from the Sun</p>',
					value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(apoapsisKm / eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm, 2)} <span class="clickable underline" data-def="au">AU</span>`
				});
			}

			const inclination = orbitalElementsRelEcliptic.getInclination();
			if (inclination) {
				orbitalPath.push({
					title: 'Inclination',
					content: '<p>Angle relative to the x-y ecliptic plane</p>',
					value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(pioneer__WEBPACK_IMPORTED_MODULE_1__.MathUtils.radToDeg(inclination), 3)} deg`
				});
			}
		}

		return orbitalPath;
	}

	/**
	 * Return close approach
	 * @param {object} neoData
	 * @param {object} heroData
	 * @returns {Array}
	 */
	getCloseApproach(neoData, heroData) {
		const { nextClosestApproachDistance, nextClosestApproachTime } = neoData;
		const closeApproach = [];

		if (heroData?.approach?.fact) {
			closeApproach.push({
				content: heroData.approach.fact
			});
		}

		if (nextClosestApproachTime) {
			const unixSeconds = pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.etToUnix(nextClosestApproachTime);
			const date = new Date(unixSeconds * 1000);

			if (date) {
				closeApproach.push({
					title: 'Date',
					content: '<p>Closest approach to Earth < 0.05 <span class="clickable underline" data-def="au">AU</span></p>',
					value: eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatDate(date)
				});
			}
		}

		if (nextClosestApproachDistance) {
			closeApproach.push({
				title: 'Distance',
				content: '<p>Nearest distance to Earth</p>',
				value: `${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatNumber(nextClosestApproachDistance, 0)} km`
			});
		}

		return closeApproach;
	}

	/**
	 * Only show panel when it's populated.
	 * @override
	 */
	show(initSwiper = true) {
		this._isPopulated && super.show(initSwiper);
	}

	/**
	 * @override
	 */
	_destroy() {
		this._isPopulated = false;

		super._destroy();
	}
}


/***/ }),

/***/ "./src/components/breadcrumb/breadcrumb.js":
/*!*************************************************!*\
  !*** ./src/components/breadcrumb/breadcrumb.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Breadcrumb": function() { return /* binding */ Breadcrumb; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");



/**
 * Breadcrumb for Asteroids.
 * @extends BaseBreadcrumb
 */
class Breadcrumb extends eyes__WEBPACK_IMPORTED_MODULE_0__.Breadcrumb {
	/**
	 * @inheritdoc
	 * @override
	 */
	async init() {
		super.init();
		this.setState({
			moduleText: this._crumbTexts.asteroids
		});
	}

	/**
	 * @inheritdoc
	 * @override
	 */
	_goToHome() {
		this._app.getManager('router').navigate({ __remove: 'all' }, '/home');
	}
}


/***/ }),

/***/ "./src/components/countdown/countdown.js":
/*!***********************************************!*\
  !*** ./src/components/countdown/countdown.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Countdown": function() { return /* binding */ Countdown; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _countdown_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./countdown.html */ "./src/components/countdown/countdown.html");
/* harmony import */ var _countdown_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_countdown_html__WEBPACK_IMPORTED_MODULE_2__);






/**
 * Countdown component.
 */
class Countdown extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, null, {
			isVisible: true,
			tText: 'T -',
			numDays: '00',
			numHours: '00',
			numMinutes: '00',
			numSeconds: '00',
			...options
		});

		this._timeTarget = null;
		this._remainingSeconds = null;

		this.bindFunctions(['update']);
	}

	/** @inheritdoc */
	init() {
		super.init();

		this._callbackRegistry.push({
			emitter: this._app.getManager('time'),
			event: 'update',
			callback: this.update
		});
	}

	/**
	 * Parse remaining seconds
	 * @param {number} remaining
	 * @returns {object}
	 */
	_parseRemaining(remaining) {
		const minuteSeconds = 60;
		const hourSeconds = minuteSeconds * 60;
		const daySeconds = hourSeconds * 24;

		let numSeconds = parseInt(Math.abs(remaining), 10);

		const numDays = Math.floor(numSeconds / daySeconds);
		numSeconds -= numDays * daySeconds;
		const numHours = Math.floor(numSeconds / hourSeconds);
		numSeconds -= numHours * hourSeconds;
		const numMinutes = Math.floor(numSeconds / minuteSeconds);
		numSeconds -= numMinutes * minuteSeconds;

		return {
			tText: remaining > 0 ? 'T﹣' : 'T﹢',
			numDays: String(numDays).padStart(2, '0'),
			numHours: String(numHours).padStart(2, '0'),
			numMinutes: String(numMinutes).padStart(2, '0'),
			numSeconds: String(numSeconds).padStart(2, '0')
		};
	}

	/**
	 * Update time display.
	 * @param {import('moment').Moment} currentMoment
	 */
	update(currentMoment) {
		// Don't update if not visible
		// Todo: make sure to set hide countdown when it's not visible (not sure if hiding parent component affects it)
		if (!this._state.isVisible) {
			return;
		}

		// Get the pioneer ET time in order to reduce multiple ET to UNIX conversions
		const currentEtTime = this._app?._pioneer?.getTime() || pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.unixToEt(currentMoment.valueOf() * 0.001);

		// Calculate remaining seconds and only update if it's changed.
		const remainingSeconds = Math.round(this._timeTarget - currentEtTime);

		if (remainingSeconds !== this._remainingSeconds) {
			// parse remaining, set states, and _remainingSeconds prop

			const {
				tText,
				numDays,
				numHours,
				numMinutes,
				numSeconds
			} = this._parseRemaining(remainingSeconds);

			this.setState({
				tText,
				numDays,
				numHours,
				numMinutes,
				numSeconds
			});

			this._remainingSeconds = remainingSeconds;
		}
	}

	/**
	 * Sets the time target in Ephemeris Time (ET)
	 * @param {number} time
	 */
	setTimeTarget(time) {
		this._timeTarget = time;
	}

	/**
	 * Gets time target.
	 * @returns {number}
	 */
	getTimeTarget() {
		return this._timeTarget;
	}

	/**
	 *
	 */
	hide() {
		console.log('hide');
		super.hide();
	}
}

Countdown.html = (_countdown_html__WEBPACK_IMPORTED_MODULE_2___default());


/***/ }),

/***/ "./src/components/definition_overlay/definition_overlay.js":
/*!*****************************************************************!*\
  !*** ./src/components/definition_overlay/definition_overlay.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DefinitionOverlay": function() { return /* binding */ DefinitionOverlay; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _definition_overlay_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./definition_overlay.html */ "./src/components/definition_overlay/definition_overlay.html");
/* harmony import */ var _definition_overlay_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_definition_overlay_html__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _data_definitions_json__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../data/definitions.json */ "./src/data/definitions.json");






/**
 * Layer panel component.
 */
class DefinitionOverlay extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		// Add state options
		super(app, null, {
			isVisible: false
		});

		// Store imported json definitions in class variable.
		this._definitions = _data_definitions_json__WEBPACK_IMPORTED_MODULE_2__;

		// Define router reference.
		this._router = null;

		// Define the query unsubscribe reference.
		this._queryUnsubscribe = null;

		// Define the scrollbar component.
		this._scrollbar = null;

		// Override small font size.
		this._class.fontSize.small = '';

		// Keep track of definition histories
		this._activeDef = null;
		this._prevDef = null;

		// Add default class to state
		Object.assign(this._state, {
			title: null,
			content: null,
			fontSizeClass: ''
		});

		// Bind functions called outside this class that need use 'this'.
		this.bindFunctions([
			'navigateToDefinition',
			'_updateDefinition',
			'_handleOutsideClick',
			'_handleContainerClick'
		]);
	}

	/**
	 * Initialization.
	 */
	init() {
		super.init();

		// Assign _router and subscribe to the definition query.
		this._router = this._app.getManager('router');
	}

	/**
	 * Called when the url get params change. Wraps _updateDefinition
	 * @param {object} params
	 * @param {CancelToken} params.cancelToken
	 * @param {string} params.definition
	 */
	async onQueryChange({ cancelToken, definition } = {}) {
		// Check if route was canceled
		if (cancelToken && cancelToken.isCanceled) {
			return;
		}

		this._prevDef = this._activeDef;
		this._activeDef = definition;
		this._updateDefinition(this._activeDef, this._prevDef);
	}

	/**
	 * Determine if the definition string has a matching object config
	 * @param {string} currDefinition
	 * @param {string} prevDefinition
	 */
	_updateDefinition(currDefinition, prevDefinition) {
		// Validate definition by checking if its in our definitions data object.
		const currDefObj = this._definitions[currDefinition] ?? false;
		const prevDefObj = this._definitions[prevDefinition] ?? false;

		if (currDefObj) {
			const { title, html: content, related } = currDefObj;

			// Set the states to populate the content.
			this.setState({ title, content });

			// A nice extension to Mi's nullish coalescing operator skillshare:
			// https://stackoverflow.com/questions/1011317/replace-a-value-if-null-or-undefined-in-javascript
			this._scrollbar ??= eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addScrollbar(this._children.contentEl, {
				sizeAutoCapable: true
			});

			// Make sure to scroll to the top of the content (it may have previosly scrolled down in portrait mobile)
			this._scrollbar.scroll(0, 300);

			// Create the related terms elements
			const relatedElements = related.map(defId => {
				const title = this._definitions[defId]?.title;
				const relatedItem = document.createElement('div');
				relatedItem.className = 'definition-related-item small clickable';
				relatedItem.setAttribute('data-def', defId);
				relatedItem.innerText = title;
				return relatedItem;
			});

			// Replace the children of the related element container
			this._children.relatedEl.replaceChildren(...relatedElements);

			// Only show if we had no prev definition.
			if (!prevDefObj) {
				this.show();
			}
		}
		else if (prevDefObj) {
			// We had a prev definition but now we dont have one at all so we need to hide the overlay
			this.hide();
		}
	}

	/**
	 * Update the router query.
	 * @param {string} definitionId
	 */
	navigateToDefinition(definitionId) {
		if (definitionId) {
			this._router.navigate({ definition: definitionId }, this._router.currentRoute.url);
		}
		// if false is specifically passed, remove the query
		else if (definitionId === false) {
			this._router.navigate({ __remove: ['definition'] }, this._router.currentRoute.url);
		}
	}

	/**
	 * Update the route to navigate to a story (slide number optional).
	 * @param {string} storyId
	 * @param {string} storySlide
	 */
	navigateToStory(storyId, storySlide = '1') {
		const query = { slide: `slide_${storySlide}` };
		const path = `/story/${storyId}`;
		const options = { __remove: ['modal', 'definition'] };

		this.app.getManager('router').navigate(query, path, options);
	}

	/**
	 * Handle click outside overlay
	 * @param {event} e
	 */
	_handleOutsideClick(e) {
		e.stopPropagation();
		this.navigateToDefinition(false);
	}

	/**
	 * Handle click in container, if we find a data-def attribute, navigate to the definition
	 * @param {event} e
	 */
	_handleContainerClick(e) {
		e.stopPropagation();

		const { storyid: storyId, storyslide: storySlide, def: definitionId } = e?.target?.dataset || {};

		if (storyId) {
			this.navigateToStory(storyId, storySlide);
		}
		else if (definitionId) {
			this.navigateToDefinition(definitionId);
		}
	}

	/**
	 * Overrides destroy method.
	 */
	__destroy() {
		// Unsubscribe from query.
		if (typeof this._queryUnsubscribe === 'function') {
			this._queryUnsubscribe();
		}

		// Make sure references are null.
		this._queryUnsubscribe = null;

		this._router = null;

		this._definitions = null;

		// Call superclass __destroy method.
		super.__destroy();
	}
}

DefinitionOverlay.html = (_definition_overlay_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "./src/components/following_panel/following_panel.js":
/*!***********************************************************!*\
  !*** ./src/components/following_panel/following_panel.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FollowingPanel": function() { return /* binding */ FollowingPanel; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");




/**
 * FollowingPanel extends CarouselPanel
 */
class FollowingPanel extends eyes__WEBPACK_IMPORTED_MODULE_0__.CarouselPanel {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, {
			// Class names
			panelTypeClass: 'following-panel',

			// Options
			title: '',
			preTitle: 'following',

			...options
		});
	}
}


/***/ }),

/***/ "./src/components/home_button/home_button.js":
/*!***************************************************!*\
  !*** ./src/components/home_button/home_button.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HomeButton": function() { return /* binding */ HomeButton; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");




/**
 * HomeButton component
 */
class HomeButton extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Initilizing the component
	 */
	init() {
		this._element = document.createElement('h5');
		this._element.innerText = 'See all asteroids';
		this._element.className = 'home-button clickable {{isVisibleClass}}';

		// Add the click event.
		this._element.addEventListener('click', () => {
			// Navigate home, resetting query.
			const routeManager = this._app.getManager('router');

			// const currentQuery = routeManager.buildQuery(routeManager.query);
			routeManager.navigate({ __remove: 'all' }, '/home');
		});

		super.init();
	}
}


/***/ }),

/***/ "./src/components/mission_panel/mission_panel.js":
/*!*******************************************************!*\
  !*** ./src/components/mission_panel/mission_panel.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MissionPanel": function() { return /* binding */ MissionPanel; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");




/**
 * MissionPanel extends CarouselPanel
 */
class MissionPanel extends eyes__WEBPACK_IMPORTED_MODULE_0__.CarouselPanel {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, {
			// Class names
			panelTypeClass: 'mission-panel',
			carouselClass: 'mission-carousel',
			prevButtonClass: 'mission-carousel-prev',
			nextButtonClass: 'mission-carousel-next',

			// Options
			title: 'Mission Panel',
			caption: '',
			headerIconClass: 'spacecraft',

			...options
		});

		/**
		 * Boolean to say whether the panel is populated with data.
		 * @type {boolean}
		 * @private
		 */
		this._isPopulated = false;

		this._expandOnShow = true;
	}

	/**
	 * Compose the watch carousel slides
	 * @param {string} title
	 * @param {string} blurb
	 * @param {string} cameraTarget
	 * @param {object} events
	 */
	populate(title, blurb, cameraTarget, events = {}) {
		const { hideExternalLinks } = this._app.getManager('router').configs;

		const panelTitle = hideExternalLinks === true ? this._app.getManager('content').hideExternalLinksInText(title) : title;

		// Set title
		this.setState({ title: panelTitle });

		// Generate tab content.
		const allTabsContent = [];

		const panelBlurb = hideExternalLinks === true ? this._app.getManager('content').hideExternalLinksInText(blurb) : blurb;

		panelBlurb && allTabsContent.push({
			title: 'Overview',
			content: [{ content: `<p class='long'>${panelBlurb}</p>` }]
		});

		// Filter events with 'visual' flag
		const filteredEvents = events ? Object.values(events).filter(({ visual }) => visual) : [];

		// Create content array
		if (filteredEvents.length) {
			const timeManager = /** @type {TimeManager} */(this.app.getManager('time'));
			const routeManager = /** @type {RouteManager} */(this.app.getManager('router'));
			const content = filteredEvents.map(({ title, start, rate, target, id, distance, verticleOffset, horizontalOffset }) => {
				const dateInt = start?.valueOf();
				const date = dateInt && new Date(dateInt);

				return {
					title,
					...date && {
						content: `<p>${eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatDate(date)}</p>`,
						value: 'Watch'
					},
					onClick: async () => {
						if (start && routeManager?.currentRoute) {
							// Prevent clock to stop due to min time limit reached
							if (id === 'launch') {
								start = start.clone().add(1, 's');
							}
							timeManager.setTime(start);
							timeManager.setTimeRate(rate || 1);
							const query = {
								time: timeManager.getTimeUrl(),
								rate: timeManager.getTimeRate()
							};

							// Reset filters to avoid missing entities
							this.app.getComponent('filtersModal').handleResetFilters();

							await routeManager.navigate(query, routeManager.currentRoute.url);
							// Align to target
							if (target) {
								// Make sure targets are loaded
								await this.app.getManager('scene').isListReady([cameraTarget, target]);
								await this.app.scene.getEntity(cameraTarget).getLoadedPromise();
								await this.app.scene.getEntity(target).getLoadedPromise();
								await this.app.cameraScripts.alignObjects(cameraTarget, target, {
									duration: 1,
									distance: distance ?? 0.1,
									verticleOffset: verticleOffset ?? 0,
									horizontalOffset: horizontalOffset ?? 0
								});
							}
						}
					}
				};
			});

			allTabsContent.push({
				title: 'Events',
				content
			});
		}

		// Create the tabs and init the swiper.
		this.createTabs(allTabsContent);

		// Set populated to true;
		this._isPopulated = true;
	}

	/**
	 * Only show panel when it's populated.
	 * @override
	 */
	show(initSwiper = true) {
		this._isPopulated && super.show(initSwiper);
	}

	/**
	 * @override
	 */
	_destroy() {
		this._isPopulated = false;

		super._destroy();
	}
}


/***/ }),

/***/ "./src/components/navigation/navigation.js":
/*!*************************************************!*\
  !*** ./src/components/navigation/navigation.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Navigation": function() { return /* binding */ Navigation; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _navigation_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./navigation.html */ "./src/components/navigation/navigation.html");
/* harmony import */ var _navigation_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_navigation_html__WEBPACK_IMPORTED_MODULE_1__);





/**
 * Navigation component.
 * @extends BaseComponent
 */
class Navigation extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app, null, {
			position: 'top'
		});

		this._entries = {};

		// Binds
		this.bindFunctions(['toggleBadge']);
	}

	/**
	 * Setup menu elements
	 * @param {Array} param - list of menu elements
	 */
	setup(param) {
		const { position = 'top', entry = [] } = param;
		this.setState({ position });

		this._children.list.innerHTML = '';
		for (let i = 0; i < entry.length; i += 1) {
			const div = document.createElement('div');
			div.className = 'clickable';
			if (entry[i].active) {
				div.classList.add('active');
			}
			const button = document.createElement('button');

			button.innerHTML = `<div><h2>${entry[i].title}</h2><div class="navigation-badge"></div></div>`;

			if (entry[i].svg) {
				const img = document.createElement('img');
				img.src = entry[i].svg;
				img.alt = entry[i].title;
				div.appendChild(img);
			}
			div.appendChild(button);

			if (entry[i].onClick) {
				div.addEventListener(
					'click',
					e => {
						e.preventDefault();
						entry[i].onClick(entry[i], e);
					},
					false
				);
				div.addEventListener(
					'touchend',
					e => {
						e.preventDefault();
						entry[i].onClick(entry[i], e);
					},
					false
				);
			}

			this._entries[entry[i].title] = { entry: entry[i], element: div };

			this._children.list.append(div);
		}
	}

	/**
	 * Toggles or sets the navigation item's active state
	 * @param {string} entryName
	 * @param {boolean?} on
	 */
	toggleActive(entryName, on) {
		if (this._entries[entryName]) {
			const elm = this._entries[entryName].element;
			const wasOn = elm.classList.contains('active');
			if (wasOn !== on) {
				elm.classList.toggle('active');
			}
		}
	}

	/**
	 * Toggles or sets the navigation item's badged state
	 * @param {string} entryName
	 * @param {boolean?} on
	 */
	toggleBadge(entryName, on) {
		if (this._entries[entryName]) {
			const elm = this._entries[entryName].element;
			const wasOn = elm.classList.contains('badged');
			if (wasOn !== on) {
				elm.classList.toggle('badged');
			}
		}
	}
}

Navigation.html = (_navigation_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "./src/components/search/search.js":
/*!*****************************************!*\
  !*** ./src/components/search/search.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Search": function() { return /* binding */ Search; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


/**
 * @inheritdoc
 * @extends EyesSearch
 */
class Search extends eyes__WEBPACK_IMPORTED_MODULE_0__.Search {
	/**
	 * @inheritdoc
	 * @override
	 */
	_getLink(link) {
		return this._app.getManager('link')?.getParsedLink?.(link) || link;
	}
}


/***/ }),

/***/ "./src/components/settings/asteroids_settings.js":
/*!*******************************************************!*\
  !*** ./src/components/settings/asteroids_settings.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidsSettings": function() { return /* binding */ AsteroidsSettings; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


/**
 * AsteroidsSettings.
 */
class AsteroidsSettings extends eyes__WEBPACK_IMPORTED_MODULE_0__.Settings {
	/**
	 * Toggle info panel override.
	 */
	toggleInfoPanel() {
		const tutorialIndex = 0;
		const goHome = true;
		this._app.getComponent('tutorialOverlay')?.navigateToTutorial(tutorialIndex, goHome);
	}
}


/***/ }),

/***/ "./src/components/splash_screen/splash_screen.js":
/*!*******************************************************!*\
  !*** ./src/components/splash_screen/splash_screen.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SplashScreen": function() { return /* binding */ SplashScreen; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _splash_screen_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./splash_screen.html */ "./src/components/splash_screen/splash_screen.html");
/* harmony import */ var _splash_screen_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_splash_screen_html__WEBPACK_IMPORTED_MODULE_1__);





/**
 * A Splash screen component.
 */
class SplashScreen extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options = {}) {
		// call super class and  pass default state object.
		super(app, null, {
			...options
		});

		this._dragging = false;
		this._mousedownY = null;
		this._mousewheelDeltaY = 0;
		this._animationPercent = 0;
		this._timeout = null;
		this._lockEnd = false;
	}

	/**
	 * Display the splash screen.
	 */
	_displaySplash() {
		this._element.style.pointerEvents = 'all';

		this._element.addEventListener('mousedown', this._onDown.bind(this));
		this._element.addEventListener('touchstart', this._onDown.bind(this));
		this._element.addEventListener('mousemove', this._onMove.bind(this));
		this._element.addEventListener('touchmove', this._onMove.bind(this));
		this._element.addEventListener('mouseup', this._onUp.bind(this));
		this._element.addEventListener('touchend', this._onUp.bind(this));
		this._element.addEventListener('wheel', this._onWheel.bind(this));

		// Move past the splash screen after a timeout too
		this._timeout = setTimeout(() => {
			this._setAnimationPercent(1, true);
		}, 5500);

		// Create Random Stars
		let starsBoxShadow1 = '';
		for (let i = 0; i < 8; i++) {
			starsBoxShadow1 += `${parseInt(Math.random() * window.innerWidth)}px ${parseInt(Math.random() * window.innerHeight)}px hsl(0deg, 0%, ${parseInt(Math.random() * 80) + 20}%), `;
		}
		this._children.splashScreenStars1.style.boxShadow = starsBoxShadow1.slice(0, -2);

		let starsBoxShadow2 = '';
		for (let i = 0; i < 24; i++) {
			starsBoxShadow2 += `${parseInt(Math.random() * window.innerWidth)}px ${parseInt(Math.random() * window.innerHeight)}px hsl(0deg, 0%, ${parseInt(Math.random() * 80) + 20}%), `;
		}
		this._children.splashScreenStars2.style.boxShadow = starsBoxShadow2.slice(0, -2);

		// Set default pioneer transition styles
		const pioneerElm = document.getElementById('pioneer');
		if (pioneerElm) {
			pioneerElm.style.transform = 'scale(1.2)';
			pioneerElm.style.filter = 'brightness(0) grayscale(0)';
			pioneerElm.style.opacity = '0';
		}

		// End the loading screen.
		this.app.endLoadingScreen();
	}

	/**
	 * On Splash Screen mouse wheel
	 * @param {MouseEvent} e
	 */
	_onWheel(e) {
		this._setAnimationPercent(1, true);
	}

	/**
	 * On Splash Screen mouse or touch down
	 * @param {MouseEvent} e
	 */
	_onDown(e) {
		if (e.touches?.length > 0) e = e.touches[0];
		this._mousedownY = e.clientY;
	}

	/**
	 * On Splash Screen drag
	 * @param {MouseEvent} e
	 */
	_onMove(e) {
		if (e.touches?.length > 0) e = e.touches[0];
		const dragDistance = this._mousedownY - e.clientY;
		if (this._mousedownY != null && dragDistance > 6) {
			this._dragging = true;
		}
		if (this._dragging) {
			this._setAnimationPercent(1, true);
		}
	}

	/**
	 * On Splash Screen mouse or touch up
	 */
	_onUp() {
		this._setAnimationPercent(1, true);

		this._dragging = false;
		this._mousedownY = null;
	}

	/**
	 * Sets the overall splash screen's animation completion
	 * When percent == 1, the splash screen ends
	 * @param {number} percent - actually between 0 and 1
	 * @param {boolean} useTransitions
	 */
	_setAnimationPercent(percent, useTransitions) {
		const previousPercent = this._animationPercent;

		this._animationPercent = percent;
		const baseTransition = 'all 0.8s cubic-bezier(0.645, 0.045, 0.355, 1)';
		const longTransition = 'all 1.1s cubic-bezier(0.645, 0.045, 0.355, 1)';

		this._children.splashScreen.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreen.style.opacity = `${1 - (Math.pow(percent, 2))}`;
		this._children.splashScreenAsteroid.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenAsteroid.style.width = `${68 - (percent * 30)}vh`;
		this._children.splashScreenAsteroid.style.height = `${68 - (percent * 30)}vh`;
		this._children.splashScreenEnterBackground.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenEnterBackground.style.top = `calc(${86 - (percent * 44)}% - 54px)`;
		this._children.splashScreenEnterBackground.style.width = `${100 + (percent * 1200)}vw`;
		this._children.splashScreenEnterBackground.style.height = `${100 + (percent * 1200)}vw`;
		this._children.splashScreenText.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenText.style.top = `${55 - (percent * 40)}%`;
		this._children.splashScreenTextEyes.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenTextEyes.style.lineHeight = `${60 - (percent * 50)}px`;
		this._children.splashScreenTextOn.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenTextOn.style.lineHeight = `${40 - (percent * 50)}px`;
		this._children.splashScreenTextAsteroids.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenTextAsteroids.style.lineHeight = `${80 - (percent * 50)}px`;
		this._children.splashScreenEnter.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenEnter.style.top = `${81 - (percent * 30)}%`;
		this._children.splashScreenStars1.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenStars1.style.marginTop = `${(percent * 1)}%`;
		this._children.splashScreenStars2.style.transition = useTransitions ? baseTransition : 'unset';
		this._children.splashScreenStars2.style.marginTop = `${(percent * 0.5)}%`;

		// Set pioneer transition styles
		const pioneerElm = document.getElementById('pioneer');
		if (pioneerElm) {
			pioneerElm.style.transition = useTransitions ? longTransition : 'unset';
			pioneerElm.style.transform = `scale(${1.2 - (percent * 0.2)})`;
			pioneerElm.style.opacity = `${percent}`;
			pioneerElm.style.filter = `brightness(${percent}) grayscale(${1 - percent})`;
		}

		// Set the pointer events early so pioneer interaction is immediate
		if (this._animationPercent >= 1) {
			this._element.style.pointerEvents = 'none';
		}
		else {
			this._element.style.pointerEvents = 'all';
		}

		if (!this._dragging && this._animationPercent >= 1 && !this._lockEnd) {
			this._lockEnd = true;
			// Remove the splash screen
			setTimeout(() => {
				clearTimeout(this._timeout);

				if (pioneerElm) {
					pioneerElm.style.transform = 'unset';
					pioneerElm.style.transition = 'unset';
					pioneerElm.style.opacity = 'unset';
					pioneerElm.style.filter = 'unset';
				}

				this.destroy();
			}, 1100 * (1 - previousPercent));
		}
	}

	/**
	 * @override
	 * Override splash screen enable to determine visibility from router logic.
	 */
	__enable() {
		super.__enable();

		const { currentRoute, previousRoute, homeRoute } = this.app.getManager('router');
		// Only trigger splash on the base or undefined route without a previous route.
		if (previousRoute.url === undefined && (currentRoute.url === undefined || currentRoute.url === homeRoute)) {
			this._displaySplash();
		}
		else {
			this.destroy();
		}
	}
}

SplashScreen.html = (_splash_screen_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "./src/components/time_slider/time_slider.js":
/*!***************************************************!*\
  !*** ./src/components/time_slider/time_slider.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeSlider": function() { return /* binding */ TimeSlider; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _time_slider_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./time_slider.html */ "./src/components/time_slider/time_slider.html");
/* harmony import */ var _time_slider_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_time_slider_html__WEBPACK_IMPORTED_MODULE_2__);





const { debounce } = eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils;

/**
 * Time slider component.
 * @extends BaseComponent
 */
class TimeSlider extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		// Set default config.
		options.config = {
			snapPoints: [
				1, // 1 sec
				10, // 10 secs
				60, // 1 min
				300, // 5 mins
				600, // 10 mins
				3600, // 1 hr
				86400, // 1 day
				604800, // 1 week
				5256000, // 2 months
				31540000 // 1 year
			],

			// apply a dynamic rate coefficient to the fastest rate
			enableDynamicRate: false,
			// default camera distance value if not measurable
			defaultCamDistance: 700000000,
			// variation in fastest time rates (seconds per second)
			fastestRate: {
				min: 86400, // 1 day / sec
				max: 157700000 // 5 yrs / sec
			},

			...options.config
		};

		super(app, null, {
			startX: null,
			transX: 0,
			lineMeasures: { left: null, width: null, isMeasured: false },
			fastestRate: null,
			rateArray: null,
			realtimeVisibleClass: 'hidden',
			...options
		});

		/**
		 * Current time rate
		 * @type {number}
		 * @private
		 */
		this._currentRate = null;

		/**
		 * Current camera distance to it's target
		 * @type {number}
		 * @private
		 */
		this._camDistance = null;

		/**
		 * Whether we're at a time limit.
		 * @type {string}
		 * @private
		 */
		this._limit = null;

		/**
		 * Additional classes for various screen sizes.
		 * @type {Array<string>}
		 * @private
		 */
		this._extraClasses = ['offset-right', 'v-squeezy', 'h-squeezy', 'portrait', 'landscape'];

		/**
		 * Called if set, once cam distance has been established.
		 * @type {function(number):void}
		 * @private
		 */
		this._camDistanceResolve = null;

		this.bindFunctions([
			'_onMouseTouchDown',
			'_onMouseTouchMove',
			'_onMouseTouchUp',
			'_getFastestRate',
			'_snapToRate',
			'_getRateArray',
			'_onRealtimeClick',
			'_update'
		]);

		// Debounced resize
		this._resizeDebounced = debounce(this._onResize, 300);
	}

	/**
	 * @inheritdoc
	 * @override
	 */
	init() {
		super.init();

		const timeManager = this.app.getManager('time');

		// Add update callback.
		this._callbackRegistry.push({
			emitter: timeManager,
			event: 'update',
			callback: this._update
		},
		{
			emitter: timeManager,
			event: 'forcedpause',
			callback: (_, limit) => this._setLimit(limit)
		});

		this._addHandlers();
	}

	/**
	 * Called when the url get params change.
	 * @param {object} params
	 * @param {number|undefined} params.rate
	 */
	async onQueryChange({ rate }) {
		const negative = rate < 0;
		const absRate = Math.abs(rate ?? 1);

		// If rate is paused, save come calculations.
		if (rate === 0) {
			this.setCurrentRate(0);
			this._setTransX(0);
			return;
		}

		// Measure line so we have a left and width values.
		const { width } = this._measureLine();

		/**
		 * onQueryChange runs into a problem:
		 * - the 3D camera is not yet positioned (or is at NaN) so we have no distance, and cant generate the fastest rate.
		 *
		 * To resolve it (literally), we have a custom promise to wait for...
		 */
		await this._waitForCamDistance();

		const { rateArray } = this._state;

		// Determine the snapped rate if snapping enabled,
		let snappedAbsRate = this._snapToRate(absRate);

		// Snap to first value in rate array if less than second.
		if (snappedAbsRate < rateArray[1]) {
			snappedAbsRate = rateArray[0];
		}

		// Determine if we're trying to go over a max limit or under a min.
		const belowMin = this._limit === 'min' && negative && rate !== undefined;
		const aboveMax = this._limit === 'max' && !negative && rate !== undefined;

		// Calculate snapped rate.
		const snappedRate = belowMin || aboveMax
			? 0
			: negative && snappedAbsRate !== rateArray[0] ? snappedAbsRate * -1 : snappedAbsRate;

		// Determine if we need to re-update the query, ie. query rate is different to the snapped rate.
		const reupdateQuery = rate !== snappedRate && rate !== undefined;

		// Set rate.
		this.setCurrentRate(snappedRate);

		// Calc and set transX.
		const normVal = this._calculateNormValue(snappedAbsRate);
		const absTransX = normVal * width * 0.5;
		const transX = negative ? absTransX * -1 : absTransX;

		this._setTransX(transX);

		// Reupdate query if needed.
		reupdateQuery && this.updateQuery();
	}

	/**
	 * Sets a local var for a reached limit.
	 * @param {string} limit
	 */
	_setLimit(limit) {
		this._limit = limit;
	}

	/**
	 * Async check for when camera is correctly positioned.
	 * Resolve in _update once cam position is not NaN
	 * @returns {Promise<void|number>}
	 */
	async _waitForCamDistance() {
		if (this._camDistance && !isNaN(this._camDistance)) {
			return Promise.resolve(this._camDistance);
		}

		return new Promise((resolve) => {
			this._camDistanceResolve = resolve;
		});
	}

	/**
	 * Add the initial event handlers.
	 */
	_addHandlers() {
		const { iconEl } = this._children;
		// Add both mouse and touch down events as some devices allow both.
		iconEl.addEventListener('mousedown', this._onMouseTouchDown);
		iconEl.addEventListener('touchstart', this._onMouseTouchDown);
	}

	/**
	 * The mouse and touch down event handler.
	 * @param {MouseEvent|Touch} e
	 */
	_onMouseTouchDown(e) {
		// Prevent default to stop touches making weird highlights.
		e?.preventDefault();

		// Measure line so we have a left and width values.
		this._measureLine();

		const { iconEl } = this._children;

		// Determine if it was a touch.
		const { isTouch, canHover } = this.app;

		// Get the first startX point depending on touch or mouse.
		const xSource = e.touches?.length ? e.touches[0] : e;
		const { clientX: startX } = xSource;

		// Make sure we have immediate transition, ie. none.
		iconEl.style.setProperty('transition', 'none');

		// Set cursor to grabbing (set on document so you can move mouse outside slider area).
		document.body.style.setProperty('cursor', 'grabbing');

		// Depending on hover and touch, add event listeners accordingly.
		if (isTouch) {
			document.addEventListener('touchmove', this._onMouseTouchMove);
			document.addEventListener('touchend', this._onMouseTouchUp);
		}
		if (canHover) {
			document.addEventListener('mousemove', this._onMouseTouchMove);
			document.addEventListener('mouseup', this._onMouseTouchUp);
		}

		// Set startX state.
		this.setState({ startX });
	}

	/**
	 * TODO:
	 * Check if default camera distance works for other entities, do we need to delay until cam is positioned?
	 *
	 * Fix manual time input css.
	 */

	/**
	 * The mouse and touch move event handler.
	 * @param {MouseEvent|Touch} e
	 */
	_onMouseTouchMove(e) {
		// Destructure state and set new vars.
		const { lineMeasures: { left, width } } = this._state;
		const xSource = e.touches?.length ? e.touches[0] : e;
		let { clientX: newTransX } = xSource;

		const min = left;
		const max = left + width;
		const halfWidth = width * 0.5;

		// Don't allow less than min or more than max.
		newTransX = Math.max(newTransX, min);
		newTransX = Math.min(newTransX, max);
		newTransX -= (left + halfWidth);

		// Calculate normalized value
		const normValue = newTransX / halfWidth;

		// Calculate rate.
		let rate = this._calculateRate(normValue);

		// Return if we havev bad calculations.
		if (isNaN(normValue) || isNaN(rate)) {
			return;
		}

		// Determine if we're going over a max limit or under a min.
		const negative = normValue < 0;
		const belowMin = this._limit === 'min' && negative;
		const aboveMax = this._limit === 'max' && !negative;

		if (belowMin || aboveMax) {
			newTransX = 0;
			rate = 0;
		}

		// Set translateX.
		this._setTransX(newTransX);

		// Mobile - If rate is at very left or very right of screen, update margin so the screen doesn't eat the label
		if (eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobilePortrait()) {
			const { snapPoints } = this._config;
			const rateIsExtreme = Math.abs(rate) > snapPoints[snapPoints.length - 3];
			const rateIsFarLeft = rateIsExtreme && (rate < (snapPoints[snapPoints.length - 3] * -1));
			const rateIsFarRight = rateIsExtreme && (rate > (snapPoints[snapPoints.length - 3]));
			const customMargin = rateIsFarLeft ? '100%' : rateIsFarRight ? '-10%' : '50%';
			document.documentElement.style.setProperty('--customIconLabelMargin', customMargin);
		}

		// Call onUpdate.
		this.setCurrentRate(rate);
	}

	/**
	 * The mouse and touch up event handler.
	 * @param {MouseEvent|Touch} e
	 */
	_onMouseTouchUp(e) {
		// Prevent default.
		e?.preventDefault();

		const { isTouch, canHover } = this.app;
		const { iconEl } = this._children;
		// Remove eventListeners depending on isTouch and canHover.
		if (isTouch) {
			document.removeEventListener('touchmove', this._onMouseTouchMove);
			document.removeEventListener('touchend', this._onMouseTouchUp);
		}
		if (canHover) {
			document.removeEventListener('mousemove', this._onMouseTouchMove);
			document.removeEventListener('mouseup', this._onMouseTouchUp);
		}

		// Add transition back.
		iconEl.style.setProperty('transition', 'transform 0.5s cubic-bezier(.3,1.24,.34,.98)');

		// Set document cursor back to default.
		document.body.style.setProperty('cursor', 'default');

		// Call updateQuery.
		this.updateQuery();
	}

	/**
	 * Handle clicking realtime button
	 * @param {Event} e
	 */
	_onRealtimeClick(e) {
		this.updateQuery(1);
	}

	/**
	 * Sets the translate X CSS property and local state.
	 * @param {number} transX
	 */
	_setTransX(transX) {
		const { trans: currTransX } = this._state;

		// Return if already matches current transX.
		if (transX === currTransX) {
			return;
		}

		// Set --x-icon-trans CSS var.
		this._element.style.setProperty('--x-icon-trans', `${transX}px`);

		this.setState({ transX });
	}

	/**
	 * To make it easier for the user to be able to reach the snap points, we can lay out
	 * the time slider line into the snap points rather than a linear interpolation
	 * (which can be hard to drag to the finer values)
	 * @param {number} fastestRate
	 * @returns {Array<number>}
	 */
	_getRateArray(fastestRate) {
		const { snapPoints } = this._config;

		const nearestIndex = snapPoints.findIndex(point => fastestRate <= point);
		const largerThanAllPoints = nearestIndex === -1;

		// If the fastest rate is really fast, it makes sense to slice out the early snap points (up to seconds, 10 seconds, minutes, 10 minutes, and hours)
		let maxSliceStart = 8;

		if (!largerThanAllPoints) {
			maxSliceStart -= (snapPoints.length - nearestIndex) * 2;
		}

		// If greater than all snap points, simply add it to the end
		if (largerThanAllPoints) {
			return [1, ...snapPoints.slice(maxSliceStart), fastestRate];
		}

		const sliceRefIndex = snapPoints.length - maxSliceStart;
		const sliceStart = nearestIndex - sliceRefIndex;

		return [1, ...snapPoints.slice(sliceStart, nearestIndex), fastestRate];
	}

	/**
	 * Calculate rate depending on whether snapping is enabled
	 * @param {number} normValue - between -1 and 1
	 * @returns {number}
	 */
	_calculateRate(normValue) {
		const { fastestRate, rateArray } = this._state;

		const negative = normValue < 0;
		const absValue = Math.abs(normValue);
		const maxIndex = rateArray.length - 1;

		// Calculate interpolated rate.
		let interpolatedRate = absValue * fastestRate;

		if (rateArray) {
			const interpIndex = absValue * maxIndex;
			const interpFraction = interpIndex % 1;

			const rateIndex = Math.floor(interpIndex);
			interpolatedRate = rateArray[rateIndex];

			if (rateIndex < maxIndex) {
				const nextRate = rateArray[rateIndex + 1];
				const additionalRate = (nextRate - interpolatedRate) * interpFraction;
				interpolatedRate += Math.round(additionalRate);
			}
		}

		// Snap rate if config says so.
		let snappedAbsRate = this._snapToRate(interpolatedRate);

		// Snap to first value in rate array if less than second.
		if (snappedAbsRate < rateArray[1]) {
			snappedAbsRate = rateArray[0];
		}

		// Reapply negation if needed.
		return negative && snappedAbsRate !== rateArray[0] ? snappedAbsRate * -1 : snappedAbsRate;
	}

	/**
	 * Blah
	 * @param {number} absRate
	 * @returns {number}
	 */
	_calculateNormValue(absRate) {
		const { rateArray } = this._state;
		const maxIndex = rateArray.length - 1;

		// Find the corresponding rate index in rateArray.
		let rateIndex = -1;
		for (let i = 0; i < rateArray.length; i++) {
			if (absRate >= rateArray[i]) {
				rateIndex = i;
			}
			else {
				break;
			}
		}

		if (rateIndex === maxIndex || rateIndex === -1) {
			// If rate is maximum, or more than the largest rate in rateArray, limit to the max value.
			return 1;
		}
		else {
			// Calculate the normalized value based on rate index and interpolated rate.
			const lowerRate = rateArray[rateIndex];
			const upperRate = rateArray[rateIndex + 1];
			const rateFraction = (absRate - lowerRate) / (upperRate - lowerRate);
			const normValue = (rateIndex + rateFraction) / maxIndex;
			return normValue;
		}
	}

	/**
	 * Returns the nearest snapped rate or multiple of that rate
	 * @param {number} value - only deals with positive values
	 * @returns {number}
	 */
	_snapToRate(value) {
		const { snapPoints } = this._config;

		// dont even THINK about using the reduce function, you wrectched fiend.
		const nearestIndex = snapPoints.findIndex(point => value < point);

		if (nearestIndex === 0) {
			return snapPoints[nearestIndex];
		}

		// If the input value is bigger than all of the snap points (nearestIndex is -1) we calculate the value divided by the last snap point and round it.

		// Get the previous point.
		const prevPoint = nearestIndex > -1 ? snapPoints[nearestIndex - 1] : snapPoints[snapPoints.length - 1];

		// Get the snapped multiple.
		const snappedMultiple = Math.round(value / prevPoint);

		// Snapped rate is the prev point times the snapped multiple.
		return snappedMultiple * prevPoint;
	}

	/**
	 * Set current time rate in pioneer and css variable.
	 * @param {number} rate
	 */
	setCurrentRate(rate) {
		// Remove the limit if we're not at 0.
		rate !== 0 && this._setLimit(null);

		// Set pioneer rate and local var.
		this.app.pioneer.setTimeRate(rate);
		this._currentRate = rate;

		// Set formatted rate.
		const formattedRate = this.formatRate(rate);
		this._element.style.setProperty('--x-rate', `'${formattedRate}'`);

		// Set realtime button visibility depending on ratet.
		const realtimeVisibleClass = (rate === 1 || rate === 0) ? 'hidden' : '';
		this.setState({ realtimeVisibleClass });
	}

	/**
	 * updateQuery handler.
	 * @param {number} rate
	 */
	updateQuery(rate = this.app.pioneer.getTimeRate()) {
		//  Set time query in route
		const router = this.app.getManager('router');
		const time = this.app.getManager('time').getTimeUrl();
		router.navigate({ time, rate }, router.currentRoute.url);
	}

	/**
	 * Calculates the dynamic fastest time rate based on dynamic camera distance.
	 * @returns {number} - seconds per second
	 */
	_getFastestRate() {
		const { enableDynamicRate, fastestRate, defaultCamDistance } = this._config;

		// Calculate the rate coefficient by getting the current camera position and comparing it to the max zoom distance (_defaultMaxDistance)
		const { defaultMaxDistance } = this._app.getManager('camera');

		let camDistance = this._camDistance;

		// Fallback to deefault cam distance if necessary (shouldnt be needed)
		if (!camDistance || isNaN(camDistance)) {
			console.warn('Time Slider:: Missing camera distance.');
			camDistance = defaultCamDistance;
		}

		// Make sure the values are valid.
		const rateCoefficient = defaultMaxDistance && !isNaN(defaultMaxDistance)
			? Math.round(camDistance) / defaultMaxDistance
			: 1;

		return enableDynamicRate
			? fastestRate.min + (fastestRate.max - fastestRate.min) * rateCoefficient
			: fastestRate.max;
	}

	/**
	 * Creates a clean formatted string from the rate value
	 * @param {number} rate
	 * @returns {string}
	 */
	formatRate(rate) {
		if (rate === 1) {
			return '';
		}
		if (rate === 0) {
			return 'Paused';
		}

		const negative = rate < 0;
		const absRate = Math.abs(rate);

		const yrs = absRate / 31540000;
		const months = absRate / 2628000;
		const weeks = absRate / 604800;
		const days = absRate / 86400;
		const hrs = absRate / 3600;
		const mins = absRate / 60;

		const oneDP = (val) => {
			const toOneDP = Number(`${Math.round(`${val}e1`)}e-1`);
			return negative ? toOneDP * -1 : toOneDP;
		};

		if (yrs >= 1) {
			return `${oneDP(yrs)} yrs/s`;
		}
		if (months >= 2) {
			return `${Math.round(negative ? months * -1 : months)} mths/s`;
		}
		if (weeks >= 1) {
			return `${Math.round(negative ? weeks * -1 : weeks)} wks/s`;
		}
		if (days >= 1) {
			return `${oneDP(days)} days/s`;
		}
		if (hrs >= 1) {
			return `${oneDP(hrs)} hrs/s`;
		}
		if (mins >= 1) {
			return `${oneDP(mins)} mins/s`;
		}
		return `${rate} secs/s`;
	}

	/**
	 * Classes are determined by the device and screen we're using.
	 * @param {object} options
	 * @returns {Array<string>}
	 */
	_getClasses(options) {
		const classes = [];

		if (options.removeAll) {
			return classes;
		}

		const limitedHeightThreshold = 641;
		const limitedWidthThreshold = 961;
		const offsetRightThreshold = 641;

		const portrait = eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobilePortrait();
		const landscape = eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isLandscape();

		const limitedHeight = window.innerHeight < limitedHeightThreshold;
		const limitedWidth = window.innerWidth < limitedWidthThreshold;
		const offsetRight = window.innerHeight < offsetRightThreshold && !portrait;

		// Expanded or not.
		if (options.expanded && offsetRight) {
			classes.push('offset-right');
		}

		// Limited height.
		if (limitedHeight) {
			classes.push('v-squeezy');
		}

		// Limited width.
		if (limitedWidth) {
			classes.push('h-squeezy');
		}

		// Portrait or landsape.
		if (portrait) {
			classes.push('portrait');
		}
		else if (landscape) {
			classes.push('landscape');
		}

		return classes;
	}

	/**
	 * Sets the position using an array of positional class names
	 * @param {object} options
	 */
	toggleExtraClasses(options) {
		const classes = this._getClasses(options);

		this._extraClasses.forEach(extraClass => {
			const addClass = (classes.includes(extraClass) && !options.removeAll);
			this._parent.classList.toggle(extraClass, addClass);
		});
	}

	/**
	 * Gets the current extra classes.
	 * @returns {DOMTokenList}
	 */
	get extraClasses() {
		return this._parent.classList;
	}

	/**
	 * Measures the line element and stores left and width values.
	 * @returns {object}
	 */
	_measureLine() {
		// We need to run a separate getBoundingClientRect in order to get the correct 'left' value.
		const { left, width } = this._children?.lineEl?.getBoundingClientRect() || {};

		if (left === undefined || width === undefined) {
			return null;
		}

		// Set states.
		this.setState({
			lineMeasures: { left, width, isMeasured: true }
		});

		return { left, width };
	}

	/**
	 * Handle component resize.
	 */
	_onResize() {
		const { width } = this._measureLine();

		// Update transX.
		const rate = this._currentRate ?? 1;
		const negative = rate < 0;
		const absRate = Math.abs(rate);
		const normVal = this._calculateNormValue(absRate);
		const absTransX = normVal * width * 0.5;
		const transX = negative ? absTransX * -1 : absTransX;

		this._setTransX(transX);
	}

	/**
	 * Handle element resize.
	 * @override
	 */
	resize() {
		// Debounce resize for improved performance.
		this._resizeDebounced();
	}

	/**
	 * Update called eevery frame.
	 */
	_update() {
		// Set our camDistance
		const { cameraEntity } = this.app.getManager('camera');
		const camDistance = cameraEntity.getPosition().magnitude();

		// Update cam distance.
		if (this._camDistance?.toFixed(4) !== camDistance?.toFixed(4)) {
			this._camDistance = camDistance;

			// Set fastestRate and rateArray when cam distance is valid.
			if (this._camDistance && !isNaN(this._camDistance)) {
				// Calculate and store fastest rate.
				const fastestRate = this._snapToRate(this._getFastestRate());

				// Calculate and store rateArray.
				const rateArray = this._getRateArray(fastestRate);

				// Set states.
				this.setState({ fastestRate, rateArray });
			}
		}

		// Call and reset resolve if needed
		if (this._camDistanceResolve && this._camDistance && !isNaN(this._camDistance)) {
			this._camDistanceResolve(this._camDistance);
			this._camDistanceResolve = null;
		}
	}

	/**
	 * Custom show override to set classes on parent (this is necessary when reusing the clock and clockshortcut components as children)
	 * @override
	 */
	show() {
		this._parent?.classList.toggle('hidden', false);
	}

	/**
	 * Custom hide override to set classes on parent (this is necessary when reusing the clock and clockshortcut components as children)
	 * @override
	 */
	hide() {
		this._parent?.classList.toggle('hidden', true);
	}

	/**
	 * Set visibility of just time slider
	 * @param {boolean} visible
	 */
	setSliderVisibility(visible) {
		this._parent?.classList.toggle('no-slider', !visible);
	}
}

TimeSlider.html = (_time_slider_html__WEBPACK_IMPORTED_MODULE_2___default());


/***/ }),

/***/ "./src/components/watch_panel/watch_card.js":
/*!**************************************************!*\
  !*** ./src/components/watch_panel/watch_card.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WatchCard": function() { return /* binding */ WatchCard; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _watch_card_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./watch_card.html */ "./src/components/watch_panel/watch_card.html");
/* harmony import */ var _watch_card_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_watch_card_html__WEBPACK_IMPORTED_MODULE_3__);








/**
 *
 */
class WatchCard extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options = {}) {
		// call super class and  pass default state object.
		super(app, null, {
			title: 'Asteroid Name',
			date: 'April 13, 2029',
			time: '10:52am',
			diameterUnit: 'km',
			diameter: '0.5',
			diameterEstimatedText: '',
			diameterRaw: 0.5,
			distanceUnit: 'km',
			distance: '512,321',
			distanceRaw: 512321,
			unitType: 'metric',
			...options
		});

		this.bindFunctions(['toggleUnit']);
	}

	/** @inheritdoc */
	init() {
		super.init();

		this._callbackRegistry.push({
			emitter: this._app.getManager('watch'),
			event: 'toggleUnit',
			callback: this.toggleUnit
		});
	}

	/**
	 * On html handleToggleUnit click
	 * @param {Event} e
	 */
	handleToggleUnit(e) {
		this._app.getManager('watch')?.toggleUnit();
	}

	/**
	 *	Toggles the card between km and mi units
	 * @param {string} newUnitType - unit to swap to
	 */
	toggleUnit(newUnitType) {
		// This is a quick, dirty band-aid change from Jack. We need a task for a central unit manager.
		const metric = newUnitType === 'metric';
		const kmMiRatio = 1.609344;
		const ftInMiles = 5280;
		const mInKm = 1000;

		const { diameterRaw, distanceRaw } = this._state;

		const currentDiameter = diameterRaw || 0;
		let newDiameter = currentDiameter;
		let newDiameterUnit = metric ? 'km' : 'mi';

		const currentDistance = distanceRaw || 0;
		let newDistance = currentDistance;
		let newDistanceUnit = metric ? 'km' : 'mi';

		if (metric) {
			// Working in metric.

			if (newDiameter < 1) {
				newDiameterUnit = 'm';
				newDiameter *= mInKm;
			}

			if (newDistance < 1) {
				newDistanceUnit = 'm';
				newDistance *= mInKm;
			}
		}
		else {
			// Working in imperial.
			newDiameter = currentDiameter / kmMiRatio;
			newDistance = currentDistance / kmMiRatio;

			if (newDiameter < 1) {
				newDiameterUnit = 'ft';
				newDiameter *= ftInMiles;
			}

			if (newDistance < 1) {
				newDistanceUnit = 'ft';
				newDistance *= ftInMiles;
			}
		}

		this.setState({
			diameterUnit: newDiameterUnit,
			diameter: this._parseDiameter(newDiameter),
			distanceUnit: newDistanceUnit,
			distance: `${Math.round(newDistance).toLocaleString(undefined)}`,
			unitType: newUnitType
		});
	}

	/**
	 * Make diameter value prettier and rounded
	 * @param {number} diameter
	 * @returns {string}
	 */
	_parseDiameter(diameter) {
		return parseFloat(diameter).toFixed(1).replace(/\.0+$/, '');
	}

	/**
	 * Parses NEO data and sets state
	 * @param {NEO} neoData
	 */
	setTarget(neoData) {
		const { name, nextClosestApproachTime, nextClosestApproachDistance, diameter, diameterEstimated } = neoData;

		const unixSeconds = pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.etToUnix(nextClosestApproachTime);
		const date = new Date(unixSeconds * 1000);

		this.setState({
			title: name,
			date: date.toLocaleDateString(undefined, { year: 'numeric', month: 'short', day: 'numeric' }),
			time: date.toLocaleTimeString(undefined),

			diameter: this._parseDiameter(diameter),
			diameterRaw: diameter,
			diameterEstimatedText: diameterEstimated ? '〚estimated〛' : '',

			distance: `${Math.round(nextClosestApproachDistance).toLocaleString(undefined)}`,
			distanceRaw: nextClosestApproachDistance
		});

		// Trigger a toggle on init.
		this.toggleUnit(this._state.unitType);
	}
}

WatchCard.html = (_watch_card_html__WEBPACK_IMPORTED_MODULE_3___default());


/***/ }),

/***/ "./src/components/watch_panel/watch_panel.js":
/*!***************************************************!*\
  !*** ./src/components/watch_panel/watch_panel.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WatchPanel": function() { return /* binding */ WatchPanel; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _countdown_countdown__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../countdown/countdown */ "./src/components/countdown/countdown.js");
/* harmony import */ var _watch_card__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./watch_card */ "./src/components/watch_panel/watch_card.js");








/**
 * WatchPanel extends CarouselPanel
 */
class WatchPanel extends eyes__WEBPACK_IMPORTED_MODULE_0__.CarouselPanel {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, {

			// States
			// isVisible: false,

			// Class names
			panelTypeClass: 'watch-panel',
			carouselClass: 'watch-carousel',
			paginationClass: 'watch-carousel-fraction',
			prevButtonClass: 'watch-carousel-prev',
			nextButtonClass: 'watch-carousel-next',

			// Options
			title: 'Asteroid Watch',
			caption: 'The next five closest approaches to Earth',
			headerIconClass: 'asteroid',

			...options
		});

		/**
		 * Store showBeExpanded state (for when showing and hiding UI)
		 */
		this.shouldBeExpanded = null;

		/**
		 * Slide change callback
		 * @param {object} params
		 * @param {number} params.realIndex
		 */
		this._onSlideChange = ({ realIndex }) => {
			const watchManager = this._app.getManager('watch');

			// Get the neo to navigate to the correct URL
			const neoName = watchManager.getNeoNameByIndex(realIndex);
			watchManager.updateURL(neoName);
		};
	}

	/**
	 * Compose the watch carousel slides
	 * @param {Array<NEO>} nextFive
	 */
	populate(nextFive) {
		// Compose the watch card and countdown components
		nextFive.forEach(asteroid => {
			// create watch card
			const watchCard = new _watch_card__WEBPACK_IMPORTED_MODULE_2__.WatchCard(this._app);
			watchCard.init();
			watchCard.setTarget(asteroid);
			this._components.push(watchCard);

			// create countdown and register update callback
			const countdown = new _countdown_countdown__WEBPACK_IMPORTED_MODULE_1__.Countdown(this._app);
			countdown.init();
			countdown.setTimeTarget(asteroid.nextClosestApproachTime);
			this._components.push(countdown);

			// Add HTML slides.
			this.addSlide([watchCard.element, countdown.element]);
		});
	}

	/** @inheritdoc */
	setExpandState() {
		super.setExpandState(this.shouldBeExpanded);
	}

	/**
	 * Show override
	 */
	show() {
		this.setExpandState();
		super.show(false);
	}

	/**
	 * Replacing expand method in Panel super class
	 * Rather than directly expanding or collapsing by adding or removing a class,
	 * we instead change the URL and respond to the onRouteChange in the watch view.
	 * It's therefore in the watch view that we set the expand/collapse state.
	 * This method is a little convoluted but it reduces the chance of going out of sync with the URL.
	 */
	expand() {
		const watchManager = this._app.getManager('watch');
		const currentSwiperSlide = this._swiper?.realIndex;
		watchManager.setSlideUrlByIndex(currentSwiperSlide);
	}

	/**
	 * Replacing collapse method in CarouselPanel super class
	 */
	collapse() {
		const watchManager = this._app.getManager('watch');
		watchManager.updateURL('');
	}
}


/***/ }),

/***/ "./src/configs/components_info.js":
/*!****************************************!*\
  !*** ./src/configs/components_info.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ([
	{
		type: 'Search',
		name: 'search',
		options: {
			config: {
				placeholderText: 'Search asteroids and comets...',
				allowFeatured: true,
				allowDetail: false,
				allowInfo: true,
				stopOnExactMatch: false,
				maxSuggestions: 3
			}
		}
	},
	{ type: 'TutorialOverlay', name: 'tutorialOverlay' },
	{ type: 'AsteroidMenuTop', name: 'asteroid_menu_top' },
	{ type: 'AsteroidMenuBottom', name: 'asteroid_menu_bottom' },
	{ type: 'AsteroidModals', name: 'asteroid_modals' },
	{
		type: 'Breadcrumb',
		name: 'breadcrumb',
		options: {
			params: {
				title: 'Eyes on Asteroids'
			}
		}
	},
	{
		type: 'Clock',
		name: 'clock',
		postCreationFunction: (_, component) => {
			// add x-small class to make time font smaller
			const timeNodes = component._element?.querySelectorAll('.time, .meridiem');
			timeNodes.forEach(node => node.classList.add('x-small'));
		}
	},
	{ type: 'ClockShortcut', name: 'clockShortcut' },
	{
		type: 'TimeSlider',
		name: 'timeSlider',
		options: {
			config: {
				// dynamic based off how close the camera is to an entity
				enableDynamicRate: true,
				// variation in fastest time rates (seconds per second)
				fastestRate: {
					min: 3629000, // 6 weeks / sec
					max: 157700000 // 5 yrs / sec
				}
			}
		}
	},
	{ type: 'AsteroidsSettings', name: 'settings' },
	{ type: 'HomeButton', name: 'homeButton' },
	{ type: 'AsteroidPanel', name: 'asteroidPanel' },
	{ type: 'MissionPanel', name: 'missionPanel' },
	{ type: 'FollowingPanel', name: 'followingPanel' },
	{ type: 'WatchPanel', name: 'watchPanel' },
	{
		type: 'LayerPanel',
		name: 'layerPanel',
		options: {
			layers: [['planets'], ['spacecraft'], ['trails', 'labels', 'icons', 'starfield'], ['ui']],
			checkboxType: 'eyes'
		}
	},
	{ type: 'DefinitionOverlay', name: 'definitionOverlay' },
	{ type: 'SplashScreen', name: 'splashScreen' },
	{ type: 'Story', name: 'story' }
]);


/***/ }),

/***/ "./src/data/stories/asteroids_101.js":
/*!*******************************************!*\
  !*** ./src/data/stories/asteroids_101.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


// An incrementing int used to cancel outdated camera transition awaits
let globalNonce = 0;

/* harmony default export */ __webpack_exports__["default"] = ({
	type: 'nonsequential',
	entities: [
		'4_vesta',
		'67p_churyumov_gerasimenko'
	],
	slides: [
		{
			id: 'slide_1',
			type: 'overlay',
			classList: ['opaque', 'black'],
			content: [
				{
					type: 'title',
					title: 'Asteroids and Comets 101'
				}
			]
		},
		{
			id: 'slide_2',
			type: 'overlay',
			classList: ['opaque', 'black'],
			content: [
				{
					type: 'image',
					src: 'assets/images/outterAsteroidBelt.png',
					title: 'Main Asteroid Belt. Credit: NASA/JPL',
					alt: 'This image illustrates the millions of asteroids between the Sun and Jupiter — know as the asteroid belt.',
					clickable: true
				},
				{
					type: 'description',
					description: 'This image illustrates the millions of asteroids between the Sun and Jupiter — know as the asteroid belt.<br><br>The current number of known asteroids in the entire solar system is:<br><span class="big semi tween-count test">0</span><br><br>',
					onEnter: async (app, block) => {
						const element = block.element.querySelector('.tween-count');
						// const response = await fetch('https://solarsystem.nasa.gov/api/v1/static_stellar_counts/1/'); // TODO: And uncomment this
						const count = 1362000 //(await response.json()).asteroids; // TODO: Remove before pushing to staging. 
						// If we're keeping the hardcoded value, add some hedging like "roughly"

						eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.tween({ i: 0 }, { i: count }, {
							onUpdate: object => {
								if (element) {
									const value = Math.round(object.i);
									element.innerHTML = Number(value).toLocaleString();
								}
							},
							duration: 3000
						});
					}
				}
			]
		},
		{
			id: 'slide_3',
			type: 'panel',
			content: [
				{
					type: 'title',
					classList: ['semi'],
					title: "Vesta"
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					await app.getManager('scene').isReady('4_vesta');
					if (localNonce !== globalNonce) return;
					await app.cameraScripts.goToSystem('inner_solar_system', { duration: 1 });
					if (localNonce !== globalNonce) return;
					await app.cameraScripts.goToCelestialObject('4_vesta', { duration: 4 });
				}
			]
		},
		{
			id: 'slide_4',
			type: 'panel',
			content: [
				{
					type: 'title',
					title: "67P Churyumov-Gerasimenko"
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					await app.getManager('scene').isReady('67p_churyumov_gerasimenko');
					if (localNonce !== globalNonce) return;
					await app.cameraScripts.goToSystem('inner_solar_system', { duration: 1 });
					if (localNonce !== globalNonce) return;
					await app.cameraScripts.goToCelestialObject('67p_churyumov_gerasimenko', { duration: 4 });
				}
			]
		},
		{
			id: 'slide_5',
			type: 'panel',
			content: [
				{
					type: 'title',
					title: ""
				}
			],
			camera: [
				async app => {
					++globalNonce;
					await app.cameraScripts.goToSystem('inner_solar_system', { duration: 2 });
				}
			],
			rate: 604800
		}
	]
});


/***/ }),

/***/ "./src/data/stories/asteroids_close_approach.js":
/*!******************************************************!*\
  !*** ./src/data/stories/asteroids_close_approach.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");



/* harmony default export */ __webpack_exports__["default"] = ({
	type: 'nonsequential',
	entities: [
		'moon',
		'99942_apophis'
	],
	slides: [
		{
			id: 'slide_1',
			type: 'overlay',
			classList: ['opaque', 'black'],
			content: [
				{
					type: 'title',
					title: 'What is a Close Approach?'
				}
			],
			camera: [
				async app => {
					await app.cameraScripts.goToSystem('outer_solar_system');
				}
			]
		},
		{
			id: 'slide_2',
			type: 'panel',
			content: [
				{
					type: 'description',
					description: ''
				}
			],
			camera: [
				async app => {
					await app.cameraScripts.goToSystem('inner_solar_system');
				}
			],
			rate: 259200
		},
		{
			id: 'slide_3',
			type: 'panel',
			content: [
				{
					type: 'description',
					title: 'Apophis',
					description: ''
				}
			],
			time: '2029-04-13T14:40:12-07:00',
			camera: [
				async app => {
					// Go to Apophis looking at Earth
					await app.getManager('scene').isListReady(['99942_apophis', 'earth']);
					app.getManager('time').pause();
					await app.cameraScripts.alignObjects('99942_apophis', 'earth', {
						duration: 2,
						verticalOffset: 15,
						horizontalOffset: -15
					});
					app.getManager('time').play();
				}
			],
			onEnter: app => {
				app.scene.get('sun').getComponentByType('orbitalParticles').setEnabled(false);
			},
			onLeave: app => {
				app.scene.get('sun').getComponentByType('orbitalParticles').setEnabled(true);
			},
			rate: 60
		},
		{
			id: 'slide_4',
			type: 'panel',
			content: [
				{
					type: 'description',
					title: "Apophis's closest approach to Earth",
					classList: ['large', 'semi'],
					description: '<div><span>Distance: </span><span class="number highlight">{{distance}}</span><span> km</span></div>',
					onEnter: (app, block) => {
						block.addState('distance', '0');

						block.update = () => {
							const distance = app.getManager('scene').getDistance('earth', '99942_apophis', { precision: 3 }).toLocaleString();
							block.setState({ distance });
						};
						app.pioneer.addCallback(block.update, true);
					},
					onLeave: (app, block) => {
						app.pioneer.removeCallback(block.update);
					}
				}
			],
			time: '2029-04-12T12:00:00-07:00',
			camera: [
				async app => {
					// View of the Earth, Moon and Apophis
					await app.getManager('scene').isListReady(['earth', 'moon', '99942_apophis']);
					app.getManager('time').pause();
					await app.cameraScripts.goToSystem('earth', {
						duration: 2,
						planeId: 'moon',
						otherEntityNames: ['moon'],
						distance: 385000 * 2.5,
						angle: 35,
						includeChildren: false,
						isRelativeToPreviousCamera: false
					});
					app.getManager('time').play();
				}
			],
			onEnter: async (app, slide) => {
				await app.getManager('scene').isListReady(['sun', 'earth', 'moon', '99942_apophis']);
				const sun = app.scene.get('sun');

				sun.getComponentByType('orbitalParticles').setEnabled(false);

				const lineOfSight = sun.get('orbiterLineOfSight');
				lineOfSight.setEnabled(true);
				lineOfSight.setTargets('earth', '99942_apophis');

				// Turn off Earth's trail
				app.scene.get('earth').get('orbitLine').setEnabled(false);

				// TODO 9 moons in future

				// Only when slide changes
				if (slide.getState('previousIndex') !== slide.getState('currentIndex')) {
					slide.reset = {};

					const apophis = app.scene.get('99942_apophis');
					// Disable default dynamo
					apophis.getControllerByType('dynamo', 0)?.setEnabled(false);
					// Add dynamo controller to Apophis for higher accuracy SSD
					// Apophis uses orbital elements controller and has no dynamo by default
					const dynamoController = apophis.addController('dynamo', 'earth_centric');
					dynamoController.setBaseUrl('$DYNAMIC_ASSETS_URL/dynamo/ssd/99942_apophis/earth/orb/');

					// Change Apophis's parent
					apophis.removeParentingTableEntry(Number.NEGATIVE_INFINITY);
					apophis.addParentingTableEntry(Number.NEGATIVE_INFINITY, 'earth');
				}

				app.getManager('time').setMax('2029-04-14T12:00:00-07:00');
			},
			onLeave: async (app, slide) => {
				// Remove added Apophis dynamo controller
				const apophis = app.scene.get('99942_apophis');
				apophis.removeParentingTableEntry(Number.NEGATIVE_INFINITY);
				apophis.addParentingTableEntry(Number.NEGATIVE_INFINITY, 'sun');
				apophis.removeController(apophis.getController('earth_centric'));
				apophis.getControllerByType('dynamo', 0)?.setEnabled(true);

				const sun = app.scene.get('sun');

				sun.getComponentByType('orbitalParticles').setEnabled(true);

				const lineOfSight = sun.get('orbiterLineOfSight');
				lineOfSight.setEnabled(false);
				
				// Turn on Earth's trail
				app.scene.get('earth').get('orbitLine').setEnabled(true);
				
				app.getManager('time').resetMax();
				
				await app.scene.getLoadedPromise();
				await app.pioneer.waitUntilNextFrame();
			},
			rate: 1800
		},
		{
			id: 'slide_5',
			type: 'panel',
			content: [
				{
					type: 'description',
					title: 'Near Earth Objects (NEOs)',
					description: '',
					onEnter: (app, block) => {
						block.auLinkClick = () => {
							app.getComponent('definitionOverlay').navigateToDefinition('au');
						};
						block._children.auLink?.addEventListener('click', block.auLinkClick);
						block._children.auLink?.addEventListener('click', block.auLinkClick);
					},
					onLeave: (app, block) => {
						block._children.auLink?.removeEventListener('click', block.auLinkClick);
					}
				}
			],
			time: '2029-03-01T10:45:12-07:00',
			rate: 300000,
			camera: [
				async app => {
					// Top down view of the Sun, with ring shown around the Sun
					await app.getManager('scene').isListReady(['sun', 'earth', '99942_apophis']);
					app.getManager('time').pause();
					await app.cameraScripts.showLocation('sun', 'earth', 'earth', 'planeNormal', {
						distance: eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm * 1.3 * 1.5,
						duration: 2,
						startFromTarget: false,
						rotateByScreenRatio: false
					});
					app.getManager('time').play();
				}
			],
			onEnter: app => {
				// Hide all planets except Earth
				const planets = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.getEntityNamesInGroup('planets');
				planets.forEach(planet => {
					if (planet !== 'earth') {
						app.scene.get(planet).setEnabled(false);
					}
				});

				// Hide all trails, except Earth
				app.getManager('layer').toggleLayer('trails');
				app.scene.get('earth').get('orbitLine').setEnabled(true);

				// Make Apophis and Earth labels always show on collision
				app.getManager('label').addException('earth');
				app.getManager('label').addException('99942_apophis');

				// Show ring
				const ringEntity = app.scene.get('sunRing');
				const labelEntity = app.scene.get('sunRingLabel');
				ringEntity.setEnabled(true);
				labelEntity.setEnabled(true);
			},
			onLeave: app => {
				// Reset planets
				const planets = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.getEntityNamesInGroup('planets');
				planets.forEach(planet => {
					if (planet !== 'earth') {
						app.scene.get(planet).setEnabled(true);
					}
				});

				// Reset trails
				app.getManager('layer').toggleLayer('trails', undefined, true);

				// Reset Apophis and Earth labels
				app.getManager('label').removeException('earth');
				app.getManager('label').removeException('99942_apophis');

				// Hide ring
				const ringEntity = app.scene.get('sunRing');
				ringEntity.setEnabled(false);
				const labelEntity = app.scene.get('sunRingLabel');
				labelEntity.setEnabled(false);
			}
		},
		{
			id: 'slide_6',
			type: 'panel',
			content: [
				{
					type: 'description',
					title: 'Potentially Hazardous Objects (PHOs)',
					description: '',
					onEnter: (app, block) => {
						// Turn on PHO filter
						block.addState('phoCount', '0');
						app.getManager('filters').setFilter({ asteroids: true, comets: true, phos: true }, null, (size) => {
							block.setState({ phoCount: Number(size).toLocaleString() });
						});
					},
					onLeave: (app, block) => {
						// Reset PHO filter
						const filtersManager = app.getManager('filters');
						filtersManager.setFilter(filtersManager.getPreviousFilters());
					}
				}
			],
			time: '2029-03-27T14:45:12-07:00',
			rate: 10000,
			camera: [
				async app => {
					await app.getManager('scene').isListReady(['earth', '99942_apophis']);
					app.getManager('time').pause();
					await app.cameraScripts.showLocation('sun', 'earth', 'earth', 'planeNormal', {
						distance: eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm * 1.3 * 1.5,
						duration: 2,
						startFromTarget: false,
						rotateByScreenRatio: false
					});
					await app.cameraScripts.goToSystemSideway('earth', {
						duration: 2,
						distance: eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.conversionTable.auToKm * 0.05 * 20,
						angleInDegree: 30,
						includeChildren: false
					});

					app.getManager('time').play();
				}
			],
			onEnter: async app => {
				// Show torus
				const torus = app.scene.get('sunTorus');
				torus.setEnabled(true);
				const torusLabel = app.scene.get('sunTorusLabel');
				torusLabel.setEnabled(true);
			},
			onLeave: app => {
				// Hide torus
				const torus = app.scene.get('sunTorus');
				torus.setEnabled(false);
				const torusLabel = app.scene.get('sunTorusLabel');
				torusLabel.setEnabled(false);
			}
		},
		{
			id: 'slide_7',
			type: 'panel',
			content: [
				{
					type: 'description',
					description: 'Explore the next 5 closest approaches <a class="clickable" href="#/watch">here</a>. These are continuously updated, as NASA is constantly on the lookout.'
				}
			],
			camera: [
				async app => {
					await app.cameraScripts.goToSystem('inner_solar_system');
				}
			],
			rate: 259200
		}
	],
	onEnter: app => {
	},
	onLeave: app => {
		// Reset force load
		const sceneManager = app.getManager('scene');
		app.getManager('layer').toggleLayer('trails', undefined, true);
		app.scene.get('earth').get('orbitLine').setEnabled(true);
	}
});


/***/ }),

/***/ "./src/data/stories/asteroids_missions.js":
/*!************************************************!*\
  !*** ./src/data/stories/asteroids_missions.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);


const forceLoad = [
	// ['67p_churyumov_gerasimenko', 'model'],
	// ['sc_rosetta', 'model'],

	// ['433_eros', 'model'],
	// ['sc_near_shoemaker', 'model'],

	// ['9p_tempel_1', 'model'],
	// ['sc_deep_impact_impactor', 'model'],

	// ['4_vesta', 'model'],
	// ['sc_dawn', 'model'],

	// ['1_ceres', 'spheroid'],

	// ['sc_stardust', 'model'],

	// ['101955_bennu', 'model'],
	// ['sc_osiris_rex', 'model'],

	// ['16_psyche', 'model'],
	// ['sc_lucy', 'model'],

	// ['dimorphos', 'model'],
	// ['sc_dart', 'model'],

	// ['earth', 'spheroid']
];

// An incrementing int used to cancel outdated camera transition awaits
let globalNonce = 0;

// Indicate that a label is clicked
let isLabelClicked = false;
const resetLabelClick = () => {
	isLabelClicked = false;
};

/**
 * Add click callback to an entity's label.
 * @param {App} app
 * @param {string} entityName
 * @param {Function} callback
 */
const addLabelClick = (app, entityName, callback) => {
	const labelEl = app.scene.getEntity(entityName)?.get('div')?.getDiv();

	if (labelEl) {
		labelEl.classList.remove('unclickable');
		labelEl.addEventListener('click', async () => {
			isLabelClicked = true;
			await callback(entityName, app);
		});
	}
};

/**
 * Remove click callback from an entity's label.
 * @param {App} app
 * @param {string} entityName
 * @param {Function} callback
 */
const removeLabelClick = (app, entityName, callback) => {
	const labelEl = app.scene.getEntity(entityName)?.get('div')?.getDiv();

	if (labelEl) {
		labelEl.classList.add('unclickable');
		labelEl.removeEventListener('click', callback);
	}
};

/**
 * Wrapper for camera goToSpacecraft.
 * @param {string} entityName
 * @param {BaseApp} app
 */
const goToSpacecraft = async (entityName, app) => {
	await app.cameraScripts.goToSpacecraft(entityName);
};

/**
 * Wrapper for camera goToCelestialObject.
 * @param {string} entityName
 * @param {BaseApp} app
 */
const goToCelestialObject = async (entityName, app) => {
	await app.cameraScripts.goToCelestialObject(entityName);
};

/* harmony default export */ __webpack_exports__["default"] = ({
	type: 'nonsequential',
	slides: [
		{
			id: 'slide_1',
			type: 'overlay',
			classList: ['opaque', 'black'],
			content: [
				{
					type: 'title',
					title: 'Asteroid and Comet Missions'
				}
			],
			camera: [
				async app => {
					++globalNonce;
					await app.cameraScripts.goToSystem('inner_solar_system');
				}
			]
		},
		{
			id: 'slide_2',
			type: 'panel',
			time: '2015-02-14T08:14:00Z',
			content: [
				{
					type: 'description',
					title: 'The Rosetta mission',
					description: 'Orbiting comet 67P Churyumov-Gerasimenko'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['67p_churyumov_gerasimenko', 'sc_rosetta']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToSpacecraft('sc_rosetta', { cinematic: true, duration: 3 });
					time.play();
				}
			],
			onEnter: (app, slide) => {
				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_rosetta', goToSpacecraft);
				addLabelClick(app, '67p_churyumov_gerasimenko', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (entityName === '67p_churyumov_gerasimenko') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_rosetta') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				// Make label(s) unclickable
				removeLabelClick(app, 'sc_rosetta', goToSpacecraft);
				removeLabelClick(app, '67p_churyumov_gerasimenko', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_3',
			type: 'panel',
			time: '2001-02-12T18:00:00Z',
			rate: 0,
			content: [
				{
					type: 'description',
					title: 'The NEAR Shoemaker mission',
					description: 'orbiting the asteroid Eros'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['433_eros', 'sc_near_shoemaker']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.alignObjects('sc_near_shoemaker', '433_eros', {
						duration: 3,
						verticalOffset: 15,
						horizontalOffset: -15,
						distance: 0.05
					});
					time.play();
				}
			],
			onEnter: (app, slide) => {
				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_near_shoemaker', goToSpacecraft);
				addLabelClick(app, '433_eros', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (entityName === '433_eros') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_near_shoemaker') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				// Make label(s) unclickable
				removeLabelClick(app, 'sc_near_shoemaker', goToSpacecraft);
				removeLabelClick(app, '433_eros', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_4',
			type: 'panel',
			time: '2005-07-04T05:44:20Z',
			content: [
				{
					type: 'description',
					title: 'The Deep Impact mission',
					description: 'The Deep Impact Impactor on collision course with comet Tempel 1 (9P/Tempel)'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['9p_tempel_1', 'sc_deep_impact', 'sc_deep_impact_impactor']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.alignObjects('sc_deep_impact_impactor', '9p_tempel_1', {
						duration: 3,
						distance: 0.005,
						verticalOffset: 15,
						horizontalOffset: 15
					});
					time.play();
				}
			],
			onEnter: (app, slide) => {
				const maxTime = '2005-07-04T05:44:33Z';
				slide.update = () => {
					const time = app.getManager('time');
					if (time.getTime().valueOf() >= time.parseTime(maxTime).valueOf()) {
						time.pause();
					}
				};
				app.pioneer.addCallback(slide.update, true);
				app.getManager('time').setMax(maxTime);

				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_deep_impact_impactor', goToSpacecraft);
				addLabelClick(app, 'sc_deep_impact', goToSpacecraft);
				addLabelClick(app, '9p_tempel_1', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (entityName === '9p_tempel_1') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_deep_impact_impactor') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				app.pioneer.removeCallback(slide.update);
				app.getManager('time').resetMax();

				// Make label(s) unclickable
				removeLabelClick(app, 'sc_deep_impact_impactor', goToSpacecraft);
				removeLabelClick(app, '9p_tempel_1', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_5',
			type: 'panel',
			time: '2012-07-21T12:01:00Z',
			rate: 35,
			content: [
				{
					type: 'description',
					title: 'The Dawn mission',
					description: "in orbit around Vesta"
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['4_vesta', 'sc_dawn']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToSpacecraft('sc_dawn', { cinematic: true, duration: 3 });
					time.play();
				}
			],
			onEnter: (app, slide) => {
				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_dawn', goToSpacecraft);
				addLabelClick(app, '4_vesta', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (entityName === '4_vesta') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_dawn') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				// Make label(s) unclickable
				removeLabelClick(app, 'sc_dawn', goToSpacecraft);
				removeLabelClick(app, '4_vesta', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_6',
			type: 'panel',
			time: '2016-03-18T13:30:00Z',
			rate: 40,
			content: [
				{
					type: 'description',
					title: 'The Dawn mission',
					description: 'in orbit around Ceres'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['1_ceres', 'sc_dawn']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToCelestialObject('1_ceres', { cinematic: false, duration: 3, distance: 2 });
					time.play();
				}
			],
			onEnter: (app, slide) => {
				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_dawn', goToSpacecraft);
				addLabelClick(app, '1_ceres', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (entityName === '1_ceres') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_dawn') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				// Make label(s) unclickable
				removeLabelClick(app, 'sc_dawn', goToSpacecraft);
				removeLabelClick(app, '1_ceres', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_7',
			type: 'panel',
			time: '2003-12-24T00:00:00Z',
			rate: 90,
			content: [
				{
					type: 'description',
					title: 'The Stardust mission',
					description: 'flying by the comet Wild 2'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isReady('sc_stardust');
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToSpacecraft('sc_stardust', { distance: -0.01, cinematic: false, duration: 3 });
					time.play();
				}
			],
			onEnter: (app, slide) => {
				// Make label(s) clickable
				addLabelClick(app, 'sc_stardust', goToSpacecraft);
				addLabelClick(app, '81p_wild_2', goToCelestialObject);
			},
			onLeave: (app, slide) => {
				// Make label(s) unclickable
				removeLabelClick(app, 'sc_stardust', goToSpacecraft);
				removeLabelClick(app, '81p_wild_2', goToCelestialObject);
			}
		},
		{
			id: 'slide_8',
			type: 'panel',
			time: '2020-10-20T21:50:24Z',
			content: [
				{
					type: 'description',
					title: 'The OSIRIS-REx mission',
					description: 'sampling the surface of the asteroid Bennu'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['101955_bennu', 'sc_osiris_rex']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.alignObjects('sc_osiris_rex', '101955_bennu', {
						duration: 4,
						distance: 0.1,
						verticalOffset: 30,
						horizontalOffset: -80
					});
					time.play();
				}
			],
			onEnter: (app, slide) => {
				app.getComponent('settings').toggleLightOptions('flood');

				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_osiris_rex', goToSpacecraft);
				addLabelClick(app, '101955_bennu', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					if (isLabelClicked) {
						return;
					}
					const entityName = entity?.getName();
					if (entityName === '101955_bennu') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_osiris_rex') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				app.getComponent('settings').toggleLightOptions('shadow');

				// Make label(s) unclickable
				removeLabelClick(app, 'sc_osiris_rex', goToSpacecraft);
				removeLabelClick(app, '101955_bennu', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_9',
			type: 'panel',
			time: '2029-08-17T01:02:00Z',
			content: [
				{
					type: 'description',
					title: 'The Psyche mission',
					description: 'en route to metal asteroid 16 Psyche.'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['16_psyche', 'sc_psyche']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToSpacecraft('sc_psyche', { cinematic: true, duration: 3, distance: 0.05 });
					time.play();
				}
			],
			onEnter: (app, slide) => {
				app.getComponent('settings').toggleLightOptions('flood');

				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_psyche', goToSpacecraft);
				addLabelClick(app, '16_psyche', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (entityName === '16_psyche') {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_psyche') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				app.getComponent('settings').toggleLightOptions('shadow');

				// Make label(s) unclickable
				removeLabelClick(app, 'sc_psyche', goToSpacecraft);
				removeLabelClick(app, '16_psyche', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_10',
			type: 'panel',
			time: '2022-09-26T23:14:11Z',
			content: [
				{
					type: 'description',
					title: 'The DART mission',
					description: 'impacting the asteroid moon Dimorphos'
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isListReady(['65803_didymos', 'dimorphos', 'sc_dart']);
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToSpacecraft('sc_dart', {
						cinematic: false,
						duration: 3,
						verticalOffset: 15
					});
					time.play();
				}
			],
			onEnter: (app, slide) => {
				app.getManager('time').setMax('2022-09-26T23:14:18.054Z');

				const camera = app.getManager('camera');

				// Make label(s) clickable
				addLabelClick(app, 'sc_dart', goToSpacecraft);
				addLabelClick(app, 'dimorphos', goToCelestialObject);
				addLabelClick(app, '65803_didymos', goToCelestialObject);

				// Make object(s) clickable
				slide.selectionCallback = camera.getSelectionCallback();
				camera.setSelectionCallback(async entity => {
					const entityName = entity?.getName();
					if (['dimorphos', '65803_didymos'].includes(entityName)) {
						await app.cameraScripts.goToCelestialObject(entityName);
					}
					else if (entityName === 'sc_dart') {
						await app.cameraScripts.goToSpacecraft(entityName);
					}
				});
			},
			onLeave: (app, slide) => {
				app.getManager('time').resetMax();

				// Make label(s) unclickable
				removeLabelClick(app, 'sc_dart', goToSpacecraft);
				removeLabelClick(app, 'dimorphos', goToCelestialObject);
				removeLabelClick(app, '65803_didymos', goToCelestialObject);

				// Reset object callback
				app.getManager('camera').setSelectionCallback(slide.selectionCallback);
			}
		},
		{
			id: 'slide_11',
			type: 'panel',
			content: [
				{
					type: 'description',
					description: ''
				}
			],
			camera: [
				async app => {
					const localNonce = ++globalNonce;
					const time = app.getManager('time');
					await app.getManager('scene').isReady('earth');
					if (localNonce !== globalNonce) return;
					time.pause();
					await app.cameraScripts.goToCelestialObject('earth', { cinematic: true, duration: 3 });
					time.play();
				}
			]
		}
	],
	onEnter: app => {
		app.scene.get('sun', 'orbitalParticles').setEnabled(false);
		app.getManager('layer').toggleLayer('starfield', { category: 'Star Field' }, true);

		window.addEventListener('mousedown', resetLabelClick);
		window.addEventListener('touchstart', resetLabelClick);
	},
	onLeave: app => {
		app.scene.get('sun', 'orbitalParticles').setEnabled(true);
		app.getManager('layer').toggleLayer('starfield', { category: 'Star Field' }, false);

		window.removeEventListener('mousedown', resetLabelClick);
		window.removeEventListener('touchstart', resetLabelClick);
	}
});


/***/ }),

/***/ "./src/data/stories/index.js":
/*!***********************************!*\
  !*** ./src/data/stories/index.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "STORY_LIST": function() { return /* reexport default export from named module */ _story_list_json__WEBPACK_IMPORTED_MODULE_3__; },
/* harmony export */   "STORIES": function() { return /* binding */ STORIES; }
/* harmony export */ });
/* harmony import */ var _asteroids_101__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asteroids_101 */ "./src/data/stories/asteroids_101.js");
/* harmony import */ var _asteroids_close_approach__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asteroids_close_approach */ "./src/data/stories/asteroids_close_approach.js");
/* harmony import */ var _asteroids_missions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./asteroids_missions */ "./src/data/stories/asteroids_missions.js");
/* harmony import */ var _story_list_json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./story_list.json */ "./src/data/stories/story_list.json");





const STORIES = {
	asteroids_101: _asteroids_101__WEBPACK_IMPORTED_MODULE_0__["default"],
	asteroids_close_approach: _asteroids_close_approach__WEBPACK_IMPORTED_MODULE_1__["default"],
	asteroids_missions: _asteroids_missions__WEBPACK_IMPORTED_MODULE_2__["default"]
};




/***/ }),

/***/ "./src/internal.js":
/*!*************************!*\
  !*** ./src/internal.js ***!
  \*************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FiltersManager": function() { return /* reexport safe */ _managers_filters_manager__WEBPACK_IMPORTED_MODULE_0__.FiltersManager; },
/* harmony export */   "NEOsManager": function() { return /* reexport safe */ _managers_neos_manager__WEBPACK_IMPORTED_MODULE_1__.NEOsManager; },
/* harmony export */   "WatchManager": function() { return /* reexport safe */ _managers_watch_manager__WEBPACK_IMPORTED_MODULE_2__.WatchManager; },
/* harmony export */   "LinkManager": function() { return /* reexport safe */ _managers_link_manager__WEBPACK_IMPORTED_MODULE_3__.LinkManager; },
/* harmony export */   "SelectionManager": function() { return /* reexport safe */ _managers_selection_manager__WEBPACK_IMPORTED_MODULE_4__.SelectionManager; },
/* harmony export */   "LabelManager": function() { return /* reexport safe */ _managers_label_manager__WEBPACK_IMPORTED_MODULE_5__.LabelManager; },
/* harmony export */   "TrailManager": function() { return /* reexport safe */ _managers_trail_manager__WEBPACK_IMPORTED_MODULE_6__.TrailManager; },
/* harmony export */   "AsteroidMenuTop": function() { return /* reexport safe */ _components_asteroid_menu_top_asteroid_menu_top__WEBPACK_IMPORTED_MODULE_7__.AsteroidMenuTop; },
/* harmony export */   "AsteroidMenuBottom": function() { return /* reexport safe */ _components_asteroid_menu_bottom_asteroid_menu_bottom__WEBPACK_IMPORTED_MODULE_8__.AsteroidMenuBottom; },
/* harmony export */   "AsteroidModals": function() { return /* reexport safe */ _components_asteroid_modals_asteroid_modals__WEBPACK_IMPORTED_MODULE_9__.AsteroidModals; },
/* harmony export */   "HomeButton": function() { return /* reexport safe */ _components_home_button_home_button__WEBPACK_IMPORTED_MODULE_10__.HomeButton; },
/* harmony export */   "WatchPanel": function() { return /* reexport safe */ _components_watch_panel_watch_panel__WEBPACK_IMPORTED_MODULE_11__.WatchPanel; },
/* harmony export */   "AsteroidPanel": function() { return /* reexport safe */ _components_asteroid_panel_asteroid_panel__WEBPACK_IMPORTED_MODULE_12__.AsteroidPanel; },
/* harmony export */   "MissionPanel": function() { return /* reexport safe */ _components_mission_panel_mission_panel__WEBPACK_IMPORTED_MODULE_13__.MissionPanel; },
/* harmony export */   "FollowingPanel": function() { return /* reexport safe */ _components_following_panel_following_panel__WEBPACK_IMPORTED_MODULE_14__.FollowingPanel; },
/* harmony export */   "Countdown": function() { return /* reexport safe */ _components_countdown_countdown__WEBPACK_IMPORTED_MODULE_15__.Countdown; },
/* harmony export */   "SplashScreen": function() { return /* reexport safe */ _components_splash_screen_splash_screen__WEBPACK_IMPORTED_MODULE_16__.SplashScreen; },
/* harmony export */   "AsteroidsApp": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_17__.AsteroidsApp; },
/* harmony export */   "NEO": function() { return /* reexport safe */ _neos__WEBPACK_IMPORTED_MODULE_18__.NEO; },
/* harmony export */   "NEOUtils": function() { return /* reexport safe */ _neos__WEBPACK_IMPORTED_MODULE_18__.NEOUtils; },
/* harmony export */   "DefinitionOverlay": function() { return /* reexport safe */ _components_definition_overlay_definition_overlay__WEBPACK_IMPORTED_MODULE_19__.DefinitionOverlay; },
/* harmony export */   "TimeSlider": function() { return /* reexport safe */ _components_time_slider_time_slider__WEBPACK_IMPORTED_MODULE_20__.TimeSlider; },
/* harmony export */   "Breadcrumb": function() { return /* reexport safe */ _components_breadcrumb_breadcrumb__WEBPACK_IMPORTED_MODULE_21__.Breadcrumb; },
/* harmony export */   "AsteroidsSettings": function() { return /* reexport safe */ _components_settings_asteroids_settings__WEBPACK_IMPORTED_MODULE_22__.AsteroidsSettings; },
/* harmony export */   "Search": function() { return /* reexport safe */ _components_search_search__WEBPACK_IMPORTED_MODULE_23__.Search; },
/* harmony export */   "Types": function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_24__.Types; }
/* harmony export */ });
/* harmony import */ var _managers_filters_manager__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./managers/filters_manager */ "./src/managers/filters_manager.js");
/* harmony import */ var _managers_neos_manager__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./managers/neos_manager */ "./src/managers/neos_manager.js");
/* harmony import */ var _managers_watch_manager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./managers/watch_manager */ "./src/managers/watch_manager.js");
/* harmony import */ var _managers_link_manager__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./managers/link_manager */ "./src/managers/link_manager.js");
/* harmony import */ var _managers_selection_manager__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./managers/selection_manager */ "./src/managers/selection_manager.js");
/* harmony import */ var _managers_label_manager__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./managers/label_manager */ "./src/managers/label_manager.js");
/* harmony import */ var _managers_trail_manager__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./managers/trail_manager */ "./src/managers/trail_manager.js");
/* harmony import */ var _components_asteroid_menu_top_asteroid_menu_top__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/asteroid_menu_top/asteroid_menu_top */ "./src/components/asteroid_menu_top/asteroid_menu_top.js");
/* harmony import */ var _components_asteroid_menu_bottom_asteroid_menu_bottom__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/asteroid_menu_bottom/asteroid_menu_bottom */ "./src/components/asteroid_menu_bottom/asteroid_menu_bottom.js");
/* harmony import */ var _components_asteroid_modals_asteroid_modals__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/asteroid_modals/asteroid_modals */ "./src/components/asteroid_modals/asteroid_modals.js");
/* harmony import */ var _components_home_button_home_button__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/home_button/home_button */ "./src/components/home_button/home_button.js");
/* harmony import */ var _components_watch_panel_watch_panel__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/watch_panel/watch_panel */ "./src/components/watch_panel/watch_panel.js");
/* harmony import */ var _components_asteroid_panel_asteroid_panel__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/asteroid_panel/asteroid_panel */ "./src/components/asteroid_panel/asteroid_panel.js");
/* harmony import */ var _components_mission_panel_mission_panel__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/mission_panel/mission_panel */ "./src/components/mission_panel/mission_panel.js");
/* harmony import */ var _components_following_panel_following_panel__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/following_panel/following_panel */ "./src/components/following_panel/following_panel.js");
/* harmony import */ var _components_countdown_countdown__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/countdown/countdown */ "./src/components/countdown/countdown.js");
/* harmony import */ var _components_splash_screen_splash_screen__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/splash_screen/splash_screen */ "./src/components/splash_screen/splash_screen.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./app */ "./src/app.js");
/* harmony import */ var _neos__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./neos */ "./src/neos.js");
/* harmony import */ var _components_definition_overlay_definition_overlay__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/definition_overlay/definition_overlay */ "./src/components/definition_overlay/definition_overlay.js");
/* harmony import */ var _components_time_slider_time_slider__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/time_slider/time_slider */ "./src/components/time_slider/time_slider.js");
/* harmony import */ var _components_breadcrumb_breadcrumb__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/breadcrumb/breadcrumb */ "./src/components/breadcrumb/breadcrumb.js");
/* harmony import */ var _components_settings_asteroids_settings__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/settings/asteroids_settings */ "./src/components/settings/asteroids_settings.js");
/* harmony import */ var _components_search_search__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/search/search */ "./src/components/search/search.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./types */ "./src/types.js");
/* eslint-disable import/first */



























// Types



/***/ }),

/***/ "./src/managers/filters_manager.js":
/*!*****************************************!*\
  !*** ./src/managers/filters_manager.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FiltersManager": function() { return /* binding */ FiltersManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/**
 * An Asteroids manager for handling the application's filter state
 * This is very basic. Logic from the filters_modal could be pulled in here
 */





/**
 * Filters Manager class.
 */
class FiltersManager extends eyes__WEBPACK_IMPORTED_MODULE_1__.BaseManager {
	/**
	 * Constructs the filters manager.
	 * @param {BaseApp} app
	 * @param {Pioneer.Scene} scene
	 */
	constructor(app, scene) {
		super(app, scene);

		this.state = {
			isFiltering: false,
			// filter keys are always {originalFilter} + s (ex. news -> newss)
			filters: {
				asteroids: false,
				comets: false,
				phos: false
			},
			lastSize: null
		};

		// The previous filters state
		this.previousFilters = {
			asteroids: false,
			comets: false,
			phos: false
		};

		this._app = app;

		this._eventNames.push('isFilteringChange');
		this._eventNames.push('lastSizeChange');
		this._initCallbacks();

		this.bindFunctions([
			'getFilters',
			'getLastSize',
			'_matchFunction'
		]);
	}

	/**
	 * Sets the application's filtering state
	 * @param {boolean} isFiltering
	 */
	_setFiltering(isFiltering) {
		if (this.state.isFiltering !== isFiltering) {
			this.state.isFiltering = isFiltering;
			this.triggerCallbacks('isFilteringChange', [this.state.isFiltering]);
		}
	}

	/**
	 * Sets the final size of the filtered results
	 * @param {number} lastSize - the final size of the filtered results
	 */
	_setLastSize(lastSize) {
		if (this.state.lastSize !== lastSize) {
			this.state.lastSize = lastSize;
			this.triggerCallbacks('lastSizeChange', [this.state.lastSize]);
		}
	}

	/**
	 * Whether the application is in a filtered state or not
	 * @returns {boolean} filter state
	 */
	get isFiltering() {
		return this.state.isFiltering;
	}

	/**
	 * The filters state
	 * @returns {object} filters state
	 */
	getFilters() {
		return this.state.filters;
	}

	/**
	 * The previous filters state
	 * @returns {object} filters state
	 */
	getPreviousFilters() {
		return this.previousFilters;
	}

	/**
	 * Gets the size of filtered results
	 * @returns {number} - number of filtered results
	 */
	getLastSize() {
		return this.state.lastSize;
	}

	/**
	 * Sets a filter
	 * @param {string | object} filter - One of 'asteroids' | 'comets' | 'phos' or filtersState object
	 * @param {boolean} on - on or not
	 * @param {Function} callback
	 */
	setFilter(filter, on, callback) {
		this.previousFilters = this.state.filters;
		// Only trigger filter on state change, to prevent unncessary executions and flash off/on
		if (typeof filter === 'string') {
			if (this.state.filters[filter] != null && this.state.filters[filter] !== on) {
				this.state.filters[filter] = on;
				this._filter(callback);
			}
		}
		else {
			for (const key in filter) {
				if (this.state.filters[key] !== filter[key]) {
					this.state.filters = { ...this.state.filters, ...filter };
					this._filter(callback);
					break;
				}
			}
		}
	}

	/**
	 * Minimally changes the current filter state to reveal an object based on the object's filter state
	 * @param {object} reveal - Can be neo object itself or just: { asteroid: false, comet: true, pho: false }
	 * @param {boolean} resetAll - If true and reveal is presently hidden, resets all filters to show everything instead of just being selective about it
	 * @param {Function} callback - callback for after filter completes
	 * @returns {boolean} Whether or not the filter state had to change to accommodate the reveal
	 */
	setFilterToReveal(reveal, resetAll, callback) {
		let refilterNeeded = false;
		// Turn off showing only phos if reveal is not a pho
		if (reveal.pho !== true && this.state.filters.phos === true) {
			this.state.filters.phos = false;
			refilterNeeded = true;
		}

		// Only check these if at least one of them is true
		// (because both false means everything is shown)
		if (!(this.state.filters.asteroids === false && this.state.filters.comets === false)) {
			// So now we can only worry about checking them on if needed
			if (reveal.asteroid === true && this.state.filters.asteroids === false) {
				this.state.filters.asteroids = true;
				refilterNeeded = true;
			};
			if (reveal.comet === true && this.state.filters.comets === false) {
				this.state.filters.comets = true;
				refilterNeeded = true;
			};
		}

		if (refilterNeeded) {
			if (resetAll === true) {
				this.state.filters = { asteroids: false, comets: false, phos: false };
			};
			this._filter(callback);
		};
		return refilterNeeded;
	}

	/**
	 * Toggles a layer
	 * @param {string} key - layer key
	 * @param {boolean} on - can be unset for a true toggle, otherwise forces
	 */
	_toggleLayer(key, on) {
		const layerManager = this._app.getManager('layer');
		const categories = {
			ui: 'User Interface',
			planets: 'Planet',
			asteroids: 'Asteroid',
			comets: 'Comet',
			dwarfPlanets: 'Dwarf Planet',
			spacecraft: 'Spacecraft',
			trails: 'Trail',
			labels: 'Label'
		};
		if (
			on == null
            || (on === true && layerManager._layers[key]?.visible === false)
            || (on === false && layerManager._layers[key]?.visible === true)) {
			layerManager.toggleLayer(key, { category: categories[key] });
		}
	}

	/**
	 * Determines whether or not the NEO fits in the filter
	 * @param {NEO} neo
	 * @returns {boolean}
	 */
	_matchFunction(neo) {
		if (this.app.getManager('selection')?._id === neo.pioneerName) {
			return true;
		}
		if (this.state.filters.asteroids && !this.state.filters.comets && neo.comet === true) {
			return false;
		};
		if (this.state.filters.comets && !this.state.filters.asteroids && neo.comet === false) {
			return false;
		};
		if (this.state.filters.phos && neo.pho === false) {
			return false;
		};
		return true;
	}

	/**
	 * Narrow orbital particles, layers and entities based on the user's filters
	 * @param {Function} callback
	 */
	_filter(callback) {
		const filtersAreActive = (this.state.filters.asteroids || this.state.filters.comets || this.state.filters.phos);
		// Filter particles
		this._app.addParticleMatchFunction(this._matchFunction, 'filters_manager', true, (orbitalElements) => {
			this._setLastSize((filtersAreActive ? orbitalElements.length : this.app.neos.size) || 0);
			this._setFiltering(filtersAreActive);
			if (typeof callback === 'function') callback(this.state.lastSize);
		});

		// Filter layers
		// If both are off, both are on
		if (!this.state.filters.asteroids && !this.state.filters.comets) {
			this._toggleLayer('asteroids', true);
			this._toggleLayer('comets', true);
		}
		else {
			this._toggleLayer('asteroids', this.state.filters.asteroids);
			this._toggleLayer('comets', this.state.filters.comets);
		}

		// Filter on a per entity level for PHOs
		const { neos } = this._app;
		const { _itemsByName: sceneEntities } = this.app.scene?._entities || {};
		const sceneEntityNames = sceneEntities ? Array.from(sceneEntities.keys()) : [];

		const foundNeos = [];

		for (const neoName of neos.keys()) {
			if (sceneEntityNames.includes(neoName)) {
				foundNeos.push(neoName);
				sceneEntities.get(neoName).setEnabled(this._matchFunction(neos.get(neoName)));
			}
		}

		// Now, for all the entities without matching neos
		const allEntities = this._app.getManager('content')?.getEntityList();

		for (const sceneEntityName of sceneEntityNames) {
			// Find the entities that are asteroids, comets or dwarf planets
			if (!foundNeos.includes(sceneEntityName) && allEntities[sceneEntityName] && ['Asteroid', 'Comet', 'Dwarf Planet'].includes(allEntities[sceneEntityName].category)) {
				// Apply the match function to them at a asteroid/comet basis
				// Note: This treats Dwarf planets as asteroids (Ceres, then, is an asteroid here)
				sceneEntities.get(sceneEntityName)?.setEnabled(this._matchFunction({
					comet: allEntities[sceneEntityName].category === 'Comet',
					pho: false
				}));
			}
		}
	}
}


/***/ }),

/***/ "./src/managers/label_manager.js":
/*!***************************************!*\
  !*** ./src/managers/label_manager.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelManager": function() { return /* binding */ LabelManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


/**
 * @inheritdoc
 * @extends EyesSelectionManager
 */
class LabelManager extends eyes__WEBPACK_IMPORTED_MODULE_0__.LabelManager {
	/**
	 * @inheritdoc
	 * @override
	 */
	_getLink(entityName) {
		const link = super._getLink(entityName);
		return this._app.getManager('link')?.getParsedLink?.(link) || link;
	}
}


/***/ }),

/***/ "./src/managers/link_manager.js":
/*!**************************************!*\
  !*** ./src/managers/link_manager.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LinkManager": function() { return /* binding */ LinkManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


/**
 * Extends the main Eyes RouteManager
 */
class LinkManager extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseManager {
	/**
	 * Asteroids-specific parsed link method
	 * @param {string} link
	 * @returns {string}
	 */
	getParsedLink(link) {
		const entityName = link.startsWith('/') ? link.slice(1) : link;

		const info = this._app?.getManager('content')?.getEntityInfo(entityName);
		if (info) {
			if (info.id === 'sun') {
				return `/stars/${entityName}`;
			}

			if (info.id === 'moon') {
				return `/moons/${entityName}`;
			}

			if (info.category === 'Spacecraft') {
				return `/missions/${entityName}`;
			}

			if (info.category === 'Planet') {
				return `/planets/${entityName}`;
			}
		}

		return `/${entityName}`;
	}
}


/***/ }),

/***/ "./src/managers/neos_manager.js":
/*!**************************************!*\
  !*** ./src/managers/neos_manager.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NEOsManager": function() { return /* binding */ NEOsManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "./src/internal.js");
/**
 * An Asteroids manager for handling the application's NEOs.
 * This is very basic. Logic from the filters_modal could be pulled in here
 */





/**
 * Filters Manager class.
 */
class NEOsManager extends eyes__WEBPACK_IMPORTED_MODULE_1__.BaseManager {
	/**
	 * Creates a temporary NEO entity.
	 * @param {object} data - NEO data
	 * @param {Pioneer.Scene} scene
	 * @param {boolean} addLabel
	 * @returns {Pioneer.Entity}
	 */
	createTempNEO(data, scene = this._app.scene, addLabel = true) {
		const entity = _internal__WEBPACK_IMPORTED_MODULE_2__.NEOUtils.createEntity(data, scene);
		this._app.getManager('label').addEntity(entity);
		this._app.getManager('scene').addTempEntity(entity);

		if (addLabel) {
			//  Set the label properties
			const contentManager = this._app.getManager('content');
			const labelManager = this._app.getManager('label');

			const { dwarfPlanet, asteroid, comet } = data;

			const iconClass = asteroid || dwarfPlanet
				? 'asteroid'
				: (comet ? 'comet' : '');

			labelManager.setLabelProps({
				getLabelClass: entityName => `no-select asteroid ${contentManager.getClassName(entityName) ?? ''}`,
				getIconClass: () => iconClass
			}, [entity.getName()]);
		}

		return entity;
	}
}


/***/ }),

/***/ "./src/managers/selection_manager.js":
/*!*******************************************!*\
  !*** ./src/managers/selection_manager.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionManager": function() { return /* binding */ SelectionManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


/**
 * @inheritdoc
 * @extends EyesSelectionManager
 */
class SelectionManager extends eyes__WEBPACK_IMPORTED_MODULE_0__.SelectionManager {
	/**
	 * @inheritdoc
	 * @override
	 */
	_getLink(entityName) {
		const link = super._getLink(entityName);
		return this._app.getManager('link')?.getParsedLink?.(link) || link;
	}
}


/***/ }),

/***/ "./src/managers/trail_manager.js":
/*!***************************************!*\
  !*** ./src/managers/trail_manager.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrailManager": function() { return /* binding */ TrailManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");


/**
 * @inheritdoc
 * @extends EyesTrailManager
 */
class TrailManager extends eyes__WEBPACK_IMPORTED_MODULE_0__.TrailManager {
	/**
	 * @inheritdoc
	 * @override
	 * Trials and orbit lines are treated as the same in Asteroids.
	 */
	toggleTrails(active) {
		super.toggleTrails(active, { scene: this._scene });
		this.toggleOrbits(active);
	}
}


/***/ }),

/***/ "./src/managers/watch_manager.js":
/*!***************************************!*\
  !*** ./src/managers/watch_manager.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WatchManager": function() { return /* binding */ WatchManager; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/**
 * An Asteroids manager for handling the asteroid watch state.
 * For Asteroid Watch, although the URL is the primary state source, a manager makes sense because
 * we require both UI and Pioneer changes
 */





/**
 * WatchManager
 */
class WatchManager extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseManager {
	/**
	 * Constructs the filters manager.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * have we redirected?
		 * @property {boolean}
		 */
		this._hasRedirected = null;

		/**
		 * Ephermeris time (ET)
		 * @property {number}
		 */
		this._currentTime = pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now();

		/**
		 * Calculated next five approaches
		 * @property {Array<NEO>}
		 */
		this._nextFiveData = null;

		/**
		 * Next five entitoes
		 * @property {Array<Entity>}
		 */
		this._nextFiveEntities = null;

		/**
		 * Next five names only
		 * @property {Array<string>}
		 */
		this._nextFiveNames = null;

		/**
		 * Object to apply Watch and focus label weighting.
		 * @property {Array<string>}
		 */
		this._labelWeights = null;

		/**
		 * Focus entity names
		 * @property {Array<string>}
		 */
		this._focusEntityNames = null;

		/**
		 * The background planets.
		 * @property {Array<string>}
		 */
		this._backgroundPlanets = ['mercury', 'venus', 'mars', 'jupiter', 'saturn', 'uranus', 'neptune'];

		/**
		 * The default width of the unhovered planet trail.
		 * (as seen in asteroids.js - this should probably be in a config)
		 * @property {number}
		 */
		this._defaultPlanetTrailWidth = 4;

		/**
		 * _slideIndex - which of the next five is selected (null means the panel is collapsed)
		 * @property {number}
		 */
		this._slideIndex = null;

		/**
		 * store Earths dynamo coverage
		 * @property {Interval}
		 */
		this._dynamoCoverage = null;

		/**
		 * _unitType - current unit of measurement
		 */
		this._unitType = 'metric';

		this._eventNames.push('toggleUnit');
		this._initCallbacks();

		this.bindFunctions(['setData', '_calculateNextNEOs', '_createEntities', '_calculateTimeLimits', 'getNeoNameByIndex', 'updateURL', 'toggleUnit']);
	}

	/**
	 * Use neo data to calculate _nextFiveData
	 */
	setData() {
		if (this._nextFiveData) {
			return;
		};

		// Filter the next five.
		const allNEOs = this._app.neos;

		if (!allNEOs) {
			throw Error('Cannot get NEO data.');
		}

		this._nextFiveData = this._calculateNextNEOs(allNEOs);

		this._setLabelWeights();
	}

	/**
	 * Set the label weights.
	 * @param {string} focusName
	 */
	_setLabelWeights(focusName) {
		this._labelWeights = Object.fromEntries(
			this._nextFiveData.map(({ pioneerName }) => [pioneerName, {
				category: pioneerName === focusName ? 'Focus' : 'Watch'
			}])
		);

		this._app.getManager('label')?.setWeights(this._labelWeights, false);
	}

	/**
	 * Determines the index of an asteroid with a given name
	 * @param {string} neoName
	 * @returns {number|null}
	 */
	determineSlideIndex(neoName) {
		return neoName ? this._nextFiveData.findIndex(neo => neo.pioneerName === neoName) : null;
	}

	/**
	 * Set the slide index
	 * @param {number|null} index
	 */
	setSlideIndex(index) {
		this._slideIndex = index;
	}

	/**
	 * Adds correct selection classes to the labels so they're highlighted correctly.
	 * Also triggers the trail hover
	 */
	setAsteroidSelection() {
		const labelManager = this._app.getManager('label');
		const asteroidName = this._nextFiveData[this._slideIndex]?.pioneerName ?? false;

		// Set focused label weights
		this._setLabelWeights(asteroidName);

		// First remove all selections.
		labelManager.removeClassFromLabels('selected', this._nextFiveNames);

		// Select the selected.
		const selected = this._nextFiveNames.find(name => name === asteroidName);
		selected && labelManager.addClassToLabels('selected', [selected]);

		// Set all trails to unhighlight except asteroidName
		for (const name of this._nextFiveNames) {
			labelManager.triggerCallbacks('hoverchange', [name, name === asteroidName]);
		}
	}

	/**
	 * Calculates the next <amount> of NEOs to pass earth according to their close approach time
	 * @param {Array<NEO>} allNEOs
	 * @param {number} amount
	 * @returns {Array<NEO>}
	 */
	_calculateNextNEOs(allNEOs, amount = 5) {
		const maxDistance = 7479893.535; // 0.05 AUs in km
		const nextFive = [];
		const nearestDiffs = [];

		// eslint-disable-next-line no-unused-vars
		for (const [_, value] of allNEOs.entries()) {
			// Make sure its in the future
			const inTheFuture = value.nextClosestApproachTime > this._currentTime;
			// Make sure it's closer than the maxDistance
			const withinDistance = value.nextClosestApproachDistance < maxDistance;

			if (withinDistance && inTheFuture) {
				const diff = value.nextClosestApproachTime - this._currentTime;
				// Push to nextFive array if it's not yet filled.
				if (nearestDiffs.length < amount) {
					nearestDiffs.push(diff);
					nextFive.push(value);
				}
				else {
					// Check if the diff is smaller than the largest diff in the array. If so, replace it.
					const largestDiff = Math.max(...nearestDiffs);
					if (diff < largestDiff) {
						const replaceIndex = nearestDiffs.indexOf(largestDiff);
						nearestDiffs[replaceIndex] = diff;
						nextFive[replaceIndex] = value;
					}
				}
			}
		}

		return nextFive.sort((a, b) => (a.nextClosestApproachTime >= b.nextClosestApproachTime) ? 1 : -1);
	}

	/**
	 * Creates the next five entities
	 * @returns {Promise}
	 */
	_createEntities() {
		if (this._nextFiveEntities) {
			return Promise.resolve();
		}

		const sceneManager = this._app.getManager('scene');
		const neosManager = this._app.getManager('neos');
		const labelManager = this._app.getManager('label');
		const contentManager = this._app.getManager('content');
		const trailManager = this._app.getManager('trail');

		// Create the next five entities.
		this._nextFiveEntities = this._nextFiveData.map(neo => neosManager.createTempNEO(neo, sceneManager.main, false));

		// Store the name vars.
		this._nextFiveNames = this._nextFiveData.map(neo => neo.pioneerName);
		this._focusEntityNames = ['earth', 'moon', ...this._nextFiveNames];

		const handleMouseLeave = (e, entityName) => {
			// Determine if were hovering on a selected asteroids watch asteroid.
			if (e.target?.classList?.contains('selected') && e.target?.classList?.contains('asteroid-watch-label')) {
				return;
			}
			labelManager.triggerCallbacks('hoverchange', [entityName, false]);
		};

		//  Set the label properties
		labelManager.setLabelProps({
			getLabelClass: entityName => `no-select asteroid-watch-label ${contentManager.getClassName(entityName) ?? ''}`,
			getIconClass: () => 'asteroid-watch-icon',
			getTextClass: () => 'asteroid-watch-text',
			handleClick: (_, entityName) => {
				this.updateURL(entityName);
			},
			handleTouch: (_, entityName) => {
				if (!this.app.isDragging() && !this.app.isTouchMax()) {
					this.updateURL(entityName);
				}
			},
			handleMouseLeave
		}, this._nextFiveNames);

		// Set the trail colors.
		const trailColorArray = this._app._colors?.neos;
		trailColorArray && trailManager.setColor(this._nextFiveNames, new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(...trailColorArray, 0.35));

		// Expect all entity loaded promises to eventually be resolved.
		return Promise.all(this._nextFiveEntities.map(neoEntity => neoEntity.getLoadedPromise()));
	}

	/**
	 * Determines the max and min time limits depending on the close approach times of the next five
	 * @returns {Interval}
	 */
	_calculateTimeLimits() {
		// Padding is 99 days (in seconds) - to stop the day countdown getting to 3 figures.
		const padding = 86400 * 99;

		const timeManager = this.app.getManager('time');
		const now = timeManager.getNow();
		const todayEtTime = timeManager.momentToET(now);
		const { nextClosestApproachTime: lastApproachTime } = this._nextFiveData[this._nextFiveData.length - 1];

		// Get the largest remaining time in ET seconds.
		const largestRemainingTime = lastApproachTime - todayEtTime;
		const maxPadding = padding - largestRemainingTime;

		const minET = lastApproachTime - maxPadding;
		const maxET = lastApproachTime + maxPadding;

		return new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(minET, maxET);
	}

	/**
	 * Restrict the earth controller coverage to time limits.
	 */
	restrictEarthCoverage() {
		const earthController = this._app.scene.getEntity('earth')?.getControllerByType('dynamo');

		if (!earthController) {
			console.warn('Could not find Earth dynamo.');
			return;
		}

		// Store previous coverage.
		this._dynamoCoverage = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval();
		this._dynamoCoverage.copy(earthController.getCoverage());

		// Set to time restriction.
		earthController.setCoverage(this._calculateTimeLimits());
	}

	/**
	 * Reset earth coverage to defaults.
	 */
	restoreEarthCoverage() {
		const earthController = this._app.scene.getEntity('earth')?.getControllerByType('dynamo');

		if (!earthController) {
			console.warn('Could not find Earth dynamo.');
			return;
		}

		earthController.setCoverage(this._dynamoCoverage);
	}

	/**
	 * Dim the background labels by adding class
	 * @param {boolean} value
	 */
	dimBackgroundLabels(value) {
		const labelManager = this._app.getManager('label');
		const dimClass = 'watch-dim';

		const backgroundLabels = Object.keys(labelManager._labels).filter(labelName => !this._focusEntityNames?.includes(labelName));

		if (value) {
			labelManager.addClassToLabels(dimClass, backgroundLabels);
		}
		else {
			labelManager.removeClassFromLabels(dimClass, backgroundLabels);
		}
	}

	/**
	 * set the default trail width for background planets
	 * @param {number} value
	 */
	setBgTrailWidthDefault(value = this._defaultPlanetTrailWidth) {
		for (const planetId of this._backgroundPlanets) {
			const entity = this.app.scene.get(planetId);

			if (entity?.trailHover?.width?.default) {
				entity.trailHover.width.default = [value, value];
			}
		}

		if (value === this._defaultPlanetTrailWidth) {
			// We're reseting to default.
			// Todo: put in some sort of onleave smoother camera transition function?
			const trailManager = this._app.getManager('trail');
			trailManager.setMultipleWidths(this._backgroundPlanets, value, value);
		}
	}

	/**
	 * Get the neo name by index number
	 * @param {number} index
	 * @returns {string}
	 */
	getNeoNameByIndex(index) {
		return this._nextFiveData?.[index]?.pioneerName;
	}

	/**
	 * Navigates to correct URL
	 * @param {string} neoName
	 * @param {boolean} removeQuery
	 */
	updateURL(neoName, removeQuery = false) {
		const routeManager = this._app.getManager('router');
		const options = { ...removeQuery && { __remove: 'all', keepTime: false } };

		routeManager.navigate({}, `/watch/${neoName}`, options);
	}

	/**
	 * Handle the menu item click.
	 * Determine which URL to go to depending on whether we've already set the data
	 */
	onWatchClick() {
		// Do not update if we are currently transitioning
		const transitioning = this._app.getManager('camera')?._isTransitioning;

		if (transitioning) {
			return;
		}

		// If we're already in the watch view, we can go live back to the main /watch overview
		const inWatchView = this._app.getManager('router').currentView === 'watch';

		if (this._nextFiveData && !inWatchView) {
			const index = this.slideIndex === null ? 0 : this.slideIndex;
			const removeQuery = true;
			this.setSlideUrlByIndex(index, removeQuery);
		}
		else {
			this._app.getManager('router').navigate({}, 'watch', { __remove: 'all', keepTime: false });
		}
	}

	/**
	 * Goes to the slide at index zero
	 * @param {number} index
	 * @param {boolean} removeQuery
	 * @returns {string}
	 */
	setSlideUrlByIndex(index, removeQuery = false) {
		// Get the neoName from index zero
		const neoName = this.getNeoNameByIndex(index);
		// Update URL with passed replaceState bool
		this.updateURL(neoName, removeQuery);

		return neoName;
	}

	/**
	 * Set references to null (except data ones) and remove label weights.
	 */
	removeReferences() {
		this._app.getManager('label')?.removeWeights(this._labelWeights);
		this._labelWeights = null;

		this.setSlideIndex(null);
		this._nextFiveEntities = null;
	}

	/**
	 * Getters and setters
	 */

	/**
	 * Set boolean value for hasRedirected
	 * @param {boolean} value
	 */
	setHasRedirected(value) {
		this._hasRedirected = value;
	}

	/**
	 * gets bool value for hasRedirected
	 * @returns {boolean}
	 */
	get hasRedirected() {
		return this._hasRedirected;
	}

	/**
	 * Returns the default planet trail width.
	 * @returns {number}
	 */
	get defaultPlanetTrailWidth() {
		return this._defaultPlanetTrailWidth;
	}

	/**
	 * Get background planets
	 * @returns {Array<string>}
	 */
	get backgroundPlanets() {
		return this._backgroundPlanets;
	}

	/**
	 * Get the current slide.
	 * @returns {number|null}
	 */
	get slideIndex() {
		return this._slideIndex;
	}

	/**
	 * return the next five data property
	 * @returns {Array<NEO>}
	 */
	get nextFiveData() {
		return this._nextFiveData;
	}

	/**
	 * return the next five entities property
	 * @returns {Array<Entity>}
	 */
	get nextFiveEntities() {
		return this._nextFiveEntities;
	}

	/**
	 *	Triggers all watchers to switch their units
	 * @param {string} unitType
	 */
	toggleUnit(unitType) {
		unitType = unitType || this._unitType === 'metric' ? 'imperial' : 'metric';
		if (['metric', 'imperial'].includes(unitType)) {
			if (this._unitType !== unitType) {
				this._unitType = unitType;
				this.triggerCallbacks('toggleUnit', [unitType]);
			}
		}
	}

	/**
	 * Get the current unitType.
	 * @returns {number|null}
	 */
	get unitType() {
		return this._unitType;
	}
}


/***/ }),

/***/ "./src/neos.js":
/*!*********************!*\
  !*** ./src/neos.js ***!
  \*********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "NEO": function() { return /* binding */ NEO; },
/* harmony export */   "NEOUtils": function() { return /* binding */ NEOUtils; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");



/** Information on an NEO. */
class NEO {
	/** The constructor. */
	constructor() {
		/**
		 * The full name.
		 * @type {string}
		 */
		this.name = '';

		/**
		 * The name within Pioneer.
		 * @type {string}
		 */
		this.pioneerName = '';

		/**
		 * 3 character orbit class 'ATI', 'ATE', 'AMO', 'APO'.
		 * @type {string}
		 */
		this.orbitClass = '';

		/**
		 * Whether or not it is an asteroid.
		 * @type {boolean}
		 */
		this.asteroid = false;

		/**
		 * Whether or not it is a comet.
		 * @type {boolean}
		 */
		this.comet = false;

		/**
		 * Whether or not it is a dwarf planet.
		 * @type {boolean}
		 */
		this.dwarfPlanet = false;

		/**
		 * Whether or not it is an NEO.
		 * @type {boolean}
		 */
		this.neo = false;

		/**
		 * Whether or not it is a PHO.
		 * @type {boolean}
		 */
		this.pho = false;

		/**
		 * Whether or not it has multiple orbital elements and has dynamo associated with it.
		 * @type {boolean}
		 */
		this.hasSPK = false;

		/**
		 * The absolute magnitude.
		 * @type {number}
		 */
		this.absoluteMagnitude = 0;

		/**
		 * The diameter.
		 * @type {number}
		 */
		this.diameter = 0;

		/**
		 * Whether or not the diameter has been estimated, since the data may not be available.
		 * @type {boolean}
		 */
		this.diameterEstimated = false;

		/**
		 * The MOID relative to earth.
		 * @type {number}
		 */
		this.moid = 0;

		/**
		 * The spin rate in rad/sec.
		 * @type {number}
		 */
		this.spinRate = 0;

		/**
		 * Whether or not the spin rate has been estimated, since the data may not be available.
		 * @type {boolean}
		 */
		this.spinRateEstimated = false;

		/**
		 * The spin axis in the J2000 frame.
		 * @type {Pioneer.Vector3}
		 */
		this.spinAxis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * Whether or not the spin axis has been estimated, since the data may not be available.
		 * @type {boolean}
		 */
		this.spinAxisEstimated = false;

		/**
		 * The next closest approach time in ephemeris time.
		 * @type {number}
		 */
		this.nextClosestApproachTime = 0;

		/**
		 * The next cosest approach distance in km.
		 * @type {number}
		 */
		this.nextClosestApproachDistance = 0;

		/**
		 * The orbital elements.
		 * @type {Pioneer.OrbitalElements}
		 */
		this.orbitalElements = new pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements();
	}
}

/** A class that helps with working with NEOs. */
class NEOUtils {
	/**
	 * Loads the NEOs. Returns a promise that resolves with a mapping from an NEO Pioneer name to information about that NEO.
	 * @param {Pioneer.Engine} pioneer
	 * @returns {Promise<Map<string, NEO>>}
	 */
	static async loadNEOs(pioneer) {
		/** @type {Map<string, NEO>} */
		const neos = new Map();

		// There are 10 files, so load all of them in parallel.
		const loadPromises = [];
		const urls = [];
		for (let n = 0; n < 10; n++) {
			urls.push(`neos.${n}.v1.dat`);
		}
		urls.push('dwarf_planets.v1.dat');
		urls.push('custom.v1.dat');
		for (const url of urls) {
			loadPromises.push(pioneer.getDownloader().download(`$DYNAMIC_ASSETS_URL/ssd/${url}`, true).then(async (download) => {
				if (download.status === 'cancelled') {
					return Promise.resolve();
				}
				else if (download.status === 'failed') {
					return Promise.reject(new Error('Failed to load asteroid file "' + download.url + '": ' + download.errorMessage));
				}
				if (!(download.content instanceof ArrayBuffer)) {
					return Promise.reject(new Error('Failed to load asteroid file "' + download.url + '": Not a binary file.'));
				}
				const reader = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);
				const version = reader.readUInt16();
				if (version !== 1) {
					throw new Error('Invalid version.');
				}

				// For each NEO in the file, read the data, populating the neo variable.
				const numNEOs = reader.readUInt32();
				for (let i = 0; i < numNEOs; i++) {
					// The neo object to populate.
					const neo = new NEO();

					// Read the name and class info.
					neo.name = reader.readString();
					neo.orbitClass = reader.readString(3);
					const flags = reader.readUInt8();
					neo.asteroid = ((flags & 0xc0) >> 6) === 0;
					neo.comet = ((flags & 0xc0) >> 6) === 1;
					neo.dwarfPlanet = ((flags & 0xc0) >> 6) === 2;
					neo.neo = ((flags & 0x20) >> 5) === 1;
					neo.pho = ((flags & 0x10) >> 4) === 1;
					neo.hasSPK = ((flags & 0x08) >> 3) === 1;
					neo.diameterEstimated = ((flags & 0x01) >> 0) === 1;

					// Read the absolute magnitude and diameter.
					neo.absoluteMagnitude = reader.readFloat32();
					neo.diameter = reader.readFloat32();
					if (Number.isNaN(neo.diameter)) {
						neo.diameter = 0.652999997138977; // The median asteroid size.
					}

					// If an NEO, read the moid and next closest approach info.
					if (neo.neo) {
						neo.moid = reader.readFloat32();
						neo.nextClosestApproachTime = reader.readFloat32();
						neo.nextClosestApproachDistance = reader.readFloat32();
					}

					// Read the orbital elements.
					neo.orbitalElements.epoch = reader.readFloat32();
					neo.orbitalElements.eccentricity = reader.readFloat32();
					neo.orbitalElements.semiMajorAxis = reader.readFloat32();
					neo.orbitalElements.meanAngularMotion = reader.readFloat32();
					neo.orbitalElements.meanAnomalyAtEpoch = reader.readFloat32();
					neo.orbitalElements.orbitOrientation.set(reader.readFloat32(), reader.readFloat32(), reader.readFloat32(), reader.readFloat32());

					// Read the spin info.
					const hasSpinRate = (flags & 0x04) >> 2;
					const hasSpinAxis = (flags & 0x02) >> 1;
					if (hasSpinRate) {
						neo.spinRate = reader.readFloat32();
						neo.spinRateEstimated = false;
					}
					else {
						neo.spinRate = 0.0075092; // Average spin rate of all NEOs as of 2021-06-24
						neo.spinRateEstimated = true;
					}
					if (hasSpinAxis) {
						neo.spinAxis.set(reader.readFloat32(), reader.readFloat32(), reader.readFloat32());
						neo.spinAxisEstimated = false;
					}
					else {
						neo.spinAxis.set(0, 0, 1); // Just setting it to the 'north' pole.
						neo.spinAxisEstimated = true;
					}

					// Get the pioneer entity name from the full name.
					neo.pioneerName = neo.name.replace(/[- /]/g, '_');
					neo.pioneerName = neo.pioneerName.replace(/[^a-zA-Z0-9_]/g, '');
					neo.pioneerName = neo.pioneerName.toLowerCase();

					// Add the neo to the neos list.
					neos.set(neo.pioneerName, neo);
				}
			}));
		}

		// Wait till all of the downloads are complete.
		await Promise.all(loadPromises);

		// Add Dimorphos manually.
		neos.set('dimorphos', {
			...neos.get('65803_didymos'),
			name: 'Dimorphos',
			pioneerName: 'dimorphos',
			diameter: 0.170
		});

		// Return the populated NEOs object.
		return neos;
	}

	/**
	 * Gets the Pioneer names of the next n closest approaches within 0.05 AU.
	 * @param {Map<string, NEO>} neos
	 * @param {number} n
	 * @returns {string[]}
	 */
	static getNextClosestApproaches(neos, n) {
		// The array we'll use to keep track of the next n closest approaches.
		const nextClosestApproachNEOs = /** @type {NEO[]} */([]);

		// Go through each neo.
		const now = pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.now();
		for (const entry of neos) {
			const neo = entry[1];

			// If the next closest approach is less than the last in the list, insert it into the list at the right spot (sorted),
			//   popping off the last one if we have too many.
			if (neo.nextClosestApproachDistance < 7479893.535 // 0.05 AU
				&& (nextClosestApproachNEOs.length === 0 || neo.nextClosestApproachTime < nextClosestApproachNEOs.at(-1).nextClosestApproachTime)
				&& neo.nextClosestApproachTime >= now) {
				const indexToInsert = pioneer__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(neo.nextClosestApproachTime, nextClosestApproachNEOs, (neo, time) => neo.nextClosestApproachTime < time);
				nextClosestApproachNEOs.splice(indexToInsert, 0, neo);
				if (nextClosestApproachNEOs.length > n) {
					nextClosestApproachNEOs.pop();
				}
			}
		}

		// Return just the Pioneer names.
		return nextClosestApproachNEOs.map(neo => neo.pioneerName);
	}

	/**
	 * Creates an NEO entity.
	 * @param {NEO} neo
	 * @param {Pioneer.Scene} scene
	 * @returns {Pioneer.Entity}
	 */
	static createEntity(neo, scene) {
		let entity = /** @type {Pioneer.Entity} */(null);

		// If Pioneer already has the entity, just use it.
		if (pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.getEntityOptions(neo.pioneerName) !== undefined) {
			entity = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.create(neo.pioneerName, scene);
		}
		else { // Pioneer doesn't have the entity, so create a custom one.
			// Create the entity options.
			/** @type {import('../../pioneer/scripts/types/entity').Options } */
			const options = {
				radius: neo.diameter / 2,
				label: neo.name,
				parents: [[Number.NEGATIVE_INFINITY, 'sun']],
				trail: {
					length: 31536000 / 2
				},
				model: {
					url: '$STATIC_ASSETS_URL/models/generic/' + asteroidUrls[Math.floor(Math.random() * 3)],
					scale: [neo.diameter / 2, neo.diameter / 2, neo.diameter / 2]
				},
				controllers: [{
					type: 'fixed',
					orientation: pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity
				}, {
					type: 'spin',
					axis: neo.spinAxis,
					periodInHours: Math.PI / neo.spinRate / 3600,
					relativeToTime: 0
				}, {
					type: 'custom',
					func: (entity) => {
						// Create Orbital elements controller
						const controller = /** @type {Pioneer.OrbitalElementsController} */(entity.addController('orbitalElements'));
						controller.addOrbitalElements(-3155716758.816, neo.orbitalElements);
						if (neo.nextClosestApproachDistance !== 0 || isNaN(neo.nextClosestApproachTime)) {
							controller.addOrbitalElements(3155716758.816, neo.orbitalElements);
						}
						else {
							controller.addOrbitalElements(neo.nextClosestApproachTime, neo.orbitalElements);
						}
						return controller;
					}
				}]
			};

			// Add the earth dynamo if it's available.
			if (neo.hasSPK) {
				options.controllers.push({
					type: 'dynamo',
					url: `ssd/${neo.pioneerName}/earth/orb/`
				});
			}

			// Create the entity.
			entity = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.createFromOptions(neo.pioneerName, options, scene);

			// If the earth dynamo was loaded, we need to wait until it is loaded,
			// then use its coverage to fix the parenting entries and orbital elements coverage, in case of impact.
			if (neo.hasSPK) {
				const dynamoController = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.DynamoController);
				dynamoController.getLoadedPromise().then(() => {
					entity.addParentingTableEntry(dynamoController.getCoverage().min, 'earth');
					entity.addParentingTableEntry(dynamoController.getCoverage().max, neo.nextClosestApproachDistance !== 0 ? 'sun' : '');
					if (neo.nextClosestApproachDistance === 0) {
						const oeController = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitalElementsController);
						oeController.removeOrbitalElements(1);
						oeController.addOrbitalElements(dynamoController.getCoverage().max, neo.orbitalElements);
					}
				});
			}
		}

		return entity;
	}
}

const asteroidUrls = [
	'asteroid_1/generic_asteroid_1.gltf',
	'asteroid_2/generic_asteroid_2.gltf',
	'asteroid_3/generic_asteroid_3.gltf'
];


/***/ }),

/***/ "./src/types.js":
/*!**********************!*\
  !*** ./src/types.js ***!
  \**********************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Types": function() { return /* reexport safe */ eyes__WEBPACK_IMPORTED_MODULE_0__.Types; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./internal */ "./src/internal.js");



eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('SelectionManager', _internal__WEBPACK_IMPORTED_MODULE_1__.SelectionManager);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('LabelManager', _internal__WEBPACK_IMPORTED_MODULE_1__.LabelManager);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('TrailManager', _internal__WEBPACK_IMPORTED_MODULE_1__.TrailManager);

eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidsSettings', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidsSettings);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidMenuTop', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidMenuTop);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidMenuBottom', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidMenuBottom);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidModals', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidModals);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidMenuTop', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidMenuTop);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidMenuBottom', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidMenuBottom);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('AsteroidPanel', _internal__WEBPACK_IMPORTED_MODULE_1__.AsteroidPanel);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('Breadcrumb', _internal__WEBPACK_IMPORTED_MODULE_1__.Breadcrumb);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('DefinitionOverlay', _internal__WEBPACK_IMPORTED_MODULE_1__.DefinitionOverlay);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('FollowingPanel', _internal__WEBPACK_IMPORTED_MODULE_1__.FollowingPanel);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('HomeButton', _internal__WEBPACK_IMPORTED_MODULE_1__.HomeButton);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('MissionPanel', _internal__WEBPACK_IMPORTED_MODULE_1__.MissionPanel);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('SplashScreen', _internal__WEBPACK_IMPORTED_MODULE_1__.SplashScreen);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('TimeSlider', _internal__WEBPACK_IMPORTED_MODULE_1__.TimeSlider);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('WatchPanel', _internal__WEBPACK_IMPORTED_MODULE_1__.WatchPanel);
eyes__WEBPACK_IMPORTED_MODULE_0__.Types.set('Search', _internal__WEBPACK_IMPORTED_MODULE_1__.Search);




/***/ }),

/***/ "./src/views/asteroid_view.js":
/*!************************************!*\
  !*** ./src/views/asteroid_view.js ***!
  \************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AsteroidView": function() { return /* binding */ AsteroidView; }
/* harmony export */ });
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_view */ "./src/views/base_view.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");



/**
 *
 */
class AsteroidView extends _base_view__WEBPACK_IMPORTED_MODULE_0__["default"] {
	/**
	 * Constructor.
	 * @param {...*} args - Arguments for BaseView
	 */
	constructor(...args) {
		super(...args);

		// Make sure we have neo data for this object.
		this._rules.spaceObject = {
			value: name => Boolean(this._app.neos.get(name)?.pioneerName)
		};

		// Hold a reference to the asteroid panel.
		this._asteroidPanel = null;

		// Specific target variables.
		this._target = null;
		this._neoData = null;
		this._heroData = null;
		this._entityInfo = null;

		this.filtersManager = null;
	}

	/** @inheritdoc */
	async onEnter(params) {
		// Add components to be excluded on UI show/hide.
		this.addUIexcludedComponents([
			'asteroid_modals',
			'definitionOverlay',
			'clock',
			'clockShortcut',
			'asteroid_menu_bottom'
		]);

		this.filtersManager = this._app.getManager('filters');

		// Assign asteroidPanel prop if it isnt yet
		this._asteroidPanel ??= this._app.getComponent('asteroidPanel');

		await super.onEnter(params);

		// We need to remove some direct style properties that are set in the pioneer engine.
		this._mainViewportEl.style.top = '';
		this._mainViewportEl.style.left = '';
	}

	/** @inheritdoc */
	onLeave(params) {
		// Restore own particle
		this._app.removeParticleMatchFunction('asteroid_view', true);

		if (params && params.cancelToken && params.cancelToken.isCanceled) {
			return;
		}

		// Make sure panel collapses and hides.
		this._asteroidPanel.hide();

		// We need to re-add some direct style properties that are set in the pioneer engine.
		this._mainViewportEl.style.top = '0px';
		this._mainViewportEl.style.left = '0px';

		super.onLeave(params);
	}

	/** @inheritdoc */
	_reset(params) {
		super._reset(params);
		this._target = null;
		this._neoData = null;
		this._heroData = null;
		this._entityInfo = null;
	}

	/** @inheritdoc */
	registerCallbacks() {
		super.registerCallbacks();
		// Register expand toggle callback
		this._asteroidPanel.registerCallback('expandtoggle', this._onExpandToggle);
	}

	/** @inheritdoc */
	removeCallbacks() {
		super.removeCallbacks();
		// Remove expand toggle callback
		this._asteroidPanel.removeCallback('expandtoggle', this._onExpandToggle);
	}

	/** @inheritdoc */
	async _updateResources({ spaceObject }) {
		const contentManager = this._app.getManager('content');

		// Update entity name and entity info
		this._target = spaceObject;
		this._neoData = this._allNEOs.get(this._target);
		this._heroData = this._allHeroes[this._neoData.pioneerName];
		this._entityInfo = contentManager.getEntityInfo(this._target);

		let targetEntity = this._app.scene.getEntity(this._target);

		// Create NEO entity if needed
		if (!targetEntity) {
			targetEntity = this._app.getManager('neos').createTempNEO(this._neoData);
		}
		// In case we're searching for an object that has been filtered out of the scene
		else if (!targetEntity._enabled) {
			const entry = this._app.getManager('search').getEntry(this._target);
			if (entry.neo) {
				this.filtersManager.setFilterToReveal(entry.neo, true);
			}
		}

		// Get the time to start as the current time clamped between the entity's
		// position coverage min and max - 3600. Also set the eventInfo start so that
		// the BaseView starts it at that time.
		const currentTime = this.app.pioneer.getTime();
		let startTime = currentTime;
		if (currentTime < targetEntity.getPositionCoverage().min) {
			startTime = targetEntity.getPositionCoverage().min;
		}
		else if (currentTime >= targetEntity.getPositionCoverage().max - 3600) {
			startTime = targetEntity.getPositionCoverage().max - 3600;
		}
		const startDateTime = new pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.DateTime();
		startDateTime.fromET(startTime);
		this.app.pioneer.setTime(currentTime);

		// Set eventInfo start only if asteroid has a close approach day in the past we want to go to
		const { nextClosestApproachTime } = this._neoData;

		if (nextClosestApproachTime != 0 && nextClosestApproachTime < currentTime) {
			this._eventInfo = { start: startDateTime.toString() + 'Z' };
		} else {
			this._eventInfo = { start: null };
		}

		// Make sure target NEO is loaded
		await targetEntity.getLoadedPromise();
		await this._app.pioneer.waitUntilNextFrame();

		// Remove own particle
		this._app.addParticleMatchFunction((neo) => neo.pioneerName !== this._target, 'asteroid_view', true);

		// Set new target for layer manager
		this._app.getManager('layer').setTarget(this._target);
		this._app.getManager('selection').selectEntity(this._target);

		contentManager.resetContext();

		// Only try to load description is there is entityInfo (ie. not for potato NEOs)
		this._entityInfo && await contentManager.loadDescriptions([this._target]);
	}

	/** @inheritdoc */
	async _updateComponents(params) {
		// Populate the panel.
		this._asteroidPanel.populate(this._neoData, this._heroData);

		super._updateComponents(params);
	}

	/** @inheritdoc */
	async _updateComponentsVisibility(params) {
		await super._updateComponentsVisibility(params);

		// Update time slider position.
		this._updateTimeSliderPosition();

		// Show and expand the panel if the UI is visible. (expandOnShow is set to true in the asteroidPanel)
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		visibleUI && this._asteroidPanel.show();

		// Hide the bottom menu if it's visible
		this._app.getComponent('asteroid_menu_bottom')?.hide();
	}

	/** @inheritdoc */
	async _updateCamera(params) {
		await this._app.cameraScripts.goToCelestialObject(this._target);
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		const isExpanded = this._asteroidPanel?._state.isExpanded;
		this._onExpandToggle(isExpanded);
	}
}


/***/ }),

/***/ "./src/views/base_view.js":
/*!********************************!*\
  !*** ./src/views/base_view.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ ExtendedBaseView; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");




/**
 * Base view for Asteroids.
 * @extends BaseView
 */
class ExtendedBaseView extends eyes__WEBPACK_IMPORTED_MODULE_0__.BaseView {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {HTMLElement} element
	 * @param {Array} [components=[]] - Components of a view
	 */
	constructor(app, element, components = []) {
		super(app, element, components);

		// Determines which components are ignore when toggling UI on/off.
		this._UIexcludedComponents = null;
		this.resetUIexcludedComponents();

		this._floatMid = null;
		this._floatMidBottom = null;

		this._pioneerParentEl = null;
		this._mainViewportEl = null;

		this._allNEOs = null;
		this._allHeroes = null;

		this._lastTime = null;

		// Set redirect rule
		this._rules.redirect = name => {
			const router = this._app.getManager('router');
			// If not valid, try getting a parsed link
			const parsedLink = this._app.getManager('link')?.getParsedLink?.(name);
			const parsedLinkIsValid = parsedLink !== `/${name}`;
			if (parsedLinkIsValid) {
				router.navigate(parsedLink);
			}
			else if (name === 'asteroids') {
				// Exception for asteroids.
				router.navigate(router.homeRoute);
			}
			else {
				// Go back and automatically simulate a search
				console.warn(`No object with name, ${name}.`);
				router.navigate(router._previousRoute?.url || '');
				this._app.getComponent('search').simulate(name);
			}
		};

		this.bindFunctions(['_onExpandToggle']);
	}

	/** @inheritdoc */
	async onEnter(params, unsubscribed = []) {
		// Set a reference to the main-viewport and pioneer parent.
		this._mainViewportEl = this._app.pioneer?.getViewport('main-viewport')?.getDiv();
		this._pioneerParentEl = document.getElementById('pioneer');

		// Assign the allNEOs and heroes vars.
		this._allNEOs ??= this._app.neos;
		this._allHeroes ??= this._app.heroes;

		await super.onEnter(params, unsubscribed);

		/**
		 * When we enter a new view where the previous UI is hidden, we may have new components enabled.
		 * Once the _resetView is called (where the components are enabbled/disabled), we need to call
		 * toggleViewUI again to correctly set the visibility of any newly enabled components.
		 * For instance:
		 * - Hide UI in home view where 'homeButton' component is disabled
		 * - Navigate to asteroid where 'homeButton' is enabled
		 * - Make sure homeButton is re-hidden to maintain the hidden UI state.
		 */
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		this.toggleViewUI(visibleUI, false);
	}

	/** @inheritdoc */
	_showControls() {
		// Restore clock and time controls
		this._app.getComponent('clock').show();
		this._app.getComponent('clockShortcut').show();
		this._app.getComponent('settings').show();

		// Set element vars if needed.
		this._floatMidBottom = this._floatMidBottom || document.getElementById('float-mid-bottom');
		this._floatMid = this._floatMid || document.getElementById('float-mid');

		this._floatMidBottom.classList.remove('hidden');
		this._floatMidBottom.classList.add('active');
		if (eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode()) {
			// Move timeline below
			this._floatMid.classList.add('low');
		}
		else {
			// Restore timeline
			this._floatMid.classList.remove('hidden');
			this._floatMid.classList.remove('low');
		}
	}

	/** @inheritdoc */
	_hideControls() {
		if (eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode()) {
			this._app.getComponent('clock').hide();
			this._app.getComponent('clockShortcut').hide();
			this._app.getComponent('settings').hide();

			// Set element vars if needed.
			this._floatMidBottom = this._floatMidBottom || document.getElementById('float-mid-bottom');
			this._floatMid = this._floatMid || document.getElementById('float-mid');

			this._floatMidBottom.classList.add('hidden');
			this._floatMidBottom.classList.remove('active');

			// Move timeline up
			this._floatMid.classList.remove('low');
		}
	}

	/** @inheritdoc */
	async onQueryChange(params) {
		super.onQueryChange(params);

		this._callQueryChanges(params);
	}

	/**
	 * Update components with router parameters.
	 * @param {object} params
	 */
	_updateComponents(params) {
		// Update breadcrumb.
		this._app.getComponent('breadcrumb')?.onRouteChange({
			...params
		});

		// Set settings orientation.
		this._app.getComponent('settings').setConfig({
			orientation: {
				smallLandscape: {
					ori: 'vertical'
				}
			}
		});

		this._callQueryChanges(params);
	}

	/**
	 * Store the lastTime
	 * @override
	 * @param {object} params
	 */
	async _updateTime(params) {
		this._lastTime = this.app.pioneer.getTime();

		await super._updateTime(params);
	}

	/**
	 * Remove loading screen after checkReady is complete.
	 * @override
	 * @param {object} params
	 */
	async _checkReady(params) {
		// If the current entity doesn't exist at the same time as the target entity, re-parent the camera to a temporary entity to keep it around until
		// the transition is complete.

		const { cameraEntity } = this.app.getManager('camera');
		const initialEntity = cameraEntity.getParent();
		const targetEntity = this.app.scene.get(this._target);

		if (initialEntity && targetEntity) {
			const time = this.app.pioneer.getTime();
			const lca = initialEntity.getLowestCommonAncestorAtTime(targetEntity, time);

			// If no lowest common ancestor, create temp entity and reparent camera to it.
			if (lca === null) {
				const tempEntityName = `${initialEntity.getName()}_temp`;
				const initialPosCopy = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3();
				initialPosCopy.copy(initialEntity.getPosition());

				const tempEntity = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.createFromOptions(
					tempEntityName,
					{
						radius: initialEntity.getExtentsRadius(),
						parents: [[Number.NEGATIVE_INFINITY, 'sun']]
					},
					this.app.scene
				);

				// Copy position and parent of initial entity.
				tempEntity.setPosition(initialPosCopy);
				const tempParentName = initialEntity.getParentAtTime(this._lastTime) ?? 'sun';
				const tempParent = this.app.scene.get(tempParentName);
				tempEntity.setParent(tempParent);

				// Set camera parent to temp entity.
				cameraEntity.setParent(tempEntity);

				// Add it to the scene manager temp entities (will be cleared in 'after')
				this.app.getManager('scene').addTempEntity(tempEntity);
			}
		}

		await super._checkReady(params);

		this.app.endLoadingScreen();
	}

	/**
	 * Determine which onQueryChanges to call depending on the current and previous query params
	 * @param {object} params
	 */
	_callQueryChanges(params) {
		// Determine which queries are, and were previously defined and call onQueryChange accordingly.
		const router = this.app.getManager('router');
		const prevQueries = router.parseQuery(router.previousRoute.query);

		const { modal, definition, tutorial, rate } = {
			...params,
			...prevQueries
		};

		// If we have a modal value, call for menu_top and modals.
		if (modal) {
			this.app.getComponent('asteroid_menu_top')?.onQueryChange(params);
			this.app.getComponent('asteroid_modals')?.onQueryChange(params);
		}

		// If we have a definition value, call for the definitionOverlay.
		definition && this.app.getComponent('definitionOverlay')?.onQueryChange(params);

		// If we have a tutorial value, call for the tutorialOverlay.
		tutorial && this.app.getComponent('tutorialOverlay')?.onQueryChange(params);

		// If we have a rate change, call for the time slider.
		rate !== undefined && this.app.getComponent('timeSlider')?.onQueryChange(params);
	}

	/** @inheritdoc */
	onLeave(params) {
		// Always Reset UI excluded components to default.
		this.resetUIexcludedComponents();
		super.onLeave(params);
	}

	/** @inheritdoc */
	_shouldResetStatus() {
		return true;
	}

	/**
	 * Appended component names to UIexcludedComponents array
	 * @param {Array<string>} componentNames
	 */
	addUIexcludedComponents(componentNames) {
		this._UIexcludedComponents.push(...componentNames);
	}

	/**
	 * Sets the default component names to exclude when toggle UI
	 */
	resetUIexcludedComponents() {
		this._UIexcludedComponents = [
			'breadcrumb',
			'settings',
			'loadIcon',
			'layerPanel'
		];
	}

	/**
	 * Override toggles UI.
	 * @param {boolean} showUI
	 * @param initSwiper
	 */
	toggleViewUI(showUI = this._app.getManager('layer').getLayer('ui').visible, initSwiper = true) {
		// Auto hide the layer panel when toggling UI
		this._app.getComponent('layerPanel').hide();
		// Go through all components in the view and show/hide them if not in the _UIexcludedComponents array.
		this._components.forEach(componentName => {
			// Return if we need to ignore the component.
			if (this._UIexcludedComponents.includes(componentName)) {
				return;
			}
			if (this.app.getManager('router')._alwaysHiddenComponents?.includes(componentName)) {
				return;
			}

			const component = this._app.getComponent(componentName);
			const isStory = componentName === 'story';

			// Before, we were disabling the component (remove it from the DOM). Now we're just hiding it.
			if (showUI) {
				component.setEnabled(true);
				component.show(initSwiper);
				isStory && component.resize();
			}
			else {
				component.hide();
			}
		});

		// This isn't great and should better match how the other components work when showing / hiding.
		const extendedControlsDiv = document.getElementById('extended-controls');
		if (extendedControlsDiv) extendedControlsDiv.style.display = showUI ? 'grid' : 'none';
	}

	/**
	 * Uses threshold and non-portrait to determine whether we should right offset
	 * (currently used to determine if time slider and main viewport offset)
	 * @returns {boolean}
	 */
	get shouldOffsetRight() {
		return !eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobilePortrait();
	}

	/**
	 * What determines if we should offset the viewport up.
	 * @returns {boolean}
	 */
	get shouldOffsetUp() {
		return eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobilePortrait();
	}

	/**
	 * Handle the expand toggle
	 * @param {boolean} expanded
	 * @param {boolean} updateTimeSlider
	 */
	_onExpandToggle(expanded, updateTimeSlider = true) {
		// Conditionally update time slider position.
		updateTimeSlider && this._updateTimeSliderPosition({ expanded });

		const loadIconEl = this._app.getComponent('loadIcon')?.element;

		// Determine if we should offset the viewport to the right or up.
		const offsetRight = this.shouldOffsetRight && expanded;
		this._pioneerParentEl?.classList.toggle('offset-right', offsetRight);
		this._mainViewportEl?.classList.toggle('offset-right', offsetRight);
		loadIconEl?.classList.toggle('offset-right', offsetRight);

		const offsetUp = this.shouldOffsetUp && expanded;
		this._pioneerParentEl?.classList.toggle('offset-up', offsetUp);
		this._mainViewportEl?.classList.toggle('offset-up', offsetUp);
		loadIconEl?.classList.toggle('offset-up', offsetUp);

		// Show the settings only if the panel is offset vertically.
		const settings = this._app.getComponent('settings');
		if (offsetUp) {
			settings?.hide();
		}
		else {
			settings?.show();
		}
	}

	/**
	 * Updates the time slider position.
	 * @param {object} options
	 */
	_updateTimeSliderPosition(options = {}) {
		this._app.getComponent('timeSlider')?.toggleExtraClasses(options);
	}
}


/***/ }),

/***/ "./src/views/following_view.js":
/*!*************************************!*\
  !*** ./src/views/following_view.js ***!
  \*************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FollowingView": function() { return /* binding */ FollowingView; }
/* harmony export */ });
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_view */ "./src/views/base_view.js");


/**
 *
 */
class FollowingView extends _base_view__WEBPACK_IMPORTED_MODULE_0__["default"] {
	/**
	 * Constructor.
	 * @param {...*} args - Arguments for BaseView
	 */
	constructor(...args) {
		super(...args);

		this._rules = {
			...this._rules,
			planet: {
				value: name => this._app.getManager('content')?.getEntityInfo(name)?.category === 'Planet'
			},
			moon: {
				value: name => this._app.getManager('content')?.getEntityInfo(name)?.id === 'moon'
			},
			sun: {
				value: name => this._app.getManager('content')?.getEntityInfo(name)?.id === 'sun'
			}

		};

		// Hold a reference to the following panel.
		this._followingPanel = null;

		this._entityInfo = null;
	}

	/** @inheritdoc */
	async onEnter(params) {
		// Add components to be excluded on UI show/hide.
		this.addUIexcludedComponents([
			'asteroid_modals',
			'definitionOverlay',
			'clock',
			'clockShortcut',
			'asteroid_menu_bottom'
		]);

		// Assign followingPanel prop if it isnt yet
		this._followingPanel ??= this._app.getComponent('followingPanel');

		await super.onEnter(params);
	}

	/** @inheritdoc */
	onLeave(params) {
		// Make sure panel hides.
		this._followingPanel.hide();

		super.onLeave(params);
	}

	/** @inheritdoc */
	_reset(params) {
		super._reset(params);
		const { planet, star, moon } = params;
		this._target = planet || star || moon;
	}

	/** @inheritdoc */
	async _updateResources(params) {
		// Set new target for layer manager
		this._app.getManager('layer').setTarget(this._target);
		this._app.getManager('selection').selectEntity(this._target);
	}

	/** @inheritdoc */
	async _updateComponents(params) {
		// Use content manager to get title and set panel title state.
		const info = this._app.getManager('content')?.getEntityInfo(this._target);
		this._followingPanel.setState({
			title: info.iauName || info.displayName
		});

		super._updateComponents(params);
	}

	/** @inheritdoc */
	async _updateComponentsVisibility(params) {
		await super._updateComponentsVisibility(params);

		// Update time slider position.
		this._updateTimeSliderPosition();

		// Show the panel if the UI is visible.
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		visibleUI && this._followingPanel.show();

		// Hide the bottom menu if it's visible
		this._app.getComponent('asteroid_menu_bottom')?.hide();
	}

	/** @inheritdoc */
	async _updateCamera() {
		await this._app.cameraScripts.goToCelestialObject(this._target);
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		this._onExpandToggle(false);
	}
}


/***/ }),

/***/ "./src/views/home_view.js":
/*!********************************!*\
  !*** ./src/views/home_view.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HomeView": function() { return /* binding */ HomeView; }
/* harmony export */ });
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_view */ "./src/views/base_view.js");


/**
 * @extends BaseView
 */
class HomeView extends _base_view__WEBPACK_IMPORTED_MODULE_0__["default"] {
	/** @inheritdoc */
	async onEnter(params) {
		// Add components to be excluded on UI show/hide.
		this.addUIexcludedComponents([
			'splashScreen',
			'asteroid_modals',
			'definitionOverlay',
			'clock',
			'clockShortcut',
			'tutorialOverlay'
		]);

		// Apply time slider classes as needed.
		this._updateTimeSliderPosition();

		// Make sure bottom menu is visible if needed.
		this._app.getComponent('asteroid_menu_bottom')?.show();

		const unsubscribed = [];
		if (this._app.getComponent('splashScreen')?.element === null) {
			unsubscribed.push('splashScreen');
		};
		await super.onEnter(params, unsubscribed);
	}

	/** @inheritdoc */
	_updateResources(params) {
		this._app.getManager('time').resetLimits();
		this._app.getManager('layer').setTarget('');

		this._target = 'sun';
	}

	/** @inheritdoc */
	async _updateCamera(params) {
		await this.app.cameraScripts.goToSystem('inner_solar_system');
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		this._updateTimeSliderPosition();
	}
}


/***/ }),

/***/ "./src/views/index.js":
/*!****************************!*\
  !*** ./src/views/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _asteroid_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asteroid_view */ "./src/views/asteroid_view.js");
/* harmony import */ var _mission_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./mission_view */ "./src/views/mission_view.js");
/* harmony import */ var _following_view__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./following_view */ "./src/views/following_view.js");
/* harmony import */ var _watch_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./watch_view */ "./src/views/watch_view.js");
/* harmony import */ var _home_view__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./home_view */ "./src/views/home_view.js");
/* harmony import */ var _story_view__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./story_view */ "./src/views/story_view.js");







/* harmony default export */ __webpack_exports__["default"] = ({
	AsteroidView: _asteroid_view__WEBPACK_IMPORTED_MODULE_0__.AsteroidView,
	MissionView: _mission_view__WEBPACK_IMPORTED_MODULE_1__.MissionView,
	FollowingView: _following_view__WEBPACK_IMPORTED_MODULE_2__.FollowingView,
	WatchView: _watch_view__WEBPACK_IMPORTED_MODULE_3__.WatchView,
	HomeView: _home_view__WEBPACK_IMPORTED_MODULE_4__.HomeView,
	StoryView: _story_view__WEBPACK_IMPORTED_MODULE_5__.StoryView
});


/***/ }),

/***/ "./src/views/mission_view.js":
/*!***********************************!*\
  !*** ./src/views/mission_view.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MissionView": function() { return /* binding */ MissionView; }
/* harmony export */ });
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_view */ "./src/views/base_view.js");



/**
 *
 */
class MissionView extends _base_view__WEBPACK_IMPORTED_MODULE_0__["default"] {
	/**
	 * Constructor.
	 * @param {...*} args - Arguments for BaseView
	 */
	constructor(...args) {
		super(...args);

		this._rules.spacecraft = {
			value: name => this._app.getManager('content')?.getEntityInfo(name)?.category === 'Spacecraft'
		};

		// Hold a reference to the mission panel.
		this._missionPanel = null;

		this._entityInfo = null;

		this.filtersManager = null;
	}

	/** @inheritdoc */
	async onEnter(params) {
		// Add components to be excluded on UI show/hide.
		this.addUIexcludedComponents([
			'asteroid_modals',
			'definitionOverlay',
			'clock',
			'clockShortcut',
			'asteroid_menu_bottom'
		]);

		this.filtersManager = this._app.getManager('filters');

		// Assign asteroidPanel prop if it isnt yet
		this._missionPanel ??= this._app.getComponent('missionPanel');

		await super.onEnter(params);

		// We need to remove some direct style properties that are set in the pioneer engine.
		this._mainViewportEl.style.top = '';
		this._mainViewportEl.style.left = '';
	}

	/** @inheritdoc */
	onLeave(params) {
		if (params && params.cancelToken && params.cancelToken.isCanceled) {
			return;
		}

		// Make sure panel collapses and hides.
		this._missionPanel.hide();

		// We need to re-add some direct style properties that are set in the pioneer engine.
		this._mainViewportEl.style.top = '0px';
		this._mainViewportEl.style.left = '0px';

		super.onLeave(params);
	}

	/** @inheritdoc */
	registerCallbacks() {
		super.registerCallbacks();
		// Register expand toggle callback
		this._missionPanel.registerCallback('expandtoggle', this._onExpandToggle);
	}

	/** @inheritdoc */
	removeCallbacks() {
		super.removeCallbacks();
		// Remove expand toggle callback
		this._missionPanel.removeCallback('expandtoggle', this._onExpandToggle);
	}

	/** @inheritdoc */
	_reset(params) {
		super._reset(params);
		this._target = null;
		this._entityInfo = null;
	}

	/** @inheritdoc */
	async _updateResources({ spacecraft }) {
		const contentManager = this._app.getManager('content');

		// Update entity name and entity info
		this._target = spacecraft;
		this._entityInfo = contentManager.getEntityInfo(this._target);

		// Load events and descriptions.
		await this._app.getManager('content').loadDescriptions([this._target]);
		await this._app.getManager('content').loadEvents(this._target, {
			all: 'all_events'
		});

		// Set new target for layer manager
		this._app.getManager('layer').setTarget(this._target);
		this._app.getManager('selection').selectEntity(this._target);

		if (this._entityInfo === null) {
			this._handleError(`MissionView._updateResources: Cannot find entity named ${this._target}.`);
			return;
		}

		// Remove layer filters if the current mission depends on the layer
		if (this._entityInfo?.related) {
			// filter and reduce here take the 'related' entity object
			// and turns it into a boolean-keyed object
			// { asteroid: ['bennu'], comets: [] } -> { asteroids: true }
			this.filtersManager.setFilterToReveal(
				Object.keys(this._entityInfo.related)
					.filter((r) => this._entityInfo.related[r].length > 0)
					.reduce((acc, cur) => {
						acc[cur] = true; return acc;
					}, {}), true);
		}
	}

	/** @inheritdoc */
	async _updateComponents(params) {
		const contentManager = this._app.getManager('content');

		// Get blurb.
		const blurb = contentManager.context[this._target]?.description?.blurb;

		// Get events.
		const events = contentManager.context?.events;

		// Determine title.
		const { iauName, displayName } = this._entityInfo;
		const title = iauName || displayName;

		// Populate the panel.
		this._missionPanel.populate(title, blurb, this._target, events);

		super._updateComponents(params);
	}

	/** @inheritdoc */
	async _updateComponentsVisibility(params) {
		await super._updateComponentsVisibility(params);

		// Update time slider position.
		this._updateTimeSliderPosition();

		// Show and expand the panel if the UI is visible. (expandOnShow is set to true in the missionPanel)
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		visibleUI && this._missionPanel.show();

		// Hide the bottom menu if it's visible
		this._app.getComponent('asteroid_menu_bottom')?.hide();
	}

	/** @inheritdoc */
	async _updateCamera(params) {
		const hasLanded = this._app.getManager('content').hasLanded(this._entityInfo);
		if (hasLanded) {
			await this._app.cameraScripts.alignSpacecraftPlanet(this._target);
		}
		else {
			await this._app.cameraScripts.goToSpacecraft(this._target);
		}
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		const isExpanded = this._missionPanel?._state.isExpanded;
		this._onExpandToggle(isExpanded);
	}
}


/***/ }),

/***/ "./src/views/story_view.js":
/*!*********************************!*\
  !*** ./src/views/story_view.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StoryView": function() { return /* binding */ StoryView; }
/* harmony export */ });
/* harmony import */ var eyes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eyes */ "../eyes/src/index.js");
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base_view */ "./src/views/base_view.js");



/**
 *
 */
class StoryView extends _base_view__WEBPACK_IMPORTED_MODULE_1__["default"] {
	/**
	 * Constructor.
	 * @param {...*} args - Arguments for BaseView
	 */
	constructor(...args) {
		super(...args);

		/**
		 * Copy of story context.
		 * @type {object}
		 */
		this._story = null;

		this._rules.id = {
			value: val => val in this._app.getManager('content').getStoryList().stories
		};

		/**
		 * Callbacks to call in onLeave.
		 * Usually to reset values to before entering this view.
		 * @type {Array}
		 */
		this._onLeaveCallbacks = [];
	}

	/** @inheritdoc */
	async onQueryChange(params) {
		// Update definition if exists (needs to be called first)
		this._app.getComponent('definitionOverlay')?.onQueryChange(params);

		await super.onQueryChange(params);

		// Update story
		await this._updateTime(params);
		await this._app.getComponent('story').onQueryChange(params);
		await this._updateCamera(params);
	}

	/** @inheritdoc */
	async onEnter(params, unsubscribed = []) {
		// Add components to be excluded on UI show/hide.
		this.addUIexcludedComponents([
			'asteroid_modals',
			'overlay',
			'definitionOverlay',
			'clock',
			'clockShortcut',
			'asteroid_menu_bottom'
		]);

		// Turn off visibility by default.
		const storyComponent = this._app.getComponent('story');
		storyComponent.hide();

		await super.onEnter(params, unsubscribed);

		// Show and expand the panel if the UI is visible. (expandOnShow is set to true in the missionPanel)
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		visibleUI && storyComponent.show();

		// Make sure spacecraft and planet layers are on.
		const layerManager = this._app.getManager('layer');
		const layerPanel = this._app.getComponent('layerPanel');
		if (!layerManager.getLayer('spacecraft').visible) {
			layerPanel.toggleLayer('spacecraft');
		}
		if (!layerManager.getLayer('planets').visible) {
			layerPanel.toggleLayer('planets');
		}

		// Make sure spacecraft is disabled
		layerPanel.setCategoryEnabled('spacecraft', false);

		// Turn off any filters.
		this._app.getManager('filters')?.setFilter({ phos: false, asteroids: false, comets: false });

		// Temporarily disable
		const clock = this._app.getComponent('clock');
		clock.setState({ allowEdit: false });
		clock.toggle('time', false);
		clock.toggle('meridiem', false);
		this._app.getManager('label').setClickable(false);
		this._app.getManager('selection').setClickable(false);

		// Hide time slider
		this._app.getComponent('timeSlider')?.setSliderVisibility(false);
	}

	/** @inheritdoc */
	async onLeave(params) {
		super.onLeave(params);
		await this._story?.onLeave?.(this._app);
		await this._app.getComponent('story').onLeave();

		// Reset
		const clock = this._app.getComponent('clock');
		clock.setState({ allowEdit: true });
		clock.toggle('time', true);
		clock.toggle('meridiem', true);
		this._app.getManager('label').setClickable(true);
		this._app.getManager('selection').setClickable(true);

		// Show time slider
		this._app.getComponent('timeSlider')?.setSliderVisibility(true);

		// Make sure spacecraft is enabled
		this._app.getComponent('layerPanel')?.setCategoryEnabled('spacecraft', true);

		// Call onLeave callbacks and reset them.
		for (let i = 0; i < this._onLeaveCallbacks.length; i++) {
			this._onLeaveCallbacks[i](params);
		}
		this._onLeaveCallbacks = [];

		this._story = null;
	}

	/** @inheritdoc */
	async _updateResources(params) {
		// Set new target for layer manager
		this._app.getManager('layer').setTarget('');

		if (this._story) {
			this._story.onLeave?.(this._app);
			this._app.getComponent('story')?.onLeave();
		}

		// Load story
		try {
			const story = await this._app.getManager('content').getStory(params.id);
			// Copy the context in case it is lost during a route change
			this._story = eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.deepClone(story);
			this._story?.onEnter?.(this._app);
		}
		catch (err) {
			this._handleError(`StoryView._updateResources: Cannot find story ${params.id}.`);
		}
	}

	/** @inheritdoc */
	async _updateTime(params) {
		super._updateTime(params);

		const timeManager = this._app.getManager('time');
		const slideInfo = params.slide
			? this._story.slides.find(slide => slide.id === params.slide)
			: this._story.slides[0];

		// Set time limits if slideInfo has it
		const { min, max } = slideInfo?.timeLimits || {};
		min && timeManager.setMin(min);
		max && timeManager.setMin(max);

		// Update time if slideInfo has it
		if (!params.time && slideInfo.time) {
			timeManager.setTime(slideInfo.time);

			// Wait for next frame to get updated position
			// after time has changed
			await this._app.pioneer.waitUntilNextFrame();
		}
	}

	/** @inheritdoc */
	_shouldHideControls() {
		return eyes__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode() && this._app.getComponent('story').getState('isVisible');
	}

	/** @inheritdoc */
	async _updateComponents(params) {
		super._updateComponents(params);
		// Get the config before entering view for reset
		const settings = this._app.getComponent('settings');
		const { allowInfoPanel } = settings.getConfig();
		this._onLeaveCallbacks.push(() => {
			settings.setConfig({
				allowInfoPanel
			});
		});
		// Set the config for this view
		settings.setConfig({
			allowInfoPanel: false
		});

		// Update story
		const storyComponent = this._app.getComponent('story');
		await storyComponent.onRouteChange(this._story.slides, params);
		storyComponent.show();
	}

	/** @inheritdoc */
	async _updateCamera(params) {
		const slideInfo = params.slide
			? this._story.slides.find(slide => slide.id === params.slide)
			: this._story.slides[0];

		if (slideInfo && slideInfo.camera) {
			// Only update camera if slide changes
			const story = this._app.getComponent('story');
			if (story.getState('previousIndex') !== story.getState('currentIndex')) {
				const preset = slideInfo.camera[0];
				await preset(this._app);
			}
		}
		else {
			await this._app.cameraScripts.goToSystem('outer_solar_system');
		}
	}
}


/***/ }),

/***/ "./src/views/watch_view.js":
/*!*********************************!*\
  !*** ./src/views/watch_view.js ***!
  \*********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WatchView": function() { return /* binding */ WatchView; }
/* harmony export */ });
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base_view */ "./src/views/base_view.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");




/**
 *
 */
class WatchView extends _base_view__WEBPACK_IMPORTED_MODULE_0__["default"] {
	/**
	 * Constructor.
	 * @param {...*} args - Arguments for BaseView
	 */
	constructor(...args) {
		super(...args);

		// Make sure we have neo data for this object.
		this._rules.neoName = {
			value: name => Boolean(this._app.neos.get(name)?.pioneerName)
		};

		this._watchManager = null;
		this._watchPanel = null;

		this.filtersManager = null;
	}

	/** @inheritdoc */
	async onRouteChange(params) {
		const missingNeoName = params.neoName === undefined;
		const cameFromOutside = this._app.getManager('router').previousView !== 'watch' && missingNeoName;

		let slideIndex = this._watchManager.determineSlideIndex(params.neoName);

		const alreadyPassed = slideIndex === -1;
		const notInDatabase = params.neoName && !this._app.scene.get(params.neoName);

		/**
		 * Three scenarios where we need to open the watch panel to the first slide (ie. redirect):
		 * 1) If we came from outside the watch view and there's no neoName
		 * 2) If the given neoName has already passed the earth
		 * 3) If the given neoName doesnt exist (not in database)
		 */
		if (cameFromOutside || alreadyPassed || notInDatabase) {
			// Warning message.
			if (notInDatabase) {
				console.warn(`Asteroid, ${params.neoName} is not in the database. Re-directing to Next Closest Approach.`);
			}
			else if (alreadyPassed) {
				// Todo: We need a popup that says "Phew! It missed!"" with "Show me <asteroid-name> anyway" or "See next approaching asteroids"
				console.warn(`Asteroid, ${params.neoName} has safely passed earth. Re-directing to Next Closest Approach.`);
			}
			slideIndex = 0;

			// Re-direct to first slide.
			this._watchManager.setHasRedirected(true);
			this._watchManager.setSlideUrlByIndex(slideIndex);

			return;
		}

		const { neoName } = params;

		// Set the panels expand state.
		this._watchPanel.shouldBeExpanded = Boolean(neoName);

		// Store the slide index in the watchManager
		this._watchManager.setSlideIndex(slideIndex);

		// Make sure the swiper slide is correctly synced to the URL.
		// Be careful not to make an infinite loop here between slideTo and the on slideChange event handler in the watch carousel component
		const swiper = this._watchPanel._swiper;

		if (neoName && swiper) {
			const { realIndex } = swiper;
			if (slideIndex !== null && slideIndex !== realIndex) {
				// This last false arg should mean that the slideChange callback is not triggered. However this doesnt seem to work...
				swiper.slideTo(slideIndex, undefined, false);
			}
		}

		// Once entities are loaded, set the target and
		await this._entitiesLoadedPromise;

		// Trigger the asteroid selection update.
		this._watchManager.setAsteroidSelection();

		await super.onRouteChange(params);
	}

	/** @inheritdoc */
	async onEnter(params) {
		this.filtersManager = this._app.getManager('filters');

		// Set time to now.
		// this._app.getManager('time')?.setToNow();

		// Activate top menu item activeness.
		this._app.getComponent('asteroid_menu_top')?.toggleActive('Asteroid Watch', true);

		// Set data in the WatchManager
		this._watchManager = this._app.getManager('watch');

		// Set of the data.
		this._watchManager.setData();
		const { nextFiveData } = this._watchManager;

		// Create the entities but don't await it as this can block for half a second and it's not essential for other tasks.
		this._entitiesLoadedPromise = this._watchManager._createEntities();

		// assign watchPanel prop if it isnt yet
		if (!this._watchPanel) {
			this._watchPanel = this._app.getComponent('watchPanel');
		}
		// Compose the swiper carousel if it doesnt exist
		if (!this._watchPanel._swiper) {
			this._watchPanel.populate(nextFiveData);
			this._watchPanel.initSwiper();
		}

		// Apply time limits earth coverage.
		this._watchManager.restrictEarthCoverage();

		// Apply classes to dim all background labels.
		this._watchManager.dimBackgroundLabels(true);

		// Trails needs their default width set to ensure they remain hidden when unhovering.
		this._watchManager.setBgTrailWidthDefault(0);

		// Make sure earth and moon label is not clickable.
		this._app.getManager('selection').setClickable(false);

		const labelManager = this._app.getManager('label');
		labelManager.setLabelClickable('earth', false);

		// Remove all filters so that we see everything again
		this.filtersManager.setFilter({ asteroids: false, comets: false, phos: false });
		this.app.getComponent('filtersModal').handleResetFilters();

		// Add components to be excluded on UI show/hide.
		this.addUIexcludedComponents([
			'asteroid_modals',
			'definitionOverlay',
			'clock',
			'clockShortcut',
			'asteroid_menu_bottom',
			'tutorialOverlay'
		]);

		await super.onEnter(params);

		// We need to remove some direct style properties that are set in the pioneer engine.
		this._mainViewportEl.style.top = '';
		this._mainViewportEl.style.left = '';
	}

	/** @inheritdoc */
	async onLeave(params) {
		// Hide and collapse panel (before removing callbacks)
		this._watchPanel.hide();

		// Temp entities can be deleting using the after function in extended base view.
		// This prevent it making the camera more jerky.
		await super.onLeave(params);

		// Restore earth dynamo coverage.
		this._watchManager.restoreEarthCoverage();

		// Restore background labels.
		this._watchManager.dimBackgroundLabels(false);

		// Restore trails default width.
		this._watchManager.setBgTrailWidthDefault();

		// Restore particles to their default opacity.
		const particleShader = this._getParticleShader();
		if (particleShader) {
			particleShader.uniforms.masterOpacity.value = 0.5;
		}

		// Deactivate top menu item activeness.
		this._app.getComponent('asteroid_menu_top')?.toggleActive('Asteroid Watch', false);

		// Clear watch manager references.
		this._watchManager.removeReferences();

		// We need to re-add some direct style properties that are set in the pioneer engine.
		this._mainViewportEl.style.top = '0px';
		this._mainViewportEl.style.left = '0px';

		// Make sure earth and moon labels clickable again
		this._app.getManager('selection').setClickable(true);

		const labelManager = this._app.getManager('label');
		labelManager.setLabelClickable('earth', true);
	}

	/** @inheritdoc */
	_reset() {
		this._target = 'earth';
	}

	/** @inheritdoc */
	registerCallbacks() {
		super.registerCallbacks();
		// Register expand toggle callback
		this._watchPanel.registerCallback('expandtoggle', this._onExpandToggle);
	}

	/** @inheritdoc */
	removeCallbacks() {
		super.removeCallbacks();
		// Remove expand toggle callback
		this._watchPanel.removeCallback('expandtoggle', this._onExpandToggle);
	}

	/**
	 * Get the furthest asteroid from the target entity and multiply by
	 * @param {string} targetId
	 * @param {object} options
	 * @param {Array<object>} options.asteroidData
	 * @param {number} options.duration
	 * @param {number} options.distanceCoeff
	 * @param {number} options.maxCamDistance
	 * @param {Function} options.onTransition
	 * @param options.forceAnimation
	 */
	async goToWatchAsteroids(targetId, { asteroidData = [], duration = 2, distanceCoeff = 4, maxCamDistance = 50000000, onTransition = undefined, forceAnimation = false }) {
		const scene = /** @type {SceneManager} */(this.app.getManager('scene')).main;
		const cameraManager = /** @type {CameraManager} */(this.app.getManager('camera'));
		const cameraEntity = cameraManager.cameraEntity;

		const targetEntity = scene.getEntity(targetId);
		const cinematic = true;
		const halfDuration = duration * 0.5;

		// Get current cam distance
		const currCamPosition = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
		cameraEntity?.getPositionRelativeToEntity(currCamPosition, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, targetEntity);
		const currCamDistance = currCamPosition.magnitude();

		// Find the asteroid that's CURRENTLY furthest from the target.
		const asteroidPos = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
		const currDistances = asteroidData.map(({ pioneerName }) => {
			const entity = scene.getEntity(pioneerName);
			targetEntity.getPositionRelativeToEntity(asteroidPos, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, entity);
			return asteroidPos.magnitude();
		});
		// Calculate furthest distance
		const furthestDistance = Math.max(...currDistances);
		// Clamp to max cam distance
		const distance = Math.min(furthestDistance * distanceCoeff, maxCamDistance);

		// Only trigger camera if it's too far or too near, or we came from outside the asteroid watch view
		const tooFarAway = isNaN(currCamDistance) || currCamDistance > maxCamDistance;
		const tooNear = currCamDistance < furthestDistance;

		const animateCamera = tooFarAway || tooNear || forceAnimation;

		if (animateCamera) {
			// Get target up.
			const targetUp = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
			targetEntity.getOrientation().getAxis(targetUp, 2);

			// The target up can be the destination so we get a 'birdseye view'
			targetUp.mult(targetUp, distance);

			this._onCameraTransition = onTransition;

			// Zoom to the distance
			await cameraManager.goToEntity(targetId, { distance, cinematic, destinationUp: targetUp, duration: halfDuration, transitionFunction: this.app.cameraScripts._easeInOutExpoTransition });

			// set cam transition func back to null
			this._onCameraTransition = null;
		}
	}

	/** @inheritdoc */
	async _updateCamera({ cancelToken }) {
		if (cancelToken.isCanceled) {
			return;
		}

		const { nextFiveData, backgroundPlanets, defaultPlanetTrailWidth, hasRedirected } = this._watchManager;
		const trailManager = this._app.getManager('trail');

		// During the camera transition, we can pass in a function that takes the progress as an argument.
		// This allows us to more smoothly transition other components (master particle opacity and trail widths for planets)
		const defaultParticleOpacity = 0.5; // this value must align with the master opacity uniform in asteroids.js TODO: add it to a separate constants file.
		const targetParticleOpacity = 0.2;
		const watchView = this;

		// onTransition function is only applied when we've vome from the outside (ie. from another view)
		const onTransition = t => {
			// Interpolate opacity and trail width.
			const particleOpacity = targetParticleOpacity + (1 - t) * (defaultParticleOpacity - targetParticleOpacity);
			const trailWidth = defaultPlanetTrailWidth * (1 - t);

			// Set opacity and trail width.
			watchView._setParticleOpacity(particleOpacity);
			trailManager.setMultipleWidths(backgroundPlanets, trailWidth, trailWidth);
		};

		const cameFromOutside = hasRedirected || this._app.getManager('router').previousView !== 'watch';

		// View all the asteroids
		await this.goToWatchAsteroids(this._target, {
			asteroidData: nextFiveData,
			...cameFromOutside && { onTransition, forceAnimation: true }
		});

		// It's possible that we've changed route during the camera transition (cancelled token), in which case we need to reset the particle opacity and trail width.

		if (cancelToken.isCanceled) {
			this._setParticleOpacity(defaultParticleOpacity);
			this._watchManager.setBgTrailWidthDefault();
		}
		else {
			// It's possible we havent used an onTransition function, in which case we need to set the final opacity and trail width values.
			this._setParticleOpacity(targetParticleOpacity);
			trailManager.setMultipleWidths(backgroundPlanets, 0, 0);
		}
	}

	/**
	 * Gets the threejs particle shader
	 * @returns {object}
	 */
	_getParticleShader() {
		return this._app._pioneer.get('main', 'sun', 'orbitalParticles')?.getThreeJsMaterials()?.[0];
	}

	/**
	 * Sets particle master opacity
	 * @param {number} opacity
	 */
	_setParticleOpacity(opacity) {
		const particleShader = this._getParticleShader();
		if (particleShader) {
			particleShader.uniforms.masterOpacity.value = opacity;
		}
	}

	/** @inheritdoc */
	after(params) {
		// Reset old target for layer manager
		this._app.getManager('layer').resetTarget();

		// Reset hasRedirected
		if (this._watchManager.hasRedirected) {
			this._watchManager.setHasRedirected(false);
		}
	}

	/** @inheritdoc */
	async _updateComponentsVisibility(params) {
		await super._updateComponentsVisibility(params);

		// Show the panel if the UI is visible.
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		visibleUI && this._watchPanel.show();

		// Hide the bottom menu if it's visible
		this._app.getComponent('asteroid_menu_bottom')?.hide();
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		const isExpanded = this._watchPanel?._state.isExpanded;
		this._onExpandToggle(isExpanded);
	}
}


/***/ }),

/***/ "../eyes/node_modules/moment/locale sync recursive ^\\.\\/.*$":
/*!*********************************************************!*\
  !*** ../eyes/node_modules/moment/locale/ sync ^\.\/.*$ ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var map = {
	"./af": "../eyes/node_modules/moment/locale/af.js",
	"./af.js": "../eyes/node_modules/moment/locale/af.js",
	"./ar": "../eyes/node_modules/moment/locale/ar.js",
	"./ar-dz": "../eyes/node_modules/moment/locale/ar-dz.js",
	"./ar-dz.js": "../eyes/node_modules/moment/locale/ar-dz.js",
	"./ar-kw": "../eyes/node_modules/moment/locale/ar-kw.js",
	"./ar-kw.js": "../eyes/node_modules/moment/locale/ar-kw.js",
	"./ar-ly": "../eyes/node_modules/moment/locale/ar-ly.js",
	"./ar-ly.js": "../eyes/node_modules/moment/locale/ar-ly.js",
	"./ar-ma": "../eyes/node_modules/moment/locale/ar-ma.js",
	"./ar-ma.js": "../eyes/node_modules/moment/locale/ar-ma.js",
	"./ar-sa": "../eyes/node_modules/moment/locale/ar-sa.js",
	"./ar-sa.js": "../eyes/node_modules/moment/locale/ar-sa.js",
	"./ar-tn": "../eyes/node_modules/moment/locale/ar-tn.js",
	"./ar-tn.js": "../eyes/node_modules/moment/locale/ar-tn.js",
	"./ar.js": "../eyes/node_modules/moment/locale/ar.js",
	"./az": "../eyes/node_modules/moment/locale/az.js",
	"./az.js": "../eyes/node_modules/moment/locale/az.js",
	"./be": "../eyes/node_modules/moment/locale/be.js",
	"./be.js": "../eyes/node_modules/moment/locale/be.js",
	"./bg": "../eyes/node_modules/moment/locale/bg.js",
	"./bg.js": "../eyes/node_modules/moment/locale/bg.js",
	"./bm": "../eyes/node_modules/moment/locale/bm.js",
	"./bm.js": "../eyes/node_modules/moment/locale/bm.js",
	"./bn": "../eyes/node_modules/moment/locale/bn.js",
	"./bn-bd": "../eyes/node_modules/moment/locale/bn-bd.js",
	"./bn-bd.js": "../eyes/node_modules/moment/locale/bn-bd.js",
	"./bn.js": "../eyes/node_modules/moment/locale/bn.js",
	"./bo": "../eyes/node_modules/moment/locale/bo.js",
	"./bo.js": "../eyes/node_modules/moment/locale/bo.js",
	"./br": "../eyes/node_modules/moment/locale/br.js",
	"./br.js": "../eyes/node_modules/moment/locale/br.js",
	"./bs": "../eyes/node_modules/moment/locale/bs.js",
	"./bs.js": "../eyes/node_modules/moment/locale/bs.js",
	"./ca": "../eyes/node_modules/moment/locale/ca.js",
	"./ca.js": "../eyes/node_modules/moment/locale/ca.js",
	"./cs": "../eyes/node_modules/moment/locale/cs.js",
	"./cs.js": "../eyes/node_modules/moment/locale/cs.js",
	"./cv": "../eyes/node_modules/moment/locale/cv.js",
	"./cv.js": "../eyes/node_modules/moment/locale/cv.js",
	"./cy": "../eyes/node_modules/moment/locale/cy.js",
	"./cy.js": "../eyes/node_modules/moment/locale/cy.js",
	"./da": "../eyes/node_modules/moment/locale/da.js",
	"./da.js": "../eyes/node_modules/moment/locale/da.js",
	"./de": "../eyes/node_modules/moment/locale/de.js",
	"./de-at": "../eyes/node_modules/moment/locale/de-at.js",
	"./de-at.js": "../eyes/node_modules/moment/locale/de-at.js",
	"./de-ch": "../eyes/node_modules/moment/locale/de-ch.js",
	"./de-ch.js": "../eyes/node_modules/moment/locale/de-ch.js",
	"./de.js": "../eyes/node_modules/moment/locale/de.js",
	"./dv": "../eyes/node_modules/moment/locale/dv.js",
	"./dv.js": "../eyes/node_modules/moment/locale/dv.js",
	"./el": "../eyes/node_modules/moment/locale/el.js",
	"./el.js": "../eyes/node_modules/moment/locale/el.js",
	"./en-au": "../eyes/node_modules/moment/locale/en-au.js",
	"./en-au.js": "../eyes/node_modules/moment/locale/en-au.js",
	"./en-ca": "../eyes/node_modules/moment/locale/en-ca.js",
	"./en-ca.js": "../eyes/node_modules/moment/locale/en-ca.js",
	"./en-gb": "../eyes/node_modules/moment/locale/en-gb.js",
	"./en-gb.js": "../eyes/node_modules/moment/locale/en-gb.js",
	"./en-ie": "../eyes/node_modules/moment/locale/en-ie.js",
	"./en-ie.js": "../eyes/node_modules/moment/locale/en-ie.js",
	"./en-il": "../eyes/node_modules/moment/locale/en-il.js",
	"./en-il.js": "../eyes/node_modules/moment/locale/en-il.js",
	"./en-in": "../eyes/node_modules/moment/locale/en-in.js",
	"./en-in.js": "../eyes/node_modules/moment/locale/en-in.js",
	"./en-nz": "../eyes/node_modules/moment/locale/en-nz.js",
	"./en-nz.js": "../eyes/node_modules/moment/locale/en-nz.js",
	"./en-sg": "../eyes/node_modules/moment/locale/en-sg.js",
	"./en-sg.js": "../eyes/node_modules/moment/locale/en-sg.js",
	"./eo": "../eyes/node_modules/moment/locale/eo.js",
	"./eo.js": "../eyes/node_modules/moment/locale/eo.js",
	"./es": "../eyes/node_modules/moment/locale/es.js",
	"./es-do": "../eyes/node_modules/moment/locale/es-do.js",
	"./es-do.js": "../eyes/node_modules/moment/locale/es-do.js",
	"./es-mx": "../eyes/node_modules/moment/locale/es-mx.js",
	"./es-mx.js": "../eyes/node_modules/moment/locale/es-mx.js",
	"./es-us": "../eyes/node_modules/moment/locale/es-us.js",
	"./es-us.js": "../eyes/node_modules/moment/locale/es-us.js",
	"./es.js": "../eyes/node_modules/moment/locale/es.js",
	"./et": "../eyes/node_modules/moment/locale/et.js",
	"./et.js": "../eyes/node_modules/moment/locale/et.js",
	"./eu": "../eyes/node_modules/moment/locale/eu.js",
	"./eu.js": "../eyes/node_modules/moment/locale/eu.js",
	"./fa": "../eyes/node_modules/moment/locale/fa.js",
	"./fa.js": "../eyes/node_modules/moment/locale/fa.js",
	"./fi": "../eyes/node_modules/moment/locale/fi.js",
	"./fi.js": "../eyes/node_modules/moment/locale/fi.js",
	"./fil": "../eyes/node_modules/moment/locale/fil.js",
	"./fil.js": "../eyes/node_modules/moment/locale/fil.js",
	"./fo": "../eyes/node_modules/moment/locale/fo.js",
	"./fo.js": "../eyes/node_modules/moment/locale/fo.js",
	"./fr": "../eyes/node_modules/moment/locale/fr.js",
	"./fr-ca": "../eyes/node_modules/moment/locale/fr-ca.js",
	"./fr-ca.js": "../eyes/node_modules/moment/locale/fr-ca.js",
	"./fr-ch": "../eyes/node_modules/moment/locale/fr-ch.js",
	"./fr-ch.js": "../eyes/node_modules/moment/locale/fr-ch.js",
	"./fr.js": "../eyes/node_modules/moment/locale/fr.js",
	"./fy": "../eyes/node_modules/moment/locale/fy.js",
	"./fy.js": "../eyes/node_modules/moment/locale/fy.js",
	"./ga": "../eyes/node_modules/moment/locale/ga.js",
	"./ga.js": "../eyes/node_modules/moment/locale/ga.js",
	"./gd": "../eyes/node_modules/moment/locale/gd.js",
	"./gd.js": "../eyes/node_modules/moment/locale/gd.js",
	"./gl": "../eyes/node_modules/moment/locale/gl.js",
	"./gl.js": "../eyes/node_modules/moment/locale/gl.js",
	"./gom-deva": "../eyes/node_modules/moment/locale/gom-deva.js",
	"./gom-deva.js": "../eyes/node_modules/moment/locale/gom-deva.js",
	"./gom-latn": "../eyes/node_modules/moment/locale/gom-latn.js",
	"./gom-latn.js": "../eyes/node_modules/moment/locale/gom-latn.js",
	"./gu": "../eyes/node_modules/moment/locale/gu.js",
	"./gu.js": "../eyes/node_modules/moment/locale/gu.js",
	"./he": "../eyes/node_modules/moment/locale/he.js",
	"./he.js": "../eyes/node_modules/moment/locale/he.js",
	"./hi": "../eyes/node_modules/moment/locale/hi.js",
	"./hi.js": "../eyes/node_modules/moment/locale/hi.js",
	"./hr": "../eyes/node_modules/moment/locale/hr.js",
	"./hr.js": "../eyes/node_modules/moment/locale/hr.js",
	"./hu": "../eyes/node_modules/moment/locale/hu.js",
	"./hu.js": "../eyes/node_modules/moment/locale/hu.js",
	"./hy-am": "../eyes/node_modules/moment/locale/hy-am.js",
	"./hy-am.js": "../eyes/node_modules/moment/locale/hy-am.js",
	"./id": "../eyes/node_modules/moment/locale/id.js",
	"./id.js": "../eyes/node_modules/moment/locale/id.js",
	"./is": "../eyes/node_modules/moment/locale/is.js",
	"./is.js": "../eyes/node_modules/moment/locale/is.js",
	"./it": "../eyes/node_modules/moment/locale/it.js",
	"./it-ch": "../eyes/node_modules/moment/locale/it-ch.js",
	"./it-ch.js": "../eyes/node_modules/moment/locale/it-ch.js",
	"./it.js": "../eyes/node_modules/moment/locale/it.js",
	"./ja": "../eyes/node_modules/moment/locale/ja.js",
	"./ja.js": "../eyes/node_modules/moment/locale/ja.js",
	"./jv": "../eyes/node_modules/moment/locale/jv.js",
	"./jv.js": "../eyes/node_modules/moment/locale/jv.js",
	"./ka": "../eyes/node_modules/moment/locale/ka.js",
	"./ka.js": "../eyes/node_modules/moment/locale/ka.js",
	"./kk": "../eyes/node_modules/moment/locale/kk.js",
	"./kk.js": "../eyes/node_modules/moment/locale/kk.js",
	"./km": "../eyes/node_modules/moment/locale/km.js",
	"./km.js": "../eyes/node_modules/moment/locale/km.js",
	"./kn": "../eyes/node_modules/moment/locale/kn.js",
	"./kn.js": "../eyes/node_modules/moment/locale/kn.js",
	"./ko": "../eyes/node_modules/moment/locale/ko.js",
	"./ko.js": "../eyes/node_modules/moment/locale/ko.js",
	"./ku": "../eyes/node_modules/moment/locale/ku.js",
	"./ku.js": "../eyes/node_modules/moment/locale/ku.js",
	"./ky": "../eyes/node_modules/moment/locale/ky.js",
	"./ky.js": "../eyes/node_modules/moment/locale/ky.js",
	"./lb": "../eyes/node_modules/moment/locale/lb.js",
	"./lb.js": "../eyes/node_modules/moment/locale/lb.js",
	"./lo": "../eyes/node_modules/moment/locale/lo.js",
	"./lo.js": "../eyes/node_modules/moment/locale/lo.js",
	"./lt": "../eyes/node_modules/moment/locale/lt.js",
	"./lt.js": "../eyes/node_modules/moment/locale/lt.js",
	"./lv": "../eyes/node_modules/moment/locale/lv.js",
	"./lv.js": "../eyes/node_modules/moment/locale/lv.js",
	"./me": "../eyes/node_modules/moment/locale/me.js",
	"./me.js": "../eyes/node_modules/moment/locale/me.js",
	"./mi": "../eyes/node_modules/moment/locale/mi.js",
	"./mi.js": "../eyes/node_modules/moment/locale/mi.js",
	"./mk": "../eyes/node_modules/moment/locale/mk.js",
	"./mk.js": "../eyes/node_modules/moment/locale/mk.js",
	"./ml": "../eyes/node_modules/moment/locale/ml.js",
	"./ml.js": "../eyes/node_modules/moment/locale/ml.js",
	"./mn": "../eyes/node_modules/moment/locale/mn.js",
	"./mn.js": "../eyes/node_modules/moment/locale/mn.js",
	"./mr": "../eyes/node_modules/moment/locale/mr.js",
	"./mr.js": "../eyes/node_modules/moment/locale/mr.js",
	"./ms": "../eyes/node_modules/moment/locale/ms.js",
	"./ms-my": "../eyes/node_modules/moment/locale/ms-my.js",
	"./ms-my.js": "../eyes/node_modules/moment/locale/ms-my.js",
	"./ms.js": "../eyes/node_modules/moment/locale/ms.js",
	"./mt": "../eyes/node_modules/moment/locale/mt.js",
	"./mt.js": "../eyes/node_modules/moment/locale/mt.js",
	"./my": "../eyes/node_modules/moment/locale/my.js",
	"./my.js": "../eyes/node_modules/moment/locale/my.js",
	"./nb": "../eyes/node_modules/moment/locale/nb.js",
	"./nb.js": "../eyes/node_modules/moment/locale/nb.js",
	"./ne": "../eyes/node_modules/moment/locale/ne.js",
	"./ne.js": "../eyes/node_modules/moment/locale/ne.js",
	"./nl": "../eyes/node_modules/moment/locale/nl.js",
	"./nl-be": "../eyes/node_modules/moment/locale/nl-be.js",
	"./nl-be.js": "../eyes/node_modules/moment/locale/nl-be.js",
	"./nl.js": "../eyes/node_modules/moment/locale/nl.js",
	"./nn": "../eyes/node_modules/moment/locale/nn.js",
	"./nn.js": "../eyes/node_modules/moment/locale/nn.js",
	"./oc-lnc": "../eyes/node_modules/moment/locale/oc-lnc.js",
	"./oc-lnc.js": "../eyes/node_modules/moment/locale/oc-lnc.js",
	"./pa-in": "../eyes/node_modules/moment/locale/pa-in.js",
	"./pa-in.js": "../eyes/node_modules/moment/locale/pa-in.js",
	"./pl": "../eyes/node_modules/moment/locale/pl.js",
	"./pl.js": "../eyes/node_modules/moment/locale/pl.js",
	"./pt": "../eyes/node_modules/moment/locale/pt.js",
	"./pt-br": "../eyes/node_modules/moment/locale/pt-br.js",
	"./pt-br.js": "../eyes/node_modules/moment/locale/pt-br.js",
	"./pt.js": "../eyes/node_modules/moment/locale/pt.js",
	"./ro": "../eyes/node_modules/moment/locale/ro.js",
	"./ro.js": "../eyes/node_modules/moment/locale/ro.js",
	"./ru": "../eyes/node_modules/moment/locale/ru.js",
	"./ru.js": "../eyes/node_modules/moment/locale/ru.js",
	"./sd": "../eyes/node_modules/moment/locale/sd.js",
	"./sd.js": "../eyes/node_modules/moment/locale/sd.js",
	"./se": "../eyes/node_modules/moment/locale/se.js",
	"./se.js": "../eyes/node_modules/moment/locale/se.js",
	"./si": "../eyes/node_modules/moment/locale/si.js",
	"./si.js": "../eyes/node_modules/moment/locale/si.js",
	"./sk": "../eyes/node_modules/moment/locale/sk.js",
	"./sk.js": "../eyes/node_modules/moment/locale/sk.js",
	"./sl": "../eyes/node_modules/moment/locale/sl.js",
	"./sl.js": "../eyes/node_modules/moment/locale/sl.js",
	"./sq": "../eyes/node_modules/moment/locale/sq.js",
	"./sq.js": "../eyes/node_modules/moment/locale/sq.js",
	"./sr": "../eyes/node_modules/moment/locale/sr.js",
	"./sr-cyrl": "../eyes/node_modules/moment/locale/sr-cyrl.js",
	"./sr-cyrl.js": "../eyes/node_modules/moment/locale/sr-cyrl.js",
	"./sr.js": "../eyes/node_modules/moment/locale/sr.js",
	"./ss": "../eyes/node_modules/moment/locale/ss.js",
	"./ss.js": "../eyes/node_modules/moment/locale/ss.js",
	"./sv": "../eyes/node_modules/moment/locale/sv.js",
	"./sv.js": "../eyes/node_modules/moment/locale/sv.js",
	"./sw": "../eyes/node_modules/moment/locale/sw.js",
	"./sw.js": "../eyes/node_modules/moment/locale/sw.js",
	"./ta": "../eyes/node_modules/moment/locale/ta.js",
	"./ta.js": "../eyes/node_modules/moment/locale/ta.js",
	"./te": "../eyes/node_modules/moment/locale/te.js",
	"./te.js": "../eyes/node_modules/moment/locale/te.js",
	"./tet": "../eyes/node_modules/moment/locale/tet.js",
	"./tet.js": "../eyes/node_modules/moment/locale/tet.js",
	"./tg": "../eyes/node_modules/moment/locale/tg.js",
	"./tg.js": "../eyes/node_modules/moment/locale/tg.js",
	"./th": "../eyes/node_modules/moment/locale/th.js",
	"./th.js": "../eyes/node_modules/moment/locale/th.js",
	"./tk": "../eyes/node_modules/moment/locale/tk.js",
	"./tk.js": "../eyes/node_modules/moment/locale/tk.js",
	"./tl-ph": "../eyes/node_modules/moment/locale/tl-ph.js",
	"./tl-ph.js": "../eyes/node_modules/moment/locale/tl-ph.js",
	"./tlh": "../eyes/node_modules/moment/locale/tlh.js",
	"./tlh.js": "../eyes/node_modules/moment/locale/tlh.js",
	"./tr": "../eyes/node_modules/moment/locale/tr.js",
	"./tr.js": "../eyes/node_modules/moment/locale/tr.js",
	"./tzl": "../eyes/node_modules/moment/locale/tzl.js",
	"./tzl.js": "../eyes/node_modules/moment/locale/tzl.js",
	"./tzm": "../eyes/node_modules/moment/locale/tzm.js",
	"./tzm-latn": "../eyes/node_modules/moment/locale/tzm-latn.js",
	"./tzm-latn.js": "../eyes/node_modules/moment/locale/tzm-latn.js",
	"./tzm.js": "../eyes/node_modules/moment/locale/tzm.js",
	"./ug-cn": "../eyes/node_modules/moment/locale/ug-cn.js",
	"./ug-cn.js": "../eyes/node_modules/moment/locale/ug-cn.js",
	"./uk": "../eyes/node_modules/moment/locale/uk.js",
	"./uk.js": "../eyes/node_modules/moment/locale/uk.js",
	"./ur": "../eyes/node_modules/moment/locale/ur.js",
	"./ur.js": "../eyes/node_modules/moment/locale/ur.js",
	"./uz": "../eyes/node_modules/moment/locale/uz.js",
	"./uz-latn": "../eyes/node_modules/moment/locale/uz-latn.js",
	"./uz-latn.js": "../eyes/node_modules/moment/locale/uz-latn.js",
	"./uz.js": "../eyes/node_modules/moment/locale/uz.js",
	"./vi": "../eyes/node_modules/moment/locale/vi.js",
	"./vi.js": "../eyes/node_modules/moment/locale/vi.js",
	"./x-pseudo": "../eyes/node_modules/moment/locale/x-pseudo.js",
	"./x-pseudo.js": "../eyes/node_modules/moment/locale/x-pseudo.js",
	"./yo": "../eyes/node_modules/moment/locale/yo.js",
	"./yo.js": "../eyes/node_modules/moment/locale/yo.js",
	"./zh-cn": "../eyes/node_modules/moment/locale/zh-cn.js",
	"./zh-cn.js": "../eyes/node_modules/moment/locale/zh-cn.js",
	"./zh-hk": "../eyes/node_modules/moment/locale/zh-hk.js",
	"./zh-hk.js": "../eyes/node_modules/moment/locale/zh-hk.js",
	"./zh-mo": "../eyes/node_modules/moment/locale/zh-mo.js",
	"./zh-mo.js": "../eyes/node_modules/moment/locale/zh-mo.js",
	"./zh-tw": "../eyes/node_modules/moment/locale/zh-tw.js",
	"./zh-tw.js": "../eyes/node_modules/moment/locale/zh-tw.js"
};


function webpackContext(req) {
	var id = webpackContextResolve(req);
	return __webpack_require__(id);
}
function webpackContextResolve(req) {
	if(!__webpack_require__.o(map, req)) {
		var e = new Error("Cannot find module '" + req + "'");
		e.code = 'MODULE_NOT_FOUND';
		throw e;
	}
	return map[req];
}
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = "../eyes/node_modules/moment/locale sync recursive ^\\.\\/.*$";

/***/ }),

/***/ "../eyes/src/app.js":
/*!**************************!*\
  !*** ../eyes/src/app.js ***!
  \**************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseApp": function() { return /* binding */ BaseApp; }
/* harmony export */ });
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment-timezone */ "../eyes/node_modules/moment-timezone/index.js");
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment_timezone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _data_entity_info_json__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./data/entity_info.json */ "../eyes/src/data/entity_info.json");
/* harmony import */ var _data_entity_spheroid_layers_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./data/entity_spheroid_layers.js */ "../eyes/src/data/entity_spheroid_layers.js");
/* harmony import */ var _data_entity_spheroid_features_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./data/entity_spheroid_features.js */ "../eyes/src/data/entity_spheroid_features.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./internal */ "../eyes/src/internal.js");
// Import moment


// Import Pioneer libraries



// Eyes CSS


// Import data




// Import locals


/**
 * The main application class.
 */
class BaseApp {
	/**
	 * Sets the subclass of BaseApp to be instantiated. It should be called in the main script outside of any function, by the app subclass.
	 */
	static setAppClass() {
		BaseApp._appClass = this;
	}

	/**
	 * Constructs the Base application.
	 * @param {Map<string, typeof BaseComponent>} componentTypes
	 */
	constructor(componentTypes) {
		// Make this global.
		// @ts-ignore // vscode ts doesn't yet support globals in its jsdoc.
		window.app = this;

		/**
		 * Pioneer engine.
		 * @type {Pioneer.Engine}
		 * @private
		 */
		this._pioneer = null;

		/**
		 * Pioneer scene.
		 * @type {Pioneer.Scene}
		 * @private
		 */
		this._scene = null;

		/**
		 * The router.
		 * @type {RouteManager}
		 * @private
		 */
		this._router = null;

		/**
		 * Root UI element
		 * @type {HTMLElement}
		 * @private
		 */
		this._element = null;

		/**
		 * The dynamic UI element.
		 * @type {HTMLElement}
		 * @private
		 */
		this._dynamicElement = null;

		/**
		 * Time limits info for app.
		 * @type {object}
		 */
		this._timeInfo = {};

		/**
		 * Information for creating scene.
		 * @type {import('./internal').SceneInfo}
		 */
		this._sceneInfo = undefined;

		/**
		 * Camera scripts instance.
		 * @type {CameraScripts}
		 */
		this._cameraScripts = new _internal__WEBPACK_IMPORTED_MODULE_7__.CameraScripts(this);

		/**
		 * Information for creating components.
		 * @type {Array<object>}
		 */
		this._componentInfo = [];

		/**
		 * Component types.
		 * @type {Map<string, typeof BaseComponent>}
		 * @private
		 */
		this._componentTypes = componentTypes;

		/**
		 * List of all managers in app.
		 * @type {Object<string, BaseManager>}
		 * @private
		 */
		this._managers = {};

		/**
		 * List of all components in app.
		 * @type {Object<string, BaseComponent>}
		 * @private
		 */
		this._components = {};

		/**
		 * List of all views in app.
		 * @type {Object<string, BaseView>}
		 * @private
		 */
		this._views = {};

		/**
		 * Info to add views.
		 * @type {Array<object>}
		 * @private
		 */
		this._viewInfo = [];

		/**
		 * Map of all view classes.
		 * @type {object}
		 * @private
		 */
		this._viewClasses = {};

		/**
		 * List of callbacks to call every frame.
		 * @type {Array<Function>}
		 * @private
		 */
		this._updates = [];

		/**
		 * Is touch functionality available.
		 * @type {boolean}
		 */
		this.isTouch = null;

		/**
		 * Is hover functionality available.
		 * @type {boolean}
		 */
		this.canHover = null;

		/**
		 * Is the app currently searching.
		 * @type {boolean}
		 * @private
		 */
		this._isSearching = null;

		/**
		 * Starting position of touch.
		 * @type {Object<string, number>}
		 */
		this._touchStartPos = { x: 0, y: 0 };

		/**
		 * Is in dragging mode or not.
		 * @type {boolean}
		 */
		this._dragging = false;

		/**
		 * Set an additional reference to the entityInfo to allow early access to it if needed.
		 */
		this._entityInfo = _data_entity_info_json__WEBPACK_IMPORTED_MODULE_4__;

		this.bindFunctions([
			'resize',
			'onTouchStart',
			'onTouchMove',
			'onTouchEnd',
			'update'
		]);

		// Scroll / Drag detection
		this._touchCount = 0;
		this._scrollable = false;
		this._touchMax = false;
		window.addEventListener('touchstart', this.onTouchStart, false);
		window.addEventListener('touchmove', this.onTouchMove, { passive: false });
		window.addEventListener('touchend', this.onTouchEnd);

		// Update css vh variable
		const vh = window.innerHeight;
		document.documentElement.style.setProperty('--vh', `${vh}px`);
		window.addEventListener('resize', this.resize, false);

		this.resize();
	}

	/**
	 * Inits the app.
	 * @returns {Promise<void>}
	 */
	async init() {
		// Store root UI element
		this._element = document.getElementById('ui');
		this._dynamicElement = document.getElementById('dynamic-ui');
		this._staticElement = document.getElementById('static-ui');

		// Instantiate Pioneer engine.
		const rootDiv = /** @type {HTMLDivElement} */(document.getElementById('pioneer'));
		rootDiv.style.position = 'absolute';
		this._pioneer = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Engine(rootDiv);

		// Set Pioneer configurations.
		if (typeof window.config['staticAssetsUrl'] === 'string') {
			this._pioneer.getDownloader().setReplacement('STATIC_ASSETS_URL', window.config['staticAssetsUrl']);
		}
		if (typeof window.config['dynamicAssetsUrl'] === 'string') {
			this._pioneer.getDownloader().setReplacement('DYNAMIC_ASSETS_URL', window.config['dynamicAssetsUrl']);
		}
		if (typeof window.config['animdataUrl'] === 'string') {
			this._pioneer.getDownloader().setReplacement('ANIMDATA_URL', window.config['animdataUrl']);
		}
		this._pioneer.getConfig().setValue('fontFamily', 'Raleway');
		this._pioneer.getConfig().setValue('fontSize', 16);
		this._pioneer.getConfig().setValue('pbr', true);

		// Register custom components.
		this._pioneer.registerComponentType('distanceLine', _internal__WEBPACK_IMPORTED_MODULE_7__.DistanceLineComponent);
		this._pioneer.registerComponentType('orbiterLineOfSight', _internal__WEBPACK_IMPORTED_MODULE_7__.OrbiterLineOfSightComponent);
		this._pioneer.registerComponentType('wmts', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.WMTSComponent);
		this._pioneer.registerComponentType('discGrid', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.DiscGridComponent);
		this._pioneer.registerComponentType('torus', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.TorusComponent);
		this._pioneer.registerComponentType('constellations', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.ConstellationsComponent);

		// Register custom controllers.
		this._pioneer.registerControllerType('positionSum', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.PositionSumController);
		this._pioneer.registerControllerType('zoomFit', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.ZoomFitController);
		this._pioneer.registerComponentType('orbitLine', pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.OrbitLineComponent);

		// Set the time to 'now'
		this._pioneer.setTime(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now());
		// Set the timerate to realtime
		this._pioneer.setTimeRate(1.0);

		await this.createManagers();
		await this.createComponents();

		// Setup the app routes.
		this.setUpRoutes();

		// Setup the app update functions.
		this.setUpUpdates();

		// Start the router.
		/** @type {RouteManager} */(this.getManager('router')).start();

		const { spout } = this.getManager('router').configs;
		if (spout === true) {
			const { spoutGlobe, spoutRenderWidth, spoutGlobeDistance, spoutTarget, spoutFontSize, spoutLonAngleOffset, spoutAlignToNorthPole } = this.getManager('router').configs;
			const target = spoutTarget || await this.getManager('spout').getSpoutCameraTargetEntity(this.getManager('router').currentRoute.params);
			this.getManager('spout').enableSpout(spoutGlobe, spoutRenderWidth, spoutGlobeDistance, target, spoutFontSize, spoutLonAngleOffset, spoutAlignToNorthPole);
		}
	}

	/**
	 * GETTERS and SETTERS -----------------------------------------------------
	 */

	/**
	 * Gets Pioneer engine.
	 * @returns {Pioneer.Engine}
	 */
	get pioneer() {
		return this._pioneer;
	}

	/**
	 * Gets Pioneer scene.
	 * @returns {Pioneer.Scene}
	 */
	get scene() {
		return this._scene;
	}

	/**
	 * Sets Pioneer scene.
	 * @param {Pioneer.Scene} scene
	 */
	set scene(scene) {
		this._scene = scene;
	}

	/**
	 * Gets CameraScripts instance.
	 * @returns {CameraScripts}
	 */
	get cameraScripts() {
		return this._cameraScripts;
	}

	/**
	 * Gets the dynamic UI element.
	 * @returns {HTMLElement}
	 */
	get dynamicElement() {
		return this._dynamicElement;
	}

	/**
	 * Gets the static UI element.
	 * @returns {HTMLElement}
	 */
	get staticElement() {
		return this._staticElement;
	}

	/**
	 * Gets scene info.
	 * @returns {object}
	 */
	get sceneInfo() {
		return this._sceneInfo;
	}

	/**
	 * Gets root UI element.
	 * @returns {HTMLElement}
	 */
	get element() {
		return this._element;
	}

	/**
	 * Sets root UI element.
	 * @param {HTMLElement} element
	 * @protected
	 */
	set element(element) {
		this._element = element;
	}

	/**
	 * Gets if we're currently searching.
	 * @returns {boolean}
	 */
	get isSearching() {
		return this._isSearching;
	}

	/**
	 * Sets if we're currently searching.
	 */
	set isSearching(isSearching) {
		this._isSearching = isSearching;
	}

	/**
	 * MANAGERS ----------------------------------------------------------------
	 */

	/**
	 * Adds a manager to the app.
	 * @template {BaseManager} ManagerType
	 * @param {string} name - Unique name for the manager
	 * @param {new (baseApp: BaseApp, ...args: any[]) => ManagerType} TypeConstructor
	 * @param {any[]} args - List of arguments
	 * @returns {ManagerType}
	 */
	addManager(name, TypeConstructor, ...args) {
		// TODO Check for TypeConstructor is string to use Types.get
		if (this._managers[name] === undefined) {
			this._managers[name] = new TypeConstructor(this, ...args);
		}
		return /** @type {ManagerType} */(this._managers[name]);
	}

	/**
	 * Removes a manager from the app.
	 * @param {string} name - Unique name for the manager
	 */
	removeManager(name) {
		if (this._managers[name] !== undefined) {
			this._managers[name].destroy();
			delete this._managers[name];
		}
	}

	/**
	 * Gets a manager.
	 * @param {string} name - Unique name
	 * @returns {BaseManager}
	 */
	getManager(name) {
		if (this._managers[name] !== undefined) {
			return this._managers[name];
		}
		return null;
	}

	/**
	 * Creates app managers.
	 */
	async createManagers() {
		// Time manager
		const timeManagerClass = _internal__WEBPACK_IMPORTED_MODULE_7__.Types.get('TimeManager');
		const timeMgr = this.addManager('time', timeManagerClass);
		const min = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().tz('1949-12-31', 'Etc/UTC'); // Dec 31st 1949
		const max = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().tz('2049-12-31', 'Etc/UTC'); // Dec 31st 2049
		timeMgr.setDefaultLimits({ min, max });
		timeMgr.setLimits({ min, max });

		// Content manager
		const contentMgr = this.addManager('content', _internal__WEBPACK_IMPORTED_MODULE_7__.ContentManager);
		contentMgr.setEntityList(_data_entity_info_json__WEBPACK_IMPORTED_MODULE_4__);
		contentMgr.setSpheroidLayers(_data_entity_spheroid_layers_js__WEBPACK_IMPORTED_MODULE_5__["default"]);
		contentMgr.setSpheroidFeatures(_data_entity_spheroid_features_js__WEBPACK_IMPORTED_MODULE_6__["default"]);

		contentMgr.setFolders({
			description: 'descriptions/',
			event: 'events/',
			stories: 'stories/'
		});

		// Scene manager
		const sceneManager = this.addManager('scene', _internal__WEBPACK_IMPORTED_MODULE_7__.SceneManager);
		this._scene = sceneManager.main;
		// sceneManager.loadWMTSFromJSON(entityWMTS);

		// Layer manager
		const layerManager = this.addManager('layer', _internal__WEBPACK_IMPORTED_MODULE_7__.LayerManager);
		const SATELLITE_GROUPS = ['CYGNSS', 'TROPICS', 'STARLING', 'PREFIRE'];
		layerManager.addLayer('ui', {
			name: 'User Interface'
		});
		layerManager.addLayer('trails', {
			name: 'Trails'
		});
		layerManager.addLayer('orbits', {
			name: 'Orbits'
		});
		layerManager.addLayer('labels', {
			name: 'Labels'
		});
		layerManager.addLayer('icons', {
			name: 'Icons'
		});
		layerManager.addLayer('planets', {
			name: 'Planets',
			categories: 'Planet'
		});
		layerManager.addLayer('asteroids', {
			name: 'Asteroids',
			categories: 'Asteroid',
			defaultVisibility: false
		});
		layerManager.addLayer('comets', {
			name: 'Comets',
			categories: 'Comet',
			defaultVisibility: false
		});
		layerManager.addLayer('dwarfPlanets', {
			name: 'Dwarf Planets',
			categories: 'Dwarf Planet',
			defaultVisibility: false
		});
		layerManager.addLayer('spacecraft', {
			name: 'Spacecraft',
			categories: 'Spacecraft',
			sublayers: ['orbiters', 'landers', 'satelliteGroup']
		});
		layerManager.addLayer('majorMoons', {
			name: 'Major Moons',
			categories: 'Major Moon',
			group: 'moons'
		});
		layerManager.addLayer('minorMoons', {
			name: 'Minor Moons',
			categories: 'Minor Moon',
			defaultVisibility: false,
			group: 'moons'
		});
		layerManager.addLayer('orbiters', {
			name: 'Orbiters',
			categories: 'Orbiter',
			group: 'spacecraft'
		});
		layerManager.addLayer('satelliteGroup', {
			name: 'Satellite Group',
			categories: SATELLITE_GROUPS,
			group: 'spacecraft',
			defaultVisibility: true
		});
		layerManager.addLayer('landers', {
			name: 'Landers',
			categories: ['Lander', 'Rover', 'Landing site'],
			group: 'spacecraft'
		});
		layerManager.addLayer('starfield', {
			name: 'Star Field',
			defaultVisibility: false
		});
		layerManager.addLayer('heliosphere', {
			name: 'Heliosphere',
			defaultVisibility: false
		});
		layerManager.addLayer('constellations', {
			name: 'Constellations',
			categories: 'Constellations',
			defaultVisibility: false
		});

		// Camera Manager
		const cameraManager = this.addManager('camera', _internal__WEBPACK_IMPORTED_MODULE_7__.CameraManager, this._scene);
		this._cameraScripts.setCameraManager(cameraManager);
		cameraManager.createViewportAndCamera(this._scene);

		// Search manager
		this.addManager('search', _internal__WEBPACK_IMPORTED_MODULE_7__.SearchManager, {
			keys: [
				{
					name: 'iauName',
					weight: 0.99
				},
				{
					name: 'displayName',
					weight: 0.98
				},
				{
					name: 'altName',
					weight: 0.98
				},
				{
					name: 'keywords',
					weight: 0.3
				},
				{
					name: 'category',
					weight: 0.3
				}
			]
		});

		// Comparison Manager
		this.addManager('comparison', _internal__WEBPACK_IMPORTED_MODULE_7__.ComparisonManager);

		// Label manager
		const labelManagerClass = _internal__WEBPACK_IMPORTED_MODULE_7__.Types.get('LabelManager');
		const labelManager = this.addManager('label', labelManagerClass, this._scene);
		labelManager.setWeights(contentMgr.getEntityList());
		labelManager.setAlgorithm(labelManagerClass.Quadtree);

		// Selection Manager
		const selectionManagerClass = _internal__WEBPACK_IMPORTED_MODULE_7__.Types.get('SelectionManager');
		const selectionManager = this.addManager('selection', selectionManagerClass, this._scene);
		selectionManager.init3Dcallback(cameraManager);
		labelManager.registerCallback('labelclicked', selectionManager.setSuppress);

		// Route manager
		const routeManager = this.addManager('router', _internal__WEBPACK_IMPORTED_MODULE_7__.RouteManager);
		routeManager.setValidQueries(['time', 'rate']);
		routeManager.init();
		routeManager.addConfigs({
			embed: undefined,
			kiosk: undefined,
			logo: undefined,
			detailPanel: undefined,
			content: undefined,
			featured: undefined,
			menu: undefined,
			locked: undefined,
			surfaceMapTiling: undefined,
			hd: undefined,
			lighting: undefined,
			hideExternalLinks: undefined,
			hideFullScreenToggle: undefined,
			maxSessionTime: undefined,
			maxInactivityTime: undefined,
			forceRestart: undefined,
			noKeyboard: undefined,
			search: undefined,
			collapseSettingsOptions: undefined,
			shareButton: undefined,
			spout: undefined,
			spoutGlobe: undefined,
			spoutRenderWidth: undefined,
			spoutGlobeDistance: undefined,
			spoutTarget: undefined,
			spoutFontSize: undefined,
			spoutLonAngleOffset: undefined,
			spoutAlignToNorthPole: undefined,
			interactPrompt: undefined
		});

		// Trail manager
		const trailManagerClass = _internal__WEBPACK_IMPORTED_MODULE_7__.Types.get('TrailManager');
		const trailManager = this.addManager('trail', trailManagerClass, this._scene);
		labelManager.registerCallback('hoverchange', trailManager.onHoverChange);

		// Spout manager
		this.addManager('spout', _internal__WEBPACK_IMPORTED_MODULE_7__.SpoutManager);

		// Add callbacks for layer manager
		layerManager.addCallback('trails', trailManager.toggleTrails);
		layerManager.addCallback('orbits', trailManager.toggleOrbits);
		layerManager.addCallback('labels', labelManager.toggleLabels);
		layerManager.addCallback('icons', labelManager.toggleIcons);
		layerManager.addCallback('starfield', sceneManager.toggleStarfield);
		layerManager.addCallback('heliosphere', sceneManager.toggleHeliosphere);
		layerManager.addCallback('constellations', sceneManager.toggleConstellations);

		// Add views for this app
		this.addViews();

		// Setup viewport and camera if needed
		this.setUpViewportAndCamera();

		// Define main scene
		// Populate scene with entities
		await this.setUpScene();

		// Setup managers
		this.setUpManagers();

		// Setup components
		await this.setUpComponents();

		// Add keyboard shortcuts
		this.addShortcuts();

		// Run update every frame
		this._pioneer.addCallback(this.update, true);
	}

	/**
	 * Set up managers for app.
	 */
	setUpManagers() {
		const scene = this.scene;
		const trailManager = this.getManager('trail');
		const timeManager = this.getManager('time');

		// Set the default time limits and time limits for the app
		let { limits } = this._timeInfo;
		if (!limits) {
			limits = {
				min: moment_timezone__WEBPACK_IMPORTED_MODULE_0___default()(_internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.constants.minDate),
				max: moment_timezone__WEBPACK_IMPORTED_MODULE_0___default()(_internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.constants.maxDate)
			};
		}
		else {
			limits.min = !('min' in limits) || limits.min === '-Infinity'
				? moment_timezone__WEBPACK_IMPORTED_MODULE_0___default()(_internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.constants.minDate)
				: this.getManager('time').parseTime(limits.min);
			limits.max = !('max' in limits) || limits.max === 'Infinity'
				? moment_timezone__WEBPACK_IMPORTED_MODULE_0___default()(_internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.constants.maxDate)
				: this.getManager('time').parseTime(limits.max);
		}
		timeManager.setDefaultLimits(limits);
		timeManager.setLimits(limits);

		// Set the scene for managers
		this.getManager('label').setScene(scene);
		this.getManager('selection').setScene(scene);
		trailManager.setScene(scene);

		// Update trails to new entities
		trailManager.ids = Array.from(this.getManager('scene').getEntitiesNames());
		trailManager.setColor(trailManager.ids);
	}

	/**
	 * COMPONENTS --------------------------------------------------------------
	 */

	/**
	 * Adds a component to the app.
	 * @template {BaseComponent} ComponentType
	 * @param {string} name - Unique name for the component
	 * @param {new (baseApp: BaseApp, ...args: any[]) => ComponentType} TypeConstructor - Class name
	 * @param {any[]} args - List of arguments
	 * @returns {Promise<ComponentType>}
	 */
	async addComponent(name, TypeConstructor, ...args) {
		// TODO Check for TypeConstructor is string to use Types.get
		if (this._components[name] !== undefined) {
			throw new Error(`Component ${name} was already added.`);
		}
		const component = new TypeConstructor(this, ...args);
		this._components[name] = component;
		// Check for async init function
		await component.init();
		return component;
	}

	/**
	 * Create a component of a class for a placeholder in an element.
	 * @template {BaseComponent} ComponentType
	 * @param {object} componentClass
	 * @param {string} componentClass.name - Unique name for the component.
	 * @param {new (baseApp: BaseApp, ...args: any[]) => ComponentType} componentClass.type - Class name.
	 * @param {any[]} [componentClass.args=[]] - List of arguments except options for class constructor.
	 * @param {object} [componentClass.options={}] - Options for class constructor, passed as the last argument.
	 * @param {HTMLElement | Document} [element=document] - Element to search for all placeholders inside it.
	 * @param {HTMLElement} [placeholder=null] - Placeholder element to replace component with.
	 * @returns {Promise<ComponentType | Error>}
	 */
	async addComponentWithPlaceholder(componentClass, element = document, placeholder = null) {
		if (!componentClass.args) {
			componentClass.args = [];
		}
		if (!componentClass.options) {
			componentClass.options = {};
		}
		// Get placeholder element with same dataset name as component name
		// Or get first placeholder element with component's class name as tag
		if (!placeholder) {
			const placeholders = Array.from(element.getElementsByTagName(componentClass.type.name));
			// Find a matching placeholder
			placeholder = /** @type {HTMLElement} */(placeholders.find(item => item instanceof HTMLElement && item.id === componentClass.name));
			if (!placeholder && placeholders[0] instanceof HTMLElement) {
				placeholder = placeholders[0];
			}
			if (!placeholder) {
				return Promise.reject(new Error(`addComponentWithPlaceholder: There is no placeholder element for ${componentClass.type}`));
			}
		}
		// Get options from placeholder's dataset
		Object.assign(componentClass.options, _internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.convertObjType({ ...placeholder.dataset }));
		// Create and add component to app
		const component = await this.addComponent(componentClass.name, componentClass.type, ...componentClass.args, componentClass.options);
		// Replace placeholder element with component element in UI
		component.setParent(placeholder.parentElement, placeholder);

		return component;
	}

	/**
	 * Removes a component from the app.
	 * @param {string} name - Unique name for the component
	 * @returns {boolean} - Succeed or fail to remove
	 */
	removeComponent(name) {
		if (this._components[name] !== undefined) {
			this._components[name].destroy();
			delete this._components[name];
			return true;
		}

		return false;
	}

	/**
	 * Remove app components.
	 */
	removeComponents() {
		for (let i = 0; i < this._componentInfo.length; i++) {
			this.removeComponent(this._componentInfo[i].name);
		}
	}

	/**
	 * Gets a component.
	 * @param {string} name - Unique name
	 * @returns {BaseComponent}
	 */
	getComponent(name) {
		if (this._components[name] !== undefined) {
			return this._components[name];
		}
		return null;
	}

	/**
	 * Gets all components.
	 * @returns {object}
	 */
	getComponents() {
		return this._components;
	}

	/**
	 * Creates static UI components.
	 */
	async createComponents() {
		const components = [
			{ name: 'loadIcon', type: 'LoadIcon' },
			{ name: 'overlay', type: 'Overlay', options: { isOpenButtonVisible: false } }
		];

		for (let i = 0; i < components.length; i++) {
			const { name, type, hasPlaceholder, args, options, postCreationFunction } = components[i];
			const componentClass = _internal__WEBPACK_IMPORTED_MODULE_7__.Types.get(type);
			const component = await componentClass.create(this, name, componentClass, hasPlaceholder, args, options);
			if (postCreationFunction) {
				postCreationFunction(this, component);
			}
		}
	}

	/**
	 * Set up keyboard shortcuts.
	 */
	addShortcuts() {
		// Add eventListener for press of 'f' key as a shortcut to enter search
		const desktopSearch = this.getComponent('searchDesktop');
		const searchShortcut = 'KeyF'; // NOTE: In other apps, this is normally the slash '/' key.

		if (desktopSearch) {
			document.addEventListener('keyup', event => {
				// Key F: focus search
				if (event.code === searchShortcut) {
					if (!this.isSearching) {
						desktopSearch.open();
						desktopSearch._children.input.focus();
					}
				}
			});
		}
	}

	/**
	 * Set up app components.
	 */
	async setUpComponents() {
		this.dynamicElement.innerHTML = this.constructor.html;
		for (let i = 0; i < this._componentInfo.length; i++) {
			const { name, type, hasPlaceholder, args, options, postCreationFunction } = this._componentInfo[i];
			const componentClass = _internal__WEBPACK_IMPORTED_MODULE_7__.Types.get(type);
			const component = await componentClass.create(this, name, componentClass, hasPlaceholder, args, options);
			if (postCreationFunction) {
				postCreationFunction(this, component);
			}
		}
	}

	/**
	 * VIEWS -------------------------------------------------------------------
	 */

	/**
	 * Gets all views.
	 * @returns {Object<string, BaseView>}
	 */
	getViews() {
		return this._views;
	}

	/**
	 * Add views to app.
	 */
	addViews() {
		// Add views
		for (let i = 0; i < this._viewInfo.length; i++) {
			const viewInfo = this._viewInfo[i];
			this.addView(viewInfo.name, this._viewClasses[viewInfo.class], this._element, viewInfo.components);
		}
	}

	/**
	 * Remove views from app.
	 */
	removeViews() {
		// Remove views
		for (const view in this._views) {
			this.removeView(view);
		}
	}

	/**
	 * Gets a view.
	 * @param {string} name - Unique name
	 * @returns {BaseView}
	 */
	getView(name) {
		if (this._views[name] !== undefined) {
			return this._views[name];
		}
		return null;
	}

	/**
	 * Adds a view component to app.
	 * @param {string} name - Unique name for the view component
	 * @param {typeof BaseComponent} TypeConstructor - Class name
	 * @param {...} args - List of arguments
	 * @returns {object}
	 */
	addView(name, TypeConstructor, ...args) {
		if (this._views[name] === undefined) {
			this._views[name] = new TypeConstructor(this, ...args);
		}
		return this._views[name];
	}

	/**
	 * Removes a view component from app.
	 * @param {string} name - Unique name for the view component
	 */
	removeView(name) {
		if (this._views[name] !== undefined) {
			delete this._views[name];
		}
	}

	/**
	 * SCENE AND CAMERA --------------------------------------------------------
	 */

	/**
	 * Set up scene for app.
	 */
	async setUpScene() {
		if (this._sceneInfo === undefined) {
			console.error('App._sceneInfo needs to be set.');
			return;
		}

		// Set maximum zoom distance in camera manager
		this.getManager('camera').defaultMaxDistance = this._sceneInfo.zoomMax || 2e18;

		// Add all of the entity names to the scene manager and call the update.
		const sceneManager = /** @type {SceneManager} */(this.getManager('scene'));
		sceneManager.addEntitiesFromSceneInfo(this._sceneInfo);

		const labelManager = /** @type {LabelManager} */(this.getManager('label'));
		const trailManager = /** @type {TrailManager} */(this.getManager('trail'));
		const cameraManager = /** @type {CameraManager} */(this.getManager('camera'));

		// Setup the entity load and unload callbacks.
		sceneManager.addEntityLoadedCallback(labelManager.setUpLabel);
		sceneManager.addEntityLoadedCallback(trailManager.setUpTrail);
		sceneManager.addEntityLoadedCallback(labelManager.setUpIcon);
		sceneManager.addEntityLoadedCallback(cameraManager.addDynamicEnvMap);

		// Specific entity loaded callback.
		sceneManager.addEntityLoadedCallback(entity => {
			if (entity.getName() === 'sc_mars_science_laboratory') {
				entity.get('div').setFadeWhenCloseToEntity('mars');
			}
			else if (entity.getName() === 'sc_mars_2020') {
				entity.get('div').setFadeWhenCloseToEntity('mars');
			}
		});

		sceneManager.addEntityWillBeUnloadedCallback(labelManager.removeLabel);

		// Run an update once.
		sceneManager.update();

		this.scene = this.getManager('scene').main;

		// Disable heliosphere by default
		this.scene.get('sun', 'model')?.setEnabled(false);
	}

	/**
	 * Set up viewport and camera for app.
	 */
	setUpViewportAndCamera() {
		const scene = this.getManager('scene').main;
		const camera = this.getManager('camera');
		camera.createViewportAndCamera(scene);
		this.cameraScripts.scene = scene;
		this.cameraScripts.cameraEntity = camera.cameraEntity;
	}

	/**
	 * UPDATE CALLBACKS --------------------------------------------------------
	 */

	/**
	 * Set up callback function called every frame.
	 */
	setUpUpdates() {
		this.addUpdate(this.getManager('scene').update);
		this.addUpdate(this.getManager('label').update);
		this.addUpdate(this.getManager('camera').update);
	}

	/**
	 * Adds a callback function to the list of updates called every frame.
	 * @param {Function} callback
	 */
	addUpdate(callback) {
		if (typeof callback === 'function') {
			this._updates.push(callback);
		}
	}

	/**
	 * Removes a callback function to the list of updates called every frame.
	 * @param {Function} callback
	 */
	removeUpdate(callback) {
		const index = this._updates.indexOf(callback);
		if (index < 0) {
			return;
		}
		this._updates.splice(index, 1);
	}

	/**
	 * Calls all the functions to update every frame.
	 */
	update() {
		for (let i = 0; i < this._updates.length; i++) {
			const callback = this._updates[i];
			callback();
		}
	}

	/**
	 * HELPER FUNCTIONS --------------------------------------------------------
	 */

	/**
	 * Bind functions to class.
	 * @param {string[]} [fns=[]] - Names of functions.
	 */
	bindFunctions(fns = []) {
		const thisAsObject = /** @type {Object<string, any>} */(this);
		for (let i = 0; i < fns.length; i++) {
			const fn = fns[i];
			thisAsObject[fn] = thisAsObject[fn].bind(this);
		}
	}

	/**
	 *	Fades out a then removes the loading-screen if any
	 */
	endLoadingScreen() {
		const loadingScreen = document.getElementById('loading-screen');

		if (loadingScreen) {
			const duration = 400;
			loadingScreen.style.transition = `opacity ${duration / 1000}s ease-out`;
			loadingScreen.style.opacity = '0';
			setTimeout(() => {
				loadingScreen.remove();
			}, duration);
		}
	}

	/**
	 * Set up routes for app.
	 * @abstract
	 */
	setUpRoutes() {
	}

	/**
	 * Returns true if touch drag.
	 * @returns {boolean}
	 */
	isDragging() {
		return this._dragging;
	}

	/**
	 * Return true if more than one touch is pressed.
	 * @returns {boolean}
	 */
	isTouchMax() {
		return this._touchMax;
	}

	/**
	 * EVENT HANDLERS ----------------------------------------------------------
	 */

	/**
	 * Resize body height to window innerHeight.
	 */
	resize() {
		const vh = window.innerHeight;
		document.documentElement.style.setProperty('--vh', `${vh}px`);
		document.body.style.height = vh + 'px';

		// Determine whether to update touch and hover properties.
		const isTouch = _internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.isTouch();
		const canHover = _internal__WEBPACK_IMPORTED_MODULE_7__.AppUtils.canHover();

		if (this.isTouch !== isTouch) {
			document.body.classList.toggle('touch', isTouch);
			this.isTouch = isTouch;
		}

		if (this.canHover !== canHover) {
			document.body.classList.toggle('hover', canHover);
			this.canHover = canHover;
		}

		// For late-update browsers
		setTimeout(() => {
			if (vh !== window.innerHeight) {
				const newVH = window.innerHeight;
				document.documentElement.style.setProperty('--vh', `${newVH}px`);
				document.body.style.height = newVH + 'px';
			}
		}, 1000);
	}

	/**
	 * Handles touchstart event.
	 * @param {Event} event
	 */
	onTouchStart(event) {
		this._touchCount++;
		this._touchMax = this._touchCount > 1;
		const touchEvent = event.changedTouches[0];
		this._touchStartPos.x = touchEvent.pageX;
		this._touchStartPos.y = touchEvent.pageY;
		this._dragging = false;

		// Check if element is scrollable or child of scrollable
		this._scrollable = false;
		let element = /** @type {Element} */(event.target);
		while (element.parentElement !== null) {
			if (element.classList.contains('scrollable')) {
				this._scrollable = true;
				break;
			}
			element = element.parentElement;
		}
	}

	/**
	 * Handles touchmove event.
	 * @param {Event} event
	 */
	onTouchMove(event) {
		const touchEvent = event.changedTouches[0];
		const pressedPositionDistance = Math.max(Math.abs(touchEvent.pageX - this._touchStartPos.x), Math.abs(touchEvent.pageY - this._touchStartPos.y));
		if (pressedPositionDistance > 5) {
			this._dragging = true;
		}

		// Prevent pinch zoom on the page
		if (!this._scrollable) {
			event.preventDefault();
		}
	}

	/**
	 * Handles touchend event.
	 * @param {Event} event
	 */
	onTouchEnd(event) {
		this._touchCount--;
		if (event.touches.length === 0) {
			this._touchMax = false;
		}
		this._dragging = false;
		this._scrollable = false;
	}

	/**
	 * Gets the Pioneer version.
	 * @returns {string}
	 */
	getPioneerVersion() {
		return this.pioneer.getVersion();
	}

	/**
	 * Gets the eyes version.
	 * @returns {string}
	 */
	getEyesVersion() {
		return _internal__WEBPACK_IMPORTED_MODULE_7__.EyesVersion;
	}
}

// Initialize the app when the window loads.
window.addEventListener('load', async () => {
	try {
		const app = new BaseApp._appClass();
		app.init();
	}
	catch (error) {
		document.body.innerHTML = '';
		throw error;
	}
});

/**
 * The subclass of BaseApp to be instantiated.
 * @type {typeof BaseApp}
 */
BaseApp._appClass = BaseApp;

window.Pioneer = pioneer__WEBPACK_IMPORTED_MODULE_1__;
window.PioneerScripts = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__;


/***/ }),

/***/ "../eyes/src/assets/index.js":
/*!***********************************!*\
  !*** ../eyes/src/assets/index.js ***!
  \***********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);















/***/ }),

/***/ "../eyes/src/base_view.js":
/*!********************************!*\
  !*** ../eyes/src/base_view.js ***!
  \********************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseView": function() { return /* binding */ BaseView; }
/* harmony export */ });
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment-timezone */ "../eyes/node_modules/moment-timezone/index.js");
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment_timezone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./internal */ "../eyes/src/internal.js");




/**
 * The base view.
 */
class BaseView extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {HTMLElement} element
	 * @param {Array} [components=[]] - Components of a view
	 */
	constructor(app, element, components = []) {
		super(app, element);

		/**
		 * All child components of this view.
		 * @type {string[]}
		 * @private
		 */
		this._components = [...components];

		/**
		 * List of valid query keys for this view.
		 * @type {string[]}
		 * @private
		 */
		this._validQueries = [];

		/**
		 * Rules for validating queries.
		 * @type {object}
		 * @private
		 */
		this._rules = {};

		/**
		 * Camera's target.
		 * @type {string}
		 */
		this._target = null;

		// View should be disabled by default, and enabled by router
		this._enabled = false;

		this.bindFunctions(['resize', 'updateVisibility', 'toggleViewUI']);
	}

	/**
	 * Gets the app as an BaseApp.
	 * @returns {BaseApp}
	 * @override
	 */
	get app() {
		return /** @type {BaseApp} */(super.app);
	}

	/**
	 * Shows control panel (clock, time controls).
	 */
	_showControls() {
	}

	/**
	 * Hides control panel (clock, time controls).
	 */
	_hideControls() {
	}

	/**
	 * Function to check if controls should be hidden or not.
	 * @returns {boolean}
	 */
	_shouldHideControls() {
		return false;
	}

	/**
	 * Updates component visibility.
	 */
	updateVisibility() {
		const showUI = this._app.getManager('layer').getLayer('ui').visible;
		if (!showUI) {
			return;
		}

		if (this._shouldHideControls()) {
			this._hideControls();
		}
		else {
			this._showControls();
		}
	}

	/**
	 * Resize handler. Triggers on window resize event.
	 */
	resize() {
		this.updateVisibility();
	}

	/**
	 * Toggles UI for this view.
	 */
	toggleViewUI() {
	}

	/**
	 * Check if view should reset enable/disable status of each component.
	 * Todo: see naming note below.
	 * @returns {boolean}
	 */
	_shouldResetStatus() {
		// If the UI is disabled dont reset the status
		return this._app.getManager('layer').getLayer('ui').visible;
	}

	/**
	 * Reset status of child components.
	 * ToDo: The name "resetStatus" seems a little generic.
	 * We're looping through all components and enabling/disabling them. Maybe "setComponentsAbility"?
	 * @param {Array} [unsubscribed=[]] - List of unsubscribed components that won't be enabled/disabled by the view.
	 */
	_resetStatus(unsubscribed = []) {
		if (this._shouldResetStatus()) {
			const allComponents = Object.keys(this._app.getComponents());
			for (let i = allComponents.length - 1; i >= 0; i--) {
				const component = allComponents[i];
				if (unsubscribed.includes(component)) {
					continue;
				}
				this._app.getComponent(component).setEnabled(this._components.includes(component));
			}
		}
	}

	/**
	 * Register all callbacks for view.
	 */
	registerCallbacks() {
		this._app.getManager('layer').addCallback('ui', this.toggleViewUI);
	}

	/**
	 * Remove all callbacks for view.
	 */
	removeCallbacks() {
		this._app.getManager('layer').removeCallback('ui', this.toggleViewUI);
	}

	/**
	 * Called when entering the view.
	 * @param {object} params
	 * @param {Array} [unsubscribed=[]] - List of unsubscribed components that won't be enabled/disabled by the view.
	 */
	async onEnter(params, unsubscribed = []) {
		// Check if route was canceled
		if (params.cancelToken.isCanceled) {
			return;
		}
		this._resetStatus(unsubscribed);

		window.addEventListener('resize', this.resize);
		this.registerCallbacks();

		const className = this._app.getManager('router').currentView + '-view';
		document.body.classList.add(className);
		// Lock navigational actions
		if (this._app.getManager('router').configs.locked) {
			document.body.classList.add('locked');
			this._app.getManager('label').setClickable(false);
			this._app.getManager('selection').setClickable(false);
		}
	}

	/**
	 * Execute actions on full route change.
	 * @param {object} params - Parameters and queries from url
	 */
	async onRouteChange(params) {
		await this.before(params);

		// Check if route was canceled
		if (params.cancelToken.isCanceled) {
			return;
		}

		// Reset variables
		this._reset(params);

		// Update resources
		await this._updateResources(params);

		// Check if route was canceled
		if (params.cancelToken.isCanceled) {
			return;
		}

		// Process query params like time and time rate.
		// NOTE: Is there a reason processQuery is here as well as onQueryChange?
		params.setTimeLimits = true;
		await this.processQuery(params);

		// Update components
		await this._updateComponentsVisibility(params);
		// Check if route was canceled
		if (params.cancelToken.isCanceled) {
			return;
		}

		// Check if entities are ready
		await this._checkReady(params);

		// Update camera
		// TODO: Check when we need to update camera
		try {
			await this._updateCamera(params);
			this._updateLoading(params);
		}
		finally {
			await this.after(params);
		}

		const { spout } = this.app.getManager('router').configs;
		if (spout === true) {
			const { spoutGlobe, spoutRenderWidth, spoutGlobeDistance, spoutTarget, spoutFontSize, spoutLonAngleOffset, spoutAlignToNorthPole } = this.app.getManager('router').configs;
			const spoutTargetEntity = spoutTarget || await this.app.getManager('spout').getSpoutCameraTargetEntity(params);
			this.app.getManager('spout').enableSpout(spoutGlobe, spoutRenderWidth, spoutGlobeDistance, spoutTargetEntity, spoutFontSize, spoutLonAngleOffset, spoutAlignToNorthPole);
		}
	}

	/**
	 * On query change.
	 * Called when query has changed but not the route.
	 * @param {object} params
	 */
	async onQueryChange(params) {
		// Check if route was canceled
		if (params.cancelToken.isCanceled) {
			return;
		}

		// Process query params like time and time rate
		await this.processQuery(params);
	}

	/**
	 * Validate queries.
	 * @param {object} input
	 * @returns {boolean} `true` if valid, otherwise `false`.
	 */
	validateQuery(input) {
		// Make a copy so it won't modify original query.
		const queries = { ...input };
		const keys = Object.keys(queries);
		const newQueries = {};
		const isInvalid = {};
		const routeManager = this._app.getManager('router');

		for (let i = keys.length - 1; i >= 0; i--) {
			const key = keys[i];
			// If there is no rule, remove from query and skip
			if (!(key in this._rules)) {
				delete queries[key];
				continue;
			}
			// Validate a query against rule value
			const rule = this._rules[key];
			const valid = typeof rule.value === 'function'
				? rule.value(queries[key])
				: rule.value === queries[key];
			// If not valid
			if (!valid) {
				isInvalid[key] = queries[key];
				// If there's a redirect rule call it.
				if (typeof this._rules.redirect === 'function') {
					this._rules.redirect(queries[key]);
					return false;
				}
				// If there is a route, navigate and exit
				if ('route' in rule) {
					routeManager.navigate(rule.route);
					return false;
				}
				// Else if there is default value, store in new query
				else if ('default' in rule) {
					newQueries[key] = rule.default;
				}
			}
		}

		// Navigate to default values if there are any
		if (!_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isEmptyObject(newQueries)) {
			routeManager.navigate({ ...queries, ...newQueries });
			return false;
		}

		// If invalid, but no route or default value, use default handler and exit
		if (!_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isEmptyObject(isInvalid)) {
			this._handleError(`validateQuery: Invalid input - ${JSON.stringify(isInvalid)}`);
			return false;
		}

		return true;
	}

	/**
	 * Process the query from path.
	 * Only consider Pioneer-related and common queries, not app-unique ones.
	 * @param {object} query
	 * @param {string} query.time - Time string that can be parsed by moment. E.g. time=2020-153T17:32:44.550
	 * @param {string} query.rate - Time rate in second that can be parsed by parseInt. E.g. rate=120 (sec/sec)
	 */
	async processQuery(query) {
		/**
		 * Note: Maybe we could add an _updateTimeLimits method here.
		 */

		// Set time
		await this._updateTime(query);

		// Set time rate
		this._updateTimeRate(query);

		const router = this._app.getManager('router');
		const prevQuery = router.parseQuery(router.previousRoute?.query);

		// Go thru all query callback keys in the router and check if the params contain the query.
		for (const queryKey of Object.keys(router._queryCallbacks)) {
			const currQueryVal = query[queryKey];
			const prevQueryVal = prevQuery[queryKey];

			// If we have query values for previous of current query, loop thru the callbacks, call them, and pass the prev and curr query valuez.
			if (currQueryVal || prevQueryVal) {
				router._queryCallbacks[queryKey].forEach(callbackFn => callbackFn(currQueryVal, prevQueryVal));
			}
		}

		// Update layer panel
		const layerManager = this._app.getManager('layer');
		const layerPanel = this._app.getComponent('layerPanel');
		const layerQueries = {
			layerUI: 'ui',
			layerTrails: 'trails',
			layerOrbits: 'orbits',
			layerLabels: 'labels',
			layerIcons: 'icons',
			layerPlanets: 'planets',
			layerAsteroids: 'asteroids',
			layerComets: 'comets',
			layerDwarfPlanets: 'dwarfPlanets',
			layerConstellations: 'constellations',
			layerSpacecraft: 'spacecraft'
		};
		for (const key in layerQueries) {
			if (key in query) {
				const layer = layerQueries[key];
				if (query[key] === 'disable') {
					layerPanel?.setCategoryEnabled(layer, false);
				}
				else {
					if (layerPanel?.isCategoryEnabled(layer)) {
						if (query[key] === 'show') {
							if (!layerManager.getLayer(layer).visible) {
								layerPanel.toggleLayer(layer);
							}
						}
						else if (query[key] === 'hide') {
							if (layerManager.getLayer(layer).visible) {
								layerPanel.toggleLayer(layer);
							}
						}
					}
				}
			}
		}

		// Update title if title manager is initialized.
		this.app.getManager('title')?.updateTitle(router.currentRoute);
	}

	/**
	 * Display error message and reroute to previous url.
	 * @param {string} [message=''] - Message for error
	 * @throws {string}
	 */
	_handleError(message = '') {
		const err = new Error(message);
		console.error(err);
		const router = this._app.getManager('router');
		if (router !== null) {
			let url = this._app.getManager('router').previousRoute.url;
			if (!url) {
				url = this._app.getManager('router').homeRoute;
			}
			this._app.getManager('router').navigate(url);
		}
	}

	/**
	 * Called when exiting the view.
	 * @param {object} params
	 */
	onLeave(params) {
		window.removeEventListener('resize', this.resize);
		this.removeCallbacks();

		const className = this._app.getManager('router').previousView + '-view';
		document.body.classList.remove(className);

		this._app.getManager('selection').unselect();
		this._app.getManager('scene').clearForceLoad();
		this._validQueries.length && this._app.getManager('router').navigate({ __remove: this._validQueries });
	}

	/**
	 * Takes router parameters and initialize view variables.
	 * ToDo: "reset" is not a good method name for something that initializes view variables. Let's change this.
	 * @param {object} params
	 */
	_reset(params) {
		this._app.getManager('scene').clearForceLoad();
	}

	/**
	 * Update resources from managers and router parameters.
	 * @param {object} params
	 */
	async _updateResources(params) {
	}

	/**
	 * Update time rate from query.
	 * @param {object} query
	 */
	_updateTimeRate(query) {
		const timeManager = this._app.getManager('time');

		if ('rate' in query) {
			timeManager.setTimeRate(parseInt(query.rate));
		}
		else {
			timeManager.resetTimeRate();
		}
	}

	/**
	 * Update time with router parameters.
	 * @param {object} params
	 */
	async _updateTime(params) {
		const timeManager = this._app.getManager('time');
		const routeManager = this._app.getManager('router');
		const isStory = routeManager.currentRoute.url.includes('story');
		let numSlides = 0;
		if (isStory && this._storyId) {
			const story = this._app.getManager('content').getStory(this._storyId);
			numSlides = story.slides.length;
		}

		/**
		 * Note:
		 * To improve readability, it would maybe make sense to update the time limits in a separate method, eg. _updateTimeLimits.
		 * See note in processQuery method.
		 */
		// Apply app limits:
		// If there's no target and if it's not a single slide story in case of custom timing (all single slide stories have custom timing)
		// OR
		// If it is a story, there's no target, and no storyId (some stories in asteroids do handle id's differently)
		if ((!this._target && (numSlides > 1)) || (isStory && !this._target && !this._storyId)) {
			timeManager.resetMin();
			timeManager.resetMax();
		}

		if (this._target) {
			await this._updateTimeForTarget(params);
		}
		else if (params.time) {
			const time = this._app.getManager('time').parseTime(params.time);
			if (time.isValid()) {
				this._app.getManager('time').setTime(params.time);
			}
			else {
				// Remove time query if invalid
				this._app.getManager('router').navigate({ __remove: ['time'] });
			}
		}
		else {
			this._app.getManager('time').setToNow();
		}
	}

	/**
	 * Update time relative to a target.
	 * @param {object} params
	 * @param {boolean} waitForEntity
	 */
	async _updateTimeForTarget(params, waitForEntity = true) {
		const timeManager = this._app.getManager('time');

		let min = timeManager.timeLimits.min.clone();
		let max = timeManager.timeLimits.max.clone();

		if (params.setTimeLimits) {
			const defaultLimits = timeManager.getDefaultLimits();
			min = defaultLimits.min.clone();
			max = defaultLimits.max.clone();

			waitForEntity && await this._app.getManager('scene').get('main').getEntity(this._target).getLoadedPromise();
			const coverage = this._app.getManager('scene').getCoverage(this._target);

			// Apply coverage limits
			if (coverage.min !== null) {
				min = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().max(min, coverage.min);
			}
			if (coverage.max !== null) {
				max = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().min(max, coverage.max);
			}

			// Apply description limits
			if (this._entityDesc?.dates?.start) {
				const startTime = timeManager.parseTime(this._entityDesc.dates.start);
				min = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().max(startTime, min);
			}
			if (this._entityDesc?.dates?.end) {
				const endTime = timeManager.parseTime(this._entityDesc.dates.end);
				max = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().min(endTime, max);
			}

			// Check for anormal times
			if (min.isAfter(max)) {
				console.error('Start date provided is after end date.');
				const router = this._app.getManager('router');
				this._app.getComponent('clock')?.setLimitMessage(1, 'time limit error');
				// This needs to be stored and cleared to prevent memory leak / delayed nav.
				setTimeout(() => router.navigate('/'), 1000);

				return;
			}

			// Set time limits
			timeManager.setMax(max);
			timeManager.setMin(min);
		}

		// If we dont have time specified in query
		// Set the time to start
		if (!params.time && this._eventInfo?.start) {
			// E.g. /sc_cassini/events/eventID
			const eventStart = timeManager.parseTime(this._eventInfo.start);
			timeManager.setTime(moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().max(eventStart, min));
		}
		else if (!params.time) {
			const now = this._app.getManager('time').getNow();
			if (now.isAfter(max) || now.isBefore(min)) {
				timeManager.setTime(min);
			}
			else {
				timeManager.setToNow();
			}
		}
		else {
			const time = timeManager.parseTime(params.time);
			if (time.isAfter(max)) {
				timeManager.setTime(max);
				timeManager.setTimeRate(0);
				this._app.getComponent('clock')?.setLimitMessage(1);
			}
			else if (time.isBefore(min)) {
				timeManager.setTime(min);
				this._app.getComponent('clock')?.setLimitMessage(-1);
			}
			else {
				timeManager.setTime(time);
			}
		}
	}

	/**
	 * Update components and visibility with router parameters.
	 * @param {object} params
	 */
	async _updateComponentsVisibility(params) {
		await this._updateComponents(params);
		// Check if route was canceled
		if (params.cancelToken.isCanceled) {
			return;
		}
		this.updateVisibility();
	}

	/**
	 * Update components with router parameters.
	 * @param {object} params
	 */
	async _updateComponents(params) {
	}

	/**
	 * Update camera with router parameters.
	 * @param {object} params
	 */
	async _updateCamera(params) {
	}

	/**
	 * Update scene loading.
	 * @param {object} params
	 */
	_updateLoading(params) {
		// Update loading
		if (this._target !== null) {
			const promises = [];
			const loadComponents = ['model', 'wmts', 'spheroidLOD'];
			const sceneManager = this._app.getManager('scene');
			const contentManager = this._app.getManager('content');

			// If target is an instrument, add it's parent to the addLoading.
			const entityInfoCategory = contentManager.getEntityInfo(this._target)?.category;
			if (entityInfoCategory) {
				if (entityInfoCategory === 'Instrument') {
					sceneManager.addLoading(sceneManager._scene.getEntity(this._target).getParent().getName(), 'view');
				}
			}
			sceneManager.addLoading(this._target, 'view');
			for (let i = 0; i < loadComponents.length; i++) {
				const component = sceneManager.get('main').get(this._target, loadComponents[i]);
				if (component !== null) {
					// Force loading of component
					// It will be cleared when leaving the view or reseting it
					sceneManager.forceLoad(component);
					promises.push(sceneManager.componentIsReady(component));
				}
			}
			Promise.all(promises).then(() => {
				if (entityInfoCategory) {
					if (entityInfoCategory === 'Instrument') {
						sceneManager.removeLoading(sceneManager._scene.getEntity(this._target).getParent().getName(), 'view');
					}
				}
				sceneManager.removeLoading(this._target, 'view');
			});
		}
	}

	/**
	 * Checks if entities are ready.
	 * @param {object} params
	 */
	async _checkReady(params) {
		// No need to check if we dont have a target
		if (this._target === null) {
			return;
		}

		// Make sure the objects are ready
		const checklist = [];
		let parent = this._target;
		while (parent !== 'sun') {
			checklist.push(parent);
			const parentEntity = this._app.getManager('scene').get('main').get(parent)?.getParent();
			if (!parentEntity) {
				break;
			}
			parent = parentEntity.getName();
		}
		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(this._app.getManager('scene').get('main'), checklist);
		await this._app.pioneer.waitUntilNextFrame();
	}

	/**
	 * Callback before all actions in onRouteChange.
	 * @param {object} params
	 */
	async before(params) {
	}

	/**
	 * Callback after all actions in onRouteChange.
	 * @param {object} params
	 */
	after(params) {
		// Reset old target for layer manager
		this._app.getManager('layer').resetTarget();
		this._app.getManager('scene').clearTempEntities();
	}
}


/***/ }),

/***/ "../eyes/src/components/base_component.js":
/*!************************************************!*\
  !*** ../eyes/src/components/base_component.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseComponent": function() { return /* binding */ BaseComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");


/**
 * @typedef ClassType
 * @property {object} isVisible - className for visible or hidden element
 * @property {string} [isVisible.true='active']
 * @property {string} [isVisible.false='hidden']
 * @property {object} fontSize
 * @property {string} fontSize.small
 * @property {string} fontSize.default
 * @property {string} fontSize.large
 */

/**
 * @typedef Options
 * @property {HTMLElement} parent
 * @property {Object<string, any>} config
 * @property {Object<string, string>} params
 * @property {boolean} [isVisible]
 */

/**
 * @typedef CallbackRegistryType
 * @property {object} emitter - The emitter to register callback to or remove callback from. Can be app, manager, view, or component instance.
 * @property {string} event - Emitter's event name to trigger the callback
 * @property {Function} callback - The callback to trigger on event
 */

/** The base class for all components. */
class BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {HTMLElement} element - The element given to the component
	 * @param {Options} [options = { parent: null, config: {}, params: {} }] - Initial state and optional config
	 */
	constructor(app, element, options = { parent: null, config: {}, params: {}, isVisible: true }) {
		/**
		 * The element given to the component.
		 * @type {Element}
		 */
		this._element = element;

		/**
		 * Application.
		 * @type {BaseApp}
		 * @private
		 */
		this._app = app;

		/**
		 * Configurations of component.
		 * @type {Object<string, any>}
		 * @private
		 */
		this._config = options['config'] || {};
		delete options['config'];
		if (!('hiddenMode' in this._config)) {
			this._config.hiddenMode = 'hidden';
		}

		/**
		 * Static variables to insert into element HTML text on initialization.
		 * @type {Object<string, string>}
		 */
		this._params = options['params'] || {};
		delete options['params'];

		// Default state of component's visibility
		if (!('isVisible' in options)) {
			options['isVisible'] = false;
		}

		/**
		 * Store className for element's state.
		 * @type {ClassType}
		 * @private
		 */
		this._class = {
			isVisible: {
				true: 'active',
				false: this._config.hiddenMode === 'hidden' ? 'hidden' : 'invisible'
			},
			fontSize: {
				small: 'small',
				default: '',
				large: ''
			}
		};

		/**
		 * The current states of component.
		 * @type {Object<string, any>}
		 * @private
		 */
		this._state = {
			...options,
			isVisibleClass: this._class.isVisible[options.isVisible ? 'true' : 'false'],
			fontSizeClass: this._class.fontSize.default
		};

		/**
		 * The old states of component.
		 * @type {Object<string, any>}
		 * @private
		 */
		this._oldState = {};

		/**
		 * The children/grandchildren of element.
		 * @type {Object<string, Element>}
		 */
		this._children = {};

		/**
		 * The child components to be managed by this component.
		 * @type {Array<typeof BaseComponent>}
		 */
		this._components = [];

		/**
		 * Text node elements that associate with state.
		 * @type {Object<string, Array<{ element: Node, field: string }>>}
		 */
		this._vars = {};

		/**
		 * The parent element of component's element.
		 * @type {HTMLElement}
		 */
		this._parent = this._element ? this._element.parentElement : (options.parent || null);

		/**
		 * Flag that indicates whether the user has enabled or disabled the component.
		 * @type {boolean}
		 * @private
		 */
		this._enabled = false;

		/**
		 * Array of possible event names.
		 * @type {string[]}
		 * @default
		 */
		this._eventNames = ['statuschange', 'visiblechange'];

		/**
		 * Callbacks reference object.
		 * @type {Object<string, Array<(...args: any[]) => void>>}
		 * @default
		 */
		this._callbacks = {};
		this._initCallbacks();

		/**
		 * Registry of callbacks to register on enable and remove on disable.
		 * @type {Array<CallbackRegistryType>}
		 */
		this._callbackRegistry = [];

		this.bindFunctions([
			'resize',
			'isEnabled',
			'setEnabled',
			'show',
			'hide',
			'toggle',
			'loadHTML',
			'getState',
			'setState'
		]);
	}

	/**
	 * Get the child components.
	 * @returns {Array<string|typeof BaseComponent>}
	 */
	get components() {
		return this._components;
	}

	/**
	 * Gets the app.
	 * @returns {BaseApp}
	 */
	get app() {
		return this._app;
	}

	/**
	 * Resize handler. Triggers on window resize event.
	 */
	resize() {
		this._updateFontSize();
	}

	/**
	 * Update font size of component's element.
	 */
	_updateFontSize() {
		let fontSizeClass = this._class.fontSize.default;

		if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobile()) {
			fontSizeClass = this._class.fontSize.small;
		}
		else if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isTablet()) {
			fontSizeClass = this._class.fontSize.default;
		}
		else if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isPanorama()) {
			fontSizeClass = this._class.fontSize.default;
		}
		else if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.is2K() || _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.is4K()) {
			fontSizeClass = this._class.fontSize.large;
		}

		this.setState({
			fontSizeClass
		});
	}

	/**
	 * Get the root element of the component.
	 * @returns {Element}
	 */
	get element() {
		return this._element;
	}

	/**
	 * Get the parent element of component's element.
	 * @returns {HTMLElement|null}
	 */
	getParent() {
		return this._parent;
	}

	/**
	 * Set the parent element for component's element.
	 * @param {HTMLElement} parent
	 * @param {HTMLElement} [replaceElement=null] - Element to replace with component's element.
	 */
	setParent(parent, replaceElement = null) {
		this._parent = parent;

		// Remove replaceElement
		if (replaceElement) {
			this._parent.removeChild(replaceElement);
		}

		// Add element to parent if component is enabled
		if (this._enabled) {
			this._parent.appendChild(this._element);
		}
	}

	/**
	 * Initialization.
	 * Called automatically by addComponent.
	 * @param {Object<string, string>} params - Parameters to replace in html
	 * @returns {Promise<void>}
	 */
	async init(params = {}) {
		Object.assign(this._params, params);

		const componentType = /** @type {typeof BaseComponent} */(this.constructor);
		if (componentType.html !== undefined) {
			this._element = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.htmlWithParamsToElement(componentType.html, this._params);
			this._element.classList.add('{{fontSizeClass}}');
			this._setVariables(this._element);
			this._setEventHandlersFromAttributes(this._element);
		}
		else {
			this._element.classList.add('{{fontSizeClass}}');
			this._setVariables(this._element);
		}
		this._updateFontSize();
	}

	/**
	 * Get component's config.
	 * @returns {object}
	 */
	getConfig() {
		return this._config;
	}

	/**
	 * Update component's config.
	 * @param {object} config
	 */
	setConfig(config) {
		Object.assign(this._config, config);
	}

	/**
	 * Bind functions to class.
	 * @param {string[]} [fns=[]] - Names of functions.
	 */
	bindFunctions(fns = []) {
		const thisAsObject = /** @type {Object<string, any>} */(this);
		for (let i = 0; i < fns.length; i++) {
			const fn = fns[i];
			thisAsObject[fn] = thisAsObject[fn].bind(this);
		}
	}

	/**
	 * Returns true if the component is enabled by the user.
	 * @returns {boolean}
	 */
	isEnabled() {
		return this._enabled;
	}

	/**
	 * Sets whether the component is enabled by the user.
	 * @param {boolean} enabled
	 */
	setEnabled(enabled) {
		const wasEnabled = this._enabled;

		if (enabled && !wasEnabled) {
			this.__enable();
		}
		else if (!enabled && wasEnabled) {
			this.__disable();
		}

		/**
		 * NOTE from Jack:
		 * The _enabled prop is now set here as previously, calling __disable and any subsequent triggerCallbacks method,
		 * would result in the callback not being called. This is because triggerCallbacks returns false is _enabled is false.
		 * We still want to trigger a statuschange as the component is being disabled.
		 * Update: the isEnabled check in triggerCallbacks has been commented out.
		 */
		this._enabled = enabled;

		this._components.forEach(item => {
			const component = (typeof item === 'string')
				? this._app.getComponent(item)
				: item;
			component.setEnabled(enabled);
		});
	}

	/**
	 * Destroy component.
	 */
	destroy() {
		this.__destroy();
	}

	/**
	 * Show component's element.
	 */
	show() {
		this.setState({
			isVisible: true,
			isVisibleClass: this._class.isVisible.true
		}, () => this.triggerCallbacks('visiblechange', [true]));
	}

	/**
	 * Hide component's element.
	 */
	hide() {
		this.setState({
			isVisible: false,
			isVisibleClass: this._class.isVisible.false
		}, () => this.triggerCallbacks('visiblechange', [false]));
	}

	/**
	 * Toggle visibility of component's element.
	 */
	toggle() {
		if (this._state['isVisible']) {
			this.hide();
		}
		else {
			this.show();
		}
	}

	/**
	 * Load HTML from file into element.
	 * @param {string} filename
	 * @param {HTMLElement} [element=null] - The element to load html into
	 */
	async loadHTML(filename, element = null) {
		const response = await fetch(filename);
		if (!response.ok) {
			console.error(response.status + ': ' + response.statusText);
		}
		else {
			const html = await response.text();
			this._parseHTML(html, element);
		}
	}

	/**
	 * Get state value using its key.
	 * @param {string} key
	 * @returns {any}
	 */
	getState(key) {
		if (!(key in this._state)) {
			return null;
		}
		return this._state[key];
	}

	/**
	 * Add a state to component.
	 * @param {string} key
	 * @param {any} value
	 * @param {HTMLElement} element - Element to call _setVariables on
	 */
	addState(key, value, element) {
		this._state[key] = value;
		if (element) {
			this._setVariables(element);
		}
	}

	/**
	 * Set state. Will trigger rerender if new state is not empty.
	 * @param {Object<string, any>} state - Changed states
	 * @param {() => void} [callback] - Optional callback
	 */
	setState(state, callback) {
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isEmptyObject(state)) {
			return;
		}

		// Simple check for changes
		let hasChanged = false;
		for (const key in state) {
			if (state[key] !== this._state[key]) {
				hasChanged = true;
				break;
			}
		}

		// Don't render if no change
		if (!hasChanged) {
			return;
		}

		this._oldState = { ...this._state };
		this._state = { ...this._state, ...state };
		this._render(state);

		if (callback !== undefined) {
			callback();
		}
	}

	/**
	 * Parse HTML and store variables.
	 * @param {string} html
	 * @param {Element} [element=null] - Element to load html into
	 */
	_parseHTML(html, element = null) {
		if (!html) {
			return;
		}

		const outElement = element || this._element;

		// Create the template and add the html content as the root node.
		this._roots = [..._internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.htmlToElements(html)];

		const docFrag = document.createDocumentFragment();
		for (let i = 0; i < this._roots.length; i++) {
			const item = this._roots[i];
			if (item instanceof HTMLElement) {
				// Set the variables and store the elements with key.
				this._setVariables(item);

				// Set the event handlers.
				this._setEventHandlersFromAttributes(item);

				// Add parsed element to component's div
				docFrag.appendChild(item);
			}
		}
		outElement.appendChild(docFrag);
	}

	/**
	 * Check if a text contain a variable (enclosed in {{ and }}).
	 * @param {string} text
	 * @returns {boolean}
	 */
	_containVar(text) {
		return (
			text
			&& typeof text.includes === 'function'
			&& text.includes('{{')
			&& text.includes('}}')
		);
	}

	/**
	 * Split a string without empty results.
	 * @param {string} str
	 * @returns {string[]}
	 */
	_splitNonEmpty(str) {
		return str.split(/\s+/g).filter(part => part !== '');
	}

	/**
	 * Store all variables as state or children for update.
	 * Format of HTML variable: {{var}}. Format of HTML key: key="childVar".
	 * @example
	 * // Replace <div>{{text}}</div> with value of this._state.text.
	 * // Replace <div class="{{aClass}}"></div> with value of this._state.aClass.
	 * // Store <div key="aChild"></div> as this._children.aChild.
	 * @param {Node} element
	 * @param {boolean} [setForChildren=true] - Also set variables for children
	 * @private
	 */
	_setVariables(element, setForChildren = true) {
		let outElement;

		// Store elements with key
		if (element instanceof Element) {
			for (let i = element.attributes.length - 1; i >= 0; i--) {
				const attribute = element.attributes[i];
				if (attribute.name === 'key') {
					this._children[attribute.value] = element;
					break;
				}
			}
		}

		// Get variables to be stored
		const elementVars = [];

		// Text node
		if (element.nodeType === Node.TEXT_NODE) {
			if (this._containVar(element.nodeValue)) {
				elementVars.push({
					field: 'nodeValue',
					elementVar: element.nodeValue
				});
			}
		}
		// Not text node
		else if (element instanceof Element) {
			// Class name/list
			let className = element.className;
			while (this._containVar(className)) {
				const endIndex = className.indexOf('}}') + 2;
				elementVars.push({
					field: 'classList',
					elementVar: className.substring(className.indexOf('{{'), endIndex)
				});
				className = className.substring(endIndex);
			}
		}

		// Store variables
		for (let i = 0; i < elementVars.length; i++) {
			let { field, elementVar } = elementVars[i];
			if (field && elementVar.startsWith('{{') && elementVar.endsWith('}}')) {
				// Replace variable
				const key = elementVar.replace('{{', '').replace('}}', '');
				// With classnames
				if (field === 'classList' && element instanceof Element) {
					element.classList.remove(elementVar);
					const state = this._state[key];
					if (state !== undefined) {
						const classList = this._splitNonEmpty(state);
						element.classList.add(...classList);
					}
				}
				else {
					// With an element
					if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isHTML(this._state[key])) {
						const newElement = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.htmlToElement(this._state[key]);
						element.parentNode.replaceChild(newElement, element);
						outElement = newElement;
					}
					// With text containing HTML
					else if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.hasHTML(this._state[key])) {
						// Update element since text node cannot display HTML
						if (element.nodeType === Node.TEXT_NODE) {
							const newElement = document.createElement('span');
							newElement.innerHTML = this._state[key];
							const parent = element.parentElement || element.parentNode;
							parent.replaceChild(newElement, element);
							outElement = newElement;
							field = 'innerHTML';
						}
						else {
							element.innerHTML = this._state[key];
						}
					}
					// With other properties
					else {
						const elementAsObj = /** @type {Object<string, any>} */(element);
						elementAsObj[field] = this._state[key];
					}
				}
				// Store variable
				if (this._vars[key] === undefined) {
					this._vars[key] = [];
				}
				this._vars[key].push({
					element: outElement || element,
					field
				});
			}
		}

		// Go through the children and so on.
		if (setForChildren) {
			for (let i = element.childNodes.length - 1; i >= 0; i--) {
				this._setVariables(element.childNodes[i]);
			}
		}
	}

	/**
	 * Sets the event handlers for all children of elem. Searches for all attributes starting with 'on' and processes them.
	 * @param {Element} element
	 * @private
	 */
	_setEventHandlersFromAttributes(element) {
		const attributeNamesToRemove = [];
		for (let i = element.attributes.length - 1; i >= 0; i--) {
			const attribute = element.attributes[i];
			if (attribute.name.startsWith('on')) {
				// Get the event type.
				const event = attribute.name.substring(2).toLowerCase();
				// Get the callback.
				const handler = /** @type {BaseComponent & { [key: string]: any }} */(this)[attribute.value];
				if (handler === undefined || !(handler instanceof Function)) {
					throw new Error('Could not find valid ' + event + ' handler ' + attribute.value + ' for element with id ' + element.id);
				}
				// Get the callback bound to this.
				const boundHandler = handler.bind(this);
				// Remove the attribute so there's no conflict.
				attributeNamesToRemove.push(attribute.name);
				// Add the event listener.
				element.addEventListener(event, boundHandler);
			}
		}
		// Remove the attributes that were handlers to remove any conflicts.
		for (let i = attributeNamesToRemove.length - 1; i >= 0; i--) {
			element.removeAttribute(attributeNamesToRemove[i]);
		}
		// Go through the children and so on.
		for (let i = element.children.length - 1; i >= 0; i--) {
			this._setEventHandlersFromAttributes(element.children[i]);
		}
	}

	/**
	 * Render div innerHTML with changed states.
	 * @param {Object<string, any>} state
	 */
	_render(state) {
		const keys = Object.keys(state);
		for (let i = keys.length - 1; i >= 0; i--) {
			const key = keys[i];
			if (key in this._vars && state[key] !== this._oldState[key]) {
				const _var = this._vars[key];
				for (let j = 0; j < _var.length; j++) {
					// Update variable
					const { field, element } = _var[j];
					// With classnames
					if (field === 'classList') {
						let classList = this._splitNonEmpty(this._oldState[key]);
						const elementAsObj = /** @type {Object<string, any>} */(element);
						elementAsObj[field].remove(...classList);
						classList = this._splitNonEmpty(state[key]);
						elementAsObj[field].add(...classList);
					}
					else {
						// With an element
						if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isHTML(state[key])) {
							const newElement = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.htmlToElement(state[key]);
							element.parentNode.replaceChild(newElement, element);
							this._vars[key][j].element = newElement;
						}
						// With text containing HTML
						else if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.hasHTML(state[key])) {
							if (element.nodeType === Node.TEXT_NODE) {
								const newElement = document.createElement('span');
								newElement.innerHTML = state[key];
								const parent = element.parentElement || element.parentNode;
								parent.replaceChild(newElement, element);
								this._vars[key][j].element = newElement;
								this._vars[key][j].field = 'innerHTML';
							}
							else {
								element.innerHTML = state[key];
							}
						}
						// With other properties
						else {
							const elementAsObj = /** @type {Object<string, any>} */(element);
							elementAsObj[field] = state[key];
						}
					}
				}
			}
		}
	}

	/**
	 * Enables the component.
	 * @abstract
	 * @package
	 */
	__enable() {
		window.addEventListener('resize', this.resize);
		this.registerCallbacks();

		if (this._parent) {
			this._parent.appendChild(this._element);
			this.triggerCallbacks('statuschange', [true, this]);
		}
	}

	/**
	 * Disables the component.
	 * @abstract
	 * @package
	 */
	__disable() {
		if (this._parent && this._parent.contains(this._element)) {
			this.triggerCallbacks('statuschange', [false, this]);
			this._element = this._parent.removeChild(this._element);
		}
		window.removeEventListener('resize', this.resize);
		this.removeCallbacks();
	}

	/**
	 * Destroy component.
	 */
	__destroy() {
		this.__disable();
		this._element = null;
		this._parent = null;
	}

	/**
	 * Initialize callback list for all events.
	 */
	_initCallbacks() {
		for (let i = 0; i < this._eventNames.length; i++) {
			this._callbacks[this._eventNames[i]] = [];
		}
	}

	/**
	 * Registers a callback for a specific event.
	 * @param {string} eventName
	 * @param {(...args: any[]) => void} callback - A callback function to be called
	 */
	registerCallback(eventName, callback) {
		if ((typeof (callback) !== 'function') || (this._eventNames.indexOf(eventName) < 0)) {
			return;
		}

		// Prevent multiple registrations of same event with same callback
		if (!this._callbacks[eventName].includes(callback)) {
			this._callbacks[eventName].push(callback);
		}
	}

	/**
	 * Remove a callback for an event.
	 * @param {string} eventName
	 * @param {(...args: any[]) => void} callback
	 */
	removeCallback(eventName, callback) {
		if ((typeof (callback) !== 'function') || (this._eventNames.indexOf(eventName) < 0)) {
			return;
		}

		const index = this._callbacks[eventName].indexOf(callback);
		if (index > -1) {
			this._callbacks[eventName].splice(index, 1);
		}
	}

	/**
	 * Trigger all callbacks for an event.
	 * @param {string} eventName
	 * @param {any[]} [params=[]] - Parameters for callback
	 */
	triggerCallbacks(eventName, params = []) {
		// Not sure why these are triggered in reverse order.
		for (let i = this._callbacks[eventName].length - 1; i >= 0; i--) {
			const callback = this._callbacks[eventName][i];
			callback(...params);
		}
	}

	/**
	 * Register all callbacks for component.
	 */
	registerCallbacks() {
		for (let i = 0; i < this._callbackRegistry.length; i++) {
			const { emitter, event, callback } = this._callbackRegistry[i];
			emitter.registerCallback(event, callback);
		}
	}

	/**
	 * Remove all callbacks for component.
	 */
	removeCallbacks() {
		for (let i = 0; i < this._callbackRegistry.length; i++) {
			const { emitter, event, callback } = this._callbackRegistry[i];
			emitter.removeCallback(event, callback);
		}
	}
}

/**
 * Helper function to create the component and add to app.
 * @static
 * @param {BaseApp} app - Application to add component
 * @param {string} name - Component's unique name
 * @param {typeof BaseComponent} TypeConstructor - Component's class to construct
 * @param {boolean} hasPlaceholder - Component has a HTML placeholder or not
 * @param {any[]} [args=[]] - Arguments to pass to constructor
 * @param {object} [options={}] - Options to pass to constructor
 * @returns {Promise<BaseComponent>}
 */
BaseComponent.create = async (app, name, TypeConstructor, hasPlaceholder = true, args = [], options = {}) => {
	const component = hasPlaceholder
		? await app.addComponentWithPlaceholder({ type: TypeConstructor, name, args, options })
		: await app.addComponent(name, TypeConstructor, ...args, options);

	if (TypeConstructor.postCreationFunction) {
		TypeConstructor.postCreationFunction(app, component);
	}
	return component;
};

/**
 * The HTML that goes with the component.
 * @type {string | undefined}
 */
BaseComponent.html = undefined;

/**
 * The HTML that goes with the component.
 * @type {((app: BaseApp, component: BaseComponent) => void) | undefined}
 */
BaseComponent.postCreationFunction = undefined;


/***/ }),

/***/ "../eyes/src/components/breadcrumb/breadcrumb.js":
/*!*******************************************************!*\
  !*** ../eyes/src/components/breadcrumb/breadcrumb.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Breadcrumb": function() { return /* binding */ Breadcrumb; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _breadcrumb_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./breadcrumb.html */ "../eyes/src/components/breadcrumb/breadcrumb.html");
/* harmony import */ var _breadcrumb_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_breadcrumb_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Breadcrumb component.
 * @extends BaseComponent
 */
class Breadcrumb extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options = { params: {} }) {
		// Default params
		options.params = {
			title: '',
			...options.params
		};
		super(app, null, options);

		this._class.isHomeActiveClass = {
			true: 'active',
			false: ''
		};

		/**
		 * Crumb text for crumbs.
		 * @type {object}
		 */
		this._crumbTexts = {
			compare: 'Compare Size',
			events: 'Mission Events'
		};

		// Set the crumb onclick handler.
		this.setCrumbClickHandler(route => {
			this._app.getManager('router').navigate(route, '', { __remove: 'all', keepTime: true });
		});

		Object.assign(this._state, {
			isHomeActive: false,
			isHomeActiveClass: this._class.isHomeActiveClass.false
		});

		this.bindFunctions(['_goToHome']);
	}

	/**
	 * Updates the breadcrumb trail.
	 * @param {Array} routeParts
	 */
	updateBreadcrumb(routeParts) {
		this._element.innerHTML = '';
		const docFrag = document.createDocumentFragment();

		// Add static part
		if (this._app.getManager('router').configs.logo === false) {
			this._children.staticLogo.classList.add('hidden');
		}
		if (this._app.getManager('router').configs.locked) {
			this._children.static.classList.remove('clickable');
		}
		docFrag.appendChild(this._children.static);

		const isHomeActive = !routeParts || routeParts.length === 0 || (routeParts.length === 1 && routeParts[0] === 'home');
		if (isHomeActive) {
			routeParts = null;
		}
		this.setState({
			isHomeActive,
			isHomeActiveClass: this._class.isHomeActiveClass[isHomeActive]
		});

		// Add dynamic parts
		if (routeParts && routeParts.length > 0) {
			for (let i = 0; i < routeParts.length; i++) {
				const routePart = routeParts[i];
				const route = routeParts.slice(0, i + 1).join('/');

				const crumb = this._createCrumb(routePart, route);
				docFrag.appendChild(crumb);
			}
		}

		this._element.appendChild(docFrag);
	}

	/**
	 * Actions on route change.
	 * @param {object} params - Parameters and queries from url
	 * @param {Array} params.routeParts
	 */
	onRouteChange({ routeParts } = {}) {
		this.updateBreadcrumb(routeParts);
	}

	/**
	 * Sets the breadcrumb onclick handler function. It allows each app to set the handler dynamically.
	 * @param {Function} onCrumbClick
	 */
	setCrumbClickHandler(onCrumbClick) {
		this._onCrumbClick = onCrumbClick;
	}

	/**
	 * Navigate back to home page.
	 */
	_goToHome() {
		const router = this._app.getManager('router');
		router.navigate({ __remove: 'all' }, '/home');
	}

	/**
	 * Get crumb text to display.
	 * @param {string} crumb
	 * @returns {string}
	 */
	_getCrumbText(crumb) {
		// Lookup predefined texts
		if (this._crumbTexts[crumb]) {
			return this._crumbTexts[crumb];
		}

		// Lookup entity info
		const entityInfo = this._app.getManager('content').getEntityInfo([crumb]);
		if (entityInfo) {
			return entityInfo.displayName || entityInfo.iauName;
		}

		// Lookup event info
		const eventInfo = this._app.getManager('content').events[crumb];
		if (eventInfo) {
			return eventInfo.title;
		}

		// Lookup story info
		const storyInfo = this._app.getManager('content').getStoryList().stories[crumb];
		if (storyInfo) {
			return storyInfo.title;
		}

		return '';
	}

	/**
	 * Creates a crumb.
	 * @param {string} text
	 * @param {string} route
	 * @returns {HTMLElement}
	 */
	_createCrumb(text, route) {
		const container = document.createElement('nav');
		const { locked } = this._app.getManager('router').configs;
		container.className = `container ${locked ? '' : 'clickable'}`;
		if (!locked) {
			container.addEventListener('click', () => {
				this._onCrumbClick(route);
			});
		}

		const separator = document.createElement('span');
		separator.className = 'separator icon icon-greater';
		container.appendChild(separator);

		const textSpan = document.createElement('a');
		textSpan.innerHTML = this._getCrumbText(text) || text;
		textSpan.className = 'text link';
		container.appendChild(textSpan);

		return container;
	}
}

Breadcrumb.html = (_breadcrumb_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/carousel/carousel.js":
/*!***************************************************!*\
  !*** ../eyes/src/components/carousel/carousel.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tippy.js */ "../eyes/node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _carousel_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./carousel.html */ "../eyes/src/components/carousel/carousel.html");
/* harmony import */ var _carousel_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_carousel_html__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _slide_template_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./slide_template.html */ "../eyes/src/components/carousel/slide_template.html");
/* harmony import */ var _slide_template_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_slide_template_html__WEBPACK_IMPORTED_MODULE_2__);





/**
 * General carousel with only previous/next navigation.
 * @see {@link https://codepen.io/simonpatrat/pen/zeGYdo} - Modified from
 */
class Carousel extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {HTMLElement} element
	 * @param {object} [options={}]
	 */
	constructor(app, element, options = {}) {
		/**
		 * Determine the hint's text based on device.
		 * @type {string}
		 */
		const hintAction = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isPrimaryTouch() ? 'Swipe/Tap' : 'Scroll/Click';

		/**
		 * Configurations for carousel.
		 * @type {object}
		 * @private
		 * @default
		 * @property {boolean} [infinite=false] - Loop to start/end if reach limit
		 * @property {number} [initialSlideIndex=0] - Slide index to show on initilization. Must be an integer.
		 * @property {boolean} [vertical=true] - Scrolling direction is vertical
		 * @property {number} [timeout=1500] - Timeout between slide scroll
		 * @property {object} navigationButtons
		 * @property {object} navigationButtons.prev
		 * @property {string} [navigationButtons.prev.text='Prev'] - Text for previous navigation button
		 * @property {string} [navigationButtons.prev.text='icon-greater up'] - Icon for previous navigation button
		 * @property {object} navigationButtons.next
		 * @property {string} [navigationButtons.next.text='Next'] - Text for next navigation button
		 * @property {string} [navigationButtons.next.text='icon-greater down'] - Icon for next navigation button
		 * @property {object} navigationButtons.replay
		 * @property {string} [navigationButtons.replay.text='Back To Start'] - Text for replay navigation button
		 * @property {string} [navigationButtons.replay.text='icon-replay'] - Icon for replay navigation button
		 * @property {object} hintText - Hint text for each slide
		 * @property {string} hintText.default - Hint text for default slide
		 * @property {string} hintText.fist - Hint text for first slide
		 * @property {string} hintText.last - Hint text for last slide
		 */
		options.config = {
			infinite: false,
			initialSlideIndex: 0,
			vertical: true,
			timeout: 1000,
			navigationButtons: {
				prev: {
					text: 'Prev',
					icon: 'icon-greater up'
				},
				next: {
					text: 'Next',
					icon: 'icon-greater down'
				},
				replay: {
					text: 'Back To Start',
					icon: 'icon-replay'
				}
			},
			hintText: {
				default: ``,
				first: `Click arrows on phone to continue`,
				last: `Click arrows on phone for previous`
			},
			...options.config
		};

		super(app, element, {
			slideType: '',
			previousIndex: -1,
			currentIndex: options.config.initialSlideIndex || 0,
			isScrolling: false,
			isScrollingClass: '',
			isTimeout: false,
			collapseClass: 'expand',
			isCollapsed: false,
			collapseButtonClass: 'icon-collapse',
			isCloseButtonVisible: false,
			closeButtonText: 'Exit',
			isControlsVisible: false,
			...options
		});

		Object.assign(this._state, {
			isCloseButtonVisibleClass: this._class.isVisible[this._state.isCloseButtonVisible],
			isControlsVisibleClass: this._class.isVisible[this._state.isControlsVisible]
		});

		this._children = {
			track: null,
			slides: []
		};

		/**
		 * Tooltip for progress arrow.
		 * @type {tippy}
		 */
		this._progressTooltip = null;

		/**
		 * List of functions to call on entering a slide.
		 * @type {object}
		 */
		this._onEnter = {};

		/**
		 * List of functions to call on leaving a slide.
		 * @type {object}
		 */
		this._onLeave = {};

		/**
		 * Supported slide types.
		 * @type {Array}
		 */
		this._slideTypes = ['panel', 'overlay'];

		/**
		 * Current slide's info.
		 */
		this._currentInfo = null;

		/**
		 * Function to call on changing slide via button or scroll.
		 * @default
		 */
		this._onSlideChange = this.goToSlide;

		/**
		 * Function to call on clicking controls button.
		 * @type {Function}
		 */
		this._toggleControls = null;

		/** @inheritdoc */
		this._eventNames.push('slidechange', 'expandtoggle');
		this._initCallbacks();

		// Binds
		this.bindFunctions([
			'_setSlideTrackDimensions',
			'_updateCarousel',
			'_onScroll',
			'_toggleCollapse',
			'_onControlsToggle',
			'goToPrevSlide',
			'goToNextSlide',
			'close'
		]);
	}

	/**
	 * Get current slide's info.
	 * @returns {object}
	 */
	get currentInfo() {
		return this._currentInfo;
	}

	/**
	 * Handle clicking controls button.
	 */
	_onControlsToggle() {
		this._toggleControls();
	}

	/**
	 * Set function to call on clicking controls button.
	 * @param {Function} cb
	 */
	setOnControlsToggle(cb) {
		this._toggleControls = cb;
	}

	/**
	 * Initialize.
	 */
	init() {
		super.init();

		this._children.carousel.classList.add(this._config.vertical ? 'vertical' : 'horizontal');

		this._createSlideTrack();
		this._updateCarousel();

		this._children.carousel.classList.add('initialized');

		// Edge case scenario fix
		window.addEventListener('keydown', event => {
			if (event.key === 'Tab' && this._state.isScrolling) {
				event.preventDefault();
			}
		});
		this._children.carousel.addEventListener('transitionstart', event => {
			if (event.target === this._children.track && event.propertyName === 'transform') {
				this.setState({ isScrolling: true, isScrollingClass: 'scrolling' });
				this._children.carousel.style.pointerEvents = 'all';
			}
		}, true);
		this._children.carousel.addEventListener('transitionend', event => {
			if (event.target === this._children.track && event.propertyName === 'transform') {
				this.setState({ isScrolling: false, isScrollingClass: 'scrolling-done' });
				this._children.carousel.style.pointerEvents = 'none';
			}
		}, true);

		this._children.progress.addEventListener('wheel', this._onScroll, { passive: false });
		this._children.progress.addEventListener('touchstart', event => {
			const touchEvent = event.changedTouches[0];
			this._touchStartY = touchEvent.pageY;
		});
		this._children.progress.addEventListener('touchmove', event => {
			const touchEvent = event.changedTouches[0];
			event.deltaY = touchEvent.pageY - this._touchStartY;
			this._onScroll(event, 'touch');
		}, { passive: false });
		this._children.progress.addEventListener('touchend', event => {
			const touchEvent = event.changedTouches[0];
			event.deltaY = touchEvent.pageY - this._touchStartY;
			this._onScroll(event, 'touch');
		}, { passive: false });
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		setTimeout(this._setSlideTrackDimensions, 100);

		this._updateTooltipsProps();
	}

	/**
	 * Update tooltip props.
	 */
	_updateTooltipsProps() {
		const { slideType } = this._state;

		this._progressTooltip.setProps({
			offset: slideType === 'overlay'
				? [0, -30]
				: [0, 10]
		});
	}

	/**
	 * Create slide track containing all slides.
	 */
	_createSlideTrack() {
		this._children.slides.forEach(slide => {
			this._children.track.appendChild(slide);
		});
		this._setSlideTrackDimensions();
	}

	/**
	 * Set slide track width, height, and transition.
	 */
	_setSlideTrackDimensions() {
		const { track, slides } = this._children;
		const { vertical } = this._config;

		slides.forEach(slide => {
			slide.style.transition = 'none';
		});

		track.style.transition = 'none';
		if (vertical) {
			const height = [...slides].reduce((acc, slide) => (
				acc + slide.getBoundingClientRect().height
			), 0);
			track.style.height = height + 'px';
		}
		else {
			const width = [...slides].reduce((acc, slide) => (
				acc + slide.getBoundingClientRect().width
			), 0);
			track.style.width = width + 'px';
		}

		track.style.transition = '';
		slides.forEach(slide => {
			slide.style.transition = '';
		});
		this._updateTrackPosition();
	}

	/**
	 * Update track's position to current slide.
	 */
	_updateTrackPosition() {
		const { currentIndex } = this._state;

		let trackOffset = 0;
		for (let i = 0; i < currentIndex; i++) {
			trackOffset += this._children.slides[i].getBoundingClientRect().height;
		}
		const translateValue = this._config.vertical
			? `translateY(-${trackOffset}px)`
			: `translateX(-${trackOffset}px)`;

		this._children.track.style.transform = translateValue;
	}

	/**
	 * Update slides' state.
	 */
	_updateSlides() {
		const { previousIndex, currentIndex } = this._state;

		const previousSlide = this._children.slides[previousIndex];
		if (previousSlide) {
			previousSlide.classList.remove('active');
			previousSlide.classList.add('hidden');
		}

		const currentSlide = this._children.slides[currentIndex];
		if (currentSlide) {
			currentSlide.classList.remove('hidden');
			currentSlide.classList.add('active');
		}
	}

	/**
	 * Update carousel.
	 */
	_updateCarousel() {
		this._updateTrackPosition();
		this._updateSlides();
	}

	/**
	 * Handle scrolling.
	 * @param {Event} event
	 * @param {string} [type='mouse'] - Scroll type, can be 'mouse' or 'touch'
	 */
	_onScroll(event, type = 'mouse') {
		if (this._state.isCollapsed && !this._state.isTimeout) {
			this.expand();
		}
		else if (!this._state.isScrolling && !this._state.isTimeout) {
			// Since we use overlayscrollbars library, the scrolling element is os-viewport
			const element = event.currentTarget.querySelector('.os-viewport') || event.currentTarget;
			const scrollTop = element.scrollTop;
			const scrolledToTop = scrollTop === 0;
			// Ceiling is needed because the sum can be a float closed to scrollHeight
			const scrolledToBottom = Math.ceil(element.getBoundingClientRect().height + scrollTop) >= element.scrollHeight;

			if (event.deltaY < 0) {
				if (type === 'mouse') {
					if (event.deltaY < -4 && scrolledToTop) {
						this.goToPrevSlide();
					}
				}
				else {
					if (event.deltaY < -5 && scrolledToBottom) {
						this.goToNextSlide();
					}
				}
			}
			else if (event.deltaY > 0) {
				if (type === 'mouse') {
					if (event.deltaY > 4 && scrolledToBottom) {
						this.goToNextSlide();
					}
				}
				else {
					if (event.deltaY > 5 && scrolledToTop) {
						this.goToPrevSlide();
					}
				}
			}
		}

		this.setState(
			{ isTimeout: true },
			() => setTimeout(() => this.setState({ isTimeout: false }), this._config.timeout)
		);

		// Need this to scroll inside panel
		if (['wheel', 'touchmove'].includes(event.type)) {
			event.stopPropagation();
		}
	}

	/**
	 * Add a slide to carousel.
	 * @param {object} slideInfo
	 * @param {string} slideInfo.type - Slide type
	 * @param {HTMLElement} slideInfo.content - Content element of a slide
	 * @param {object} [options={}]
	 * @param {boolean} options.isFirst - Is first slide
	 * @param {boolean} options.isLast - Is last slide
	 */
	addSlide(slideInfo, { isLast = false, isFirst = false } = {}) {
		const html = slideInfo.html || (_slide_template_html__WEBPACK_IMPORTED_MODULE_2___default());
		const { type, content } = slideInfo;

		if (!this._slideTypes.includes(type)) {
			console.warn(`addSlide: Unknown slide type "${type}". Supported types: ${this._slideTypes}`);
		}

		const slide = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.htmlWithParamsToElement(html, {
			prevButtonText: this._config.navigationButtons.prev.text,
			prevButtonIcon: this._config.navigationButtons.prev.icon,
			nextButtonText: this._config.navigationButtons.next.text,
			nextButtonIcon: this._config.navigationButtons.next.icon,
			replayButtonText: this._config.navigationButtons.replay.text,
			replayButtonIcon: this._config.navigationButtons.replay.icon,
			hintText: () => {
				if (isLast) {
					return this._config.hintText.last;
				}
				else if (isFirst) {
					return this._config.hintText.first;
				}
				else {
					return this._config.hintText.default;
				}
			},
			type
		});

		slide.querySelector('.content').appendChild(content);

		if (isLast) {
			slide.classList.add('last');
		}
		if (isFirst) {
			slide.classList.add('first');
		}
		if (slideInfo.classList) {
			slide.classList.add(...slideInfo.classList);
		}
		if (slideInfo.id) {
			slide.dataset.id = slideInfo.id;
		}
		slide.dataset.type = slideInfo.type || '';
		this._children.track.appendChild(slide);
		this._children.slides.push(slide);

		const slideContainer = slide.firstChild;
		slideContainer.addEventListener('wheel', this._onScroll, { passive: false });
		slideContainer.addEventListener('touchstart', event => {
			const touchEvent = event.changedTouches[0];
			this._touchStartY = touchEvent.pageY;
		});
		slideContainer.addEventListener('touchmove', event => {
			const touchEvent = event.changedTouches[0];
			event.deltaY = touchEvent.pageY - this._touchStartY;
			this._onScroll(event, 'touch');
		}, { passive: false });
		slideContainer.addEventListener('touchend', event => {
			const touchEvent = event.changedTouches[0];
			event.deltaY = touchEvent.pageY - this._touchStartY;
			this._onScroll(event, 'touch');
		}, { passive: false });

		this._setVariables(slide);
		this._setEventHandlersFromAttributes(slide);
		this._setSlideTrackDimensions();
		this._updateCarousel();

		_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addScrollbar(slideContainer);

		this._progressTooltip = (0,tippy_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this._children.progress.parentElement, {
			theme: 'default',
			onShow(instance) {
				clearTimeout(instance.timeout);
				instance.timeout = setTimeout(() => {
					instance.hide();
				}, 2000);
			}
		});
	}

	/**
	 * Add multiple slides to carousel.
	 * @param {Array} slidesInfo
	 */
	addSlides(slidesInfo) {
		for (let i = 0; i < slidesInfo.length; i++) {
			this.addSlide(slidesInfo[i]);
		}
	}

	/**
	 * On entering a slide.
	 * @param {number} index
	 * @returns {Promise}
	 */
	async onEnter(index) {
		const onEnter = this._onEnter[index];
		for (let i = 0; i < onEnter.length; i++) {
			if (typeof onEnter[i] === 'function') {
				await onEnter[i]();
			}
		}
	}

	/**
	 * On leaving a slide.
	 * @param {number} index
	 * @returns {Promise}
	 */
	async onLeave(index) {
		if (!(typeof index === 'number')) {
			index = this._state.currentIndex;
		}
		const onLeave = this._onLeave[index];
		for (let i = 0; i < onLeave.length; i++) {
			if (typeof onLeave[i] === 'function') {
				await onLeave[i]();
			}
		}
	}

	/**
	 * Go to slide using index.
	 * @param {number} currentIndex
	 * @returns {Promise}
	 */
	async goToSlide(currentIndex) {
		const { spout, spoutFontSize } = this.app.getManager('router').configs;

		const previousIndex = this._state.currentIndex;
		if (currentIndex !== previousIndex) {
			await this.onLeave(previousIndex);
		}

		const slideType = this._children.slides[currentIndex].dataset.type;
		this.setState({
			currentIndex,
			previousIndex,
			slideType
		}, () => {
			this._updateCarousel();
			this._children.progress.style.top = `calc(${currentIndex * 100 / (this._children.slides.length - 1)}% - ${this._children.progress.offsetHeight / 2}px)`;
			// Since we use overlayscrollbars library, the scrolling element is os-viewport
			const element = this._children.slides[currentIndex].querySelector('.os-viewport');
			if (element) {
				element.scrollTop = 0;
			}

			this.triggerCallbacks('slidechange', [this._currentInfo]);

			// Update tooltip
			this._progressTooltip.setContent(`${currentIndex + 1} of ${this._children.slides.length}`);
			this._updateTooltipsProps();
			if (this._state.isVisible) {
				// this._progressTooltip.show();
			}
		});

		await this.onEnter(currentIndex);

		if (spout === true) {
			await this.app.getManager('spout').setUpSpoutLabels(spoutFontSize);
		}

	}

	/**
	 * Go to previous slide.
	 */
	goToPrevSlide() {
		const { currentIndex } = this._state;
		const lastSlideIndex = this._children.slides.length - 1;

		const slideToGo = currentIndex - 1;
		if (slideToGo < 0) {
			if (this._config.infinite) {
				this._onSlideChange(lastSlideIndex);
			}
		}
		else {
			this._onSlideChange(slideToGo);
		}
	}

	/**
	 * Go to next slide.
	 */
	goToNextSlide() {
		const { currentIndex } = this._state;
		const lastSlideIndex = this._children.slides.length - 1;

		const slideToGo = currentIndex + 1;
		if (slideToGo > lastSlideIndex) {
			if (this._config.infinite) {
				this._onSlideChange(0);
			}
		}
		else {
			this._onSlideChange(slideToGo);
		}
	}

	/**
	 * Go to first slide.
	 */
	goToFirstSlide() {
		this._onSlideChange(0);
	}

	/**
	 * Returns visible state.
	 * @returns {boolean}
	 */
	isVisible() {
		return this._state.isVisible;
	}

	/**
	 * Collapses panel.
	 */
	collapse() {
		this.setState({ isCollapsed: true, collapseClass: 'collapse', collapseButtonClass: 'icon-expand' });
		this.triggerCallbacks('expandtoggle', [false]);
	}

	/**
	 * Expands panel.
	 */
	expand() {
		this.setState({ isCollapsed: false, collapseClass: 'expand', collapseButtonClass: 'icon-collapse' });
		this.triggerCallbacks('expandtoggle', [true]);
	}

	/**
	 * Close carousel.
	 */
	close() {
	}

	/**
	 * @override
	 */
	show() {
		super.show();
		this._updateCarousel();
		if ((this._progressTooltip !== null) && (this._children.slides.length > 1)) {
			// this._progressTooltip.show();
		}
	}

	/**
	 * Clear carousel slides.
	 */
	clear() {
		this._children.track.innerHTML = '';
		this._children.slides = [];
		this._onEnter = {};
		this._onLeave = {};
		this._currentInfo = null;
		this._state.previousIndex = 1;
		this._state.currentIndex = this._config.initialSlideIndex || 0;
	}

	/**
	 * Toggles between expand and collapse states.
	 */
	_toggleCollapse() {
		if (this._state.isCollapsed) {
			this.expand();
		}
		else {
			this.collapse();
		}
	}
}

Carousel.html = (_carousel_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (Carousel);


/***/ }),

/***/ "../eyes/src/components/carousel/index.js":
/*!************************************************!*\
  !*** ../eyes/src/components/carousel/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _carousel_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carousel.js */ "../eyes/src/components/carousel/carousel.js");




/* harmony default export */ __webpack_exports__["default"] = (_carousel_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/carousel_panel/carousel_panel.js":
/*!***************************************************************!*\
  !*** ../eyes/src/components/carousel_panel/carousel_panel.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "../eyes/node_modules/swiper/swiper.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _carousel_panel_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./carousel_panel.html */ "../eyes/src/components/carousel_panel/carousel_panel.html");
/* harmony import */ var _carousel_panel_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_carousel_panel_html__WEBPACK_IMPORTED_MODULE_2__);




swiper__WEBPACK_IMPORTED_MODULE_0__["default"].use([swiper__WEBPACK_IMPORTED_MODULE_0__.Navigation, swiper__WEBPACK_IMPORTED_MODULE_0__.Pagination, swiper__WEBPACK_IMPORTED_MODULE_0__.Keyboard, swiper__WEBPACK_IMPORTED_MODULE_0__.Mousewheel]);

/**
 * The carousel panel component is a collapsible panel with a swiper carousel.
 * The content passed to this component determines the content of the carousel. It can either be a component, or pure HTML.
 */
class CarouselPanel extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseComponent {
	/**
	 * Constructor
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options = {}) {
		/**
		 * NOTE:
		 * It's important to be able to use multiple swiper carousels in the same app.
		 * Therefore we need to make sure we're using unique classes to pass to the Swiper config in order that it connects to the correct elements.
		 * Only the classes used for CSS styling should remain the same between multiple swiper carousel instances.
		 */

		const { paginationClass, prevButtonClass, nextButtonClass } = options;

		options.config = {
			direction: 'horizontal',

			speed: 600,
			grabCursor: true,

			touchStartPreventDefault: false,

			slidesPerView: 1,
			spaceBetween: 100,
			keyboard: {
				enabled: true
			},
			mousewheel: {
				forceToAxis: true,
				thresholdDelta: 100
			},

			// Navigation arrows
			navigation: {
				prevEl: `.${prevButtonClass}`,
				nextEl: `.${nextButtonClass}`
			},

			// Conditional pagination if we have a pagination class

			...paginationClass && {
				pagination: {
					el: `.${paginationClass}`,
					type: 'custom',
					renderCustom: (swiper, current, total) => `${current} of ${total}`
				}
			},

			...options.config
		};


		super(app, null, {
			isVisible: false,
			// text
			// note: despite these being fixed values, they only work in the HTML template if they're in state
			preTitle: 'viewing',
			title: 'Panel Title',
			caption: 'This is the panel subtitle',

			// classes
			carouselClass: '',
			paginationClass: '',
			prevButtonClass: '',
			nextButtonClass: '',
			isExpandedClass: 'collapsed',
			tabsVisibleClass: 'hidden',
			tabNumClass: '',

			...options
		});

		/**
		 * Define swiper prop
		 */
		this._swiper = null;

		/**
		 * Define tab inidices.
		 */
		this._tabIndices = null;

		/** Define the active tab index */
		this._activeTabIndex = null;

		/**
		 * All tab elements
		 */
		this._tabElements = null;

		/**
		 * Class name props
		 */
		this._bulletClass = 'swiper-pagination-bullet';
		this._activeBulletClass = 'swiper-pagination-bullet-active';
		this._swiperSlideClass = 'swiper-slide';

		/**
		 * Slide change callback
		 */
		this._onSlideChange = null;

		/**
		 * Does showing the panel also expand it
		 */
		this._expandOnShow = false;

		/**
		 * Orientation store
		 */
		this._orientation = null;

		/**
		 * Resize timeout
		 */
		this._resizeTimeout = null;

		/**
		 * _isInitialized boolean.
		 */
		this._isInitialized = null;

		/**
		 * Create an expandtoggle callback
		 */
		this._eventNames.push('expandtoggle');
		this._initCallbacks();

		// Bind functions.
		this.bindFunctions(['_onTabClick']);
	}

	/**
	 * Add swiper events
	 * NOTE:
	 * Normally, when a components state is determined by the URL, buttons and gestures on the component itself should only update the URL.
	 * However, in the case of swiper, the draggable component needs to be animating BEFORE we know which URL to go to. Therefore we're instead allowing
	 * all of the built in swiping animations, and then changing the URL simultaneously.
	 * We have to be careful with this method to avoid letting the component and URL go out of sync. For unstance, if the user were to manually enter a URL.
	 */
	_addEvents() {
		this._swiper.on('slideChange', params => {
			const { realIndex, previousIndex } = params;
			let bulletIndex = realIndex;

			// Call onSlideChange if set (in sub class)
			typeof this._onSlideChange === 'function' && this._onSlideChange(params);

			// Check if the previous slide had a scrollbar, if so, scroll to top and make sure mousedown is false
			const prevSlideEl = this._children.swiperSlides.childNodes[previousIndex];
			if (prevSlideEl?._scrollInstance) {
				prevSlideEl._isMousedown = false;
				prevSlideEl._scrollInstance.scroll(0);
			}

			// If we have tabs, we may need to toggle the active class for all tab elements.
			if (this._tabElements) {
				const newTabIndex = this._tabIndices.findIndex(({ start, end }) => realIndex >= start && realIndex <= end);

				const { start } = this._tabIndices[newTabIndex];
				bulletIndex -= start;

				if (newTabIndex > -1 && newTabIndex !== this._activeTabIndex) {
					this._tabElements.forEach((tabEl, i) => {
						tabEl.classList.toggle('active', i === newTabIndex);
					});

					this._activeTabIndex = newTabIndex;

					// Make sure we re-create and replace the bullets.
					this._createBullets(bulletIndex);

					return;
				}
			}

			// Update the active bullet
			this._setActiveBullet(bulletIndex);
		});

		// Click event to handle definition overlays
		this._children.swiperSlides.addEventListener('click', event => {
			const definition = event?.target?.dataset?.def;
			if (definition) {
				this._app.getComponent('definitionOverlay').navigateToDefinition(definition);
			}
		});
	}

	/**
	 * Checks whether orientation has changed and sets new orientation.
	 * @returns {boolean}
	 */
	_hasOrientationChanged() {
		const newOrientation = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.isPortrait() ? 'portrait' : 'landscape';
		const orientationChanged = this._orientation !== newOrientation;
		this._orientation = newOrientation;

		return orientationChanged;
	}

	/**
	 * Check the scroll height of each slide to determine whether it requires a scrollbar.
	 */
	_addScrollbars() {
		// Test for orientation change and record orientation.
		const orientationChanged = this._hasOrientationChanged();

		this._children?.swiperSlides?.childNodes?.forEach(slideEl => {
			const { clientHeight, scrollHeight, cHeight, sHeight } = slideEl;

			const heightUnchanged = (cHeight && cHeight === clientHeight) && (sHeight && sHeight === scrollHeight);


			// Return if no height changes.
			if (heightUnchanged && !orientationChanged) {
				return;
			}

			// Destroy old scrollbar if exists.
			slideEl._scrollInstance?.destroy();

			// Get new heights.
			const { clientHeight: newClientHeight, scrollHeight: newScrollHeight } = slideEl;
			slideEl.sHeight = newClientHeight;
			slideEl.cHeight = newScrollHeight;


			// Compare new element heights to see if we need a scrollbar again.
			if (newScrollHeight > newClientHeight) {
				slideEl.classList.add('scrollable');

				slideEl._scrollInstance ??= _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.addScrollbar(slideEl);


				// Add click and drag scrolling (seemingly not included in OverlayScrollbars)
				slideEl._isMousedown = false;
				slideEl._clientY = 0;

				const onMouseMove = ({ clientY }) => {
					if (slideEl._isMousedown) {
						const yDiff = slideEl._clientY - clientY;
						slideEl._scrollInstance.scroll({ y: `+=${yDiff}` });
						slideEl._clientY = clientY;
					}
				};

				slideEl.onmousedown = ({ clientY }) => {
					slideEl._isMousedown = true;
					slideEl._clientY = clientY;

					window.addEventListener('mousemove', onMouseMove);
					window.addEventListener('mouseup', function onMouseUp() {
						slideEl._isMousedown = false;
						window.removeEventListener('mousemove', onMouseMove);
						window.removeEventListener('mouseup', onMouseUp);
					});
				};
			}
		});
	}

	/**
	 * Create tabs with content
	 * @param {Array} allTabsContent
	 */
	createTabs(allTabsContent) {
		// Set  tab  indices to empty array.
		this._tabIndices = [];
		this._activeTabIndex = 0;
		let indexPointer = 0;

		// if we already have a panel, we need to destroy it.
		if (this._swiper) {
			this._destroy();
		}

		// Create the tab elements and append them to tab container.
		this._tabElements = allTabsContent.map(({ title, content }, i) => {
			const tabButtonEl = document.createElement('button');
			tabButtonEl.innerHTML = title;
			tabButtonEl.className = `clickable ${i === this._activeTabIndex ? 'active' : ''}`;
			tabButtonEl.addEventListener('click', this._onTabClick);

			// Add tab start and end indices.
			this._tabIndices.push({
				start: indexPointer,
				end: indexPointer + content.length - 1
			});
			indexPointer += content.length;


			// Create the slide element from the tab data and add slide.
			for (const tabData of content) {
				const slideElements = this._createSlideElements(tabData);
				this.addSlide(slideElements, tabData.onClick);
			}

			return tabButtonEl;
		});

		this._children.tabsContainer.replaceChildren(...this._tabElements);


		// Make sure we set the tabs class to be visible and num tabs class.
		this.setState({
			tabsVisibleClass: '',
			tabNumClass: `tabs-${this._tabElements.length}`
		});
	}

	/**
	 * Create slide elements from tab data
	 * @param {object} tabData - content info
	 * @returns {HTMLElement}
	 */
	_createSlideElements(tabData) {
		const { title, content, value } = tabData;

		const slideElements = [];

		if (title) {
			const titleEl = document.createElement('h4');
			titleEl.className = 'title semi';
			titleEl.innerHTML = title;
			slideElements.push(titleEl);
		}

		if (content) {
			const contentEl = document.createElement('div');
			contentEl.className = 'description';
			contentEl.innerHTML = content;
			slideElements.push(contentEl);
		}

		if (value) {
			const valueEl = document.createElement('div');
			valueEl.className = 'value semi';
			valueEl.innerHTML = value;
			slideElements.push(valueEl);
		}

		return slideElements;
	}

	/**
	 * Create bullet pagination
	 * @param {number} activeBullet
	 */
	_createBullets(activeBullet = 0) {
		const { bullets } = this._children;
		const { slides } = this._swiper;

		let slidesArray = [...slides];
		let startOffset = 0;

		if (this._tabElements) {
			const { start, end } = this._tabIndices[this._activeTabIndex];
			startOffset = start;
			slidesArray = slidesArray.slice(start, end + 1);
		}

		const allBullets = [...slidesArray].map((slide, i) => {
			const bullet = document.createElement('span');
			bullet.classList.add(this._bulletClass);

			// Set slide index.
			bullet.setAttribute('data-slide-index', i + startOffset);

			// Add the click event
			bullet.addEventListener('click', e => {
				const { slideIndex } = e.target.dataset;

				this._swiper.slideTo(slideIndex);
			});

			return bullet;
		});


		// Hide the bullets, replace them, then show them again.
		const onHideFinish = transition => {
			if (transition && transition.propertyName !== 'width') {
				return;
			}

			// Replace the bullets and unhide.
			bullets.replaceChildren(...allBullets);
			bullets.classList.remove('hidden');

			// Set default active bullet to index 0 if initial create
			this._setActiveBullet(activeBullet);
		};

		// Check if already hidden, if so call onHideFinish.
		if (bullets.classList.contains('hidden')) {
			onHideFinish();
		}
		else {
			bullets.classList.add('hidden');
			bullets.ontransitionend = onHideFinish;
			bullets.ontransitioncancel = onHideFinish;
		}
	}

	/**
	 * Makes sure all bullets are deactivated except the passed index
	 * @param {number} activeIndex
	 */
	_setActiveBullet(activeIndex) {
		const { bullets } = this._children;

		bullets.childNodes.forEach((bullet, i) => {
			bullet.classList.remove(this._activeBulletClass);
			if (i === activeIndex) {
				bullet.classList.add(this._activeBulletClass);
			}
		});
	}

	/**
	 * Add an array of elements as a slide to the carousel
	 * @param {Array<HTMLElement>} elements
	 * @param {Function|null} onClick
	 */
	addSlide(elements = [], onClick) {
		const slideEl = document.createElement('div');

		// Determine classes.
		slideEl.className = `${onClick ? 'clickable' : ''} ${this._swiperSlideClass}`;

		// Add click event listener if it exists
		onClick && slideEl.addEventListener('click', onClick);

		slideEl.replaceChildren(...elements);

		this._children.swiperSlides.append(slideEl);
	}

	/**
	 * Wait for slides DOM detection,
	 * create the swiper object,
	 * call post swiper init function
	 * @returns {Promise}
	 */
	initSwiper() {
		const { carouselClass } = this._state;

		const selector = `.${carouselClass} .swiper-wrapper > div`;

		return _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.elementReady(selector)
			.then(() => {
				// If there's already a swiper, update it, add bullet and slide to zero.
				if (this._swiper) {
					this._swiper.update();

					// Add scrollbars and bullets.
					this._addScrollbars();
					this._createBullets();

					this._swiper.slideTo(0);
				}
				else {
					// Otherwise, create it.
					this._swiper = new swiper__WEBPACK_IMPORTED_MODULE_0__["default"](`.${carouselClass}`, this._config);
					this._postSwiperInitFunction(this._swiper);
				}
			});
	}


	/**
	 * Called after swiper is initialized.
	 */
	_postSwiperInitFunction() {
		// Add event handler
		this._addEvents();

		// Add scrollbars
		this._addScrollbars();

		// Add bullets
		this._createBullets();

		//  Slide to zero.
		this._swiper.update();
		this._swiper.slideTo(0);
	}

	/**
	 * Destroy the slider
	 */
	_destroy() {
		this._children.swiperSlides.innerHTML = '';
		clearTimeout(this._resizeTimeout);
	}

	/**
	 * Handles a tab select
	 * @param {Event} e
	 */
	_onTabClick(e) {
		// Slide to correct start index.
		const activeTabIndex = this._tabElements.findIndex(tab => tab === e.target);
		const { start } = this._tabIndices[activeTabIndex];
		this._swiper.slideTo(start);
	}

	/**
	 * Expands panel
	 */
	expand() {
		this.setState({ isExpanded: true, isExpandedClass: 'expanded' });
		this.triggerCallbacks('expandtoggle', [true]);
	}

	/**
	 * Collapses panel
	 */
	collapse() {
		this.setState({ isExpanded: false, isExpandedClass: 'collapsed' });
		this.triggerCallbacks('expandtoggle', [false]);
	}

	/**
	 * Sets expand state and triggers callback
	 * @param {boolean} expanded
	 */
	setExpandState(expanded) {
		this.setState({ isExpanded: expanded, isExpandedClass: expanded ? 'expanded' : 'collapsed' });
		this.triggerCallbacks('expandtoggle', [expanded]);
	}


	/**
	 * Show override can also conditionally expand the panel
	 * @param {boolean} initSwiper
	 */
	show(initSwiper = true) {
		// Init the swiper if the UI is visible and there is content.
		const visibleUI = this._app.getManager('layer').getLayer('ui').visible;
		const hasSwiperContent = this._children.swiperSlides?.childNodes?.length;

		const showFunc = () => {
			if (this._expandOnShow) {
				this.setState({
					isVisible: true,
					isVisibleClass: this._class.isVisible.true,
					isExpanded: true,
					isExpandedClass: 'expanded'
				});

				this.triggerCallbacks('expandtoggle', [true]);
				this.triggerCallbacks('visiblechange', [true]);
			}
			else {
				super.show();
			}
		};

		if (initSwiper && visibleUI && hasSwiperContent) {
			this.initSwiper().then(() => showFunc());
		}
		else {
			showFunc();
		}
	}


	/**
	 * Hide override to also collapse the panel
	 */
	hide() {
		this.setState({
			isVisible: false,
			isVisibleClass: this._class.isVisible.false,
			isExpanded: false,
			isExpandedClass: 'collapsed'
		});

		this.triggerCallbacks('expandtoggle', [false, false]);
		this.triggerCallbacks('visiblechange', [false]);

		// Set init boolean to false only if we're expandingOnShow
		if (this._expandOnShow) {
			this._isInitialized = false;
		}
	}

	/**
	 * Resize.
	 * Updating the scrollbars requires a timeout to wait for other components to finish moving / resizing.
	 */
	resize() {
		// ToDo: Can also use lodash's debounced.
		clearTimeout(this._resizeTimeout);
		this._resizeTimeout = setTimeout(() => {
			this._addScrollbars();
		}, 200);
	}
}

CarouselPanel.html = (_carousel_panel_html__WEBPACK_IMPORTED_MODULE_2___default());
/* harmony default export */ __webpack_exports__["default"] = (CarouselPanel);


/***/ }),

/***/ "../eyes/src/components/carousel_panel/index.js":
/*!******************************************************!*\
  !*** ../eyes/src/components/carousel_panel/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _carousel_panel__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./carousel_panel */ "../eyes/src/components/carousel_panel/carousel_panel.js");








/* harmony default export */ __webpack_exports__["default"] = (_carousel_panel__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/checkbox/checkbox.js":
/*!***************************************************!*\
  !*** ../eyes/src/components/checkbox/checkbox.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Checkbox": function() { return /* binding */ Checkbox; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _checkbox_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkbox.html */ "../eyes/src/components/checkbox/checkbox.html");
/* harmony import */ var _checkbox_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_checkbox_html__WEBPACK_IMPORTED_MODULE_1__);



/**
 * @inheritdoc
 * @extends BaseComponent
 */
class Checkbox extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, null, {
			config: {
				key: '',
				colorClass: '',
				function: null
			},
			isChecked: false,
			text: '',
			checkboxClass: '',
			textClass: '',
			...options
		});

		// Storing class names
		Object.assign(this._class, {
			checkbox: {
				true: 'checked',
				false: ''
			},
			color: {
				true: this._config.colorClass,
				false: ''
			},
			checkmark: {
				true: 'icon-checkmark',
				false: 'checkbox-hover'
			}
		});

		Object.assign(this._state, {
			isCheckedClass: this._class.checkbox[this._state.isChecked],
			colorClass: this._class.color[this._state.isChecked],
			iconCheckmarkClass: this._class.checkmark[this._state.isChecked]
		});

		this.bindFunctions(['toggle']);
	}

	/** @inheritdoc */
	init() {
		super.init();

		if (this._config.key) {
			this._element.setAttribute('key', this._config.key);
		}

		this._element.addEventListener('click', this.toggle);
	}

	/**
	 * Called on clicking checkbox.
	 * @param {PointerEvent} e
	 * @param {boolean} [suppress=false] - Only update states, suppress the function call if True.
	 * @returns {Promise}
	 */
	async toggle(e, suppress = false) {
		const isChecked = !this._state.isChecked;
		const isCheckedClass = this._class.checkbox[isChecked];
		const colorClass = this._class.color[isChecked];
		const iconCheckmarkClass = this._class.checkmark[isChecked];

		this.setState({
			isChecked,
			isCheckedClass,
			colorClass,
			iconCheckmarkClass
		}, async () => {
			if (!suppress && this._config.function instanceof Function) {
				await this._config.function(e);
			}
		});
	}
}

Checkbox.html = (_checkbox_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (Checkbox);


/***/ }),

/***/ "../eyes/src/components/checkbox/index.js":
/*!************************************************!*\
  !*** ../eyes/src/components/checkbox/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _checkbox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./checkbox.js */ "../eyes/src/components/checkbox/checkbox.js");



/* harmony default export */ __webpack_exports__["default"] = (_checkbox_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/clock/clock.js":
/*!*********************************************!*\
  !*** ../eyes/src/components/clock/clock.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Clock": function() { return /* binding */ Clock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _clock_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clock.html */ "../eyes/src/components/clock/clock.html");
/* harmony import */ var _clock_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_clock_html__WEBPACK_IMPORTED_MODULE_2__);




/**
 * @inheritdoc
 * @extends BaseComponent
 */
class Clock extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, null, {
			isVisible: false,
			isDateVisible: true,
			isTimeVisible: true,
			isMeridiemVisible: true,
			allowEdit: true,
			date: 'Date',
			time: 'Time',
			meridiem: '',
			alert: '',
			isKioskSessionTimer: false,
			...options
		});

		Object.assign(this._state, {
			isDateVisibleClass: this._class.isVisible[this._state.isDateVisible],
			isTimeVisibleClass: this._class.isVisible[this._state.isTimeVisible],
			isMeridiemVisibleClass: this._class.isVisible[this._state.isMeridiemVisible]
		});

		this.bindFunctions(['update', 'onDateTimeClick']);
	}

	/** @inheritdoc */
	init() {
		super.init();
		const { allowEdit, isKioskSessionTimer } = this._state;

		this._app.getManager('time').setDateFormats({
			utc: {
				date: 'MMM DD, YYYY',
				time: 'HH[:]mm[:]ss'
			},
			local: {
				date: 'MMM DD, YYYY',
				time: 'hh[:]mm[:]ss',
				meridiem: 'a',
				parse: ['MMM D, YYYY h:m:s a', 'MMM D, YYYY h:m a', 'MMM D, YYYY h a', 'MMM D, YYYY']
			}
		});

		this._app.getManager('time').setDisplayUTC(false);

		const { displayContainer, timeInput, timeForm } = this._children;

		// Time input
		if (allowEdit) {
			displayContainer.classList.add('editable');
			timeInput.addEventListener('keyup', event => {
				event.stopPropagation();
			});
			timeInput.addEventListener('keydown', event => {
				event.stopPropagation();
			});

			// Time form
			timeForm.classList.add('editable');
			timeForm.addEventListener('submit', event => {
				timeInput.blur();
				this._parseTime(timeInput.value);
				event.preventDefault();
			});
			timeInput.addEventListener('blur', _ => {
				timeForm.classList.add('hidden');
				displayContainer.classList.remove('hidden');
			});
		}

		this._setVariables(this._element);

		this._children.date.classList.add('semi');
		this._children.time.classList.add('semi');
		this._children.meridiem.classList.add('semi');
		this._children.timeInput.classList.add('semi');
		this._children.timeForm.classList.add('semi');

		if (!isKioskSessionTimer) {
			this._callbackRegistry.push({
				emitter: this._app.getManager('time'),
				event: 'update',
				callback: this.update
			});
		}
	}

	/**
	 * Handle date/time click
	 */
	onDateTimeClick() {
		const { displayContainer, timeInput, timeForm, date, time, meridiem } = this._children;

		const routeManager = this._app.getManager('router');
		const isStory = routeManager.currentRoute.url.includes('story');

		if (!this._state.allowEdit || isStory) {
			return;
		}
		const meridiemText = this._state.meridiem ? ` ${meridiem.innerHTML}` : '';
		timeInput.value = `${date.innerHTML} ${time.innerHTML}${meridiemText}`;
		displayContainer.classList.add('hidden');
		timeForm.classList.remove('hidden');
		timeInput.focus();
	}

	/**
	 * Checks if time should be Earth Received Time.
	 * @returns {boolean}
	 */
	isERT() {
		return this._isERT;
	}

	/**
	 * Toggle clock field's visibility.
	 * @param {string} field - date, time, or meridiem
	 * @param {boolean} isVisible
	 */
	toggle(field, isVisible) {
		switch (field) {
			case 'date':
				this.setState({
					isDateVisible: isVisible,
					isDateVisibleClass: this._class.isVisible[isVisible]
				});
				break;
			case 'time':
				this.setState({
					isTimeVisible: isVisible,
					isTimeVisibleClass: this._class.isVisible[isVisible]
				});
				break;
			case 'meridiem':
				this.setState({
					isMeridiemVisible: isVisible,
					isMeridiemVisibleClass: this._class.isVisible[isVisible]
				});
				break;
			default:
				break;
		}
	}

	/**
	 * Parse and set time from input value.
	 * @param {string} timeString
	 */
	_parseTime(timeString) {
		const router = this._app.getManager('router');
		const time = this._app.getManager('time').parseTime(timeString, 'parse');
		if (time.isValid()) {
			// If time is UTC, force to UTC
			// Otherwise force to local
			this._app.getManager('time').setDisplayUTC(time.isUTC());
			const timeUrl = this._app.getManager('time').getTimeUrl(time);
			// Navigate to time
			router.navigate({ time: timeUrl }, router.currentRoute.url);
		}
		else {
			console.error('Invalid input: ' + timeString);
			// Remove time from query, which will reset time to now.
			// In case time is not in query, it won't do anything.
			router.navigate({ __remove: ['time'] }, router.currentRoute.url);
		}
	}

	/**
	 * Update time display.
	 * @param {moment} time
	 * @param {boolean} kioskCountdown - if updating a kiosk session timer
	 */
	update(time, kioskCountdown = false) {
		// Don't update if not visible
		if (!this._state.isVisible) {
			return;
		}

		// If a kiosk countdown, only update the clock with the time passed in
		if (kioskCountdown) {
			this.setState({ time });
		}
		else {
			// Update with regular time and date
			this.setState({
				date: time.format(this._app.getManager('time').getDateFormat('date')),
				time: time.format(this._app.getManager('time').getDateFormat('time')),
				meridiem: this._app.getManager('time').isUTC() ? '' : time.format(this._app.getManager('time').getDateFormat('meridiem')),
				alert: this._app.getManager('time').forcedPause ? 'alert' : ''
			});
		}
	}

	/**
	 * Change time rate to 1s/s and time to real time.
	 */
	backToLive() {
		const router = this._app.getManager('router');
		const timeManager = this._app.getManager('time');
		if (!timeManager.isNow()) {
			const time = timeManager.getTimeUrl(timeManager.getNow());
			const oldTime = router.query.time;

			router.navigate({
				__remove: ['time', 'rate']
			}, router.currentRoute.url);

			if (oldTime !== time) {
				timeManager.setTimeRate(1);
				timeManager.setToNow();
			}
		}
	}

	/**
	 * Sets the limit message and calls show/hide.
	 * @param {number} limit - : 1 is max exceeded, -1 is min preceeded
	 * @param {string} message
	 */
	setLimitMessage(limit, message) {
		// Set the limit message.
		const messageTimeMs = 3000;

		let limitMessage;

		if (!message) {
			// Determine limit message.
			const { currentView } = this._app.getManager('router');
			const { _isSpacecraft } = this._app.getView(currentView);
			let messageSuffix = `time ${limit === 1 ? 'maximum' : 'minimum'}`;

			if (currentView === 'event') {
				messageSuffix = `event ${limit === 1 ? 'end' : 'start'}`;
			}
			else if (_isSpacecraft) {
				messageSuffix = `mission ${limit === 1 ? 'end' : 'start'}`;
			}

			limitMessage = limit === 1 ? `"cannot exceed ${messageSuffix}"` : `"cannot preceed ${messageSuffix}"`;
		}
		else {
			limitMessage = `"${message}"`;
		}

		this._children.displayContainer?.style.setProperty('--limit-message', limitMessage);

		// Display the message.
		this._displayLimitMessage(true);

		// Allow time to read then hide the message.
		this.limitMessageTimeout = setTimeout(() => {
			this._displayLimitMessage(false);
		}, messageTimeMs);
	}

	/**
	 * Show or hide the limit message.
	 * @param {boolean} visible
	 */
	_displayLimitMessage(visible) {
		this._children.displayContainer?.classList.toggle('limit', visible);
	}

	/**
	 * Overwritten base __disable.
	 */
	__disable() {
		this._displayLimitMessage(false);
		clearTimeout(this.limitMessageTimeout);

		super.__disable();
	}
}

Clock.html = (_clock_html__WEBPACK_IMPORTED_MODULE_2___default());

/* harmony default export */ __webpack_exports__["default"] = (Clock);


/***/ }),

/***/ "../eyes/src/components/clock/index.js":
/*!*********************************************!*\
  !*** ../eyes/src/components/clock/index.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _clock_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clock.js */ "../eyes/src/components/clock/clock.js");



/* harmony default export */ __webpack_exports__["default"] = (_clock_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/clock_shortcut/clock_shortcut.js":
/*!***************************************************************!*\
  !*** ../eyes/src/components/clock_shortcut/clock_shortcut.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tippy.js */ "../eyes/node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _clock_shortcut_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./clock_shortcut.html */ "../eyes/src/components/clock_shortcut/clock_shortcut.html");
/* harmony import */ var _clock_shortcut_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_clock_shortcut_html__WEBPACK_IMPORTED_MODULE_2__);





/**
 * @inheritdoc
 * @extends BaseComponent
 */
class ClockShortcut extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app, null, {
			hasHover: false,
			liveContainerClass: 'hidden',
			liveClass: 'live',
			liveText: 'live',
			liveIcon: 'icon-live',
			replayClass: 'container',
			replayIcon: 'icon-replay'
		});

		this._state.replayClass = 'hidden';
		this._class.fontSize.small = 'x-small';

		/**
		 * Callback to override back to live behavior.
		 * @type {Function}
		 */
		this._liveCallback = null;

		this.bindFunctions(['_replay', 'backToLive', 'update']);
	}

	/** @inheritdoc */
	init() {
		super.init();

		// This is not dynamic, so switching betweem desktop and mobile will not update these event listeners...
		const { canHover, isTouch } = this._app;
		if (canHover && !isTouch) {
			this._children.liveContainer.addEventListener('mouseenter', () => {
				this.setState({
					hasHover: true,
					liveIcon: 'icon-live'
				});
			});
			this._children.liveContainer.addEventListener('mouseleave', () => {
				this.setState({
					hasHover: false,
					liveIcon: 'icon-back-to-live'
				});
			});
		}

		/**
		 * Set default tippy props
		 * See docs: https://atomiks.github.io/tippyjs/v6/methods/
		 */
		tippy_js__WEBPACK_IMPORTED_MODULE_3__["default"].setDefaultProps({
			theme: 'default',
			touch: ['hold', 2000],
			delay: [600, null],
			plugins: [tippy_js__WEBPACK_IMPORTED_MODULE_3__.followCursor]
		});
		(0,tippy_js__WEBPACK_IMPORTED_MODULE_3__["default"])(this._children.liveContainer, { content: 'Reset time to live.', placement: 'top' });

		this._children.live.classList.add('semi', 'color');
		this._children.replay.classList.add('semi', 'color');

		// Remove replay element
		this._element.removeChild(this._children.replayContainer);

		this._callbackRegistry.push({
			emitter: this._app.getManager('time'),
			event: 'update',
			callback: this.update
		});
	}

	/**
	 * Sets a custom callback for the go back to live button.
	 * @param {Function} callback
	 */
	setCallback(callback) {
		if (typeof callback === 'function') {
			this._liveCallback = callback;
		}
		else {
			this._liveCallback = null;
		}
	}

	/**
	 * Change time rate to 1s/s and time to real time.
	 */
	backToLive() {
		if (typeof this._liveCallback === 'function') {
			this._liveCallback();
		}
		else {
			const router = this._app.getManager('router');
			const timeManager = this._app.getManager('time');
			if (!timeManager.isNow()) {
				const time = timeManager.getTimeUrl(timeManager.getNow());
				const oldTime = router.query.time;

				router.navigate({
					__remove: ['time', 'rate']
				}, router.currentRoute.url);

				if (oldTime !== time) {
					timeManager.setTimeRate(1);
					timeManager.setToNow();
				}
			}
		}
	}

	/**
	 * Change time rate to 1s/s and time to start time.
	 */
	_replay() {
		const navigated = this._app.getManager('router').navigate({ __remove: ['time', 'rate'] });
		if (!navigated) {
			this._app.getManager('time').setTimeRate(1);
			this._app.getManager('time').setToStart();
		}
	}

	/**
	 * Update time display.
	 * @param {moment} time
	 */
	update(time) {
		// Don't update if not visible
		if (!this._state.isVisible) {
			return;
		}
		const isNow = this._app.getManager('time').isNow();
		const now = this._app.getManager('time').getNow();
		const inBounds = this._app.getManager('time').isWithinLimits(now);

		const newState = {
			liveContainerClass: (inBounds === 0) ? (isNow ? 'active' : 'clickable') : 'hidden',
			liveClass: isNow ? 'live' : '',
			replayClass: _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.isMobileMode() ? 'icon icon-box' : 'container'
		};

		if (!this._state.hasHover) {
			newState.liveIcon = isNow ? 'icon-live' : 'icon-back-to-live';
		}
		this.setState(newState);
	}
}

ClockShortcut.html = (_clock_shortcut_html__WEBPACK_IMPORTED_MODULE_2___default());

/* harmony default export */ __webpack_exports__["default"] = (ClockShortcut);


/***/ }),

/***/ "../eyes/src/components/clock_shortcut/index.js":
/*!******************************************************!*\
  !*** ../eyes/src/components/clock_shortcut/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _clock_shortcut_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./clock_shortcut.js */ "../eyes/src/components/clock_shortcut/clock_shortcut.js");




/* harmony default export */ __webpack_exports__["default"] = (_clock_shortcut_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/kiosk_base/kiosk_base.js":
/*!*******************************************************!*\
  !*** ../eyes/src/components/kiosk_base/kiosk_base.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KioskBase": function() { return /* binding */ KioskBase; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _kiosk_base_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./kiosk_base.html */ "../eyes/src/components/kiosk_base/kiosk_base.html");
/* harmony import */ var _kiosk_base_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_kiosk_base_html__WEBPACK_IMPORTED_MODULE_2__);





/**
 * Base kiosk class with autoplay and session timer
 */
class KioskBase extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	static screenLastClicked = Math.ceil(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now());

	/**
	 * Constructor
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options = {}) {
		super(app, null, {
			isVisible: false,
			loadingTextVisibleClass: 'hidden',
			sessionEndVisibleClass: 'hidden',
			autoplayVisibleClass: 'hidden',
			sessionTimerVisibleClass: 'hidden',
			continueButtonVisibleClass: '',
			forceRestartClass: '',
			...options
		});

		this._router = this.app.getManager('router');

		this.inactivityInterval = null;
		this.sessionInterval = null;

		this.timeOfDaySessionStarted = Math.ceil(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now());

		this.componentDefaultVisibility = {
			menu: false,
			shareModal: false,
			infoPanel: false,
			layerPanel: false,
			featuredStoriesPanel: true,
			timecontrolsCollapsible: true
		};
	}

	/**
	 * Initialize kiosk
	 */
	init() {
		super.init();

		const scene = this.app.pioneer.get('main');

		scene.getLoadedPromise().then(() => {
			this.resetLastClicked();
			this.validateQueries();
			const { maxSessionTime, maxInactivityTime, forceRestart } = this._router.configs;

			// Only start session/inactivity countdowns if maxSessionTime/maxInactivityTime is specified and valid
			if (this._isValidTime(maxSessionTime)) {
				this.maxSessionTime = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.minToSec(maxSessionTime);

				this.setUpSessionTimerComponent();
				this.startSessionTimer();

				// Set up session end buttons
				if (forceRestart === true) {
					this.setState({ continueButtonVisibleClass: 'hidden', forceRestartClass: 'force-restart' });
				}
			}

			if (this._isValidTime(maxInactivityTime) && !this.inactivityInterval) {
				this.maxInactivityTime = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.minToSec(maxInactivityTime);
				this.startInactivityTimer();
			}

			return true;
		}).catch(error => {
			console.warn(error);
		});
	}

	/**
	 * Check for invalid queries
	 */
	validateQueries() {
		const { maxSessionTime: maxSessionTimeFromURL, maxInactivityTime: maxInactivityTimeFromURL } = this._router.configs;
		// Maintain current valid query values from router configs
		const queryValues = {};
		for (const [key, value] of Object.entries(this._router.configs)) {
			if (value) {
				queryValues[key] = value;
			}
		}

		// Remove invalid time values from URL
		for (const query in queryValues) {
			if (query.toLowerCase().includes('time') && !this._isValidTime(queryValues[query])) {
				delete queryValues[query];
			}
		}

		const { maxSessionTime, maxInactivityTime } = queryValues;

		// Ensure that session time is always greater than inactivity time to avoid rogue session timer during autoplay
		const bothTimersInURL = this._isValidTime(maxSessionTime) && this._isValidTime(maxInactivityTime);

		if (bothTimersInURL) {
			// Add some time to inactivity time if they're too close in value
			if (Math.abs(maxSessionTimeFromURL - maxInactivityTimeFromURL) <= 0.05 && maxSessionTimeFromURL > 0 && maxInactivityTimeFromURL > 0) {
				queryValues['maxInactivityTime'] = maxSessionTimeFromURL + 0.1;
			}
			// Session timer should always be less than inactivity timer (aka autoplay timer)
			else if (maxSessionTimeFromURL >= maxInactivityTimeFromURL) {
				if (maxInactivityTimeFromURL === 0) {
					// Zero both out if inactivity is 0
					delete queryValues['maxSessionTime'];
				}
				else {
					// Set inactivity timer to be 1 minute longer than session time
					queryValues['maxInactivityTime'] = maxSessionTimeFromURL + 1;
				}
			}
		}

		this._router.setConfig('maxSessionTime', queryValues['maxSessionTime']);
		this._router.setConfig('maxInactivityTime', queryValues['maxInactivityTime']);
	}

	/**
	 * Determine whether the given URL time is a valid entry
	 * @param {number|string} time
	 * @returns {boolean}
	 */
	_isValidTime(time) {
		return time !== '' && !isNaN(Number(time)) && Number(time) > -1;
	}

	/**
	 * Override setEnabled so when the kiosk component is enabled, relevant sub-components are shown (timer, autoplay UI, etc.)
	 * @param {boolean} enabled
	 * @override
	 */
	setEnabled(enabled) {
		super.setEnabled(enabled);

		const { kiosk, maxSessionTime, maxInactivityTime } = this._router.configs;

		if (enabled && (kiosk || this._isValidTime(maxSessionTime) || this._isValidTime(maxInactivityTime))) {
			// Show Kiosk container
			this.show();
		}
	}

	/**
	 * Reset time window was last clicked
	 */
	resetLastClicked() {
		KioskBase.screenLastClicked = Math.ceil(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now());
	}

	/**
	 * Reset session when 'start over' button clicked at the end of the session
	 */
	async sessionStartOverButtonClick() {
		// Show loading text until transition is complete
		this.setState({ loadingTextVisibleClass: '' });

		await this.resetApp();

		this.app.getManager('camera').waitForTransitionComplete().then(() => {
			this.setState({ loadingTextVisibleClass: 'hidden' });
			return null;
		}).catch(error => {
			console.warn('error: ', error);
		});
	}

	/**
	 * Handle behavior when user interacts with the window
	 */
	async onWindowInteract() {
		const { maxSessionTime, maxInactivityTime, forceRestart } = this._router.configs;
		const { kioskAutoplay, kioskSessionEnd } = this._children;
		const inAutoplay = !this.isHidden(kioskAutoplay);
		const sessionOver = !this.isHidden(kioskSessionEnd);

		this.setState({ autoplayVisibleClass: 'hidden' });
		this.setState({ sessionEndVisibleClass: 'hidden' });

		// Don't show 'Starting Experience' while in autoplay or a session
		if ((inAutoplay || sessionOver) && !forceRestart) {
			this.setState({ loadingTextVisibleClass: '' });
		}

		clearInterval(this.inactivityInterval);
		this.inactivityInterval = null;

		// Only do camera transition if clicking to end autoplay
		if (inAutoplay) {
			await this.app.cameraScripts.goToSystem('inner_solar_system');
		}

		// Hide kiosk components if window is interacted with
		this.app.getManager('camera').waitForTransitionComplete().then(() => {
			this.setState({ loadingTextVisibleClass: 'hidden' });
			return null;
		}).catch(error => {
			console.warn('error: ', error);
		});

		this.setState({ sessionEndVisibleClass: 'hidden' });

		this.resetLastClicked();

		// Start new session
		if (this._isValidTime(maxSessionTime) && (inAutoplay || sessionOver)) {
			this.resetSessionTimer();
		}

		if (this._isValidTime(maxInactivityTime)) {
			this.startInactivityTimer();
		}
	}

	/**
	 * Set up the visual session timer countdown component
	 */
	setUpSessionTimerComponent() {
		const sessionClockComponent = this.app.getComponent('kioskSessionClock');
		const { kioskSessionTimer } = this._children;

		sessionClockComponent.setState({ isKioskSessionTimer: true });

		// Show session countdown timer
		sessionClockComponent.show();
		sessionClockComponent.setEnabled(true);
		sessionClockComponent.setParent(kioskSessionTimer);
		this.updateSessionTimerComponent();
	}

	/**
	 * Start session timer
	 */
	startSessionTimer() {
		this.timeOfDaySessionStarted = Math.ceil(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now());

		this.sessionInterval = setInterval(() => {
			this.handleSessionTimer();
		}, 1000);
	}

	/**
	 * Handle behavior after a certain amount of time in a session
	 */
	handleSessionTimer() {
		const { kioskAutoplay } = this._children;
		const inAutoplay = !this.isHidden(kioskAutoplay);
		const now = Math.ceil(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now());
		this.timeElapsed = now - this.timeOfDaySessionStarted;

		this.setState({ sessionTimerVisibleClass: '' });

		// Ongoing session
		if (this.timeElapsed < this.maxSessionTime) {
			this.updateSessionTimerComponent();
		}
		else if (!inAutoplay) {
			// Session end but before autoplay begins
			this.endSession();
		}
	}

	/**
	 * Behavior when the session ends/session timer runs out
	 */
	async endSession() {
		const { forceRestart } = this._router.configs;
		const { kioskSessionEnd } = this._children;

		clearInterval(this.sessionInterval);
		this.sessionInterval = null;

		// Hide session timer and show start over screen
		this.setState({ sessionTimerVisibleClass: 'hidden' });

		if (this.isHidden(kioskSessionEnd)) {
			this.setState({ sessionEndVisibleClass: '' });
		}

		// Only reset to home if force restart, else just reset overlays on session end
		if (forceRestart === true) {
			await this.resetApp();
		}
		else {
			this.resetComponents(this.componentDefaultVisibility);
		}
	}

	/**
	 * Reset the session timer
	 */
	resetSessionTimer() {
		this.timeElapsed = 0;

		this.setUpSessionTimerComponent();

		// Restart session timer
		this.startSessionTimer();
		this.setState({ sessionEndVisibleClass: 'hidden' });
		this.setState({ sessionTimerVisibleClass: '' });
	}

	/**
	 * Update session timer component visually
	 */
	updateSessionTimerComponent() {
		const sessionTimerComponent = this.app.getComponent('kioskSessionClock');

		const formattedCountdownTime = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.formatCountdownTime(this.maxSessionTime * 1000, (this.maxSessionTime - this.timeElapsed) * 1000);
		sessionTimerComponent.update(formattedCountdownTime, true);
	}

	/**
	 * Start inactivity timer
	 */
	startInactivityTimer() {
		this.inactivityInterval = setInterval(() => {
			this.handleMaxInactivityTime();
		}, 1000);
	}

	/**
	 * Handle behavior after a certain amount of time without any activity
	 */
	handleMaxInactivityTime() {
		this.currentTimeWithoutActivity = Math.ceil(pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.now()) - KioskBase.screenLastClicked;
	}

	/**
	 * Behavior when inactivity time runs out and autoplay begins
	 */
	async startAutoplay() {
		// Hide session timer and session end and show autoplay
		this.setState({ sessionTimerVisibleClass: 'hidden' });
		this.setState({ sessionEndVisibleClass: 'hidden' });

		this.setState({ autoplayVisibleClass: '' });

		await this.resetApp();

		// Stop inactivity timer so it doesn't keep counting in the background
		clearInterval(this.inactivityInterval);
		this.inactivityInterval = null;
	}

	/**
	 * Reset layers to default
	 * @param {object} layersToReset
	 */
	resetLayers(layersToReset) {
		if (layersToReset) {
			// Reset layers to defaults
			for (const layer of Object.keys(layersToReset)) {
				const { defaultVisibility } = this.app.getManager('layer').getLayer(layer);
				this.app.getManager('layer').toggleLayer(layer, {}, defaultVisibility);
			}
		}
	}

	/**
	 * Reset components to default visibility
	 * @param {object} componentsToReset
	 */
	resetComponents(componentsToReset) {
		if (componentsToReset) {
			// Hide/show components
			for (const [componentName, showComponent] of Object.entries(componentsToReset)) {
				const component = this.app.getComponent(componentName);
				showComponent ? component?.show() : component?.hide();
				// Expand component if applicable (i.e., time controls)
				this.app.getComponent(componentName)?.setExpanded?.(showComponent);
			}
		}
	}

	/**
	 * Reset app to default state
	 */
	async resetApp() {
		const uiLayers = this.app.getComponent('layerPanel').getCategoriesDisplay();
		const { currentView } = this._router;
		const isAtSystem = this.app.getManager('camera').getContext().context === _internal__WEBPACK_IMPORTED_MODULE_0__.CameraScripts.CONTEXT.SYSTEM;
		const isAtInnerSolarSystem = isAtSystem && this.app.getManager('camera').getContext().id === 'sun';
		const isTransitioning = this.app.getManager('camera').getIsTransitioning();

		this.resetLayers(uiLayers);
		this.resetComponents(this.componentDefaultVisibility);

		// Go to home if not there already
		if (!isAtInnerSolarSystem) {
			this._router.navigate('/home');
		}
		else if (!isTransitioning) {
			// Reset camera to inner solar system
			await this.app.cameraScripts.goToSystem('inner_solar_system');

			if (currentView === 'story') {
				this.app.getComponent('story')?.close();
			}
		}

		// Set time and rate back to real time
		this.app.getManager('camera').waitForTransitionComplete().then(() => {
			const clock = this.app.getComponent('clock');
			clock.backToLive();

			this.app.getManager('layer').toggleLayer('planets', {}, true);
		}).catch(error => {
			console.warn('error: ', error);
		});
	}

	/**
	 * Return if a component is hidden
	 * @param {Element} component
	 * @returns {boolean}
	 */
	isHidden(component) {
		return component?.classList.contains('hidden');
	}
}

KioskBase.html = (_kiosk_base_html__WEBPACK_IMPORTED_MODULE_2___default());


/***/ }),

/***/ "../eyes/src/components/layer_panel/layer_panel.js":
/*!*********************************************************!*\
  !*** ../eyes/src/components/layer_panel/layer_panel.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerPanel": function() { return /* binding */ LayerPanel; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _layer_panel_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./layer_panel.html */ "../eyes/src/components/layer_panel/layer_panel.html");
/* harmony import */ var _layer_panel_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_layer_panel_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Layer panel component.
 * @extends BaseComponent
 */
class LayerPanel extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		// Default configuration
		options.config = {
			layers: options.layers || [],
			checkboxType: options.checkboxType || 'default',
			...options.config
		};

		// Add state options
		super(app, null, {
			isVisible: false,
			ui: app.getManager('layer').getLayer('ui').defaultVisibility,
			planets: app.getManager('layer').getLayer('planets').defaultVisibility,
			asteroids: app.getManager('layer').getLayer('asteroids').defaultVisibility,
			comets: app.getManager('layer').getLayer('comets').defaultVisibility,
			dwarfPlanets: app.getManager('layer').getLayer('dwarfPlanets').defaultVisibility,
			spacecraft: app.getManager('layer').getLayer('spacecraft').defaultVisibility,
			trails: app.getManager('layer').getLayer('trails').defaultVisibility,
			orbits: app.getManager('layer').getLayer('orbits').defaultVisibility,
			labels: app.getManager('layer').getLayer('labels').defaultVisibility,
			icons: app.getManager('layer').getLayer('icons').defaultVisibility,
			starfield: app.getManager('layer').getLayer('starfield').defaultVisibility,
			constellations: app.getManager('layer').getLayer('constellations').defaultVisibility,
			...options
		});

		this._eyesCheck = options.checkboxType === 'eyes';

		// Storing class names
		Object.assign(this._class, {
			checkbox: {
				true: this._eyesCheck ? 'active' : 'active icon-checkmark',
				false: this._eyesCheck ? '' : 'checkbox-hover'
			},
			boxColor: {
				true: 'settings-alt',
				false: ''
			},
			isVisible: {
				true: '',
				false: ''
			}
		});

		// Add default class to state
		Object.assign(this._state, {
			uiClass: this._class.checkbox[this._state.ui],
			uiColorClass: this._class.boxColor[this._state.ui],
			planetsClass: this._class.checkbox[this._state.planets],
			planetsColorClass: this._class.boxColor[this._state.planets],
			asteroidsClass: this._class.checkbox[this._state.asteroids],
			asteroidsColorClass: this._class.boxColor[this._state.asteroids],
			cometsClass: this._class.checkbox[this._state.comets],
			cometsColorClass: this._class.boxColor[this._state.comets],
			dwarfPlanetsClass: this._class.checkbox[this._state.dwarfPlanets],
			dwarfPlanetsColorClass: this._class.boxColor[this._state.dwarfPlanets],
			constellationsClass: this._class.checkbox[this._state.constellations],
			constellationsColorClass: this._class.boxColor[this._state.constellations],
			spacecraftClass: this._class.checkbox[this._state.spacecraft],
			spacecraftColorClass: this._class.boxColor[this._state.spacecraft],
			trailsClass: this._class.checkbox[this._state.trails],
			trailsColorClass: this._class.boxColor[this._state.trails],
			orbitsClass: this._class.checkbox[this._state.orbits],
			orbitsColorClass: this._class.boxColor[this._state.orbits],
			labelsClass: this._class.checkbox[this._state.labels],
			labelsColorClass: this._class.boxColor[this._state.labels],
			iconsClass: this._class.checkbox[this._state.icons],
			iconsColorClass: this._class.boxColor[this._state.icons],
			starfieldClass: this._class.checkbox[this._state.starfield],
			starfieldColorClass: this._class.boxColor[this._state.starfield]
		});

		this._categories = {
			ui: 'User Interface',
			planets: 'Planet',
			asteroids: 'Asteroid',
			comets: 'Comet',
			dwarfPlanets: 'Dwarf Planet',
			spacecraft: 'Spacecraft',
			trails: 'Trail',
			labels: 'Label',
			icons: 'Icons',
			starfield: 'Star Field',
			constellations: 'Constellations'
		};

		this._categoriesDisplay = {
			ui: 'User Interface',
			planets: 'Planets',
			asteroids: 'Asteroids',
			comets: 'Comets',
			dwarfPlanets: 'Dwarf Planets',
			constellations: 'Constellations',
			spacecraft: 'Spacecraft',
			trails: 'Trails',
			orbits: 'Orbits',
			labels: 'Labels',
			icons: 'Icons',
			starfield: 'Star Field'
		};

		this.bindFunctions([
			'toggleLayer',
			'handleLayerToggle'
		]);

		// Store Web animations
		this._fadeInRight = null;
		this._fadeOutRight = null;
		this._fadeInBottom = null;
		this._fadeOutBottom = null;

		this._lastMode = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode();

		this._initCallbacks();
	}

	/**
	 * Get display categories
	 * @returns {object}
	 */
	getCategoriesDisplay() {
		return this._categoriesDisplay;
	}

	/** @inheritdoc */
	resize() {
		super.resize();
		this._updatePosition();
	}

	/** @inheritdoc */
	init() {
		super.init();
		// TODO: This doesnt work for now
		// We need to create the animation just before playing it
		// this._createAnimations();

		this._callbackRegistry.push({
			emitter: this._app.getManager('layer'),
			event: 'toggleLayer',
			callback: this.handleLayerToggle
		});

		const layerPanelBody = this._children.layerPanelBody;
		if (layerPanelBody) {
			layerPanelBody.textContent = '';

			const container = document.createElement('div');
			container.className = 'container';
			this._config.layers.forEach(layerGroup => {
				const blockDiv = document.createElement('div');
				blockDiv.classList.add('block');
				const layersUl = document.createElement('ul');
				layersUl.classList.add('layers');
				layerGroup.forEach(layer => {
					if (this._eyesCheck) {
						// Keep this for now until verify the new Checkbox against Asteroids
						const layerLi = document.createElement('li');
						layerLi.setAttribute('key', layer);
						layerLi.className = `layer-panel-layer item clickable {{${layer}Class}}`;
						const checkboxDiv = document.createElement('div');
						checkboxDiv.classList.add('eyes-checkbox');
						checkboxDiv.innerHTML = `<input type="checkbox" id="layer-panel-checkbox-${layer}" ${this._state[layer] ? 'checked' : ''}><label for="layer-panel-checkbox-${layer}"></label>`;
						layerLi.append(checkboxDiv);

						const nameSpan = document.createElement('span');
						nameSpan.classList.add('small');
						nameSpan.textContent = this._categoriesDisplay[layer];
						layerLi.append(nameSpan);

						layerLi.addEventListener('click', this.toggleLayer);

						layersUl.append(layerLi);
					}
					else {
						const option = new _internal__WEBPACK_IMPORTED_MODULE_0__.Checkbox(this._app, {
							config: {
								key: layer,
								colorClass: this._class.boxColor.true,
								function: this.toggleLayer
							},
							isChecked: this._app.getManager('layer').getLayer(layer).defaultVisibility,
							text: this._categoriesDisplay[layer],
							checkboxClass: 'layer-panel-layer item',
							textClass: 'small'
						});
						option.init();

						this._components.push(option);
						layersUl.appendChild(option.element);
					}
				});
				blockDiv.append(layersUl);
				container.append(blockDiv);
			});

			layerPanelBody.append(container);

			this._setVariables(layerPanelBody);
		}
	}

	/**
	 * Creates animations.
	 */
	_createAnimations() {
		this._fadeOutRight = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
			this._element,
			{ direction: 'right', fade: 'out', yOffset: 0 }
		);
		this._fadeInRight = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
			this._element,
			{ direction: 'right', fade: 'in', yOffset: 0 }
		);
		this._fadeOutBottom = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
			this._element,
			{ direction: 'down', fade: 'out', yOffset: 0 }
		);
		this._fadeInBottom = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
			this._element,
			{ direction: 'down', fade: 'in', yOffset: 0 }
		);
	}

	/**
	 * Resets animations.
	 */
	_resetAnimations() {
		this._fadeInRight.currentTime = 0;
		this._fadeOutRight.currentTime = 0;
		this._fadeInBottom.currentTime = 0;
		this._fadeOutBottom.currentTime = 0;
		this._fadeInRight.pause();
		this._fadeOutRight.pause();
		this._fadeInBottom.pause();
		this._fadeOutBottom.pause();
	}

	/**
	 * Toggles layer and trigger callback.
	 * @param {string} key
	 */
	toggleLayer(key) {
		const layerKey = key.target?.getAttribute('key') ?? key;
		this._app.getManager('layer').toggleLayer(layerKey, { category: this._categories[layerKey] });
	}

	/**
	 * Handles any layer toggle.
	 * @param {string} id
	 * @param {boolean} visible
	 * @param {Array} params
	 */
	handleLayerToggle(id, visible, params) {
		// Keep this for now until verify the new Checkbox against Asteroids
		const keyClass = id + 'Class';
		const colorClass = id + 'ColorClass';
		// Check if layer id is in state.
		if (this.getState(id) !== null) {
			this.setState({
				[id]: visible,
				[keyClass]: this._class.checkbox[visible],
				[colorClass]: this._class.boxColor[visible]
			});

			if (this._eyesCheck) {
				// setVariables doesn't seem to change attributes so we'll set it here
				const layerCheckbox = document.getElementById(`layer-panel-checkbox-${id}`);
				if (layerCheckbox) layerCheckbox.checked = visible;
			}
		}

		// Sync checkbox state in case the layer is toggled elsewhere
		const checkbox = this._components.find(component => component.getConfig().key === id);
		if (checkbox && checkbox.getState('isChecked') !== visible) {
			checkbox.toggle(null, true);
		}
	}

	/**
	 * Check whether a category is enabled.
	 * @param {string} categoryName
	 * @returns {boolean}
	 */
	isCategoryEnabled(categoryName) {
		return !this._children[categoryName]?.classList.contains('disabled');
	}

	/**
	 * Set whether a category is disabled
	 * @param {string} categoryName
	 * @param {boolean} enabled
	 */
	setCategoryEnabled(categoryName, enabled = true) {
		this._children[categoryName]?.classList.toggle('disabled', !enabled);
	}

	/**
	 * Overrides default hide.
	 */
	hide() {
		if (!this.getState('isVisible')) {
			return;
		}
		super.hide();
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode()) {
			this._fadeOutBottom = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
				this._element,
				{ direction: 'down', fade: 'out', yOffset: 0 }
			);
			this._fadeOutBottom.play();
		}
		else {
			this._fadeOutRight = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
				this._element,
				{ direction: 'right', fade: 'out', yOffset: 0 }
			);
			this._fadeOutRight.play();
		}
	}

	/**
	 * Overrides default show.
	 */
	show() {
		super.show();
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode()) {
			this._fadeInBottom = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
				this._element,
				{ direction: 'down', fade: 'in', yOffset: 0 }
			);
			this._fadeInBottom.play();
		}
		else {
			this._fadeInRight = _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils.directionalFade(
				this._element,
				{ direction: 'right', fade: 'in', yOffset: 0 }
			);
			this._fadeInRight.play();
		}
	}

	/**
	 * Updates the position of the panel depending on the resolution.
	 */
	_updatePosition() {
		const currentMode = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobileMode();
		if (currentMode !== this._lastMode) {
			this._lastMode = currentMode;
			if (this._state.isVisible) {
				this.show();
			}
		}
	}

	/**
	 * Overrides default enable.
	 */
	__enable() {
		super.__enable();
		this._createAnimations();
	}

	/**
	 * Overrides default disable.
	 */
	__disable() {
		super.__disable();
		this._fadeInRight = null;
		this._fadeOutRight = null;
		this._fadeInBottom = null;
		this._fadeOutBottom = null;
	}
}

LayerPanel.html = (_layer_panel_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/load_icon/index.js":
/*!*************************************************!*\
  !*** ../eyes/src/components/load_icon/index.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _load_icon_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./load_icon.js */ "../eyes/src/components/load_icon/load_icon.js");



/* harmony default export */ __webpack_exports__["default"] = (_load_icon_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/load_icon/load_icon.js":
/*!*****************************************************!*\
  !*** ../eyes/src/components/load_icon/load_icon.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _load_icon_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./load_icon.html */ "../eyes/src/components/load_icon/load_icon.html");
/* harmony import */ var _load_icon_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_load_icon_html__WEBPACK_IMPORTED_MODULE_1__);



/**
 * @inheritdoc
 * @extends BaseComponent
 */
class LoadIcon extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/** @inheritdoc */
	init() {
		super.init();

		this._callbackRegistry.push(
			{
				emitter: this._app.getManager('scene'),
				event: 'loading',
				callback: this.show
			},
			{
				emitter: this._app.getManager('scene'),
				event: 'loaded',
				callback: this.hide
			}
		);

		this.hide();
	}
}

LoadIcon.html = (_load_icon_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (LoadIcon);


/***/ }),

/***/ "../eyes/src/components/overlay/index.js":
/*!***********************************************!*\
  !*** ../eyes/src/components/overlay/index.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./overlay.js */ "../eyes/src/components/overlay/overlay.js");



/* harmony default export */ __webpack_exports__["default"] = (_overlay_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/overlay/overlay.js":
/*!*************************************************!*\
  !*** ../eyes/src/components/overlay/overlay.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _overlay_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./overlay.html */ "../eyes/src/components/overlay/overlay.html");
/* harmony import */ var _overlay_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_overlay_html__WEBPACK_IMPORTED_MODULE_2__);




/**
 * Overlay component.
 * @extends BaseComponent
 */
class Overlay extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, null, {
			isVisible: false,
			isOpenButtonVisible: true,
			content: null,
			...options
		});

		this._class.isOpenButtonVisibleClass = {
			true: '',
			false: 'hidden'
		};

		Object.assign(this._state, {
			isOpenButtonVisibleClass: this._class.isOpenButtonVisibleClass[this._state.isOpenButtonVisible]
		});

		/**
		 * Scrollbar library instance.
		 * @type {OverlayScrollbars}
		 */
		this._scrollbar = null;
	}

	/** @inheritdoc */
	init() {
		super.init();

		if (this._state.content !== null) {
			this._children.overlayContent.appendChild(this._state.content);
		}

		// Hide overlay when clicking on it
		this._element.addEventListener('click', this.hide);

		// Hide overlay after fading out completes
		this._element.addEventListener('animationend', () => {
			if (this._children.overlay.classList.contains('hidden')) {
				this._children.overlay.style.display = 'none';
			}
		});
	}

	/**
	 * Set content of overlay.
	 * @param {HTMLElement} element
	 */
	setContent(element) {
		if (this._state.content === null) {
			this._children.overlayContent.appendChild(element);
		}
		else {
			this._children.overlayContent.replaceChild(element, this._state.content);
		}

		this._state.content = element;
	}

	/**
	 * Show overlay.
	 */
	show() {
		this._element.classList.add('initialized');
		this._children.overlay.style.display = '';
		super.show();
	}

	/**
	 * Enables the component.
	 * @abstract
	 * @package
	 */
	__enable() {
		super.__enable();

		if (this._scrollbar === null) {
			// Wait until element is attached to DOM, then add scrollbar
			_internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.onAttachElement(this._children.overlay, () => {
				this._scrollbar = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.addScrollbar(this._children.overlay);
			});
		}
		else {
			this._scrollbar.scroll(0);
		}
	}
}

Overlay.html = (_overlay_html__WEBPACK_IMPORTED_MODULE_2___default());

/* harmony default export */ __webpack_exports__["default"] = (Overlay);


/***/ }),

/***/ "../eyes/src/components/search/index.js":
/*!**********************************************!*\
  !*** ../eyes/src/components/search/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _search_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./search.js */ "../eyes/src/components/search/search.js");



/* harmony default export */ __webpack_exports__["default"] = (_search_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/search/search.js":
/*!***********************************************!*\
  !*** ../eyes/src/components/search/search.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _search_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./search.html */ "../eyes/src/components/search/search.html");
/* harmony import */ var _search_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_search_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * @inheritdoc
 * @extends BaseComponent
 */
class Search extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 * @param {object} [options.config={}]
	 */
	constructor(app, options = { config: {} }) {
		/**
		 * @property {object} options.config
		 * @property {boolean} [options.config.initialOpen=false]
		 * @property {boolean} [options.config.allowFeatured=false]
		 * @property {boolean} [options.config.allowDetail=true]
		 * @property {boolean} [options.config.allowInfo=false]
		 * @property {boolean} [options.config.stopOnExactMatch=false]
		 * @property {object} options.config.infoText
		 * @property {string} [options.config.infoText.default='most popular']
		 * @property {string} [options.config.infoText.results='result']
		 * @property {string} [options.config.infoText.suggestions='suggestion']
		 * @property {string} [options.config.infoText.nomatches='no matches']
		 * @property {number} [options.config.maxSuggestions=1]
		 * @property {string} [options.config.placeholderText='Search...']
		 * @property {string[]} [options.config.nameSearch=['id', 'name']] - Array of keys to try to search for item's name
		 * @property {string[]} [options.config.nameDisplay=['name', 'id']] - Array of keys to try to display item's name
		 */
		options.config = {
			initialOpen: false,
			allowFeatured: false,
			allowDetail: true,
			allowInfo: false,
			stopOnExactMatch: false,
			infoText: {
				default: 'most popular',
				results: 'result',
				suggestions: 'suggestion',
				nomatches: 'no matches'
			},
			maxSuggestions: 1,
			placeholderText: 'Search...',
			nameSearch: ['iauName', 'displayName'],
			nameDisplay: ['displayName', 'iauName'],
			...options.config
		};

		super(app, null, {
			text: '',
			searchInfo: options.config?.infoText?.default || '',
			alwaysOpen: false,
			magClass: 'mag-open',
			searchClass: 'search-close',
			focusedClass: '',
			isFeaturedVisible: false,
			...options
		});

		this._class.isItemVisible = {
			true: '',
			false: 'hidden'
		};

		Object.assign(this._state, {
			allowFeaturedClass: this._class.isItemVisible[this._config.allowFeatured],
			isFeaturedVisibleClass: this._class.isItemVisible[this._config.allowFeatured && this._state.isFeaturedVisible],
			allowInfoClass: this._class.isItemVisible[this._config.allowInfo]
		});

		this._eventNames.push('resultselected');
		this._initCallbacks();

		/**
		 * Scrollbar for result list.
		 */
		this._resultsScrollbar = null;

		/**
		 * Scrollbar for featured list.
		 */
		this._featuredScrollbar = null;

		/**
		 * Function to call on window resize.
		 * @type {Function}
		 */
		this.onResize = null;

		/**
		 * Result list to display.
		 * @type {Array}
		 */
		this.results = [];

		/**
		 * A list of item ids to filter out of the search results
		 * @type {Array<string>}
		 */
		this._excludeResults = [];

		/**
		 * Threshold for Fuse score of suggestions.
		 * @type {number}
		 */
		this._suggestionsThreshold = 0.05;

		/**
		 * Index of the selected entry.
		 * @type {number}
		 */
		this.index = -1;

		this.bindFunctions([
			'_find',
			'renderResults',
			'open',
			'close',
			'eraseInput',
			'onIconClick',
			'reset',
			'keydown',
			'onInputFocus',
			'_getDetails',
			'_handleClick'
		]);

		window.addEventListener('setupSearch', this.resize);
	}

	/** @inheritdoc */
	init() {
		super.init();

		// Make sure placeholder text fully visible in the input
		const size = this._children.input.getAttribute('placeholder').length * 0.9;
		this._children.input.style.minWidth = `${size}ch`;


		this._children.input.onkeyup = event => {
			const isFeaturedVisible = this._children.input.value.length === 0;
			if (this._config.allowFeatured && isFeaturedVisible !== this._state.isFeaturedVisible) {
				// Scroll to the top.
				this._featuredScrollbar?.scroll(0);
				// Set visible and text states.
				this.setState({
					isFeaturedVisible,
					isFeaturedVisibleClass: this._class.isItemVisible[isFeaturedVisible],
					...isFeaturedVisible && { searchInfo: this._config.infoText.default }
				});
			}
		};

		this.resize();

		this.registerManager(this._app.getManager('search'));
	}

	/**
	 * Execute actions when click on magnifier.
	 */
	onIconClick() {
		const currentlyClosed = this._state.searchClass === 'search-close';

		if (currentlyClosed) {
			this._scrollbar?.scroll(0);
			this.open();
			this._children.input.focus();
		}
		else {
			if (this._children.input.value === '') {
				this.reset();
			}
			else {
				this._children.results.querySelector('.active')?.firstChild.click();
			}
		}
	}

	/**
	 * Triggers when window is resizing.
	 */
	resize() {
		super.resize();

		if (typeof this.onResize === 'function') {
			this.onResize();
		}
	}

	/**
	 * Clear input and close panel.
	 */
	reset() {
		this.eraseInput();
		if (!this._config.initialOpen) {
			this.close();
		}
	}

	/**
	 * Handles keypress when focused on the search input field.
	 * @param {object} e - Keypress event
	 */
	keydown(e) {
		const key = e.key;

		if (key === 'Escape') {
			this.eraseInput();
			this.close();
		}

		const total = this.results.length;
		if (!total) {
			return;
		}

		// Arrow Down
		if (key === 'ArrowDown') {
			this.index = (this.index + 1) % total;
			e.preventDefault();
		}
		// Arrow Up
		else if (key === 'ArrowUp') {
			this.index -= 1;
			if (this.index < 0) {
				this.index = total - 1;
			}
			e.preventDefault();
		}
		// Enter
		else if (key === 'Enter') {
			// Fly to the selected search or the first one
			this._handleClick(this.results[this.index]?.link || this.results[0]?.link, this._searchString);
			e.preventDefault();
		}
		this.setSelected(this.index);
	}

	/**
	 * Set up selected index and state.
	 * @param {number} index - Current index of the selected element
	 */
	setSelected(index) {
		this.index = index;

		for (let i = 0; i < this.results.length; i++) {
			const element = this.results[i].element;
			if (!element) {
				continue;
			}
			if (i === this.index) {
				element.classList.add('active');
			}
			else {
				element.classList.remove('active');
			}
		}
	}

	/**
	 * Execute actions when input has focus.
	 */
	onInputFocus() {
		this.setState({
			focusedClass: 'input-focused'
		});
	}

	/**
	 * Erase search input.
	 */
	eraseInput() {
		this._resultsScrollbar?.destroy();
		this._resultsScrollbar = null;

		this._children.input.value = '';
		this._children.results.innerHTML = '';
	}

	/**
	 * Registers a search manager.
	 * @param {object} searchManager
	 */
	registerManager(searchManager) {
		this._searchManager = searchManager;
	}

	/**
	 * Applies search using either event from the window or text that is passed.
	 * @param {object} event
	 * @param {string} text
	 */
	_find(event, text) {
		if (this._searchTimeout) {
			clearTimeout(this._searchTimeout);
		}

		if (event && event.target && event.target.value) {
			text = event.target.value;
		}

		const { maxEntries } = this._config;

		this._searchTimeout = setTimeout(async () => {
			if (this._searchManager) {
				const results = this._searchManager.find(text, maxEntries);

				// Filter results if we have anything in the excludeResults array.
				const filteredResults = results?.length && this._excludeResults?.length ?
					results.filter(({ item }) => !this._excludeResults.includes(item.id)) :
					results;

				await this.renderResults(filteredResults, text);
			}
		}, 100);
	}

	/**
	 * Renders html elements based on the results.
	 * @param {Fuse.FuseResult} results
	 * @param {string} text - text that was searched for the results
	 */
	async renderResults(results, text) {
		this.index = -1;
		this.results = [];
		this._searchString = text;

		this._resultsScrollbar?.destroy();
		this._resultsScrollbar = null;

		this._children.results.innerHTML = '';
		this._children.results.classList.remove('no-results');

		if (!results || !Array.isArray(results)) {
			return;
		}

		// Separate candidates from suggestions
		const suggestions = [];
		const candidates = [];
		for (let i = 0; i < results.length; i++) {
			const result = results[i];
			const { nameSearch } = this._config;
			const name = result.item[nameSearch.find(key => result.item[key] !== undefined)];
			// Check for a perfect match on name
			if (this._config.stopOnExactMatch && text.toLowerCase() === name.toLowerCase()) {
				candidates.length = 0;
				suggestions.length = 0;
				candidates.push(result);
				break;
			}

			if (result.score < this._suggestionsThreshold) {
				candidates.push(result);
			}
			else {
				suggestions.push(result);
			}
		}

		// Perfect match
		if (candidates.length === 1) {
			if (this._config.allowDetail) {
				// TODO: Do not re render if this is the same result
				await this._renderResultCard(candidates[0], text);
			}
			else {
				this._renderResultList(candidates, text);
			}
		}
		else if (candidates.length === 0) {
			// No results
			this._renderSuggestions(suggestions, text);
		}
		else {
			// Multiple matches
			this._renderResultList(candidates, text);
		}

		// Add scrollbar
		if (candidates.length > 3) {
			this._resultsScrollbar ??= this._createScrollbar(this._children.results);
		}

		// Update info text if it's allowed.
		const { allowInfo, infoText, maxSuggestions } = this._config;

		if (allowInfo) {
			let searchInfo = infoText.nomatches;

			if (candidates.length) {
				searchInfo = `${candidates.length} ${infoText.results}${candidates.length > 1 ? 's' : ''}`;
			}
			else if (suggestions.length) {
				searchInfo = `${Math.min(suggestions.length, maxSuggestions)} ${infoText.suggestions}${suggestions.length > 1 ? 's' : ''}`;
			}

			this.setState({ searchInfo });
		}
		// select the first entry by default
		this.setSelected(0);
	}

	/**
	 * Renders a single detailed result card.
	 * @param {Fuse.FuseResult} result
	 * @param {string} text - the search string
	 */
	async _renderResultCard(result, text) {
		try {
			let details = await this._getDetails(result);
			if (!details && result && result.item) {
				const { nameDisplay } = this._config;
				details = {
					title: result.item[nameDisplay.find(key => result.item[key] !== undefined)]
				};
			}

			// Card title
			const div = document.createElement('div');
			div.className = 'card-title result-div';

			const h4 = document.createElement('h4');
			h4.className = 'semi clickable';

			let innerHTML = details.title;
			if (typeof innerHTML === 'string') {
				const index = innerHTML.toUpperCase().indexOf(text.toUpperCase());
				if (index > -1) {
					const sub = innerHTML.substring(index, index + text.length);
					const splitted = innerHTML.split(sub);

					if (splitted && splitted.length === 2) {
						innerHTML = '';
						if (splitted[0].length > 0) {
							innerHTML += `<span class='unmatch'>${splitted[0]}</span>`;
						}
						innerHTML += sub;
						if (splitted[1].length > 0) {
							innerHTML += `<span class='unmatch'>${splitted[1]}</span>`;
						}
					}
				}
			}
			else {
				innerHTML = '';
			}

			h4.innerHTML = innerHTML;
			const link = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addStartToPath(result.item.id);
			h4.addEventListener('mouseover', () => {
				this.setSelected(0);
			}, false);
			h4.addEventListener('click', e => {
				if (result.item) {
					this._handleClick(result.item.id, text);
				}
				e?.stopPropagation?.();
			}, false);
			div.appendChild(h4);
			this.results.push({ link, element: div });

			// TODO: Display icon instead of image

			this._children.results.innerHTML = '';
			this._children.results.appendChild(div);

			if (details.cards) {
				this._createStoryBlock(details.cards);
			}

			if (details.featuredEvents && details.featuredEvents.initial) {
				this._createEventsBlock(details.featuredEvents.initial, result.item.id);
			}

			if (details.exploration && details.exploration.initial) {
				this._createExplorationBlock(details.exploration.initial);
			}

			if (details.featuredMoons) {
				this._createMoonsBlock(details.featuredMoons, result.item.id);
			}
			// TODO: No need for that right now
			// if (details.custom) {
			// 	for (let i = 0; i < details.custom.length; i++) {
			// 		const custom = details.custom[i];
			// 		this._createChunk(custom.entries, custom.title, text);
			// 	}
			// }
		}
		catch (err) {
			// Render one line if details not found
			if (err.status !== undefined && err.status === 404) {
				this._renderResultList([result], text);
			}
			else if (err) {
				console.error(err);
			}
		}
	}

	/**
	 * Creates a block of events in the results.
	 * @param {string[]} featuredItems
	 * @param {string} result
	 */
	_createEventsBlock(featuredItems, result) {
		if (!Array.isArray(featuredItems) || featuredItems.length === 0) {
			return;
		}
		const entityInfo = this._app.getManager('content').getEntityInfo(result);
		if (entityInfo === null || !entityInfo.hasEvents) {
			return;
		}

		// Container
		const container = this._createBlockContainer();
		container.classList.add('events');

		// Title
		const title = 'Featured Events';
		this._createHeaderBlock(title, container);

		// Items
		for (let i = 0; i < featuredItems.length; i++) {
			const event = featuredItems[i];
			const text = event.title;
			const link = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addStartToPath(result + '/events/' + event.eventId);
			const element = this._createSingleResult(text, link, container);
			this.results.push({ link, element });
		}
	}

	/**
	 * Creates a block of Moons in the results.
	 * @param {object[]} featuredItems
	 */
	_createMoonsBlock(featuredItems) {
		if (!Array.isArray(featuredItems) || featuredItems.length === 0) {
			return;
		}

		// Container
		const container = this._createBlockContainer();
		container.classList.add('moons');

		// Title
		const title = 'Featured Moons';
		this._createHeaderBlock(title, container);

		// Items
		for (let i = 0; i < featuredItems.length; i++) {
			const text = featuredItems[i];
			const link = featuredItems[i];
			const element = this._createSingleResult(text, link, container);
			this.results.push({ link, element });
		}
	}

	/**
	 * Creates a block of events in the results.
	 * @param {object[]} featuredItems
	 */
	_createExplorationBlock(featuredItems) {
		if (!Array.isArray(featuredItems) || featuredItems.length === 0) {
			return;
		}

		// Container
		const container = this._createBlockContainer();
		container.classList.add('exploration');

		// Title
		const title = 'Exploration';
		this._createHeaderBlock(title, container);

		// Items
		for (let i = 0; i < featuredItems.length; i++) {
			const event = featuredItems[i];
			let text = event.title;
			if (event.info !== null && event.info !== undefined) {
				text += ' (' + event.info + ')';
			}
			const link = event.url;
			const element = this._createSingleResult(text, link, container);
			this.results.push({ link, element });
		}
	}

	/**
	 * Creates a block of stories in the results.
	 * @param {object[]} cards
	 */
	_createStoryBlock(cards) {
		if (!Array.isArray(cards) || cards.length === 0) {
			return;
		}

		// Container
		const container = this._createBlockContainer();
		container.classList.add('stories');

		// Title
		const title = 'Stories';

		// Items
		let storyResults = false;
		for (let i = 0; i < cards.length; i++) {
			const card = cards[i];
			// Only populate stories for now
			if (card.storyId !== undefined) {
				const story = this._app.getManager('content').getStoryList().stories[card.storyId];
				if (story !== undefined) {
					// Only create the header block if at least one story is being returned.
					if (!storyResults) {
						this._createHeaderBlock(title, container);
						storyResults = true;
					}
					const text = story.title;
					const link = '/story/' + card.storyId;
					const element = this._createSingleResult(text, link, container);
					this.results.push({ link, element });
				}
			}
		}
	}

	/**
	 * Creates a block container to group results.
	 * @returns {HTMLElement}
	 */
	_createBlockContainer() {
		const blockContainer = document.createElement('div');
		blockContainer.className = 'block-container';
		this._children.results.appendChild(blockContainer);
		return blockContainer;
	}

	/**
	 * Creates a header for each block of results.
	 * @param {string} title
	 * @param {HTMLElement} container
	 */
	_createHeaderBlock(title, container) {
		const titleDiv = document.createElement('div');
		titleDiv.className = 'header';

		const lineTitle = document.createElement('span');
		lineTitle.className = 'title small semi';
		lineTitle.innerHTML = title;
		titleDiv.appendChild(lineTitle);

		container.appendChild(titleDiv);
	}

	/**
	 * Creates a result data buttton.
	 * @param {string} title
	 * @param {string} link
	 * @param {HTMLElement} container
	 * @returns {HTMLElement}
	 */
	_createSingleResult(title, link, container) {
		const entryDiv = document.createElement('div');
		entryDiv.className = 'result-div';
		const entryButton = document.createElement('button');
		entryButton.className = 'small clickable capitalize';
		entryButton.innerHTML = title;
		const index = (this.results.length - 1) + 1; // Must take into account card title

		// Add click callback
		entryDiv.addEventListener('click', e => {
			this._handleClick(link, this._searchString);
			e?.stopPropagation?.();
		}, false);
		entryDiv.addEventListener('mouseover', () => {
			this.setSelected(index);
		}, false);

		entryDiv.appendChild(entryButton);
		container.appendChild(entryDiv);

		return entryDiv;
	}

	/**
	 * Renders a list of results.
	 * @param {Fuse.FuseResult} results
	 * @param {string} text
	 */
	_renderResultList(results, text) {
		for (let i = 0; i < results.length; i++) {
			const result = results[i].item;
			const { nameSearch } = this._config;
			const generalName = result[nameSearch.find(key => result[key] !== undefined)];

			if (!generalName) {
				continue;
			}

			const button = document.createElement('button');
			button.className = 'entries clickable thin small';
			const url = result.url || result.id;
			let innerHTML = generalName;
			const index = generalName.toUpperCase().indexOf(text.toUpperCase());
			if (index > -1) {
				const sub = innerHTML.substring(index, index + text.length);
				innerHTML = innerHTML.replace(sub, `<span class='semi'>${sub}</span>`);
			}
			button.innerHTML = innerHTML;
			const link = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addStartToPath(url);

			const div = document.createElement('div');
			div.className = 'result-div';
			div.appendChild(button);

			div.addEventListener('mouseover', () => {
				this.setSelected(i);
			}, false);
			div.addEventListener('click', e => {
				this._handleClick(url, text);
				e?.stopPropagation?.();
			}, false);

			this.results.push({ link, element: div });

			this._children.results.appendChild(div);
		}
	}

	/**
	 * Renders suggested items.
	 * @param {Fuse.FuseResult} results
	 * @param {string} text
	 */
	_renderSuggestions(results, text) {
		const div = document.createElement('div');
		div.className = 'suggestion';

		// Add suggestions
		if (results.length > 0) {
			const label = document.createElement('label');
			label.className = 'title small semi';
			label.innerHTML = 'Did you mean...?';
			div.appendChild(label);

			for (let i = 0; i < Math.min(this._config.maxSuggestions, results.length); i++) {
				const button = document.createElement('button');
				button.className = 'entries clickable';
				const result = results[i].item;
				const { nameSearch } = this._config;
				const generalName = result[nameSearch.find(key => result[key] !== undefined)];
				if (generalName) {
					const url = result.url || result.id;
					button.innerHTML = generalName;
					const link = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addStartToPath(url);
					button.addEventListener('mouseover', () => {
						this.setSelected(i);
					}, false);
					button.addEventListener('click', e => {
						this._handleClick(url, text);
						e?.stopPropagation?.();
					}, false);

					const buttonDiv = document.createElement('div');
					buttonDiv.className = 'result-div small';
					buttonDiv.appendChild(button);
					div.appendChild(buttonDiv);
					this.results.push({ link, element: buttonDiv });
				}
			}
		}
		else if (!this._config.allowInfo) {
			const label = document.createElement('label');
			label.className = 'title no-match small';
			label.innerHTML = 'No matches.';
			div.appendChild(label);
			this._children.results.classList.add('no-results');
		}

		this._children.results.appendChild(div);
	}

	/**
	 * Open search bar.
	 */
	open() {
		this.setState({
			magClass: 'mag-close',
			searchClass: 'search-open',
			isFeaturedVisible: this._config.allowFeatured,
			isFeaturedVisibleClass: this._class.isItemVisible[this._config.allowFeatured],
			...this._config.allowFeatured && { searchInfo: this._config.infoText.default }
		});

		// Set isSearching to true.
		this.app.isSearching = true;
	}

	/**
	 * Close search bar.
	 */
	close() {
		if (this.getState('alwaysOpen')) {
			this.setState({
				magClass: 'mag-close',
				searchClass: 'search-open',
				focusedClass: '',
				isFeaturedVisible: false,
				isFeaturedVisibleClass: this._class.isItemVisible.false
			});
		}
		else {
			this.setState({
				magClass: 'mag-open',
				searchClass: 'search-close',
				focusedClass: '',
				isFeaturedVisible: false,
				isFeaturedVisibleClass: this._class.isItemVisible.false
			});
		}
		// Take focus away from input.
		this._children.input?.blur();

		// Set isSearching to false.
		this.app.isSearching = false;
	}

	/**
	 * Setup featured suggestion panel.
	 * If no info, clear the panel.
	 * @param {Array} [info=[]]
	 */
	setupFeaturedSuggestion(info = []) {
		// Clear the panel
		this._children.featured.innerHTML = '';

		// Populate the panel with info
		for (let i = 0; i < info.length; i++) {
			const { text, url } = info[i];
			const li = document.createElement('li');
			li.innerHTML = text;
			li.className = 'clickable thin';
			li.addEventListener('click', e => {
				this._handleClick(url, this._searchString);
				e?.stopPropagation?.();
			});
			this._children.featured.appendChild(li);
		}
	}

	/**
	 * Create scrollbar.
	 * @param {HTMLElement} parentEl - the parent element of the overflowing element
	 * @returns {object}
	 */
	_createScrollbar(parentEl) {
		return _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addScrollbar(parentEl, {
			sizeAutoCapable: true
		});
	}

	/**
	 * Gets parsed link if available.
	 * @param {string} link
	 * @returns {string|object}
	 */
	_getLink(link) {
		return link;
	}

	/**
	 * Handle click on the search result.
	 * @param {string} link - url link
	 * @param {string} text - search text
	 */
	_handleClick(link, text) {
		// Check for link
		if (!link) {
			return;
		}

		this.reset();
		this.triggerCallbacks('resultselected');

		const router = this._app.getManager('router');

		// Get parsed link if available.
		const parsedLink = this._getLink(link);

		const linkPath = typeof parsedLink === 'string' ? parsedLink : (parsedLink.path ?? '');

		if (linkPath.includes('events')) {
			router.navigate({}, linkPath, { __remove: 'all' });
		}
		else {
			const {
				options = { keepTime: true },
				query = {}
			} = typeof parsedLink === 'object' && parsedLink;

			// Go to the object, maintaining time query if it exists.
			router.navigate(query, linkPath, options);
		}
	}

	/**
	 * Manually simulate a search without typing
	 * @param {string} text
	 */
	simulate(text) {
		const { input } = this._children;

		this.onIconClick();
		input.value = text;
		this._find({}, text);
		input.onkeyup();
	}

	/**
	 * Get details for a result.
	 * @param {Fuse.FuseResult} result
	 * @returns {Promise}
	 */
	async _getDetails(result) {
		return this._app.getManager('content').getEntityDesc(result.item.id);
	}

	/**
	 * Sets the this._excludeResults list
	 * @param {Array<string>} excludeResults
	 */
	setExcludeResults(excludeResults) {
		this._excludeResults = excludeResults;
	}

	/**
	 * Enables the component.
	 * @abstract
	 * @package
	 */
	__enable() {
		super.__enable();

		// If allowFeatured and featured parent is in the DOM, create featured scrollbar.
		const { allowFeatured } = this._config;
		if (allowFeatured) {
			const { parentElement: featuredParentEl } = this._children.featured || {};
			const parentInDOM = document.body.contains(featuredParentEl);

			if (parentInDOM) {
				this._featuredScrollbar ??= this._createScrollbar(featuredParentEl);
			}
		}
	}
}

Search.html = (_search_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (Search);


/***/ }),

/***/ "../eyes/src/components/settings/index.js":
/*!************************************************!*\
  !*** ../eyes/src/components/settings/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _settings_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./settings.js */ "../eyes/src/components/settings/settings.js");




/* harmony default export */ __webpack_exports__["default"] = (_settings_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/settings/settings.js":
/*!***************************************************!*\
  !*** ../eyes/src/components/settings/settings.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var screenfull__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! screenfull */ "../eyes/node_modules/screenfull/index.js");
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tippy.js */ "../eyes/node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _settings_html__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./settings.html */ "../eyes/src/components/settings/settings.html");
/* harmony import */ var _settings_html__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_settings_html__WEBPACK_IMPORTED_MODULE_3__);







/**
 * @inheritdoc
 * @extends BaseComponent
 */
class Settings extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		const config = {
			isCollapsible: true,
			allowToggleUnit: false,
			allowLayers: true,
			allowZoom: true,
			allowFullscreen: screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].isEnabled,
			allowPhotoMode: false,
			allowInfoPanel: true,
			allowLighting: true,
			showLightOptions: false,
			allowGuidedCamera: false,
			zoomIn: app.getManager('camera').zoomIn,
			zoomOut: app.getManager('camera').zoomOut,
			...options.config
		};
		delete options.config;

		config.orientation = {
			bigPortrait: {
				check: config.orientation?.bigPortrait?.check || (() => _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isPortrait() && !_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isMobilePortrait() && !_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isTabletPortrait()),
				ori: config.orientation?.bigPortrait?.ori || 'vertical'
			},
			tabletPortrait: {
				check: config.orientation?.tabletPortrait?.check || (() => _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isTabletPortrait()),
				ori: config.orientation?.tabletPortrait?.ori || 'vertical'
			},
			smallPortrait: {
				check: config.orientation?.smallPortrait?.check || (() => _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isMobilePortrait()),
				ori: config.orientation?.smallPortrait?.ori || 'vertical'
			},
			bigLandscape: {
				check: config.orientation?.bigLandscape?.check || (() => _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isLandscape() && !_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isMobileLandscape() && !_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isTabletLandscape()),
				ori: config.orientation?.bigLandscape?.ori || 'vertical'
			},
			tabletLandscape: {
				check: config.orientation?.tabletPortrait?.check || (() => _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isTabletLandscape() || _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isPanorama()),
				ori: config.orientation?.tabletPortrait?.ori || 'vertical'
			},
			smallLandscape: {
				check: config.orientation?.smallLandscape?.check || (() => _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isMobileLandscape()),
				ori: config.orientation?.smallLandscape?.ori || 'horizontal'
			}
		};

		super(app, null, {
			isMetric: false,
			isVisible: true,
			isFullscreen: false,
			isPhotoMode: false,
			isGuidedCamera: true,
			showOrbitLines: true,
			showLabels: true,
			lightType: 'shadow',
			config,
			...options
		});

		/**
		 * Manually set orientation for buttons.
		 * @type {string}
		 */
		this._ori = '';

		this._isMobileMode = _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isMobileMode();
		this._isHorizontal = null;

		Object.assign(this._class, {
			container: {
				collapse: 'hidden',
				expand: 'active'
			},
			isItemVisible: {
				true: '',
				false: 'hidden'
			},
			icon: {
				imperial: 'icon-mi',
				metric: 'icon-km',
				info: 'icon-info'
			},
			fullscreen: {
				true: 'fullscreen',
				false: 'window'
			},
			photo: {
				true: 'active',
				false: ''
			},
			light: {
				natural: 'icon-natural-light',
				shadow: 'icon-shadow-light',
				flood: 'icon-flood-light'
			},
			camera: {
				true: 'icon-free-cam',
				false: 'icon-auto-cam'
			},
			isHorizontal: {
				true: 'horizontal',
				false: 'vertical'
			}
		});

		const isVisible = !this._isMobileMode;
		const isCollapsed = this._isMobileMode;
		const isHorizontal = this.isHorizontal();
		const CameraManager = /** @type {CameraManager}  */ this.app.getManager('camera');
		this._fullLightColor = CameraManager.getFullLightColor();
		this._shadowLightColor = CameraManager.getShadowLightColor();

		Object.assign(this._state, {
			isVisible,
			isCollapsed,
			isVisibleClass: this._class.isVisible[isVisible],
			containerClass: isCollapsed ? this._class.container.collapse : this._class.container.expand,
			isCollapsibleClass: this._class.isItemVisible[this._config.isCollapsible],
			allowInfoPanelClass: this._class.isItemVisible[this._config.allowInfoPanel],
			allowToggleUnitClass: this._class.isItemVisible[this._config.allowToggleUnit],
			allowPhotoModeClass: this._class.isItemVisible[this._config.allowPhotoMode],
			allowZoomClass: this._class.isItemVisible[this._config.allowZoom],
			allowLightingClass: this._class.isItemVisible[this._config.allowLighting],
			showLightingOptionsClass: this._class.isItemVisible[this._config.showLightOptions],
			allowGuidedCameraClass: this._class.isItemVisible[this._config.allowGuidedCamera],
			allowFullscreenClass: this._class.isItemVisible[this._config.allowFullscreen],
			allowLayersClass: this._class.isItemVisible[this._config.allowLayers],
			unitButton: this._state.isMetric ? this._class.icon.imperial : this._class.icon.metric,
			infoButton: this._class.icon.info,
			fullscreenClass: this._class.fullscreen[this._state.isFullscreen],
			photoModeClass: this._class.photo[this._state.isPhotoMode],
			lightClass: this._class.light[this._state.lightType],
			guidedClass: this._class.camera[this._state.isGuidedCamera],
			isHorizontal,
			orientationClass: this._class.isHorizontal[isHorizontal]
		});

		/**
		 * Array of possible event names.
		 * @type {string[]}
		 * @default
		 */
		this._eventNames.push('unitchange', 'photomodechange', 'guidedcamerachange', 'expandtoggle');
		this._initCallbacks();

		/**
		 * Mouse is held down
		 * @type {boolean}
		 * @default
		 */
		this._isMouseHold = false;

		/**
		 * Zoom is continuous or not.
		 * @type {boolean}
		 * @default
		 */
		this._isContinuousZoom = false;

		/**
		 * Interval to zoom continuously.
		 */
		this._zoomInterval = null;
		this._zoomTimeout = null;

		/**
		 * Array to store tippy tooltip instances.
		 */
		this._tooltips = [];

		/**
		 * Set default tippy props
		 * See docs: https://atomiks.github.io/tippyjs/v6/methods/
		 */
		tippy_js__WEBPACK_IMPORTED_MODULE_4__["default"].setDefaultProps({
			theme: 'default',
			touch: ['hold', 2000],
			delay: [600, null],
			plugins: [tippy_js__WEBPACK_IMPORTED_MODULE_4__.followCursor]
		});

		// Binds
		this.bindFunctions([
			'toggleCollapse',
			'toggleUnit',
			'toggleLayers',
			'toggleFullscreen',
			'togglePhotoMode',
			'hideLightingOptions',
			'toggleLightOptions',
			'toggleLight',
			'toggleGuidedCamera',
			'toggleInfoPanel',
			'startGuidedCamera',
			'stopGuidedCamera',
			'_zoomIn',
			'_zoomOut',
			'_stopZooming',
			'_updateSize'
		]);
	}

	/** @inheritdoc */
	init() {
		super.init();

		const {
			isCollapsible,
			allowToggleUnit,
			allowLayers,
			allowZoom,
			allowFullscreen,
			allowPhotoMode,
			allowInfoPanel,
			allowLighting,
			allowGuidedCamera
		} = this._config;

		const newState = {};

		// Desktop toggle button
		if (isCollapsible) {
			newState.isCollapsibleClass = this._class.isItemVisible[isCollapsible];
		}

		if (allowInfoPanel) {
			newState.allowInfoPanelClass = this._class.isItemVisible[allowInfoPanel];
		}

		if (allowToggleUnit) {
			newState.allowToggleUnitClass = this._class.isItemVisible[allowToggleUnit];
		}

		if (allowPhotoMode) {
			newState.allowPhotoModeClass = this._class.isItemVisible[allowPhotoMode];
		}

		if (allowZoom) {
			newState.allowZoomClass = this._class.isItemVisible[allowZoom];

			// Zoom in
			this._children.zoomInButton.addEventListener('mousedown', () => {
				this._stopZooming();
				this._zoomIn(true);
			});
			this._children.zoomInButton.addEventListener('mouseleave', this._stopZooming);
			this._children.zoomInButton.addEventListener('mouseup', () => {
				if (!this._isContinuousZoom) {
					this._zoomIn();
				}
				this._stopZooming();
			});
			this._children.zoomInButton.addEventListener('touchstart', event => {
				event.preventDefault();
				this._stopZooming();
				this._zoomIn(true);
			});
			this._children.zoomInButton.addEventListener('touchmove', event => {
				event.preventDefault();
				const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
				if (element.getAttribute('key') !== 'zoomInButton') {
					this._stopZooming();
				}
			});
			this._children.zoomInButton.addEventListener('touchend', event => {
				event.preventDefault();
				if (!this._isContinuousZoom) {
					this._zoomIn();
				}
				this._stopZooming();
			});

			// Zoom out
			this._children.zoomOutButton.addEventListener('mousedown', () => {
				this._stopZooming();
				this._zoomOut(true);
			});
			this._children.zoomOutButton.addEventListener('mouseleave', this._stopZooming);
			this._children.zoomOutButton.addEventListener('mouseup', () => {
				if (!this._isContinuousZoom) {
					this._zoomOut();
				}
				this._stopZooming();
			});
			this._children.zoomOutButton.addEventListener('touchstart', event => {
				event.preventDefault();
				this._stopZooming();
				this._zoomOut(true);
			});
			this._children.zoomOutButton.addEventListener('touchmove', event => {
				event.preventDefault();
				const element = document.elementFromPoint(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
				if (element.getAttribute('key') !== 'zoomOutButton') {
					this._stopZooming();
				}
			});
			this._children.zoomOutButton.addEventListener('touchend', event => {
				event.preventDefault();
				if (!this._isContinuousZoom) {
					this._zoomOut();
				}
				this._stopZooming();
			});
		}

		if (allowLighting) {
			newState.allowLightingClass = this._class.isItemVisible[allowLighting];
			this._children.flood.onclick = this.toggleLightOptions.bind(this._children.flood, 'flood');
			this._children.shadow.onclick = this.toggleLightOptions.bind(this._children.shadow, 'shadow');
			this._children.natural.onclick = this.toggleLightOptions.bind(this._children.natural, 'natural');

			// Turn on shadow light mode by default
			this._children.shadow.classList.add('selected-lighting');

			this.toggleLightOptions('shadow');
		}

		if (allowGuidedCamera) {
			newState.allowGuidedCameraClass = this._class.isItemVisible[allowGuidedCamera];
		}

		if (allowFullscreen && screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].isEnabled) {
			newState.allowFullscreenClass = this._class.isItemVisible[allowFullscreen];

			// On fullscreen api change event
			screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].on('change', () => {
				const isFullscreen = screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].isFullscreen;
				this.setState({
					isFullscreen,
					fullscreenClass: this._class.fullscreen[isFullscreen]
				});
			});
		}

		if (allowLayers) {
			newState.allowLayersClass = this._class.isItemVisible[allowLayers];
		}

		this.setState(newState);

		// Add tooltips to elements
		const tooltipElements = this._element.querySelectorAll('.settings button:not(.zoom), span[key="zoomInButton"], span[key="zoomOutButton"]');

		this.addTooltips(
			tooltipElements,
			{
				update: function (isHorizontal) {
					/**
					 * Note: We don't want to use an arrow function to enclose the 'this' property
					 * because we want 'this' to reference the tippy instance itself
					 */
					// eslint-disable-next-line no-invalid-this
					this.setProps({ placement: isHorizontal ? 'top' : 'left' });
				}
			}

		);

		this._updateSize();

		this._callbackRegistry.push({
			emitter: this._app.getManager('time'),
			event: 'ratechange',
			callback: this.onRateChange
		});
	}

	/**
	 * Use tippy library to create tooltip instances to add to the _toolips array
	 * @param {Array<HTMLElement>} elements
	 * @param {object} params
	 * @returns {Array<object>|object}
	 */
	addTooltips(elements, params) {
		const props = params.props || {};

		const tippys = (0,tippy_js__WEBPACK_IMPORTED_MODULE_4__["default"])(
			elements,
			props
		);

		// If passed, add update function to each tippy instance.
		if (typeof params.update === 'function') {
			for (const tip of tippys) {
				tip.update = params.update;
			}
		}
		if (typeof params.onclick === 'function') {
			for (const tip of tippys) {
				tip.popper.onclick = params.onclick;
			}
		}

		this._tooltips.push(...tippys);

		return tippys.length === 1 ? tippys[0] : tippys;
	}

	/**
	 * Loop through the tooltips and call their update function if it exists
	 * @param {boolean} isHorizontal
	 */
	updateTooltips(isHorizontal) {
		for (const tooltip of this._tooltips) {
			if (typeof tooltip.update === 'function') {
				tooltip.update(isHorizontal);
			}
		}
	}

	/**
	 * Update setting's config.
	 * @param {object} config
	 */
	setConfig(config) {
		const { collapseSettingsOptions, hideFullScreenToggle, lighting } = this.app.getManager('router').configs;
		// Only allow fullscreen if has capability
		if (config.allowFullscreen && hideFullScreenToggle !== true) {
			config.allowFullscreen = screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].isEnabled;
		}

		// Update orientation
		if (config.orientation) {
			const oriConfig = this._config.orientation;
			const orientations = ['bigPortrait', 'tabletPortrait', 'smallPortrait', 'bigLandscape', 'tabletLandscape', 'smallLandscape'];
			for (let i = 0; i < orientations.length; i++) {
				const ori = orientations[i];
				if (!config.orientation[ori]) {
					config.orientation[ori] = oriConfig[ori];
				}
				else {
					config.orientation[ori].check ??= oriConfig[ori].check;
					config.orientation[ori].ori ??= oriConfig[ori].ori;
				}
			}
		}

		super.setConfig(config);
		const newState = {};

		for (const key in config) {
			if (key === 'orientation') {
				const isHorizontal = this.isHorizontal();
				newState.isHorizontal = isHorizontal;
				newState[`${key}Class`] = this._class.isHorizontal[isHorizontal];
			}
			else {
				newState[`${key}Class`] = this._class.isItemVisible[config[key]];
			}
		}

		this.setState(newState);

		// Override any set configs with embed queries
		if (collapseSettingsOptions === true) {
			this.collapse();
		}
		if (hideFullScreenToggle === true) {
			this.hideFullScreenOption();
		}
		if (lighting === 'flood' || lighting === 'natural') {
			this.toggleLightOptions(lighting);
		}

		this._updateSize(true);
	}

	/**
	 * Get manually set orientation.
	 * @returns {string}
	 */
	getOrientation() {
		return this._ori;
	}

	/**
	 * Manually set orientation to overwrite the auto orientation.
	 * Passing no orientation will reset to auto mode.
	 * @param {string} [ori=''] - Buttons' orientation: 'horizontal' or 'vertical'
	 */
	setOrientation(ori = '') {
		this._ori = ori;
	}

	/**
	 * Check if orientation should be horizontal or not.
	 * @returns {boolean}
	 */
	isHorizontal() {
		// Manually set orietation
		if (this._ori !== '') {
			return this._ori === 'horizontal';
		}

		// Auto orientation
		for (const key in this._config.orientation) {
			const orientation = this._config.orientation[key];
			if (orientation.check()) {
				return orientation.ori === 'horizontal';
			}
		}

		return false;
	}

	/**
	 * Update settings size dynamically according to mode and the numbers of visible buttons.
	 * @param {boolean} forceResize - force to resize regardless of isHorizontal
	 */
	_updateSize(forceResize = false) {
		const isHorizontal = this.isHorizontal();
		if (!forceResize && this._isHorizontal === isHorizontal) {
			return;
		}

		this._isHorizontal = isHorizontal;

		// Collapse/expand button
		let buttonCount = 1;

		// Visible settings buttons
		const buttons = Array.from(this._children.content.querySelectorAll(':scope > button'));
		for (let i = 0; i < buttons.length; i++) {
			if (buttons[i].classList.contains('hidden')) {
				continue;
			}
			buttonCount++;
		}
		if (this._config.allowZoom) {
			// Add one because zoom buttons are grouped as one
			buttonCount++;
		}

		// Set size
		if (this._isHorizontal) {
			this._element.style.width = `calc(${buttonCount} * 30px + ${buttonCount} * 2px)`;
			this._element.style.height = '30px';
		}
		else {
			this._element.style.width = '30px';
			this._element.style.height = `calc(${buttonCount} * 30px + ${buttonCount} * 2px)`;
		}

		// Update tooltip placement
		this.updateTooltips(isHorizontal);
	}

	/**
	 * Execute zoom continuously.
	 * @param {Function} zoomFunction
	 */
	_zoomContinuously(zoomFunction) {
		this._isMouseHold = true;

		if (this._zoomTimeout !== null) {
			clearTimeout(this._zoomTimeout);
		}
		this._zoomTimeout = setTimeout(() => {
			if (this._isMouseHold) {
				this._isContinuousZoom = true;
				// Mouse was held down for some time
				if (this._zoomInterval !== null) {
					clearInterval(this._zoomInterval);
				}
				this._zoomInterval = setInterval(() => {
					if (this._isMouseHold) {
						zoomFunction(true);
					}
					else {
						clearInterval(this._zoomInterval);
					}
				}, 30);
			}
		}, 200);
	}

	/**
	 * Handle zoom in discretely or continuously.
	 * @param {boolean} [isContinuous=false] - Zoom continuously
	 */
	_zoomIn(isContinuous = false) {
		if (isContinuous) {
			this._zoomContinuously(this._config.zoomIn);
		}
		else {
			this._config.zoomIn();
		}
	}

	/**
	 * Handle zoom out discretely or continuously.
	 * @param {boolean} [isContinuous=false] - Zoom continuously
	 */
	_zoomOut(isContinuous = false) {
		if (isContinuous) {
			this._zoomContinuously(this._config.zoomOut);
		}
		else {
			this._config.zoomOut();
		}
	}

	/**
	 * Stop continuous zoom.
	 */
	_stopZooming() {
		clearInterval(this._zoomInterval);
		this._isMouseHold = false;
		this._isContinuousZoom = false;
	}

	/**
	 * Show settings.
	 */
	show() {
		this.setState({
			isVisible: true,
			isVisibleClass: this._class.isVisible.true
		});
	}

	/**
	 * Hide settings.
	 */
	hide() {
		this.setState({
			isVisible: false,
			isVisibleClass: this._class.isVisible.false,
			showLightingOptionsClass: this._class.isVisible.false
		});
	}

	/**
	 * Returns true if visible.
	 * @returns {boolean}
	 */
	isVisible() {
		return this._state.isVisible;
	}

	/**
	 * Show buttons.
	 */
	expand() {
		this.setState({
			isCollapsed: false,
			containerClass: this._class.container.expand
		});
	}

	/**
	 * Hide buttons.
	 */
	collapse() {
		this.setState({
			isCollapsed: true,
			showLightingOptionsClass: this._class.isVisible.false,
			containerClass: this._class.container.collapse
		});
	}

	/**
	 * Toggle expand/collapse buttons.
	 */
	toggleCollapse() {
		if (this._state.isCollapsed) {
			this.expand();
		}
		else {
			this.collapse();
		}
		this.triggerCallbacks('expandtoggle', [!this._state.isCollapsed, this._state.isPhotoMode]);
	}

	/**
	 * Toggle unit between metric and imperial.
	 */
	toggleUnit() {
		const isMetric = !this._state.isMetric;
		this.setState({
			isMetric,
			unitButton: isMetric ? this._class.icon.imperial : this._class.icon.metric
		}, () => {
			this.triggerCallbacks('unitchange', [this._state.isMetric]);
		});
	}

	/**
	 * Toggle fullscreen.
	 */
	toggleFullscreen() {
		if (screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].isEnabled) {
			screenfull__WEBPACK_IMPORTED_MODULE_0__["default"].toggle();
		}
	}

	/**
	 * Toggle layers panel.
	 */
	toggleLayers() {
		const layersPanelOpen = !this._app.getComponent('layerPanel').getState('isVisible');
		if (layersPanelOpen) {
			this._app.getComponent('layerPanel').show();
			this.collapse();
		}
		else {
			this._app.getComponent('layerPanel').hide();
		}
	}

	/**
	 * Toggle photo mode.
	 */
	togglePhotoMode() {
		const isPhotoMode = !this._state.isPhotoMode;
		this.setState({
			isPhotoMode,
			photoModeClass: this._class.photo[isPhotoMode]
		}, () => {
			if (this._state.isPhotoMode) {
				this.collapse();
			}
			else {
				this.expand();
			}
			this.triggerCallbacks('photomodechange', [this._state.isPhotoMode]);
		});
	}

	/**
	 * Hide the lighting options panel
	 * @param {Event} e
	 */
	hideLightingOptions(e) {
		const checkList = [this._children.lightToggle, this._children.lightOptions, this._children.flood, this._children.natural, this._children.shadow];

		if (!checkList.includes(e.target)) {
			this.setState({
				showLightingOptionsClass: this._class.isVisible.false
			});
		}
		window.removeEventListener('mousedown', this.hideLightingOptions);
		window.removeEventListener('touchstart', this.hideLightingOptions);
	}

	/**
	 * Hide fullscreen option
	 */
	hideFullScreenOption() {
		const newState = {};
		newState.allowFullscreenClass = this._class.isItemVisible[false];
		this.setState(newState);
	}

	/**
	 * Toggle light options panel
	 * @param {string} type
	 */
	toggleLightOptions(type) {
		this.setState({
			lightType: type,
			lightClass: this._class.light[type],
			showLightingOptionsClass: this._class.isVisible.false
		}, () => {
			if (type === 'flood') {
				this._app.getManager('camera')?.toggleCameraLight(true, this._fullLightColor);
				this._app.getManager('comparison')?.setCameraLight(true, this._fullLightColor);
			}
			else if (type === 'natural') {
				this._app.getManager('camera')?.toggleCameraLight(false);
				this._app.getManager('comparison')?.setCameraLight(false);
			}
			else if (type === 'shadow') {
				this._app.getManager('camera')?.toggleCameraLight(true, this._shadowLightColor);
				this._app.getManager('comparison')?.setCameraLight(true, this._shadowLightColor);
			}

			for (const key in this._children) {
				// Remove highlight from unselected light options
				if (key !== type && (key === 'flood' || key === 'natural' || key === 'shadow')) {
					this._children[key].classList.remove('selected-lighting');
				}
			}

			// Add highlight to selected lighting option icon and title
			this._children[`${type}`].classList.add('selected-lighting');
		});
	}

	/**
	 * Toggle lighting.
	 */
	toggleLight() {
		this.setState({
			showLightingOptionsClass: this.getState('showLightingOptionsClass') === this._class.isVisible.true ? this._class.isVisible.false : this._class.isVisible.true
		});

		if (this.getState('showLightingOptionsClass') === this._class.isVisible.true) {
			window.addEventListener('mousedown', this.hideLightingOptions);
			window.addEventListener('touchstart', this.hideLightingOptions);
		}
		else {
			window.removeEventListener('mousedown', this.hideLightingOptions);
			window.removeEventListener('touchstart', this.hideLightingOptions);
		}
	}

	/**
	 * Start guided camera.
	 */
	startGuidedCamera() {
		this.setState({
			isGuidedCamera: true,
			guidedClass: this._class.camera.true
		}, () => this.triggerCallbacks('guidedcamerachange', [this._state.isGuidedCamera]));
	}

	/**
	 * Stop guided camera.
	 */
	stopGuidedCamera() {
		this.setState({
			isGuidedCamera: false,
			guidedClass: this._class.camera.false
		}, () => this.triggerCallbacks('guidedcamerachange', [this._state.isGuidedCamera]));
	}

	/**
	 * Toggle guided camera.
	 */
	toggleGuidedCamera() {
		if (this._state.isGuidedCamera) {
			this.stopGuidedCamera();
		}
		else {
			this.startGuidedCamera();
		}
	}

	/**
	 * Toggles info panel.
	 */
	toggleInfoPanel() {
		if (this._app.getComponent('infoPanel') !== null) {
			this._app.getComponent('infoPanel').openPanel();
		}
	}

	/** @inheritdoc */
	resize() {
		super.resize();

		// Reorient if needed
		const isHorizontal = this.isHorizontal();
		if (this._isHorizontal !== isHorizontal) {
			this.setState({
				isHorizontal,
				orientationClass: this._class.isHorizontal[isHorizontal]
			});
		}

		this._updateSize();
	}
}

Settings.html = (_settings_html__WEBPACK_IMPORTED_MODULE_3___default());

/* harmony default export */ __webpack_exports__["default"] = (Settings);


/***/ }),

/***/ "../eyes/src/components/share_modal/index.js":
/*!***************************************************!*\
  !*** ../eyes/src/components/share_modal/index.js ***!
  \***************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _share_modal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./share_modal */ "../eyes/src/components/share_modal/share_modal.js");



/* harmony default export */ __webpack_exports__["default"] = (_share_modal__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/share_modal/share_modal.js":
/*!*********************************************************!*\
  !*** ../eyes/src/components/share_modal/share_modal.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _share_modal_html__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./share_modal.html */ "../eyes/src/components/share_modal/share_modal.html");
/* harmony import */ var _share_modal_html__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_share_modal_html__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! tippy.js */ "../eyes/node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _data_embed_controls__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../data/embed_controls */ "../eyes/src/data/embed_controls.js");








/**
 * Share Modal component.
 */
class ShareModal extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, null, {
			isVisible: false,
			iframeElements: true,
			linkTitle: '',
			previewDevice: '',
			previewResolution: '',
			previewVisibleClass: _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isiPhone() ? 'hidden' : '',
			isWide: null,
			...options,
			config: {
				title: 'Share',
				shareBtnParent: {
					selector: '.header',
					wideSelector: '.header',
					threshold: 1025
				},
				linkAltText: 'Eyes',
				linkImageSrc: '',
				paramsToKeep: ['time', 'rate', 'slide', 'followId', ...options?.paramsToKeep ?? []],
				resetOnClose: true,

				// Device resolution options.
				deviceResolutions: {
					desktop: { width: 1280, height: 720 },
					tablet: { width: 1024, height: 1366 },
					phone: { width: 375, height: 667 }
				},
				...options?.config
			}

		});

		this._activeTab = null;
		this._srcURL = null;

		/**
		 * Options scrollbar instance.
		 * @type {OverlayScrollbars}
		 */
		this._embedOptionsScrollbar = null;

		// Tippy vars.
		this._tippySingleton = null;
		this._tippyItems = null;
		this._tippyTimeout = null;

		this._embedQueries = {};

		this._inputElements = {};

		this.bindFunctions(['_iframeLoadEventListener']);
	}

	/**
	 * Concatenated EMBED_DEFAULT_CONTROLS with this._config.controls.
	 * If the EMBED_DEFAULT_CONTROLS array has objects with matching groupName property to options.controls array, merge the items array.
	 * If options.controls contains new groupName properties, add them to the array.
	 */
	mergeEmbedControls() {
		const { controls } = this._config;
		const mergedControls = _data_embed_controls__WEBPACK_IMPORTED_MODULE_3__["default"].map(defaultControl => {
			const { groupName: defaultGroupName, items: defaultItems } = defaultControl;
			const newControl = controls.find(control => control.groupName === defaultGroupName);

			if (newControl) {
				const { items: newItems } = newControl;
				// Filter out default items that are already in the newItems array.
				const mergedItems = defaultItems.filter(({ name }) => !newItems.some(({ name: newName }) => newName === name));
				return { ...defaultControl, items: [...newItems, ...mergedItems] };
			}

			return defaultControl;
		});

		// Add any new controls to the mergedControls array.
		const newControls = controls.filter(control => !mergedControls.some(({ groupName }) => groupName === control.groupName));

		// Set the embedO
		this._config.embedOptions = [...mergedControls, ...newControls];
	}

	/**
	 * Initilizing the component
	 * @override
	 * @inheritdoc
	 */
	init() {
		super.init();
		const { canHover } = this._app;

		// Merge the embed controls.
		this.mergeEmbedControls();

		// Set the embed parameters.
		this.setEmbedParams();

		// Generate the embed content.
		this.generateEmbedContent();

		// Set the wide selector state.
		this.setIsWide();

		// Scrollbar creation
		this.createScrollbars();

		// Create and add the share button to the parent.
		this.createShareButton();
		this.addShareButtonToParent();

		/**
		 * Set default tippy props
		 */
		tippy_js__WEBPACK_IMPORTED_MODULE_4__["default"].setDefaultProps({
			theme: 'default',
			touch: true,
			hideOnClick: false,
			delay: [300, null],
			placement: 'top',
			trigger: 'mouseenter click',
			// If we dont have hovering ability, hide the tooltip after a delay
			onTrigger: instance => {
				clearTimeout(this._tippyTimeout);
				if (!canHover) {
					this._tippyTimeout = setTimeout(() => {
						instance?.hide();
					}, 3000);
				}
			},
			// Manual hide on outside click as hideOnClick is false and behaves oddly for touch when true.
			onClickOutside: instance => {
				instance.hide();
			},
			// Make sure the tippy elements are blurred (not focused) when hidden (doesnt happen by default on touch devices)
			onHidden: _ => {
				this._tippyItems?.forEach(({ reference }) => reference.blur());
			}
		});
	}

	/**
	 * Create the scrollbars for the embed options.
	 */
	createScrollbars() {
		const { embedOptsContent } = this._children;
		const sectionParent = embedOptsContent.parentElement;

		_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.onAttachElement(sectionParent, () => {
			this._embedOptionsScrollbar = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.addScrollbar(sectionParent);
		});
	}

	/**
	 * Get the current device.
	 * @returns {string} The current device.
	 */
	getCurrentDevice() {
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isTablet()) {
			return 'tablet';
		}
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isMobile()) {
			return 'phone';
		}
		return 'desktop';
	}

	/**
	 * Creates the share button.
	 */
	createShareButton() {
		this.shareButton = document.createElement('button');
		this.shareButton.className = 'share-button clickable';
		this.shareButton.innerText = 'Share';

		const shareIcon = document.createElement('span');
		shareIcon.className = 'icon icon-share';
		this.shareButton.prepend(shareIcon);

		// Add the click event.
		this.shareButton.addEventListener('click', () => {
			// Set the src URL.
			this.setSrcURL();

			// Set the default preview device.
			this.setPreviewDevice({ target: { value: this.getCurrentDevice() } });

			// Always set the active tab to the link on open.
			this.setActiveTab('link');

			// Set the src and alt text attributes for the link image.
			const { linkImage } = this._children;
			const { linkAltText: backupAltText, linkImageSrc: backupImageSrc } = this._config;

			// For future when we have entity-specific SEO - we can use the title and og:image
			const title = document.querySelector('title')?.innerText;
			const ogImage = document.querySelector('meta[property="og:image"]')?.getAttribute('content');
			const altText = title || backupAltText;
			const src = (ogImage !== '$OG_IMAGE' && ogImage) || backupImageSrc;

			// Set the link image attributes.
			linkImage.setAttribute('alt', altText);
			linkImage.setAttribute('src', src);

			// Set the link title state.
			const { fullTitle } = this._app.getManager('title');
			const linkTitle = fullTitle ?? altText;
			this.setState({ linkTitle });

			// Show the modal.
			this.show();
		});
	}

	/**
	 * Determine if the wide selector should be used for the share button parent.
	 * @returns {boolean} Whether the isWide state has been updated.
	 */
	setIsWide() {
		const { isWide: currentIsWide } = this._state;
		const { shareBtnParent } = this._config;
		const { threshold } = shareBtnParent;

		const newIsWide = window.innerWidth >= threshold;

		if (currentIsWide !== newIsWide) {
			this.setState({ isWide: newIsWide });
			return true;
		}

		return false;
	}

	/**
	 * Add the share button to the parent.
	 */
	addShareButtonToParent() {
		const { shareBtnParent } = this._config;
		const { isWide } = this._state;
		const { selector, wideSelector } = shareBtnParent;

		// Remove it from its current parent.
		this.shareButton.parentNode?.removeChild(this.shareButton);

		// Add it to the new parent, once it's ready.
		const shareBtnParentSelector = isWide ? wideSelector : selector;
		_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.elementReady(shareBtnParentSelector, 3000)
			.then(shareButtonParent => {
				// Append the button to the parent.
				shareButtonParent.appendChild(this.shareButton);
				return true;
			})
			.catch(e => e);
	}


	/**
	 * Set the src URL and update the code text content.
	 * @param {string} href
	 * @param {boolean} updateCode
	 */
	setSrcURL(href = window.location.href, updateCode = true) {
		const { linkCode } = this._children;
		const { paramsToKeep } = this._config;

		// Determine the parameters to keep from config.
		const splitHref = href.split('?');
		const params = splitHref[1] ? new URLSearchParams(splitHref[1]) : new URLSearchParams();
		const paramKeysArray = Array.from(params.keys());

		// Iterate over all keys
		for (const key of paramKeysArray) {
			// If the key is not in the array, delete it
			if (!paramsToKeep.includes(key)) {
				params.delete(key);
			}
		}

		this._srcURL = `${splitHref[0]}${params.size ? '?' : ''}${params.toString()}`;

		// Set the basic link code text content - a direct copy of the href, with no params removed.
		if (updateCode) {
			linkCode.textContent = href;
		}
	}

	/**
	 * Sets the default embed parameters.
	 */
	setEmbedParams() {
		const { embedOptions } = this._config;

		// Create the embed parameters.
		embedOptions.forEach(({ items }) => {
			items.forEach(option => {
				const { query, inputDefault, invert } = option;
				const value = invert ? !inputDefault : inputDefault;
				this._embedQueries[query] = value;
			});
		});
	}

	/**
	 * Update the embed parameters and the code text content.
	 * @param {string} query
	 * @param {string|boolean|number} value
	 */
	updateEmbedParams(query, value) {
		if (this._embedQueries[query] === value || this._embedQueries[query] === undefined) {
			return;
		}

		// Update the embed param.
		this._embedQueries[query] = value;

		// Update the embed code.
		this.updateEmbedCode();
	}

	/**
	 * Set the embed preview and copy-able code text content.
	 * @param {object} params
	 */
	updateEmbedCode(params) {
		const { force = false, updatePreview = true } = params || {};
		const { embedCode, embedPreviewParent } = this._children;
		const { iframeElements } = this._state;

		// Get the embed code as a string.
		const { srcURL, iframeString, noTrackingIframeString } = this.getEmbedCodeFromParams();

		const embedCodeString = iframeElements ? iframeString : srcURL;

		// Update embed code text content.
		if (embedCodeString !== embedCode.textContent || force) {
			embedCode.textContent = embedCodeString;
		}

		// Add the embed code to the parent element and subsequent nav listener.
		if (updatePreview && !_internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isiPhone() && (embedPreviewParent?.innerHTML.replace(/&amp;/g, '&') !== noTrackingIframeString || force)) {
			// Remove the previous load event listener.
			const iframe = embedPreviewParent.querySelector('iframe');
			iframe?.removeEventListener('load', this._iframeLoadEventListener);

			// Reset the iframe's innerHTML
			embedPreviewParent.innerHTML = noTrackingIframeString;

			// Add the load event listener to the new iframe.
			const newIframe = embedPreviewParent.querySelector('iframe');
			newIframe.addEventListener('load', this._iframeLoadEventListener);
		}

		/**
		 * TODO in preview iframe code:
		 * Turn off google analytics for the preview
		 */

		// Force a resize to update the iframe transform.
		this.resize();
	}

	/**
	 * Calculate the template size.
	 */
	calcTemplateWidth() {
		const { deviceResolutions } = this._config;
		const { embedPreviewParent } = this._children;
		const { previewDevice, useBrowserTemplate } = this._state;

		if (!useBrowserTemplate) {
			return;
		}

		const { width, height } = deviceResolutions[previewDevice] || deviceResolutions.desktop;

		console.log('\ncalculating template size for', previewDevice);
		console.log('width:', width);
		console.log('height:', height);
	}

	/**
	 * Calculate the iframe transform scale and offset-x according to its parent's dimensions.
	 */
	calcIframeTransform() {
		console.log('calcIframeTransform: ');
		const { previewResolution } = this._state;
		const { width, height } = previewResolution;

		// Force a resize to update the iframe transform.
		this.resize();
	}

	/**
	 * Define the load event listener function.
	 * @param {Event} e
	 */
	_iframeLoadEventListener(e) {
		const { contentWindow } = e.target;
		// Check if the iframe's contentWindow is accessible.
		if (contentWindow) {
			// Add a hashchange event listener to the iframe's window.
			contentWindow.onhashchange = () => {
				this.setSrcURL(contentWindow.location.href, false);
				this.updateEmbedCode({ updatePreview: false });
			};
		}
	}

	/**
	 * Calculate the iframe transform scale and offset-x according to its parent's dimensions.
	 */
	calcIframeTransforms() {
		const { embedPreviewParent } = this._children;
		const { deviceResolutions } = this._config;

		const { width, height } = deviceResolutions.desktop;

		const { paddingTop, paddingRight, paddingBottom, paddingLeft } = getComputedStyle(embedPreviewParent);
		const { clientWidth: parentWidth, clientHeight: parentHeight } = embedPreviewParent;

		const paddedParentWidth = parentWidth - parseFloat(paddingLeft) - parseFloat(paddingRight);
		const paddedParentHeight = parentHeight - parseFloat(paddingTop) - parseFloat(paddingBottom);

		// Set the width and height CSS vars.
		this._element.style.setProperty('--iframe-width', `${width}px`);
		this._element.style.setProperty('--iframe-height', `${height}px`);

		// Determine the scale based on the parent and iframe dimensions.
		const widthScale = paddedParentWidth / width;
		const heightScale = paddedParentHeight / height;
		const iframeScale = Math.min(widthScale, heightScale);

		// Set the --iframe-scale CSS variable.
		this._element.style.setProperty('--iframe-scale', iframeScale);

		// Determine the scaled offset-x and set the CSS variable.
		const offsetX = (paddedParentWidth - (width * iframeScale)) / 2;
		const scaledOffsetX = offsetX / iframeScale;
		this._element.style.setProperty('--iframe-offset-x', `${scaledOffsetX}px`);
	}

	/**
	 * Set the preview device.
	 * @param {Event} e
	 */
	setPreviewDevice(e) {
		const { value: previewDevice } = e.target;
		const { previewDevice: currPreviewDevice } = this._state;

		// If the current device is the same as the new device, return.
		if (previewDevice === currPreviewDevice) {
			return;
		}

		// Update the previewDevice state.
		this.setState({ previewDevice });

		// Force update the embed code.
		this.updateEmbedCode({ force: true });
	}

	/**
	 * Toggle the iframe elements.
	 * @param {Event} e
	 */
	toggleIframeElements(e) {
		// Set the checked state.
		const { checked } = e.target;
		this.setState({ iframeElements: checked });

		// Update the embed code.
		this.updateEmbedCode({ updatePreview: false });
	}

	/**
	 * Get the embed code from the params.
	 * @returns {object} The embed code as a string.
	 */
	getEmbedCodeFromParams() {
		const { embedOptions } = this._config;
		const flattenedOptions = embedOptions.flatMap(({ items }) => items);

		// Start with the existing params (already know we need to keep them as set in setSrcURL)
		const splitUrl = this._srcURL.split('?');
		const urlParams = new URLSearchParams(splitUrl[1]);
		const noTrackingUrlParams = new URLSearchParams(splitUrl[1]);

		/**
		 * Include only the parameters that:
		 * have been changed from the appQueryDefaults
		 * have satisfied the dependencies
		 */
		const embedParamEntries = Object.entries(this._embedQueries).filter(([currQuery, currValue]) => {
			// Get the app default value for the current query.
			const { appQueryDefault, dependencies } = flattenedOptions.find(({ query }) => query === currQuery) ?? {};

			// Determine if the depenedencies are satisfied.
			const dependenciesSatisfied = !dependencies
				|| (dependencies?.length && dependencies.every(([depQuery, depValidFunc]) => depValidFunc(this._embedQueries[depQuery])));

			return currValue !== appQueryDefault && dependenciesSatisfied;
		});

		// Create the URLSearchParams from the queries.
		const embedParams = Object.fromEntries(embedParamEntries);
		const noTrackingParams = { ...embedParams, tracking: 'false' };

		// Add the embedParams to the urlParams.
		Object.keys(embedParams).forEach(key => urlParams.set(key, embedParams[key]));

		// Add the noTrackingParams to the noTrackingUrlParams.
		Object.keys(noTrackingParams).forEach(key => noTrackingUrlParams.set(key, noTrackingParams[key]));

		// Update the src URL with the new params.
		const srcURL = `${splitUrl[0]}${urlParams.size ? '?' : ''}${urlParams.toString()}`;
		const noTrackingSrcURL = `${splitUrl[0]}${noTrackingUrlParams.size ? '?' : ''}${noTrackingUrlParams.toString()}`;

		// Build iFrame string code, including the src attribute.
		const iframeString = `<iframe src="${srcURL}" allowfullscreen ></iframe>`;
		const noTrackingIframeString = `<iframe src="${noTrackingSrcURL}" allowfullscreen ></iframe>`;

		// Get the embed code as a string.
		return { srcURL, iframeString, noTrackingIframeString };
	}

	/**
	 * Generate the embed content.
	 */
	generateEmbedContent() {
		const { embedOptions } = this._config;
		const { embedOptsContent, embedAdvOptsContent } = this._children;

		embedOptions.forEach(({ isAdvanced, groupName, items }) => {
			// Create the group container.
			const containerType = groupName ? 'fieldset' : 'div';
			const groupContainer = document.createElement(containerType);
			groupContainer.className = 'embed-group';

			// Add the legend header if the groupName exists
			if (groupName) {
				const groupLegend = document.createElement('legend');
				groupLegend.innerText = groupName;
				groupContainer.appendChild(groupLegend);
			}

			// Create the interactive group inputs.
			this.createGroupInputs(items, groupContainer);

			// Append the header and container to the options parent.
			const optionsParent = isAdvanced ? embedAdvOptsContent : embedOptsContent;
			optionsParent.appendChild(groupContainer);
		});
	}

	/**
	 * Create the group inputs.
	 * @param {Array<object>} items
	 * @param {HTMLElement} groupContainer
	 */
	createGroupInputs(items, groupContainer) {
		items.forEach(option => {
			const { name, description, query, type, values, inputDefault, greyValue, appQueryDefault, invert, onChange } = option;

			const singleInput = type === 'checkbox' || type === 'number';
			const radioInput = type === 'radio';
			const greyedOut = inputDefault === greyValue;

			/**
			 * Currently this supports checkbox or number (single input), and radio inputs.
			 */
			if (singleInput) {
				// Create the container.
				const inputContainer = document.createElement('div');
				inputContainer.className = `input-container ${type}-container ${greyedOut ? 'greyed-out' : ''}`;

				// Create the label and input
				const embedId = `input-${query}`;
				const label = document.createElement('label');
				label.className = 'clickable';
				label.innerText = name;
				label.setAttribute('for', embedId);

				const input = document.createElement('input');
				input.className = 'clickable';
				input.setAttribute('id', embedId);
				input.setAttribute('type', type);
				input.setAttribute('name', query);

				if (type === 'checkbox' && inputDefault === true) {
					input.setAttribute('checked', '');
				}
				else if (type === 'number') {
					const [min, max, step] = values;
					input.setAttribute('min', min);
					input.setAttribute('max', max);
					input.setAttribute('step', step ?? 1);
					input.setAttribute('value', inputDefault);
					input.setAttribute('inputmode', 'decimal');
					input.setAttribute('required', '');
				}
				else {
					input.setAttribute('value', inputDefault);
				}

				// Prevent the click event from bubbling up (fixes weird no-cursor bug in chrome)
				input.addEventListener('click', e => e.stopPropagation());

				// Add the change event listener.
				input.addEventListener('change', e => {
					const { checked, value, validity } = e.target;
					if (type === 'checkbox') {
						const invertedValue = invert ? !checked : checked;
						this.updateEmbedParams(query, invertedValue);

						// Call the onChange function if it exists.
						typeof onChange === 'function' && onChange(checked);
					}
					else if (type === 'number') {
						const valueFloat = parseFloat(value);
						const setValue = validity.valid ? valueFloat : appQueryDefault;

						// Update the embed params (if the value is invalid, we still need to update to the app default (to potentially remove a previous value)
						this.updateEmbedParams(query, setValue);

						// Toggle the greyed-out class based on the validity.
						const isGreyedOut = !validity.valid || valueFloat === greyValue;
						inputContainer.classList.toggle('greyed-out', isGreyedOut);

						// Call the onChange function if it exists.
						typeof onChange === 'function' && onChange(value);
					}
				});

				// Create the help icon and tippy.
				const helpIcon = document.createElement('span');
				helpIcon.className = 'clickable icon icon-help';
				helpIcon.setAttribute('data-tippy-content', description);
				helpIcon.setAttribute('aria-label', `Help: ${description}`);
				// Make it focusable (spans are not focusable by default)
				helpIcon.setAttribute('tabindex', '0');

				// Add the input, label and icon to the container.
				inputContainer.appendChild(input);
				inputContainer.appendChild(label);
				inputContainer.appendChild(helpIcon);

				// Append the inputContainer to the groupContainer.
				groupContainer.appendChild(inputContainer);
			}
			else if (radioInput) {
				// Create the radio fieldset.
				const radioFieldset = document.createElement('fieldset');
				radioFieldset.className = `radio-fieldset ${type}-option`;

				// Create the radio legend.
				const radioLegend = document.createElement('legend');
				radioLegend.innerText = name;
				radioFieldset.appendChild(radioLegend);

				values.forEach(({ title, value, description }) => {
					// Create the details and summary elements.
					const inputContainer = document.createElement('div');
					inputContainer.className = `input-container ${type}-container`;

					// Create the radio label.
					const radioId = `input-${query}-${value}`;
					const radioLabel = document.createElement('label');
					radioLabel.className = 'clickable';
					radioLabel.innerText = title;
					radioLabel.setAttribute('for', radioId);

					// Create the radio input.
					const radioInput = document.createElement('input');
					radioInput.className = 'clickable';
					radioInput.setAttribute('id', radioId);
					radioInput.setAttribute('type', type);
					radioInput.setAttribute('name', query);
					radioInput.setAttribute('value', value);
					// Conditionally set the checked attribute.
					if (value === inputDefault) {
						radioInput.setAttribute('checked', '');
					}

					// Add the change event listener.
					radioInput.addEventListener('change', e => {
						const { value } = e.target;
						this.updateEmbedParams(query, value);
					});

					// Create the help icon and tippy.
					const helpIcon = document.createElement('span');
					helpIcon.className = 'clickable icon icon-help';
					helpIcon.setAttribute('data-tippy-content', description);
					helpIcon.setAttribute('aria-label', `Help: ${description}`);
					// Make it focusable (spans are not focusable by default)
					helpIcon.setAttribute('tabindex', '0');

					// Add the input, label and icon to the inputContainer.
					inputContainer.appendChild(radioInput);
					inputContainer.appendChild(radioLabel);
					inputContainer.appendChild(helpIcon);

					// Append the inputContainer to the fieldset container.
					radioFieldset.appendChild(inputContainer);
				});

				// Append the radio container to the group container.
				groupContainer.appendChild(radioFieldset);
			}
		});
	}

	/**
	 * Destroy the embed content.
	 */
	destroyEmbedContent() {
		const { embedOptsContent, embedAdvOptsContent } = this._children;
		embedOptsContent.innerHTML = '';
		embedAdvOptsContent.innerHTML = '';
	}


	/**
	 * Set the active tab.
	 * @param {string} tabName
	 */
	setActiveTab(tabName) {
		const { tabHeaders, tabContent } = this._children;

		// Set the active class on the tab headers and content.
		tabHeaders.childNodes.forEach(tabHeaderEl => {
			const active = tabHeaderEl.classList.contains(tabName);
			tabHeaderEl.classList.toggle('active', active);
		});

		tabContent.childNodes.forEach(tabContentEl => {
			const active = tabContentEl.classList.contains(tabName);
			tabContentEl.classList.toggle('active', active);
		});

		// If the embed tab is selected, update the embed code
		if (tabName === 'embed') {
			this.updateEmbedCode();

			// Set the tippy tooltip content if not already set.
			if (this._tippySingleton === null) {
				this._tippyItems = (0,tippy_js__WEBPACK_IMPORTED_MODULE_4__["default"])('.icon-help');
				this._tippySingleton = (0,tippy_js__WEBPACK_IMPORTED_MODULE_4__.createSingleton)(this._tippyItems, {
					moveTransition: 'transform 0.2s ease-out'
				});
			}
		}

		// Set the active tab state.
		this._activeTab = tabName;
	}

	/**
	 * Copy to clipboard method
	 * @param {Event} e
	 */
	copyToClipboard(e) {
		const { linkCode, linkContainer, embedCode, copiedOverlay } = this._children;

		// Determine whether we're copying the link or the embed code.
		const isLink = e.currentTarget.parentElement === linkContainer;
		const codeText = isLink ? linkCode.textContent : embedCode?.textContent;

		if (!codeText) {
			return;
		}

		navigator.clipboard.writeText(codeText)
			.then(() => {
				// Add the active class to display the overlay.
				copiedOverlay.classList.remove('flash');

				// Trigger a reflow.
				// eslint-disable-next-line no-unused-expressions, no-void
				void copiedOverlay.offsetWidth;

				// Remove the active class to hide the overlay.
				copiedOverlay.classList.add('flash');
				return true;
			})
			.catch(err => {
				console.error('Could not copy text: ', err);
			});
	}

	// HANDLERS

	/**
	 * Click / close handler.
	 * @param {Event} e
	 */
	handleClick(e) {
		const { resetOnClose } = this._config;
		const shouldClose = e.target === this._element || e.target === this._children.closeButton;
		if (shouldClose) {
			this.hide();
			this.resetScrollbar();
			resetOnClose && this.resetEmbedOptions();
			this.destroyTooltips();
		}

		const shouldDeselectText = e.target?.nodeName !== 'CODE';
		shouldDeselectText && window.getSelection().removeAllRanges();
	}

	/**
	 * Tab click handler.
	 * @param {Event} e
	 */
	handleTabClick(e) {
		const tabName = e.target?.innerText?.toLowerCase();
		const setActive = tabName === 'link' || tabName === 'embed';
		setActive && this.setActiveTab(tabName);
	}

	/**
	 * Destroy the tippy instances.
	 */
	destroyTooltips() {
		this._tippyItems = null;

		this._tippySingleton?.destroy();
		this._tippySingleton = null;
	}

	/**
	 * Reset the embed options.
	 */
	resetEmbedOptions() {
		this.setEmbedParams();

		// Destroy, then re-create the embed content.
		this.destroyEmbedContent();
		this.generateEmbedContent();
	}

	/**
	 * Reset the scrollbar.
	 */
	resetScrollbar() {
		// Reset scroll to top
		this._embedOptionsScrollbar.scroll(0);
	}

	/**
	 * Called on every resize.
	 * @override
	 */
	resize() {
		// Update the iframe transform
		this.calcIframeTransforms();

		// Determine if we need to update the share button parent.
		const isWideHasUpdated = this.setIsWide();

		if (isWideHasUpdated) {
			this.addShareButtonToParent();
			this.resetScrollbar();
		}
	}

	/**
	 * Manually hide the share button.
	 * @param {boolean} enabled
	 * @override
	 */
	setEnabled(enabled) {
		super.setEnabled(enabled);

		// Toggle the share button visibility and parent.
		this.shareButton.classList.toggle('hidden', !enabled);
		const addToParent = enabled && !this.shareButton.parentNode;
		addToParent && this.addShareButtonToParent();
	}

	/**
	 * Make sure the destroy also removes the share button.
	 */
	__destroy() {
		super.__disable();

		this.shareButton.parentNode?.removeChild(this.shareButton);
		this.shareButton = null;
	}
}

ShareModal.html = (_share_modal_html__WEBPACK_IMPORTED_MODULE_2___default());

/* harmony default export */ __webpack_exports__["default"] = (ShareModal);


/***/ }),

/***/ "../eyes/src/components/story/blocks/buttons_block/buttons_block.js":
/*!**************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/buttons_block/buttons_block.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ButtonsBlock": function() { return /* binding */ ButtonsBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _buttons_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./buttons_block.html */ "../eyes/src/components/story/blocks/buttons_block/buttons_block.html");
/* harmony import */ var _buttons_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_buttons_block_html__WEBPACK_IMPORTED_MODULE_1__);
//@ts-nocheck







/**
 * Block for buttons
 */
class ButtonsBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, {
			...options
		});

		this._app = app;
		this._options = options;

		const scene = app.pioneer.get('main');
		scene.getLoadedPromise().then(() => {
			this.setUpHTML(options);
			return true;
		}).catch(error => {
			console.warn(error);
		});
	}

	/**
	 * Set up html
	 * @param {object} options - options from story config file
	 */
	async setUpHTML(options) {
		const { buttonContent } = options.config.info;
		const buttonBlock = document.getElementsByClassName('buttons-block');

		buttonContent.forEach((buttonInfo, index) => {
			const { id, iconSrc, label } = buttonInfo;
			// Create buttons depending on options given
			const button = document.createElement('button');
			buttonBlock[0].appendChild(button);

			button.classList.add('clickable');
			button.classList.add('custom-button');
			button.classList.add(`${id}`);

			if (index === 0) {
				// Add the "focused" class to the first button (i.e. eclipse earth view)
				button.classList.add('focused');
			}

			const buttonIcon = document.createElement('img');
			button.appendChild(buttonIcon);
			buttonIcon.classList.add('button-icon');
			buttonIcon.src = iconSrc;

			const buttonLabel = document.createTextNode(label);
			button.appendChild(buttonLabel);

			button.onclick = this.buttonClick;
		});

	}

	/**
	 * Custom button click events
	 * @param {object} e - e.target for click event
	 */
	buttonClick = async e => {
		const { buttonContent } = this._options.config.info;
		const timeManager = this._app.getManager('time');

		const selectedButton = Object.values(buttonContent).find(button => e.target.classList.contains(button.id));

		// Remove the "focused" class from all buttons
		const allButtons = document.querySelectorAll('.custom-button');
		allButtons.forEach(button => button.classList.remove('focused'));

		// Set custom time limits for each button view
		if (selectedButton.timeLimits) {
			timeManager.setMin(selectedButton.timeLimits.min);
			timeManager.setMax(selectedButton.timeLimits.max);
		}
		else {
			timeManager.resetLimits();
		}
		// Get default time set in story to reset each view to desired time
		const { _id: storyId } = this._app.getComponent('story');
		const currentStory = this._app.getManager('content').getStory(storyId);
		const defaultTime = currentStory.slides[0].time;

		// If custom time for each button exists in [story_id].js, set that; If not, set default slide time on enter of new view
		timeManager.setTime(selectedButton.startTime ?? defaultTime);
		timeManager.setTimeRate(300);

		// Add the "focused" class to the clicked button
		e.target.classList.add('focused');

		// Passed in button click function from story
		selectedButton.onClick(this._app);
	};
}

ButtonsBlock.html = (_buttons_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/checkbox_block/checkbox_block.js":
/*!****************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/checkbox_block/checkbox_block.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CheckboxBlock": function() { return /* binding */ CheckboxBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _checkbox_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./checkbox_block.html */ "../eyes/src/components/story/blocks/checkbox_block/checkbox_block.html");
/* harmony import */ var _checkbox_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_checkbox_block_html__WEBPACK_IMPORTED_MODULE_1__);
// @ts-nocheck







/**
 * Block for buttons
 */
class CheckboxBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, {
			...options
		});

		const scene = app.pioneer.get('main');
		scene.getLoadedPromise().then(() => {
			this.setUpHTML(options);
			return true;
		}).catch(error => {
			console.warn(error);
		});

		this.options = options;
	}

	/**
	 * Set up html
	 * @param {object} options - options from story config file
	 */
	async setUpHTML(options) {
		const { checkboxContent } = options.config.info;
		const checkboxBlock = document.getElementsByClassName('checkboxes-block')[0];

		checkboxContent.forEach(checkboxInfo => {
			const { id, label, onChange } = checkboxInfo;

			// Create label element
			const labelElement = document.createElement('label');
			labelElement.classList.add('cb-container');
			labelElement.classList.add('clickable');

			// Create checkbox element
			const checkbox = document.createElement('input');
			checkbox.type = 'checkbox';
			checkbox.checked = true; // Set default checked state
			checkbox.id = `${id}-checkbox`;

			// Create span for custom checkmark
			const span = document.createElement('span');
			span.classList.add('checkmark');

			// Append elements
			labelElement.appendChild(document.createTextNode(label));
			labelElement.appendChild(checkbox);
			labelElement.appendChild(span);
			checkboxBlock.appendChild(labelElement);

			// Listen to the "change" event
			checkbox.addEventListener('change', e => {
				onChange(e, this._app);
			});
		});
	}

	/**
	 * Set checked or not
	 * @param {*} checkboxId
	 * @param {*} checked
	 */
	setChecked(checkboxId, checked) {
		const checkbox = document.getElementById(`${checkboxId}-checkbox`);
		if (checkbox) {
			checkbox.checked = checked;
		}
	}
}

CheckboxBlock.html = (_checkbox_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/description_block/description_block.js":
/*!**********************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/description_block/description_block.js ***!
  \**********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DescriptionBlock": function() { return /* binding */ DescriptionBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _description_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./description_block.html */ "../eyes/src/components/story/blocks/description_block/description_block.html");
/* harmony import */ var _description_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_description_block_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Block for description.
 */
class DescriptionBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, {
			hasMore: false,
			isMoreVisible: false,
			...options
		});

		this._class.hasMoreClass = {
			true: '',
			false: 'hidden'
		};

		this._more = {
			isVisible: {
				moreMessage: 'Show Less',
				moreIcon: 'icon-minus',
				moreClass: ''
			},
			isHidden: {
				moreMessage: 'Show More',
				moreIcon: 'icon-plus',
				moreClass: 'hidden'
			}
		};

		Object.assign(this._state, this._more.isHidden, {
			hasMoreClass: this._class.hasMoreClass[this._state.hasMore]
		});
	}

	/** @inheritdoc */
	init() {
		super.init();

		const hasMore = Boolean(this._config.info.more);
		this.setState({
			hasMore,
			hasMoreClass: this._class.hasMoreClass[hasMore]
		});
	}

	/**
	 * Show more block.
	 */
	showMore() {
		this.setState({
			isMoreVisible: true,
			...this._more.isVisible
		});
	}

	/**
	 * Hide more block.
	 */
	hideMore() {
		this.setState({
			isMoreVisible: false,
			...this._more.isHidden
		});
	}

	/**
	 * Show/hide more block.
	 */
	toggleMore() {
		if (this._state.isMoreVisible) {
			this.hideMore();
		}
		else {
			this.showMore();
		}
	}
}

DescriptionBlock.html = (_description_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/hint_block/hint_block.js":
/*!********************************************************************!*\
  !*** ../eyes/src/components/story/blocks/hint_block/hint_block.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "HintBlock": function() { return /* binding */ HintBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _hint_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hint_block.html */ "../eyes/src/components/story/blocks/hint_block/hint_block.html");
/* harmony import */ var _hint_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_hint_block_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Block for description.
 */
class HintBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, {
			iconBefore: 'icon-greater',
			iconAfter: 'icon-greater',
			...options
		});

		Object.assign(this._state, {
			text: this._config.info.text || 'Scroll to continue',
			isIconBeforeVisibleClass: this._class.isVisible[this._config.info.iconBeforeText || false],
			isIconAfterVisibleClass: this._class.isVisible[this._config.info.iconAfterText || false]
		});
	}
}

HintBlock.html = (_hint_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/image_block/image_block.js":
/*!**********************************************************************!*\
  !*** ../eyes/src/components/story/blocks/image_block/image_block.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ImageBlock": function() { return /* binding */ ImageBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _image_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./image_block.html */ "../eyes/src/components/story/blocks/image_block/image_block.html");
/* harmony import */ var _image_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_image_block_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Block for description.
 */
class ImageBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/**
	 * Called on clicking block.
	 * Expand the thumbnail to fullscreen.
	 * @override
	 */
	onClick() {
		// Set overlay's content to image
		const image = this._element.cloneNode(true);
		image.classList.add('fullscreen');
		image.classList.remove('clickable');

		this._app.getComponent('overlay').setContent(image);
		this._app.getComponent('overlay').show();
	}
}

ImageBlock.html = (_image_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/replay_button_block/replay_button_block.js":
/*!**************************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/replay_button_block/replay_button_block.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ReplayButtonBlock": function() { return /* binding */ ReplayButtonBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _replay_button_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./replay_button_block.html */ "../eyes/src/components/story/blocks/replay_button_block/replay_button_block.html");
/* harmony import */ var _replay_button_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_replay_button_block_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Block for button.
 */
class ReplayButtonBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/** @inheritdoc */
	init() {
		if (!this._config.info.text) {
			this._config.info.text = this._config.info.fromStart ? 'Restart Story' : 'Replay Animation';
		}
		super.init(this._config.info);
	}

	/**
	 * @inheritdoc
	 */
	async onClick() {
		const router = this._app.getManager('router');
		if (this._config.info.fromStart) {
			// Replay from start
			router.navigate(router.currentRoute.url);
		}
		else {
			// Replay current slide
			router.reload();
		}
	}
};

ReplayButtonBlock.html = (_replay_button_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/story_base_content_block/story_base_content_block.js":
/*!************************************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/story_base_content_block/story_base_content_block.js ***!
  \************************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StoryBaseContentBlock": function() { return /* binding */ StoryBaseContentBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");



/**
 * A base class for a block of content.
 */
class StoryBaseContentBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={config:{info:{}}}]
	 */
	constructor(app, options = { config: { info: {} } }) {
		options.isVisible = true;
		super(app, null, options);

		if (this._config.info.onEnter) {
			this.onEnter = async () => await this._config.info.onEnter(app, this);
		}

		if (this._config.info.onLeave) {
			this.onLeave = async () => await this._config.info.onLeave(app, this);
		}

		this.bindFunctions(['onEnter', 'onLeave', 'onClick']);
	}

	/** @inheritdoc */
	init() {
		super.init(this._config.info);
		this._element.classList.add('content-block', '{{isVisibleClass}}');
		if (Array.isArray(this._config.info.classList)) {
			this._element.classList.add(...this._config.info.classList);
		}
		this._setVariables(this._element, false);

		if (this._config.info.clickable || this._config.info.func) {
			this._element.classList.add('clickable');
			this._element.addEventListener('click', this.onClick);
		}
	}

	/**
	 * Called on entering the slide containing block.
	 * @returns {Promise}
	 */
	async onEnter() {
	}

	/**
	 * Called on leaving the slide containing block.
	 * @returns {Promise}
	 */
	async onLeave() {
	}

	/**
	 * Called on clicking block.
	 * @returns {Promise}
	 */
	async onClick() {
		const { type } = this._config.info;
		// Buttons get custom onClick functions passed in
		if (type !== 'buttons') {
			await this._config.info.func(this._app, this);
		}
	}
}


/***/ }),

/***/ "../eyes/src/components/story/blocks/title_block/title_block.js":
/*!**********************************************************************!*\
  !*** ../eyes/src/components/story/blocks/title_block/title_block.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TitleBlock": function() { return /* binding */ TitleBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _title_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./title_block.html */ "../eyes/src/components/story/blocks/title_block/title_block.html");
/* harmony import */ var _title_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_title_block_html__WEBPACK_IMPORTED_MODULE_1__);



/**
 * Block for description.
 */
class TitleBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
}

TitleBlock.html = (_title_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/blocks/toggle_block/toggle_block.js":
/*!************************************************************************!*\
  !*** ../eyes/src/components/story/blocks/toggle_block/toggle_block.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ToggleBlock": function() { return /* binding */ ToggleBlock; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _toggle_block_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toggle_block.html */ "../eyes/src/components/story/blocks/toggle_block/toggle_block.html");
/* harmony import */ var _toggle_block_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_toggle_block_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Block for description.
 */
class ToggleBlock extends _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app, {
			isSelected: false,
			...options
		});

		this._class.isSelectedClass = {
			true: 'selected',
			false: ''
		};

		// Make sure this is a boolean value
		this._config.info.selected = Boolean(this._config.info.selected);

		Object.assign(this._state, {
			isSelectedClass: this._class.isSelectedClass[this._state.isSelected]
		});
	}

	/**
	 * Called on entering the slide containing block.
	 * @returns {Promise}
	 */
	async onEnter() {
		await super.onEnter();
		if (this._config.info.selected !== this._state.isSelected) {
			await this.onClick();
		}
	}

	/**
	 * Called on leaving the slide containing block.
	 * @returns {Promise}
	 */
	async onLeave() {
		await super.onLeave();
		if (this._state.isSelected) {
			await this.onClick();
		}
	}

	/**
	 * Called on clicking block.
	 * @returns {Promise}
	 */
	async onClick() {
		await super.onClick();
		if (this._state.isSelected) {
			this.unselect();
			console.log('unselect');
		}
		else {
			this.select();
			console.log('select');
		}
	}

	/**
	 * Select button.
	 */
	select() {
		this.setState({
			isSelected: true,
			isSelectedClass: this._class.isSelectedClass.true
		});
	}

	/**
	 * Unselect button.
	 */
	unselect() {
		this.setState({
			isSelected: false,
			isSelectedClass: this._class.isSelectedClass.false
		});
	}
}

ToggleBlock.html = (_toggle_block_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/story/story.js":
/*!*********************************************!*\
  !*** ../eyes/src/components/story/story.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Story": function() { return /* binding */ Story; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");



/**
 * Story component.
 * @class
 * @extends Carousel
 */
class Story extends _internal__WEBPACK_IMPORTED_MODULE_0__.Carousel {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options) {
		super(app, null, {
			isCloseButtonVisible: true,
			closeButtonText: 'Close',
			...options
		});

		/**
		 * Story ID.
		 * @type {string}
		 */
		this._id = '';

		/**
		 * Story info, containing all slides in story.
		 * @type {Array}
		 */
		this._info = [];

		this._blocks = {};

		this._config.navigationButtons.next.text = _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.isPrimaryTouch()
			? 'Swipe to continue'
			: 'Scroll to continue';

		/**
		 * Function to call on changing slide via button or scroll.
		 * @type {Function}
		 */
		this._onSlideChange = async (index, includeTime = false) => {
			const query = {
				slide: this._children.slides[index].dataset.id
			};
			// Include the time so when we go back in time
			// we start at the end of the phase instead of start
			if (includeTime) {
				query.time = this._app.getManager('time').getTimeUrl();
			}
			else {
				query.__remove = ['time'];
			}

			const router = this._app.getManager('router');
			const currentRoute = router.currentRoute;
			await router.navigate(query, currentRoute.url);
		};
	}

	/** @inheritdoc */
	init() {
		super.init();

		// Set close button aria-label.
		const closeBtn = this._element.querySelector('.close-button');
		closeBtn?.setAttribute('aria-label', 'Close story');

		this._setVariables(this._children.carousel, false);
	}

	/**
	 * Set aria label depending on isCollapsed state.
	 */
	_setExpandToggleAriaLabel() {
		const toggleBtns = this._element.querySelectorAll('.mobile-collapse');
		const labelText = this._state.isCollapsed ? 'Collapse story panel' : 'Expand story panel';

		toggleBtns.forEach(el => el.setAttribute('aria-label', labelText));
	}

	/**
	 * Overriding toggleCollapse method to update aria label
	 * @override
	 */
	_toggleCollapse() {
		this._setExpandToggleAriaLabel();

		super._toggleCollapse();
	}

	/**
	 * Update story on route change.
	 * @param {object} storyInfo
	 * @param {object} [params={}] - Route parameters
	 * @param {CancelToken} params.cancelToken
	 * @param {string} params.slide - Slide ID
	 * @param {string} params.id - Story ID
	 */
	async onRouteChange(storyInfo, { cancelToken, slide, id } = {}) {
		// Check if route was canceled
		if (cancelToken && cancelToken.isCanceled) {
			return;
		}
		this.clear();
		this._info = storyInfo;
		this._id = id;

		// Hide navigation UI in locked mode
		if (this._app.getManager('router').configs.locked) {
			const isCloseButtonVisible = false;
			this.setState({
				isCloseButtonVisible,
				isCloseButtonVisibleClass: this._class.isVisible[isCloseButtonVisible]
			});
		}

		// Set up story UI
		await this.setUp();

		// Set expand toggle aria labels.
		this._setExpandToggleAriaLabel();

		// Find slide index using id, or default to first slide
		const index = slide
			? this._children.slides.findIndex(x => x.dataset.id === slide) || 0
			: 0;

		// Update time rate
		if (storyInfo[index]?.rate !== undefined) {
			this._app.getManager('time').setTimeRate(storyInfo[index].rate);
		}

		// Go to slide
		await this.goToSlide(index);
	}

	/**
	 * Execute actions on query change.
	 * @param {object} params
	 * @param {object} params.cancelToken
	 * @param {string} params.slide
	 */
	async onQueryChange({ cancelToken, slide } = {}) {
		// Check if route was canceled
		if (cancelToken && cancelToken.isCanceled) {
			return;
		}

		// Find slide index using id, or default to first slide
		const index = slide
			? this._children.slides.findIndex(x => x.dataset.id === slide) || 0
			: 0;

		// Update time rate
		if (this._info[index]?.rate !== undefined) {
			this._app.getManager('time').setTimeRate(this._info[index].rate);
		}

		// Go to slide
		await this.goToSlide(index);
	}

	/**
	 * Create content element for a block.
	 * @param {object} blockInfo
	 * @param {number} slideIndex
	 * @returns {HTMLElement}
	 */
	async createBlockContent(blockInfo, slideIndex) {
		const { hideExternalLinks } = this.app.getManager('router').configs;

		let block;

		switch (blockInfo.type) {
			case 'title': {
				const storyBlockInfo = { ...blockInfo };
				storyBlockInfo.title = hideExternalLinks === true ? this.app.getManager('content').hideExternalLinksInText(storyBlockInfo.title) : storyBlockInfo.title;
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.TitleBlock(this._app, { config: { info: storyBlockInfo } });
				break;
			}
			case 'description': {
				const storyBlockInfo = { ...blockInfo };
				storyBlockInfo.description = hideExternalLinks === true ? this.app.getManager('content').hideExternalLinksInText(storyBlockInfo.description) : storyBlockInfo.description;
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.DescriptionBlock(this._app, { config: { info: storyBlockInfo } });
				break;
			}
			case 'image':
			case 'diagram': {
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.ImageBlock(this._app, { config: { info: blockInfo } });
				break;
			}
			case 'toggle': {
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.ToggleBlock(this._app, { config: { info: blockInfo } });
				break;
			}
			case 'hint': {
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.HintBlock(this._app, { config: { info: blockInfo } });
				break;
			}
			case 'replay': {
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.ReplayButtonBlock(this._app, { config: { info: blockInfo } });
				break;
			}
			case 'buttons': {
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.ButtonsBlock(this._app, { config: { info: blockInfo } });
				break;
			}
			case 'checkboxes': {
				block = new _internal__WEBPACK_IMPORTED_MODULE_0__.CheckboxBlock(this._app, { config: { info: blockInfo } });
				break;
			}
			default:
				break;
		}

		await block.init();
		this._onEnter[slideIndex].push(block.onEnter);
		this._onLeave[slideIndex].push(block.onLeave);
		this._blocks[blockInfo.type] = block;
		return block.element;
	}

	/**
	 * Get block
	 * @param {string} blockType
	 * @returns {any} block
	 */
	getStoryBlock(blockType) {
		return this._blocks[blockType] || console.warn(`Block ${blockType} is not available`);
	}

	/**
	 * Create content element for a slide.
	 * @param {object} slide
	 * @param {number} index
	 * @returns {HTMLElement}
	 */
	async createSlideContent(slide, index) {
		if (slide.htmlFile) {
			// TODO: Load html from a file
		}
		else {
			const content = document.createDocumentFragment();

			for (let i = 0; i < slide.content.length; i++) {
				const blockInfo = slide.content[i];
				const block = await this.createBlockContent(blockInfo, index);
				if (block) {
					content.appendChild(block);
				}
			}

			return content;
		}
	}

	/**
	 * Set up story UI with story info.
	 */
	async setUp() {
		for (let i = 0; i < this._info.length; i++) {
			const { id, type, classList = [], onEnter, onLeave } = this._info[i];
			this._onEnter[i] = [];
			this._onLeave[i] = [];

			if (onEnter) {
				this._onEnter[i].push(() => onEnter(this._app, this));
			}
			const content = await this.createSlideContent(this._info[i], i);
			classList.push('grid-layout', 'simple-grid');

			if (onLeave) {
				this._onLeave[i].push(() => onLeave(this._app, this));
			}

			this.addSlide({
				id,
				type,
				classList,
				content
			},
			{
				isFirst: i === 0,
				isLast: i === this._info.length - 1
			});
		}
	}

	/**
	 * Close carousel.
	 * @override
	 */
	close() {
		const router = this._app.getManager('router');
		router.navigate(router.homeRoute);
	}

	/**
	 * @inheritdoc
	 */
	async onLeave(index) {
		await super.onLeave(index);

		// Reset on leaving story
		if (!(typeof index === 'number')) {
			const router = this._app.getManager('router');
			router.removeQuery(['slide']);
		}
	}

	/**
	 * Update tooltip props.
	 */
	_updateTooltipsProps() {
		const { slideType } = this._state;

		const style = getComputedStyle(document.body);
		const offsetHeight = -(parseFloat(style.getPropertyValue('--gridHeaderHeight')) + 20);

		if (this._progressTooltip !== null) {
			this._progressTooltip.setProps({
				offset: slideType === 'overlay'
					? [0, offsetHeight]
					: [0, 10]
			});
		}
	}
}


/***/ }),

/***/ "../eyes/src/components/time_controller/index.js":
/*!*******************************************************!*\
  !*** ../eyes/src/components/time_controller/index.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _time_controller_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./time_controller.js */ "../eyes/src/components/time_controller/time_controller.js");




/* harmony default export */ __webpack_exports__["default"] = (_time_controller_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/time_controller/time_controller.js":
/*!*****************************************************************!*\
  !*** ../eyes/src/components/time_controller/time_controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var tippy_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! tippy.js */ "../eyes/node_modules/tippy.js/dist/tippy.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _time_controller_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./time_controller.html */ "../eyes/src/components/time_controller/time_controller.html");
/* harmony import */ var _time_controller_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_time_controller_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * @inheritdoc
 * @extends BaseComponent
 * TODO: This is only used by Mars2020 app. Discuss what to do.
 */
class TimeController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * @inheritdoc
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app, null, {
			isPlay: false,
			playClass: '',
			rate: 0,
			rateDisplay: 0
		});

		this._class.fontSize.small = 'tiny';
		this._class.isPlay = {
			true: 'icon-pause',
			false: 'icon-play'
		};

		/**
		 * List of allowed rates.
		 * @type {Array}
		 */
		this._rates = [
			-94608000, // 3 years
			-31536000, // 1 year
			-6048000, // 10 weeks
			-604800, // 1 week
			-86400, // 1 day
			-36000, // 10 hours
			-3600, // 1 hour
			-600, // 10 mins
			-60,
			-10,
			-1,
			0,
			1,
			10,
			60,
			600,
			3600,
			36000,
			86400,
			604800,
			6048000,
			31536000,
			94608000
		];

		this._manager = this._app.getManager('time');
		this._router = this._app.getManager('router');
		this._manager.setDefaultTimeRate(1);

		const rate = this._manager.getTimeRate();
		const isPlay = rate !== 0;

		this.setState({
			isPlay,
			playClass: this._class.isPlay[isPlay],
			rate,
			rateDisplay: this.getRateDisplay()
		});

		this.bindFunctions([
			'getRateLimits',
			'setRateLimits',
			'setRate',
			'setDefaultRate',
			'setRealRate',
			'decreaseRate',
			'increaseRate',
			'togglePlayPause',
			'onRateChange',
			'onForcedPause',
			'onForcedPauseResume'
		]);
	}

	/** @inheritdoc */
	init() {
		super.init();

		/**
		 * Set default tippy props
		 * See docs: https://atomiks.github.io/tippyjs/v6/methods/
		 */
		tippy_js__WEBPACK_IMPORTED_MODULE_2__["default"].setDefaultProps({
			theme: 'default',
			touch: ['hold', 2000],
			delay: [600, null],
			plugins: [tippy_js__WEBPACK_IMPORTED_MODULE_2__.followCursor]
		});
		(0,tippy_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this._children.toggleBtn, { placement: 'top' });
		(0,tippy_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this._children.increaseBtn, { placement: 'top' });
		(0,tippy_js__WEBPACK_IMPORTED_MODULE_2__["default"])(this._children.decreaseBtn, { placement: 'top' });

		this._children.decreaseContainer.classList.add('bg-color', 'gray', 'dark');
		this._children.increaseContainer.classList.add('bg-color', 'gray', 'dark');
		this._children.label.classList.add('semi');
		this._children.rateDisplay.classList.add('semi');

		this._callbackRegistry.push({
			emitter: this._app.getManager('time'),
			event: 'ratechange',
			callback: this.onRateChange
		});
	}

	/**
	 * Get available time rates.
	 * @returns {Array<number>}
	 */
	getRateLimits() {
		return this._rates;
	}

	/**
	 * Set available time rates;
	 * @param {Array<number>} rates
	 */
	setRateLimits(rates) {
		this._rates = rates;
	}

	/**
	 * Navigate to url with rate.
	 * @param {number} rate
	 */
	setRate(rate) {
		this._router.navigate({
			time: this._manager.getTimeUrl(),
			rate
		}, this._router.currentRoute.url);
	}

	/**
	 * Decrease time rate to previous in available rates list.
	 */
	decreaseRate() {
		// List is empty
		if (this._rates.length === 0) {
			return;
		}
		const index = this._rates.indexOf(this._manager.getTimeRate());
		// Already at lower bound
		if (index === 0) {
			return;
		}
		this.setRate(this._rates[index - 1]);
	}

	/**
	 * Increase time rate to next in available rates list.
	 */
	increaseRate() {
		// List is empty
		if (this._rates.length === 0) {
			return;
		}
		const index = this._rates.indexOf(this._manager.getTimeRate());
		// Already at upper bound
		if (index === this._rates.length - 1) {
			return;
		}
		this.setRate(this._rates[index + 1]);
	}

	/**
	 * Toggle time play/pause.
	 */
	togglePlayPause() {
		const isPlay = !this._state.isPlay;
		if (isPlay) {
			this._manager.play();
		}
		else {
			this._manager.pause();
		}
		this.setRate(this._manager.getTimeRate());
	}

	/**
	 * Set rate to default rate.
	 */
	setDefaultRate() {
		this.setRate(this._manager.getDefaultTimeRate());
	}

	/**
	 * Set rate to real rate.
	 */
	setRealRate() {
		this.setRate(1);
	}

	/**
	 * Update UI on rate change.
	 */
	onRateChange() {
		const rate = this._manager.getTimeRate();
		const isPlay = rate !== 0;

		// No state change
		if (isPlay === this._state.isPlay && this._state.rate === rate) {
			return;
		}
		// Enforce rate inside list
		if (this._rates.length > 0) {
			if (!this._rates.includes(rate)) {
				this.setRate(this._manager.getDefaultTimeRate());
				return;
			}
		}

		this.setState({
			isPlay,
			rate,
			playClass: this._class.isPlay[isPlay],
			rateDisplay: this.getRateDisplay(rate)
		});
	}

	/**
	 * Update time rate on forced pause.
	 */
	onForcedPause() {
		this.setRate(0);
	}

	/**
	 * Update time rate on forced pause resume.
	 */
	onForcedPauseResume() {
		this.setDefaultRate();
	}

	/**
	 * Get info for time rate.
	 * @param {number|null} rate
	 * @returns {object} Rate and unit (per sec). E.g. `{ rate: 1, unit: ' sec' }`, `{ rate: 1, unit: ' min' }`
	 */
	getRateUnit(rate = null) {
		if (rate === null) {
			rate = this._manager.getTimeRate();
		}

		const yrs = rate / 31536000;
		const months = rate / 2592000;
		const weeks = rate / 604800;
		const days = rate / 86400;
		const hrs = rate / 3600;
		const mins = rate / 60;
		let unit = '';

		// Only get rate as whole number
		if ((yrs >= 1 || yrs <= -1) && yrs % 1 === 0) {
			rate = yrs;
			unit = ' yr';
		}
		else if ((months >= 1 || months <= -1) && months % 1 === 0) {
			rate = months;
			unit = ' mth';
		}
		else if ((weeks >= 1 || weeks <= -1) && weeks % 1 === 0) {
			rate = weeks;
			unit = ' wk';
		}
		else if ((days >= 1 || days <= -1) && days % 1 === 0) {
			rate = days;
			unit = ' day';
		}
		else if ((hrs >= 1 || hrs <= -1) && hrs % 1 === 0) {
			rate = hrs;
			unit = ' hr';
		}
		else if ((mins >= 1 || mins <= -1) && mins % 1 === 0) {
			rate = mins;
			unit = ' min';
		}
		else {
			rate %= 60;
			unit = ' sec';
		}

		return { rate, unit };
	}

	/**
	 * Get text display for rate.
	 * @param {number} input
	 * @returns {string}
	 */
	getRateDisplay(input) {
		const { rate, unit } = this.getRateUnit(input);
		if (rate !== 0) {
			return rate + unit + '(s)/sec';
		}
		else {
			return 'paused';
		}
	}
}

TimeController.html = (_time_controller_html__WEBPACK_IMPORTED_MODULE_1___default());

/* harmony default export */ __webpack_exports__["default"] = (TimeController);


/***/ }),

/***/ "../eyes/src/components/toast/toast.js":
/*!*********************************************!*\
  !*** ../eyes/src/components/toast/toast.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Toast": function() { return /* binding */ Toast; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _toast_html__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./toast.html */ "../eyes/src/components/toast/toast.html");
/* harmony import */ var _toast_html__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_toast_html__WEBPACK_IMPORTED_MODULE_1__);




/**
 * Toast component.
 *
 * A toast is essentially an alert that appears on the screen for a short period of time.
 * Currently we can only display one toast at a time.
 * @extends BaseComponent
 */
class Toast extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		// Add state options
		super(app, null, {
			isVisible: false,
			iconClass: 'icon-locked',
			toastContent: 'TOAST!',
			hideDelay: 2000,
			...options
		});

		/**
		 * The hideTimeout is the timeout that will hide the toast.
		 * @type {number|null}
		 * @private
		 */
		this._hideTimeout = null;
	}

	/**
	 * Sets the icon class
	 * @param {string} iconClass
	 */
	setIcon(iconClass) {
		this.setState({
			iconClass
		});
	}

	/**
	 * Set the toast content
	 * @param {string} content
	 */
	setContent(content) {
		this.setState({
			toastContent: content
		});
	}

	/** @override */
	show() {
		super.show();

		// Set the hide timeout if we have a hide delay.
		const { hideDelay } = this._state;
		if (hideDelay) {
			clearTimeout(this._hideTimeout);

			this._hideTimeout = setTimeout(() => {
				this.hide();
			}, hideDelay);
		}
	}

	/** @override */
	hide() {
		super.hide();
		// Clear the hide timeout.
		clearTimeout(this._hideTimeout);
	}
}

Toast.html = (_toast_html__WEBPACK_IMPORTED_MODULE_1___default());


/***/ }),

/***/ "../eyes/src/components/tutorial_overlay/index.js":
/*!********************************************************!*\
  !*** ../eyes/src/components/tutorial_overlay/index.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _tutorial_overlay_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tutorial_overlay.js */ "../eyes/src/components/tutorial_overlay/tutorial_overlay.js");



/* harmony default export */ __webpack_exports__["default"] = (_tutorial_overlay_js__WEBPACK_IMPORTED_MODULE_0__["default"]);


/***/ }),

/***/ "../eyes/src/components/tutorial_overlay/tutorial_overlay.js":
/*!*******************************************************************!*\
  !*** ../eyes/src/components/tutorial_overlay/tutorial_overlay.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var swiper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! swiper */ "../eyes/node_modules/swiper/swiper.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../internal */ "../eyes/src/internal.js");
/* harmony import */ var _tutorial_overlay_html__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./tutorial_overlay.html */ "../eyes/src/components/tutorial_overlay/tutorial_overlay.html");
/* harmony import */ var _tutorial_overlay_html__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(_tutorial_overlay_html__WEBPACK_IMPORTED_MODULE_6__);









swiper__WEBPACK_IMPORTED_MODULE_0__["default"].use([swiper__WEBPACK_IMPORTED_MODULE_0__.Navigation, swiper__WEBPACK_IMPORTED_MODULE_0__.Keyboard, swiper__WEBPACK_IMPORTED_MODULE_0__.Mousewheel]);

const DISMISS_TEXT = {
	DEFAULT: 'OK, got it. Thanks!',
	LAST: "OK, let's go!"
};

/**
 * Tutorial overlay component.
 * @extends BaseComponent
 */
class TutorialOverlay extends _internal__WEBPACK_IMPORTED_MODULE_5__.BaseComponent {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		/**
		 * Swiper options
		 */
		options.config = {
			direction: 'horizontal',

			speed: 600,

			slidesPerView: 1,
			spaceBetween: 100,
			keyboard: {
				enabled: true
			},
			mousewheel: {
				forceToAxis: true,
				thresholdDelta: 100
			},

			// Navigation arrows
			navigation: {
				prevEl: '.tutorial-carousel-prev',
				nextEl: '.tutorial-carousel-next'
			},

			...options.config
		};

		// TODO: Make this more general for reuse, like allow changing footer text
		super(app, null, {
			isVisible: false,
			carouselClass: 'tutorial-carousel',
			slideClass: '',
			dismissText: DISMISS_TEXT.DEFAULT,
			...options
		});

		/**
		 * Define swiper prop
		 */
		this._swiper = null;

		/**
		 * Array of tutorial data
		 */
		this._allTutorials = null;

		/**
		 * Array of measurements for targeted elements
		 */
		this._elementMeasures = null;

		/**
		 * Define startIndex
		 */
		this._currIndex = null;

		/**
		 * Define slide viewed timeout
		 */
		this._slideViewedTimeout = null;

		/**
		 * For some reason, it takes some extra time for some elements to be measureed as in the correct position.
		 * Setting a timeout before initialization fixes this (badly) but it is cleared on exit (query undefined).
		 */
		this._initTimeout = null;

		/**
		 * Class name props
		 */
		this._bulletClass = 'swiper-pagination-bullet';
		this._activeBulletClass = 'swiper-pagination-bullet-active';
		this._swiperSlideClass = 'swiper-slide';

		/**
		 * Local storage item name
		 */
		this._storageName = 'EoA_Tutorials';
	}

	/**
	 * Sets the all tutorials prop, and create carousel slides
	 * @param {Array} tutorials
	 */
	setTutorials(tutorials) {
		this._allTutorials = tutorials;

		this._createSlides();
	}

	/**
	 * Return tutorials list after hiding tutorial slides in slideshow
	 * @param {string} slideId
	 * @returns {Array<TutorialOverlay>}
	 */
	hideTutorialSlide(slideId) {
		const { tutorials } = this.app;
		return tutorials.filter(({ id }) => id !== slideId);
	}

	/**
	 * Add slide change to update active bullet (as we're not using the built-in swiper bullets...cant remember why).
	 * Also allowing clicking to navigate to definition if data-def attr including in clickable links in tutorials.json.
	 */
	_addEvents() {
		this._swiper.on('slideChange', ({ realIndex }) => {
			// Update the highlighted element.
			this._setHighlightedElement(realIndex);

			// Update the active bullet
			this._setActiveBullet(realIndex);

			// Update the URL if necessary.
			if (this._currIndex !== realIndex) {
				this.navigateToTutorial(realIndex);
			}

			// Set the dismisss text and slideClass states.
			const { id: slideName } = this._allTutorials[realIndex] || {};
			const lastSlide = realIndex === this._allTutorials.length - 1;
			const slideClass = slideName ? `tutorial-slide-${slideName}` : '';

			this.setState({
				dismissText: lastSlide ? DISMISS_TEXT.LAST : DISMISS_TEXT.DEFAULT,
				slideClass
			});
		});

		// Click event to handle definition overlays
		this._children.swiperSlides.addEventListener('click', event => {
			const definition = event?.target?.dataset?.def;
			if (definition) {
				this._app.getComponent('definitionOverlay').navigateToDefinition(definition);
			}
		});
	}


	/**
	 * Use the tutorial data to build the swiper slides
	 */
	_createSlides() {
		const { isTouch } = this._app;

		this._allTutorials.forEach(({ id, title, description, extra }) => {
			const slideElements = [];

			if (title) {
				const titleEl = document.createElement('h2');
				titleEl.innerHTML = title;
				slideElements.push(titleEl);
			}

			if (description) {
				// Assumes only touch and desktop keys.
				const html = typeof description === 'object' ?
					(isTouch ? description.touch : description.desktop) :
					description;

				// Make sure we have HTML to apply.
				if (typeof html === 'string') {
					const descriptionEl = document.createElement('p');
					descriptionEl.innerHTML = html;
					slideElements.push(descriptionEl);
				}
			}

			if (extra) {
				// Assumes only touch and desktop keys.
				const html = typeof extra === 'object' ?
					(isTouch ? extra.touch : extra.desktop) :
					extra;

				// Make sure we have HTML to apply.
				if (typeof html === 'string') {
					const extraEl = document.createElement('div');
					extraEl.className = 'tutorial-extra';
					extraEl.innerHTML = html;
					slideElements.push(extraEl);
				}
			}

			const slideClass = `${this._swiperSlideClass} tutorial-slide-${id}`;

			slideElements.length && this._addSlide(slideElements, slideClass);
		});
	}

	/**
	 * Add an array of elements as a slide to the carousel
	 * @param {Array<HTMLElement>} elements
	 * @param {string} slideClass
	 */
	_addSlide(elements = [], slideClass) {
		// Create element.
		const slideEl = document.createElement('div');

		slideEl.className = slideClass;

		// Add elements as children.
		slideEl.replaceChildren(...elements);

		// Append to swiper slides.
		this._children.swiperSlides.append(slideEl);
	}

	/**
	 * Create bullet pagination
	 */
	_createBullets() {
		const { bullets } = this._children;
		const { slides } = this._swiper;


		const allBullets = [...slides].map((slide, i) => {
			const bullet = document.createElement('span');
			bullet.classList.add(this._bulletClass);

			// Add the click event
			bullet.addEventListener('click', e => this._swiper.slideTo(i));

			return bullet;
		});

		bullets.replaceChildren(...allBullets);
	}

	/**
	 * Makes sure all bullets are deactivated except the passed index
	 * @param {number} activeIndex
	 */
	_setActiveBullet(activeIndex = this._currIndex) {
		const { bullets } = this._children;

		bullets.childNodes.forEach((bullet, i) => {
			bullet.classList.remove(this._activeBulletClass);
			if (i === activeIndex) {
				bullet.classList.add(this._activeBulletClass);
			}
		});
	}


	/**
	 * Unhighlights all targeted elements except passed index
	 * @param {number} highlightIndex
	 * @param {boolean} forceMeasure
	 */
	_setHighlightedElement(highlightIndex = this._currIndex, forceMeasure = false) {
		const calcMeasures = !this._elementMeasures || forceMeasure;

		if (calcMeasures) {
			this._elementMeasures = this._calcElementMeasures();
		}

		const measures = this._elementMeasures[highlightIndex];
		const { mask } = this._allTutorials[highlightIndex];

		if (measures) {
			// Destructure vars.
			const { xPos, yPos, relWidth, relHeight } = measures;
			const { xSizeMult = 1, ySizeMult = 1 } = mask || {};


			// Calc size, range and pos values.
			const sizeCoeff = 15; // Correlated to the black percent value in radial gradient css.
			const sizeXaddition = relWidth * sizeCoeff * 100;
			const sizeYaddition = relHeight * sizeCoeff * 100;

			const xSize = (200 + sizeXaddition) * xSizeMult;
			const ySize = (200 + sizeYaddition) * ySizeMult;

			const xSizeValid = Math.max(200, xSize);
			const ySizeValid = Math.max(200, ySize);

			const rangeXcoeff = 100 / (xSizeValid - 100);
			const rangeYcoeff = 100 / (ySizeValid - 100);

			const relX = (0.5 - rangeXcoeff * 0.5) + xPos * rangeXcoeff;
			const relY = (0.5 - rangeYcoeff * 0.5) + yPos * rangeYcoeff;

			const percX = (relX * 100).toFixed(2);
			const percY = (relY * 100).toFixed(2);

			// Set the CSS vars.
			this._element.style.setProperty('--tutorial-mask-grad', 'radial-gradient(transparent, black 5%)');
			this._element.style.setProperty('--tutorial-mask-pos', `${percX}% ${percY}%`);
			this._element.style.setProperty('--tutorial-mask-size', `${xSizeValid}% ${ySizeValid}%`);
		}
		else {
			this._element.style.setProperty('--tutorial-mask-grad', null);
			this._element.style.setProperty('--tutorial-mask-pos', null);
			this._element.style.setProperty('--tutorial-mask-size', null);
		}

		// Potential fallback if we test and find cases where masks dont work
		// this._targetElements.forEach((element, i) => {
		// 	if (element) {
		// 		element.style.zIndex = i === highlightIndex ? 1001 : null;
		// 	}
		// });
	}


	/**
	 * Called when the url get params change. Wraps _updateDefinition
	 * @param {object} params
	 * @param {CancelToken} params.cancelToken
	 * @param {string} params.tutorial
	 */
	onQueryChange({ cancelToken, tutorial } = {}) {
		// Cancel slider viewed timeout no matter what.
		clearTimeout(this._slideViewedTimeout);

		// Should only show if we're on the home route. Return if we're not there.
		const { currentRoute, homeRoute } = this.app.getManager('router');
		const notHome = currentRoute.url !== homeRoute;

		// Check if route was canceled
		if (notHome || cancelToken?.isCanceled) {
			return;
		}

		const newCurrIndex = this._getIndexByTutorialId(tutorial);


		// Return if we're already on the correct index.
		if (newCurrIndex === this._currIndex) {
			return;
		}

		this._currIndex = newCurrIndex;

		/**
		 * Determine whether we:
		 * 1) Try to slide to the current index (will only work if user directly changes url)
		 * 2) Show / potentially initialize the swiper if it's not visible
		 * 3) Hide the slider as there was no passed tutorialId
		 */
		if (this._currIndex > -1) {
			if (this._state.isVisible) {
				this._swiper.slideTo(this._currIndex);
			}
			else {
				this.show();
			}
			this._setSlideViewedTimeout(newCurrIndex);
		}
		else {
			this.hide();
		}
	}

	/**
	 * Initialize the swiper carousel.
	 */
	_initSwiper() {
		const { carouselClass } = this._state;

		const selector = `.${carouselClass} .swiper-wrapper > div`;

		_internal__WEBPACK_IMPORTED_MODULE_5__.AppUtils.elementReady(selector)
			.then(() => {
				this._initTimeout = setTimeout(() => {
					// If there's already a swiper, update it and slide to first index.
					if (this._swiper) {
						this._swiper.update();
						this._swiper.slideTo(this._currIndex);
					}
					else {
					// Otherwise, create it.
						this._swiper = new swiper__WEBPACK_IMPORTED_MODULE_0__["default"](`.${carouselClass}`, this._config);
						this._postSwiperInitFunction(this._swiper);
					}

					// Set active bullets and highlight target elements if slideTo doesnt trigger event (if index is 0)
					if (this._currIndex === 0) {
						this._setActiveBullet();
						this._setHighlightedElement();
					}

					// Show it now it's ready.
					super.show();
				}, 500);
			});
	}

	/**
	 * Called after swiper is initialized.
	 */
	_postSwiperInitFunction() {
		// Add event handler
		this._addEvents();

		// Add bullets
		this._createBullets();

		//  Slide to firstIndex.
		this._swiper.slideTo(this._currIndex);
	}

	/**
	 * Get the tutorial index by id
	 * @param {string} tutorialId
	 * @returns {number}
	 */
	_getIndexByTutorialId(tutorialId) {
		return this._allTutorials?.findIndex(({ id }) => id === tutorialId);
	}

	/**
	 * Start a timer which, when reached, will record that this view has  been "viewed" in the localStorage
	 * @param {boolean} viewIndex
	 */
	_setSlideViewedTimeout(viewIndex) {
		/**
		 * A slide is recorded as viewed after 3 seconds
		 */
		this._slideViewedTimeout = setTimeout(() => {
			const viewedTutorials = localStorage?.getItem(this._storageName)?.split(',') || [];

			/**
			 * Check if stored tutorial list contains the current view index.
			 * If not, add it, sort it and store  it back to localStorage.
			 */
			if (!viewedTutorials.includes(viewIndex.toString())) {
				viewedTutorials.push(viewIndex);
				viewedTutorials.sort();
				localStorage?.setItem(this._storageName, viewedTutorials);
			}
		}, 3000);
	}

	/**
	 * Calculate the center points and size of the target elements, relative to the height and width of the body
	 * @returns {Array}
	 */
	_calcElementMeasures() {
		const { clientWidth, clientHeight } = document.body;

		return this._allTutorials.map(({ targetSelector }) => {
			// If parent is not null, it means it's visible in the DOM.
			const elements = [...document.body.querySelectorAll(targetSelector)].filter(el => el.offsetParent !== null);

			if (!elements.length) {
				return false;
			}

			const { left, width, top, height } = elements[0].getBoundingClientRect();

			return {
				xPos: 1 - ((left + (width * 0.5)) / clientWidth),
				yPos: 1 - ((top + (height * 0.5)) / clientHeight),
				relWidth: width / clientWidth,
				relHeight: height / clientHeight
			};
		});
	}

	/**
	 * @inheritdoc
	 */
	show() {
		// Make sure we display UI if it's hidden.
		const layerManager = this._app.getManager('layer');
		if (!layerManager.getLayer('ui').visible) {
			layerManager.toggleLayer('ui');
		}

		const hasSwiperContent = this._children.swiperSlides?.childNodes?.length;
		hasSwiperContent && this._initSwiper();

		// Remove external links from slide footer
		const routeManager = this._app.getManager('router');
		if (routeManager.configs.hideExternalLinks === true) {
			const smallprint = document.getElementsByClassName('tutorial-smallprint')[0].innerHTML;
			document.getElementsByClassName('tutorial-smallprint')[0].innerHTML = this._app.getManager('content').hideExternalLinksInText(smallprint);
		}
	}

	/**
	 * @inheritdoc
	 */
	hide() {
		// Clear init timeout and reset currIndex
		clearTimeout(this._initTimeout);
		this._currIndex = null;

		super.hide();
	}

	/**
	 * Look at previous displayed tutorials in localStorage to determine whether to show and which index to prioritize.
	 * @returns {boolean|null}
	 */
	calcPriorityIndex() {
		const viewedTutorials = localStorage?.getItem(this._storageName)?.split(',') || [];

		const remainingTutorials = this._allTutorials.filter((_, index) => !viewedTutorials.includes(index.toString()));

		return remainingTutorials.length ? this._getIndexByTutorialId(remainingTutorials[0].id) : null;
	}

	/**
	 * Update the router query.
	 * @param {number} tutorialIndex
	 * @param {boolean} goHome
	 */
	navigateToTutorial(tutorialIndex, goHome = false) {
		const { homeRoute, currentRoute, navigate } = this.app.getManager('router');

		const path = goHome ? homeRoute : (currentRoute.url ?? '');
		const validIndex = typeof tutorialIndex === 'number' && tutorialIndex > -1 && tutorialIndex < this._allTutorials.length;

		if (validIndex) {
			const { id: tutorial } = this._allTutorials[tutorialIndex];
			navigate({ tutorial }, path);
		}
	}

	/**
	 * Update the query to close the tutorial overlay.
	 */
	close() {
		this.app.getManager('router').navigate({ __remove: ['tutorial'] });
	}

	/**
	 * On resize we need to update our element measures and call _setHighlightedElement again
	 */
	resize() {
		if (this._state.isVisible && this._currIndex !== null) {
			this._setHighlightedElement(this._currIndex, true);
		}
	}
}

TutorialOverlay.html = (_tutorial_overlay_html__WEBPACK_IMPORTED_MODULE_6___default());

/* harmony default export */ __webpack_exports__["default"] = (TutorialOverlay);


/***/ }),

/***/ "../eyes/src/data/embed_controls.js":
/*!******************************************!*\
  !*** ../eyes/src/data/embed_controls.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * Some default controls for the embed modal.
 * Should hypothetically apply to all apps dependent on Eyess
 * Defaults will be overridden (via deep merge) by the app-specific embed controls (see EotSS component info for example)
 */
const embedDefaultControls = [
	{
		groupName: 'User Interface',
		isAdvanced: false,
		items: [
			{
				name: 'Show Detail Panel',
				description: 'Displays the detail panel for an entity on the left side of the screen',
				query: 'detailPanel',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: true
			},
			{
				name: 'Show NASA logo',
				description: 'Displays the NASA logo in the top left corner',
				query: 'logo',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: true
			},
			{
				name: 'Show Search',
				description: 'Determines whether the search bar is visible',
				query: 'search',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: true
			},
			{
				name: 'Show Share Button',
				description: 'Determines whether the share button is visible',
				query: 'shareButton',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: true
			},
			{
				name: 'Show Main Menu',
				description: 'Determines whether the main menu is visible in the top right',
				query: 'menu',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: true
			},
			{
				name: 'Show Expanded Settings Bar',
				description: 'Determines whether the settings bar is expanded upon first load',
				query: 'collapseSettingsOptions',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: false,
				invert: true
			},
			{
				name: 'Show Fullscreen Button',
				description: 'Include the fullscreen button in the settings bar',
				query: 'hideFullScreenToggle',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: false,
				invert: true
			}
		]
	},
	{
		groupName: 'Navigation',
		isAdvanced: false,
		items: [
			{
				name: 'Allow Navigation',
				description: 'Allows the user to navigate to other entities',
				query: 'locked',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: false,
				invert: true
			},
			{
				name: 'Allow External Links',
				description: 'Allows all external links to navigate away from the app to outside resources',
				query: 'hideExternalLinks',
				type: 'checkbox',
				inputDefault: true,
				appQueryDefault: false,
				invert: true
			}
		]
	},
	{
		groupName: '3D',
		isAdvanced: false,
		items: [
			{
				name: 'Trail Width (pixels)',
				description: 'Change the width of all entity path trails',
				query: 'trailWidth',
				type: 'number',
				values: [0.5, 5, 0.5], // min, max, step
				inputDefault: 1,
				appQueryDefault: 1
			},
			{
				name: 'Lighting',
				query: 'lighting',
				type: 'radio',
				values: [
					{
						title: 'Flood',
						value: 'flood',
						description: 'Flood lighting allows for even lighting across all 3D entities'
					},
					{
						title: 'Natural',
						value: 'natural',
						description: 'Natural lighting allows for realistic lighting based on the sun\'s position'
					},
					{
						title: 'Shadow',
						value: 'shadow',
						description: 'Shadow lighting allows for somewhat realistic lighting based on the sun\'s position, but highlights the shadows so they are not completely dark'
					}
				],
				inputDefault: 'shadow',
				appQueryDefault: 'shadow'
			}
		]
	}
];

/* harmony default export */ __webpack_exports__["default"] = (embedDefaultControls);


/***/ }),

/***/ "../eyes/src/data/entity_spheroid_features.js":
/*!****************************************************!*\
  !*** ../eyes/src/data/entity_spheroid_features.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
	jupiter: [
		{
			id: 'magnetosphere',
			title: 'Jupiter\'s Magnetic Field',
			description: 'DESCRIPTION'
		},
		{
			id: 'auroras',
			title: 'Jupiter\'s Auroras',
			description: 'DESCRIPTION'
		},
		{
			id: 'radiationBelt',
			title: 'Jupiter\'s Radiation Belt',
			description: 'DESCRIPTION'
		}
	],
	saturn: [
		{
			id: 'magnetosphere',
			title: 'Saturn\'s Magnetic Field',
			description: 'DESCRIPTION'
		}
	]
});


/***/ }),

/***/ "../eyes/src/data/entity_spheroid_layers.js":
/*!**************************************************!*\
  !*** ../eyes/src/data/entity_spheroid_layers.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony default export */ __webpack_exports__["default"] = ({
	earth: [
		{
			id: 'viirs',
			title: 'High-quality global mosaic from yesterday',
			description: 'This daily global mosaic is from the Visible Infrared Imaging Radiometer Suite (VIIRS), which is one of the key instruments onboard the Suomi National Polar-Orbiting Partnership (Suomi NPP) spacecraft.',
			type: 'wmts',
			features: ['shadowEntities', 'atmosphere'],
			endPoint: 'assets/wmts_xml',
			layer: 'VIIRS_SNPP_CorrectedReflectance_TrueColor',
			tile: '250m',
			time: 'yesterday'
		}
	],
	mars: [
		{
			id: 'vikingMosaic',
			title: 'Global mosaic from the Viking missions to Mars.',
			description: 'The two Mars Viking Orbiters imaged the entire surface of Mars at a resolution of 150 to 300 meters.',
			type: 'wmts',
			features: ['shadowEntities', 'atmosphere'],
			endPoint: 'https://trek.nasa.gov/tiles/Mars/EQ/corrected/Mars_Viking_MDIM21_ClrMosaic_global_232m',
			layer: 'Mars_Viking_MDIM21_ClrMosaic_global_232m'
		}
	],
	moon: [
		{
			id: 'lroMosaic',
			title: 'Global mosaic from the Lunar Reconnaissance Orbiter mission',
			description: 'The wide-angle camera on LRO mapped the entire moon at 100 meters/pixel.',
			type: 'wmts',
			features: ['shadowEntities'],
			endPoint: 'https://trek.nasa.gov/tiles/Moon/EQ/corrected/LRO_WAC_Mosaic_Global_303ppd_v02',
			layer: 'LRO_WAC_Mosaic_Global_303ppd_v02'
		}
	],
	titan: [
		{
			id: 'surface',
			title: 'Surface imagery of Titan from Cassini\'s Imaging Science Subsystem camera',
			description: 'This global mosaic is at 4 km/pixel, combining one hundred flybys of Titan by the Cassini mission',
			type: 'texture',
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'titan/surface_$SIZE_$FACE.png',
					sizes: [16, 512, 2048]
				}
			}
		},
		{
			id: 'radar',
			title: 'Radar Map of Titan\'s Surface',
			description: 'This 351 meters/pixel map incorporates 104 Titan flybys by the Cassini mission.',
			type: 'texture',
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'titan/radar_$SIZE_$FACE.png',
					sizes: [16, 512, 2048]
				}
			}
		}
	],
	venus: [
		{
			id: 'surface',
			title: 'Radar Map of the Surface of Venus',
			description: 'The Magellan mission used radar to see beneath the smog of Venus.',
			type: 'texture',
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'venus/surface_$SIZE_$FACE.png',
					sizes: [16, 512, 1024]
				}
			}
		}
	]
});


/***/ }),

/***/ "../eyes/src/index.js":
/*!****************************!*\
  !*** ../eyes/src/index.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationUtils": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.AnimationUtils; },
/* harmony export */   "AppUtils": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils; },
/* harmony export */   "BaseApp": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseApp; },
/* harmony export */   "BaseComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent; },
/* harmony export */   "BaseManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseManager; },
/* harmony export */   "BaseView": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseView; },
/* harmony export */   "Breadcrumb": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Breadcrumb; },
/* harmony export */   "ButtonsBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ButtonsBlock; },
/* harmony export */   "CameraFollowManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CameraFollowManager; },
/* harmony export */   "CameraManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CameraManager; },
/* harmony export */   "CameraScripts": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CameraScripts; },
/* harmony export */   "CancelToken": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CancelToken; },
/* harmony export */   "Carousel": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Carousel; },
/* harmony export */   "CarouselPanel": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CarouselPanel; },
/* harmony export */   "Checkbox": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Checkbox; },
/* harmony export */   "CheckboxBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CheckboxBlock; },
/* harmony export */   "Clock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Clock; },
/* harmony export */   "ClockShortcut": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ClockShortcut; },
/* harmony export */   "ComparisonManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ComparisonManager; },
/* harmony export */   "ContentManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ContentManager; },
/* harmony export */   "DescriptionBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.DescriptionBlock; },
/* harmony export */   "DistanceLineComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.DistanceLineComponent; },
/* harmony export */   "ERTManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ERTManager; },
/* harmony export */   "EyesVersion": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.EyesVersion; },
/* harmony export */   "HintBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.HintBlock; },
/* harmony export */   "ImageBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ImageBlock; },
/* harmony export */   "KioskBase": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.KioskBase; },
/* harmony export */   "LabelManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LabelManager; },
/* harmony export */   "LayerManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LayerManager; },
/* harmony export */   "LayerPanel": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LayerPanel; },
/* harmony export */   "LoadIcon": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LoadIcon; },
/* harmony export */   "OrbiterLineOfSightComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbiterLineOfSightComponent; },
/* harmony export */   "Overlay": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Overlay; },
/* harmony export */   "ReplayButtonBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ReplayButtonBlock; },
/* harmony export */   "RouteManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.RouteManager; },
/* harmony export */   "SceneManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SceneManager; },
/* harmony export */   "Search": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Search; },
/* harmony export */   "SearchManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SearchManager; },
/* harmony export */   "SelectionManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SelectionManager; },
/* harmony export */   "Settings": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Settings; },
/* harmony export */   "ShareModal": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ShareModal; },
/* harmony export */   "SpoutManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpoutManager; },
/* harmony export */   "Story": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Story; },
/* harmony export */   "StoryBaseContentBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.StoryBaseContentBlock; },
/* harmony export */   "TimeController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TimeController; },
/* harmony export */   "TimeManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TimeManager; },
/* harmony export */   "TitleBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TitleBlock; },
/* harmony export */   "TitleManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TitleManager; },
/* harmony export */   "Toast": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Toast; },
/* harmony export */   "ToggleBlock": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ToggleBlock; },
/* harmony export */   "TrailManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TrailManager; },
/* harmony export */   "TutorialOverlay": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TutorialOverlay; },
/* harmony export */   "Types": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Types; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../eyes/src/internal.js");



/***/ }),

/***/ "../eyes/src/internal.js":
/*!*******************************!*\
  !*** ../eyes/src/internal.js ***!
  \*******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EyesVersion": function() { return /* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_0__.version; },
/* harmony export */   "OrbiterLineOfSightComponent": function() { return /* reexport safe */ _lib_orbiter_line_of_sight_component__WEBPACK_IMPORTED_MODULE_1__.OrbiterLineOfSightComponent; },
/* harmony export */   "DistanceLineComponent": function() { return /* reexport safe */ _lib_distance_line_component__WEBPACK_IMPORTED_MODULE_2__.DistanceLineComponent; },
/* harmony export */   "CancelToken": function() { return /* reexport safe */ _utils_cancel_token__WEBPACK_IMPORTED_MODULE_3__.CancelToken; },
/* harmony export */   "AppUtils": function() { return /* reexport safe */ _utils_app_utils__WEBPACK_IMPORTED_MODULE_4__.AppUtils; },
/* harmony export */   "AnimationUtils": function() { return /* reexport safe */ _utils_animation_utils__WEBPACK_IMPORTED_MODULE_5__.AnimationUtils; },
/* harmony export */   "BaseComponent": function() { return /* reexport safe */ _components_base_component__WEBPACK_IMPORTED_MODULE_6__.BaseComponent; },
/* harmony export */   "Settings": function() { return /* reexport safe */ _components_settings__WEBPACK_IMPORTED_MODULE_7__["default"]; },
/* harmony export */   "LoadIcon": function() { return /* reexport safe */ _components_load_icon__WEBPACK_IMPORTED_MODULE_8__["default"]; },
/* harmony export */   "Overlay": function() { return /* reexport safe */ _components_overlay__WEBPACK_IMPORTED_MODULE_9__["default"]; },
/* harmony export */   "Search": function() { return /* reexport safe */ _components_search__WEBPACK_IMPORTED_MODULE_10__["default"]; },
/* harmony export */   "Clock": function() { return /* reexport safe */ _components_clock__WEBPACK_IMPORTED_MODULE_11__["default"]; },
/* harmony export */   "ClockShortcut": function() { return /* reexport safe */ _components_clock_shortcut__WEBPACK_IMPORTED_MODULE_12__["default"]; },
/* harmony export */   "Carousel": function() { return /* reexport safe */ _components_carousel__WEBPACK_IMPORTED_MODULE_13__["default"]; },
/* harmony export */   "TutorialOverlay": function() { return /* reexport safe */ _components_tutorial_overlay__WEBPACK_IMPORTED_MODULE_14__["default"]; },
/* harmony export */   "CarouselPanel": function() { return /* reexport safe */ _components_carousel_panel__WEBPACK_IMPORTED_MODULE_15__["default"]; },
/* harmony export */   "ShareModal": function() { return /* reexport safe */ _components_share_modal__WEBPACK_IMPORTED_MODULE_16__["default"]; },
/* harmony export */   "TimeController": function() { return /* reexport safe */ _components_time_controller__WEBPACK_IMPORTED_MODULE_17__["default"]; },
/* harmony export */   "Checkbox": function() { return /* reexport safe */ _components_checkbox__WEBPACK_IMPORTED_MODULE_18__["default"]; },
/* harmony export */   "LayerPanel": function() { return /* reexport safe */ _components_layer_panel_layer_panel__WEBPACK_IMPORTED_MODULE_19__.LayerPanel; },
/* harmony export */   "Breadcrumb": function() { return /* reexport safe */ _components_breadcrumb_breadcrumb__WEBPACK_IMPORTED_MODULE_20__.Breadcrumb; },
/* harmony export */   "StoryBaseContentBlock": function() { return /* reexport safe */ _components_story_blocks_story_base_content_block_story_base_content_block__WEBPACK_IMPORTED_MODULE_21__.StoryBaseContentBlock; },
/* harmony export */   "HintBlock": function() { return /* reexport safe */ _components_story_blocks_hint_block_hint_block__WEBPACK_IMPORTED_MODULE_22__.HintBlock; },
/* harmony export */   "ToggleBlock": function() { return /* reexport safe */ _components_story_blocks_toggle_block_toggle_block__WEBPACK_IMPORTED_MODULE_23__.ToggleBlock; },
/* harmony export */   "TitleBlock": function() { return /* reexport safe */ _components_story_blocks_title_block_title_block__WEBPACK_IMPORTED_MODULE_24__.TitleBlock; },
/* harmony export */   "ImageBlock": function() { return /* reexport safe */ _components_story_blocks_image_block_image_block__WEBPACK_IMPORTED_MODULE_25__.ImageBlock; },
/* harmony export */   "DescriptionBlock": function() { return /* reexport safe */ _components_story_blocks_description_block_description_block__WEBPACK_IMPORTED_MODULE_26__.DescriptionBlock; },
/* harmony export */   "ReplayButtonBlock": function() { return /* reexport safe */ _components_story_blocks_replay_button_block_replay_button_block__WEBPACK_IMPORTED_MODULE_27__.ReplayButtonBlock; },
/* harmony export */   "ButtonsBlock": function() { return /* reexport safe */ _components_story_blocks_buttons_block_buttons_block__WEBPACK_IMPORTED_MODULE_28__.ButtonsBlock; },
/* harmony export */   "CheckboxBlock": function() { return /* reexport safe */ _components_story_blocks_checkbox_block_checkbox_block__WEBPACK_IMPORTED_MODULE_29__.CheckboxBlock; },
/* harmony export */   "Story": function() { return /* reexport safe */ _components_story_story__WEBPACK_IMPORTED_MODULE_30__.Story; },
/* harmony export */   "KioskBase": function() { return /* reexport safe */ _components_kiosk_base_kiosk_base__WEBPACK_IMPORTED_MODULE_31__.KioskBase; },
/* harmony export */   "Toast": function() { return /* reexport safe */ _components_toast_toast__WEBPACK_IMPORTED_MODULE_32__.Toast; },
/* harmony export */   "BaseManager": function() { return /* reexport safe */ _managers_base_manager__WEBPACK_IMPORTED_MODULE_33__.BaseManager; },
/* harmony export */   "SelectionManager": function() { return /* reexport safe */ _managers_selection_manager__WEBPACK_IMPORTED_MODULE_34__.SelectionManager; },
/* harmony export */   "LabelManager": function() { return /* reexport safe */ _managers_label_manager__WEBPACK_IMPORTED_MODULE_35__.LabelManager; },
/* harmony export */   "RouteManager": function() { return /* reexport safe */ _managers_route_manager__WEBPACK_IMPORTED_MODULE_36__.RouteManager; },
/* harmony export */   "ContentManager": function() { return /* reexport safe */ _managers_content_manager__WEBPACK_IMPORTED_MODULE_37__.ContentManager; },
/* harmony export */   "SceneManager": function() { return /* reexport safe */ _managers_scene_manager__WEBPACK_IMPORTED_MODULE_38__.SceneManager; },
/* harmony export */   "LayerManager": function() { return /* reexport safe */ _managers_layer_manager__WEBPACK_IMPORTED_MODULE_39__.LayerManager; },
/* harmony export */   "TrailManager": function() { return /* reexport safe */ _managers_trail_manager__WEBPACK_IMPORTED_MODULE_40__.TrailManager; },
/* harmony export */   "CameraManager": function() { return /* reexport safe */ _managers_camera_manager__WEBPACK_IMPORTED_MODULE_41__.CameraManager; },
/* harmony export */   "CameraScripts": function() { return /* reexport safe */ _managers_camera_scripts__WEBPACK_IMPORTED_MODULE_42__.CameraScripts; },
/* harmony export */   "ERTManager": function() { return /* reexport safe */ _managers_ert_manager__WEBPACK_IMPORTED_MODULE_43__.ERTManager; },
/* harmony export */   "TimeManager": function() { return /* reexport safe */ _managers_time_manager__WEBPACK_IMPORTED_MODULE_44__.TimeManager; },
/* harmony export */   "ComparisonManager": function() { return /* reexport safe */ _managers_comparison_manager__WEBPACK_IMPORTED_MODULE_45__.ComparisonManager; },
/* harmony export */   "SearchManager": function() { return /* reexport safe */ _managers_search_manager__WEBPACK_IMPORTED_MODULE_46__.SearchManager; },
/* harmony export */   "TitleManager": function() { return /* reexport safe */ _managers_title_manager__WEBPACK_IMPORTED_MODULE_47__.TitleManager; },
/* harmony export */   "SpoutManager": function() { return /* reexport safe */ _managers_spout_manager__WEBPACK_IMPORTED_MODULE_48__.SpoutManager; },
/* harmony export */   "CameraFollowManager": function() { return /* reexport safe */ _managers_camera_follow_manager__WEBPACK_IMPORTED_MODULE_49__.CameraFollowManager; },
/* harmony export */   "BaseView": function() { return /* reexport safe */ _base_view__WEBPACK_IMPORTED_MODULE_50__.BaseView; },
/* harmony export */   "BaseApp": function() { return /* reexport safe */ _app__WEBPACK_IMPORTED_MODULE_51__.BaseApp; },
/* harmony export */   "Types": function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_52__.Types; }
/* harmony export */ });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./version */ "../eyes/src/version.js");
/* harmony import */ var _lib_orbiter_line_of_sight_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/orbiter_line_of_sight_component */ "../eyes/src/lib/orbiter_line_of_sight_component.js");
/* harmony import */ var _lib_distance_line_component__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/distance_line_component */ "../eyes/src/lib/distance_line_component.js");
/* harmony import */ var _utils_cancel_token__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/cancel_token */ "../eyes/src/utils/cancel_token.js");
/* harmony import */ var _utils_app_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/app_utils */ "../eyes/src/utils/app_utils.js");
/* harmony import */ var _utils_animation_utils__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/animation_utils */ "../eyes/src/utils/animation_utils.js");
/* harmony import */ var _components_base_component__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./components/base_component */ "../eyes/src/components/base_component.js");
/* harmony import */ var _components_settings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./components/settings */ "../eyes/src/components/settings/index.js");
/* harmony import */ var _components_load_icon__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./components/load_icon */ "../eyes/src/components/load_icon/index.js");
/* harmony import */ var _components_overlay__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/overlay */ "../eyes/src/components/overlay/index.js");
/* harmony import */ var _components_search__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/search */ "../eyes/src/components/search/index.js");
/* harmony import */ var _components_clock__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/clock */ "../eyes/src/components/clock/index.js");
/* harmony import */ var _components_clock_shortcut__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/clock_shortcut */ "../eyes/src/components/clock_shortcut/index.js");
/* harmony import */ var _components_carousel__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/carousel */ "../eyes/src/components/carousel/index.js");
/* harmony import */ var _components_tutorial_overlay__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/tutorial_overlay */ "../eyes/src/components/tutorial_overlay/index.js");
/* harmony import */ var _components_carousel_panel__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/carousel_panel */ "../eyes/src/components/carousel_panel/index.js");
/* harmony import */ var _components_share_modal__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/share_modal */ "../eyes/src/components/share_modal/index.js");
/* harmony import */ var _components_time_controller__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./components/time_controller */ "../eyes/src/components/time_controller/index.js");
/* harmony import */ var _components_checkbox__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./components/checkbox */ "../eyes/src/components/checkbox/index.js");
/* harmony import */ var _components_layer_panel_layer_panel__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./components/layer_panel/layer_panel */ "../eyes/src/components/layer_panel/layer_panel.js");
/* harmony import */ var _components_breadcrumb_breadcrumb__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./components/breadcrumb/breadcrumb */ "../eyes/src/components/breadcrumb/breadcrumb.js");
/* harmony import */ var _components_story_blocks_story_base_content_block_story_base_content_block__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./components/story/blocks/story_base_content_block/story_base_content_block */ "../eyes/src/components/story/blocks/story_base_content_block/story_base_content_block.js");
/* harmony import */ var _components_story_blocks_hint_block_hint_block__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./components/story/blocks/hint_block/hint_block */ "../eyes/src/components/story/blocks/hint_block/hint_block.js");
/* harmony import */ var _components_story_blocks_toggle_block_toggle_block__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./components/story/blocks/toggle_block/toggle_block */ "../eyes/src/components/story/blocks/toggle_block/toggle_block.js");
/* harmony import */ var _components_story_blocks_title_block_title_block__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./components/story/blocks/title_block/title_block */ "../eyes/src/components/story/blocks/title_block/title_block.js");
/* harmony import */ var _components_story_blocks_image_block_image_block__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./components/story/blocks/image_block/image_block */ "../eyes/src/components/story/blocks/image_block/image_block.js");
/* harmony import */ var _components_story_blocks_description_block_description_block__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./components/story/blocks/description_block/description_block */ "../eyes/src/components/story/blocks/description_block/description_block.js");
/* harmony import */ var _components_story_blocks_replay_button_block_replay_button_block__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./components/story/blocks/replay_button_block/replay_button_block */ "../eyes/src/components/story/blocks/replay_button_block/replay_button_block.js");
/* harmony import */ var _components_story_blocks_buttons_block_buttons_block__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./components/story/blocks/buttons_block/buttons_block */ "../eyes/src/components/story/blocks/buttons_block/buttons_block.js");
/* harmony import */ var _components_story_blocks_checkbox_block_checkbox_block__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./components/story/blocks/checkbox_block/checkbox_block */ "../eyes/src/components/story/blocks/checkbox_block/checkbox_block.js");
/* harmony import */ var _components_story_story__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./components/story/story */ "../eyes/src/components/story/story.js");
/* harmony import */ var _components_kiosk_base_kiosk_base__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./components/kiosk_base/kiosk_base */ "../eyes/src/components/kiosk_base/kiosk_base.js");
/* harmony import */ var _components_toast_toast__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./components/toast/toast */ "../eyes/src/components/toast/toast.js");
/* harmony import */ var _managers_base_manager__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./managers/base_manager */ "../eyes/src/managers/base_manager.js");
/* harmony import */ var _managers_selection_manager__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./managers/selection_manager */ "../eyes/src/managers/selection_manager.js");
/* harmony import */ var _managers_label_manager__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./managers/label_manager */ "../eyes/src/managers/label_manager.js");
/* harmony import */ var _managers_route_manager__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./managers/route_manager */ "../eyes/src/managers/route_manager.js");
/* harmony import */ var _managers_content_manager__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./managers/content_manager */ "../eyes/src/managers/content_manager.js");
/* harmony import */ var _managers_scene_manager__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./managers/scene_manager */ "../eyes/src/managers/scene_manager.js");
/* harmony import */ var _managers_layer_manager__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./managers/layer_manager */ "../eyes/src/managers/layer_manager.js");
/* harmony import */ var _managers_trail_manager__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./managers/trail_manager */ "../eyes/src/managers/trail_manager.js");
/* harmony import */ var _managers_camera_manager__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./managers/camera_manager */ "../eyes/src/managers/camera_manager.js");
/* harmony import */ var _managers_camera_scripts__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./managers/camera_scripts */ "../eyes/src/managers/camera_scripts.js");
/* harmony import */ var _managers_ert_manager__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./managers/ert_manager */ "../eyes/src/managers/ert_manager.js");
/* harmony import */ var _managers_time_manager__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./managers/time_manager */ "../eyes/src/managers/time_manager.js");
/* harmony import */ var _managers_comparison_manager__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./managers/comparison_manager */ "../eyes/src/managers/comparison_manager.js");
/* harmony import */ var _managers_search_manager__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./managers/search_manager */ "../eyes/src/managers/search_manager.js");
/* harmony import */ var _managers_title_manager__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./managers/title_manager */ "../eyes/src/managers/title_manager.js");
/* harmony import */ var _managers_spout_manager__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./managers/spout_manager */ "../eyes/src/managers/spout_manager.js");
/* harmony import */ var _managers_camera_follow_manager__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./managers/camera_follow_manager */ "../eyes/src/managers/camera_follow_manager.js");
/* harmony import */ var _base_view__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./base_view */ "../eyes/src/base_view.js");
/* harmony import */ var _app__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./app */ "../eyes/src/app.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./types */ "../eyes/src/types.js");
/* eslint-disable import/first */



// Custom Pioneer components



// Utils




// Components
































// Managers


















// Base View


// App


// Types



/***/ }),

/***/ "../eyes/src/lib/distance_line_component.js":
/*!**************************************************!*\
  !*** ../eyes/src/lib/distance_line_component.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DistanceLineComponent": function() { return /* binding */ DistanceLineComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");


/**
 * @typedef LineAnimationOptions
 * @property {boolean} isAnimating whether we're currently animating
 * @property {number} duration length of animation in ms
 * @property {number} sourceStartTime starting time returned from Date.now() at start
 * @property {number} targetStartTime starting time returned from Date.now() at start
 */

/**
 * @typedef AnimationProgress
 * @property {number} sourceProgress source progress 0 - 1
 * @property {number} targetProgress target progress 0 - 1
 */

/**
 * The line component.
 * @extends BaseComponent
 */
class DistanceLineComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 * @package
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * Target entity for the end of the line.
		 * @type {Entity}
		 * @private
		 */
		this._targetEntity = null;

		/**
		 * The color to draw.
		 * @type {Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(0.48, 0.56, 0.66);

		/**
		 * The distance between the center of the two entities (km)
		 * @type {number}
		 * @private
		 */
		this._distance = null;

		/**
		 * The source's radius relative to total distance (0-1)
		 * @type {number}
		 * @private
		 */
		this._sourceRelRadius = null;

		/**
		 * The targets's radius relative to total distance (0-1)
		 * @type {number}
		 * @private
		 */
		this._targetRelRadius = null;

		/**
		 * The source's measuring start point is center or surface (defaults to center)
		 * @type {boolean}
		 * @private
		 */
		this._sourceMpIsSurface = false;

		/**
		 * The target's measuring start point is center or surface (defaults to center)
		 * @type {boolean}
		 * @private
		 */
		this._targetMpIsSurface = false;

		/**
		 * Whether to switch the start position of the line to the target
		 * @type {boolean}
		 * @private
		 */
		this._switchStartPos = null;

		/**
		 * Sets depth test to false by default.
		 * @type {boolean}
		 * @private
		 */
		this._depthTest = false;


		/**
		 * Animation object options
		 * @type {LineAnimationOptions}
		 * @private
		 */
		this._animation = {
			isAnimating: false,
			duration: 300,
			sourceStartTime: null,
			targetStartTime: null
		};

		/**
		 * The width to draw.
		 * @type {number}
		 * @private
		 */
		this._width = 2;

		/**
		 * The LineMesh object used to do the drawing.
		 * @type {LineMesh}
		 * @private
		 */
		this._lineMesh = null;

		// Set the radius
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Sets the source and target entities for the line.
	 * @param {Entity} targetEntity
	 */
	setTargetEntity(targetEntity) {
		this._targetEntity = targetEntity;
	}

	/**
	 * Sets the source measure point.
	 * @param {string} measurePoint
	 */
	setSourceMeasurePoint(measurePoint) {
		const newIsSurface = measurePoint === 'surface';
		const hasChanged = this._sourceMpIsSurface !== newIsSurface;

		if (!hasChanged) {
			return;
		}

		this._sourceMpIsSurface = newIsSurface;

		this._animation.isAnimating = true;
		this._animation.sourceStartTime = Date.now();
	}

	/**
	 * Sets the target measure point.
	 * @param {string} measurePoint
	 */
	setTargetMeasurePoint(measurePoint) {
		const newIsSurface = measurePoint === 'surface';
		const hasChanged = this._targetMpIsSurface !== newIsSurface;

		if (!hasChanged) {
			return;
		}

		this._targetMpIsSurface = newIsSurface;

		this._animation.isAnimating = true;
		this._animation.targetStartTime = Date.now();
	}

	/**
	 * Sets the color for the line.
	 * @param {Color} color
	 */
	setColor(color) {
		this._color = color;
	}

	/**
	 * Sets the width of the line.
	 * @param {number} width
	 */
	setWidth(width) {
		this._width = width;
	}

	/**
	 * Sets the distance props (distance, source and target relative radii)
	 * @param {object} params
	 * @param {number} params.distance
	 * @param {number} params.sourceRadius
	 * @param {number} params.targetRadius
	 */
	setDistanceProps({ distance, sourceRadius, targetRadius }) {
		this._distance = distance;
		this._sourceRelRadius = Math.max(Math.min(sourceRadius / this._distance, 1), 0);
		this._targetRelRadius = Math.max(Math.min(targetRadius / this._distance, 1), 0);
	}

	/**
	 * Applies animation easing-in-out function.
	 * https://github.com/d3/d3-ease/tree/main/src
	 * @param {number} progress
	 * @returns {number}
	 */
	_applyEasing(progress) {
		const e = 4;
		const easedProgress = progress * 2;

		return (easedProgress <= 1 ? Math.pow(easedProgress, e) : 2 - Math.pow(2 - easedProgress, e)) / 2;
	}

	/**
	 * Updates the lineStart and lineEnd position vectors when animating between center and surface for source or target.
	 * @param {Vector3} lineStart
	 * @param {Vector3} lineEnd
	 * @param {Vector3} startCenterPos
	 * @param {Vector3} startSurfacePos
	 * @param {Vector3} endCenterPos
	 * @param {Vector3} endSurfacePos
	 */
	_updateAnimation(lineStart, lineEnd, startCenterPos, startSurfacePos, endCenterPos, endSurfacePos) {
		// Return if not animating.
		if (!this._animation.isAnimating) {
			return;
		}


		const { sourceStartTime, targetStartTime, duration } = this._animation;

		// Calculate progress lerps. This logic could be condensed but it's perhaps easier to read like this.

		if (sourceStartTime) {
			const sourceDiff = Date.now() - sourceStartTime;
			const sourceProgress = sourceDiff > duration ? 1 : sourceDiff / duration;

			if (sourceProgress !== 1) {
				// Apply easing.
				const sourceProgressEased = this._applyEasing(sourceProgress);

				// Determine vector lerp.
				if (this._sourceMpIsSurface) {
					if (this._switchStartPos) {
						lineEnd.lerp(endCenterPos, endSurfacePos, sourceProgressEased);
					}
					else {
						lineStart.lerp(startCenterPos, startSurfacePos, sourceProgressEased);
					}
				}
				else {
					if (this._switchStartPos) {
						lineEnd.lerp(endSurfacePos, endCenterPos, sourceProgressEased);
					}
					else {
						lineStart.lerp(startSurfacePos, startCenterPos, sourceProgressEased);
					}
				}
			}
			else {
				// Source animation is complete.
				this._animation.isAnimating = false;
				this._animation.sourceStartTime = null;
			}
		}

		if (targetStartTime) {
			const targetDiff = Date.now() - targetStartTime;
			const targetProgress = targetDiff > duration ? 1 : targetDiff / duration;

			if (targetProgress !== 1) {
				// Apply easing.
				const targetProgressEased = this._applyEasing(targetProgress);

				// Determine vector lerp.
				if (this._targetMpIsSurface) {
					if (this._switchStartPos) {
						lineStart.lerp(startCenterPos, startSurfacePos, targetProgressEased);
					}
					else {
						lineEnd.lerp(endCenterPos, endSurfacePos, targetProgressEased);
					}
				}
				else {
					if (this._switchStartPos) {
						lineStart.lerp(startSurfacePos, startCenterPos, targetProgressEased);
					}
					else {
						lineEnd.lerp(endSurfacePos, endCenterPos, targetProgressEased);
					}
				}
			}
			else {
				// Target animation is complete.
				this._animation.isAnimating = false;
				this._animation.targetStartTime = null;
			}
		}
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		this._lineMesh = new pioneer__WEBPACK_IMPORTED_MODULE_0__.LineMesh(this);

		// Set colors.
		this._lineMesh.setColors([
			this._color,
			this._color
		]);

		// Set widths.
		this._lineMesh.setWidths([
			this._width,
			this._width
		]);

		// Set opacity.
		this.setOpacity(1);

		return Promise.resolve();
	}

	/**
	 * Sets the line opacity
	 * @param {number} opacity
	 */
	setOpacity(opacity) {
		this._lineMesh.setAlphaMultiplier(opacity);
	}

	/**
	 * Sets whether we use a depth test for the mesh line.
	 * @param {boolean} depthTest
	 */
	setDepthTest(depthTest) {
		this._depthTest = depthTest;
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		const [lineMesh] = this.getThreeJsObjects();

		if (this._targetEntity === null) {
			if (lineMesh) {
				lineMesh.visible = false;
			}
			return;
		}

		if (lineMesh?.material) {
			lineMesh.material.depthTest = this._depthTest;
		}

		// Determine start pos.
		this._calcStartPos(camera);

		// Update the points and set the calculated positions and colors.
		this._updatePoints(camera);

		// Set the Three.js object position the entity's camera-space position
		const startEntity = this._switchStartPos ? this._targetEntity : this.getEntity();
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(lineMesh, startEntity, camera);

		this._lineMesh.prepareForRender(camera);
	}

	/**
	 * Determine the start position
	 * @param {CameraComponent} camera
	 */
	_calcStartPos(camera) {
		const switchThreshold = 0.001;
		const targetToCamera = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();

		// Get camera distance to targetEntity.
		camera.getEntity().getPositionRelativeToEntity(targetToCamera, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this._targetEntity);

		// Cam distance to target relative to total distance.
		const relDistance = targetToCamera.magnitude() / this._distance;
		const switchStartPos = relDistance < switchThreshold;

		// Update _switchStartPos if needed.
		if (this._switchStartPos !== switchStartPos) {
			this._switchStartPos = switchStartPos;
		}

		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(targetToCamera);
	}

	/**
	 * Updates the points array.
	 *
	 * The start center is normally the source (this.getEntity) entity center, with the end being the target (this._targetEntity) center.
	 * However, if the camera is close to the target, we want to switch so the start is the target and the end is the source.
	 * This way, we wont get any erratically moving lines from long distance accuracy issues.
	 * For this, we're using this._switchStartPos as the determining boolean.
	 * @param {CameraComponent} camera
	 * @private
	 */
	_updatePoints(camera) {
		if (this._targetEntity === null) {
			return;
		}

		// Get 4 vectors.
		const startCenterPos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const startSurfacePos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const endSurfacePos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const endCenterPos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();


		// Start center is set to zero.
		startCenterPos.copy(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);

		// Set target entity center vector.
		endCenterPos.sub(this._targetEntity.getCameraSpacePosition(camera), this.getEntity().getCameraSpacePosition(camera));
		if (this._switchStartPos) {
			endCenterPos.neg(endCenterPos);
		}

		const startSurfaceU = this._switchStartPos ? this._targetRelRadius : this._sourceRelRadius;
		const endSurfaceU = 1 - (this._switchStartPos ? this._sourceRelRadius : this._targetRelRadius);

		// Get lerped surface vectors.
		startSurfacePos.lerp(startCenterPos, endCenterPos, startSurfaceU);
		endSurfacePos.lerp(startCenterPos, endCenterPos, endSurfaceU);

		// Determine line start and end vectors.
		const startMpIsSurface = this._switchStartPos ? this._targetMpIsSurface : this._sourceMpIsSurface;
		const endMpIsSurface = this._switchStartPos ? this._sourceMpIsSurface : this._targetMpIsSurface;
		const lineStart = startMpIsSurface ? startSurfacePos : startCenterPos;
		const lineEnd = endMpIsSurface ? endSurfacePos : endCenterPos;

		// Update animation.
		this._updateAnimation(lineStart, lineEnd, startCenterPos, startSurfacePos, endCenterPos, endSurfacePos);

		// Update positions.
		const positions = [
			lineStart,
			lineEnd
		];
		this._lineMesh.setPositions(positions);


		// Release vector3s
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(startCenterPos);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(startSurfacePos);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(endSurfacePos);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(endCenterPos);
	}
}


/***/ }),

/***/ "../eyes/src/lib/orbiter_line_of_sight_component.js":
/*!**********************************************************!*\
  !*** ../eyes/src/lib/orbiter_line_of_sight_component.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbiterLineOfSightComponent": function() { return /* binding */ OrbiterLineOfSightComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");


/**
 * The line component.
 * @extends Pioneer.BaseComponent
 */
class OrbiterLineOfSightComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 * @package
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * Target point A for the line.
		 * @type {Pioneer.Entity}
		 */
		this._targetA = null;

		/**
		 * Target point B for the line.
		 * @type {Pioneer.Entity}
		 */
		this._targetB = null;

		/**
		 * Ignore distance flag.
		 * @type {boolean}
		 */
		this._ignoreDistance = false;

		/**
		 * Ignore distance threshold.
		 * Will fade in between min (a:0) and max (a:1).
		 * @type {object}
		 */
		this._distanceThreshold = { min: 2, max: 20 };

		/**
		 * The positions to draw. Sent to the line mesh.
		 * @type {Array<Pioneer.Vector3>}
		 * @private
		 */
		this._positions = [];

		/**
		 * The colors to draw. Sent to the line mesh.
		 * @type {Array<Pioneer.Color>}
		 * @private
		 */
		this._colors = [];

		/**
		 * The widths to draw. Sent to the line mesh.
		 * @type {Array<number>}
		 * @private
		 */
		this._widths = [];

		/**
		 * The color to draw.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 0);

		/**
		 * The width to draw.
		 * @type {number}
		 * @private
		 */
		this._width = 2;

		// Setup ThreeJS
		this._threeJsScene = entity.getScene().getThreeJsScene();

		/**
		 * The LineMesh object used to do the drawing.
		 * @type {Pioneer.LineMesh}
		 * @private
		 */
		this._lineMesh = null;

		// Set the radius
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Sets the target entity for the line.
	 * @param {Pioneer.Entity} entityA
	 * @param {Pioneer.Entity} entityB
	 */
	setTargets(entityA, entityB) {
		if (typeof entityA === 'string') {
			entityA = this.getEntity().getScene().get(entityA);
		}
		if (typeof entityB === 'string') {
			entityB = this.getEntity().getScene().get(entityB);
		}

		this._targetA = entityA;
		this._targetB = entityB;
	}

	/**
	 * Sets the color for the line.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color = color;
	}

	/**
	 * Sets the width of the line.
	 * @param {number} width
	 */
	setWidth(width) {
		this._width = width;
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @protected
	 */
	__loadResources() {
		this._lineMesh = new pioneer__WEBPACK_IMPORTED_MODULE_0__.LineMesh(this);
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @package
	 */
	__prepareForRender(camera) {
		if (this._targetA === null || this._targetB === null) {
			if (this.getThreeJsObjects().length > 0) {
				this.getThreeJsObjects()[0].visible = false;
			}
			return;
		}

		// Update the points and set the calculated positions and colors.
		this._updatePoints(camera);
		let alphaMultiplier = 1.0;
		if (!this._ignoreDistance) {
			const cameraDistance = camera.getEntity().getPosition().magnitude();
			const f = (cameraDistance - this._distanceThreshold.min) / (this._distanceThreshold.max - this._distanceThreshold.min);
			alphaMultiplier *= f;
		}

		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);

		this._lineMesh.setAlphaMultiplier(alphaMultiplier);
		this._lineMesh.prepareForRender(camera);
	}

	/**
	 * Updates the points array.
	 * @private
	 */
	_updatePoints() {
		// Get target positions in Mars frame
		const targetAPos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const targetBPos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();

		this._targetA.getPositionRelativeToEntity(targetAPos, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity());
		this._targetB.getPositionRelativeToEntity(targetBPos, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity());

		// Update positions
		this._positions = [];
		this._positions.push(targetAPos);
		this._positions.push(targetBPos);
		this._lineMesh.setPositions(this._positions);

		// Update colors
		const color = this._color;
		this._colors = [];
		this._colors.push(color);
		this._colors.push(color);
		this._lineMesh.setColors(this._colors);

		// Update widths
		this._widths = [];
		this._widths.push(this._width);
		this._widths.push(this._width);
		this._lineMesh.setWidths(this._widths);

		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(targetAPos);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(targetBPos);
	}
}


/***/ }),

/***/ "../eyes/src/lib/quadtree.js":
/*!***********************************!*\
  !*** ../eyes/src/lib/quadtree.js ***!
  \***********************************/
/***/ (function() {

/*
 * Javascript Quadtree
 * @version 1.1.1
 * @licence MIT
 * @author Timo Hausmann
 * https://github.com/timohausmann/quadtree-js/
 */

/*
 Copyright © 2012 Timo Hausmann

Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:

The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENthis. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/

;(function(window, Math) {

	 /*
	  * Quadtree Constructor
	  * @param Object bounds		bounds of the node, object with x, y, width, height
	  * @param Integer max_objects		(optional) max objects a node can hold before splitting into 4 subnodes (default: 10)
	  * @param Integer max_levels		(optional) total max levels inside root Quadtree (default: 4)
	  * @param Integer level		(optional) deepth level, required for subnodes
	  */
	function Quadtree( bounds, max_objects, max_levels, level ) {

		this.max_objects	= max_objects || 10;
		this.max_levels		= max_levels || 4;

		this.level 		= level || 0;
		this.bounds 		= bounds;

		this.objects 		= [];
		this.nodes 		= [];
	};


	/*
	 * Split the node into 4 subnodes
	 */
	Quadtree.prototype.split = function() {

		var 	nextLevel	= this.level + 1,
			subWidth	= Math.round( this.bounds.width / 2 ),
			subHeight 	= Math.round( this.bounds.height / 2 ),
			x 		= Math.round( this.bounds.x ),
			y 		= Math.round( this.bounds.y );

	 	//top right node
		this.nodes[0] = new Quadtree({
			x	: x + subWidth,
			y	: y,
			width	: subWidth,
			height	: subHeight
		}, this.max_objects, this.max_levels, nextLevel);

		//top left node
		this.nodes[1] = new Quadtree({
			x	: x,
			y	: y,
			width	: subWidth,
			height	: subHeight
		}, this.max_objects, this.max_levels, nextLevel);

		//bottom left node
		this.nodes[2] = new Quadtree({
			x	: x,
			y	: y + subHeight,
			width	: subWidth,
			height	: subHeight
		}, this.max_objects, this.max_levels, nextLevel);

		//bottom right node
		this.nodes[3] = new Quadtree({
			x	: x + subWidth,
			y	: y + subHeight,
			width	: subWidth,
			height	: subHeight
		}, this.max_objects, this.max_levels, nextLevel);
	};


	/*
	 * Determine which node the object belongs to
	 * @param Object pRect		bounds of the area to be checked, with x, y, width, height
	 * @return Integer		index of the subnode (0-3), or -1 if pRect cannot completely fit within a subnode and is part of the parent node
	 */
	Quadtree.prototype.getIndex = function( pRect ) {

		var 	index 			= -1,
			verticalMidpoint 	= this.bounds.x + (this.bounds.width / 2),
			horizontalMidpoint 	= this.bounds.y + (this.bounds.height / 2),

			//pRect can completely fit within the top quadrants
			topQuadrant = (pRect.y < horizontalMidpoint && pRect.y + pRect.height < horizontalMidpoint),

			//pRect can completely fit within the bottom quadrants
			bottomQuadrant = (pRect.y > horizontalMidpoint);

		//pRect can completely fit within the left quadrants
		if( pRect.x < verticalMidpoint && pRect.x + pRect.width < verticalMidpoint ) {
			if( topQuadrant ) {
				index = 1;
			} else if( bottomQuadrant ) {
				index = 2;
			}

		//pRect can completely fit within the right quadrants
		} else if( pRect.x > verticalMidpoint ) {
			if( topQuadrant ) {
				index = 0;
			} else if( bottomQuadrant ) {
				index = 3;
			}
		}

		return index;
	};


	/*
	 * Insert the object into the node. If the node
	 * exceeds the capacity, it will split and add all
	 * objects to their corresponding subnodes.
	 * @param Object pRect		bounds of the object to be added, with x, y, width, height
	 */
	Quadtree.prototype.insert = function( pRect ) {

		var 	i = 0,
	 		index;

	 	//if we have subnodes ...
		if( typeof this.nodes[0] !== 'undefined' ) {
			index = this.getIndex( pRect );

		  	if( index !== -1 ) {
				this.nodes[index].insert( pRect );
			 	return;
			}
		}

	 	this.objects.push( pRect );

		if( this.objects.length > this.max_objects && this.level < this.max_levels ) {

			//split if we don't already have subnodes
			if( typeof this.nodes[0] === 'undefined' ) {
				this.split();
			}

			//add all objects to there corresponding subnodes
			while( i < this.objects.length ) {

				index = this.getIndex( this.objects[ i ] );

				if( index !== -1 ) {
					this.nodes[index].insert( this.objects.splice(i, 1)[0] );
				} else {
					i = i + 1;
			 	}
		 	}
		}
	 };


	/*
	 * Return all objects that could collide with the given object
	 * @param Object pRect		bounds of the object to be checked, with x, y, width, height
	 * @Return Array		array with all detected objects
	 */
	Quadtree.prototype.retrieve = function( pRect ) {

		var 	index = this.getIndex( pRect ),
			returnObjects = this.objects;

		//if we have subnodes ...
		if( typeof this.nodes[0] !== 'undefined' ) {

			//if pRect fits into a subnode ..
			if( index !== -1 ) {
				returnObjects = returnObjects.concat( this.nodes[index].retrieve( pRect ) );

			//if pRect does not fit into a subnode, check it against all subnodes
			} else {
				for( var i=0; i < this.nodes.length; i=i+1 ) {
					returnObjects = returnObjects.concat( this.nodes[i].retrieve( pRect ) );
				}
			}
		}

		return returnObjects;
	};


	/*
	 * Clear the quadtree
	 */
	Quadtree.prototype.clear = function() {

		this.objects = [];

		for( var i=0; i < this.nodes.length; i=i+1 ) {
			if( typeof this.nodes[i] !== 'undefined' ) {
				this.nodes[i].clear();
		  	}
		}

		this.nodes = [];
	};

	//make Quadtree available in the global namespace
	window.Quadtree = Quadtree;

})(window, Math);


/***/ }),

/***/ "../eyes/src/managers/base_manager.js":
/*!********************************************!*\
  !*** ../eyes/src/managers/base_manager.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseManager": function() { return /* binding */ BaseManager; }
/* harmony export */ });



/**
 * Base manager class.
 */
class BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		/**
		 * Application.
		 * @type {BaseApp}
		 * @private
		 */
		this._app = app;

		/**
		 * Pioneer engine.
		 * @type {Pioneer.Engine}
		 * @private
		 */
		this._pioneer = app.pioneer;

		/**
		 * Array of possible event names.
		 * @type {string[]}
		 * @default
		 */
		this._eventNames = [];

		/**
		 * Callbacks reference object.
		 * @type {Object<string, Array<(...params: any[]) => void>>}
		 * @default
		 */
		this._callbacks = {};
	}

	/**
	 * Gets Pioneer engine.
	 * @returns {Pioneer.Engine}
	 */
	get pioneer() {
		return this._pioneer;
	}

	/**
	 * Gets application object.
	 * @returns {BaseApp}
	 */
	get app() {
		return this._app;
	}

	/**
	 * Initialize callback list for all events.
	 * @protected
	 */
	_initCallbacks() {
		for (let i = 0; i < this._eventNames.length; i++) {
			this._callbacks[this._eventNames[i]] = [];
		}
	}

	/**
	 * Registers a callback for a specific event.
	 * @param {string} eventName
	 * @param {(...params: any[]) => void} callback - A callback function to be called
	 */
	registerCallback(eventName, callback) {
		if ((typeof (callback) !== 'function') || (this._eventNames.indexOf(eventName) < 0)) {
			return;
		}

		// Prevent multiple registrations of same event with same callback
		if (!this._callbacks[eventName].includes(callback)) {
			this._callbacks[eventName].push(callback);
		}
	}

	/**
	 * Remove a callback for an event.
	 * @param {string} eventName
	 * @param {(...params: any[]) => void} callback
	 */
	removeCallback(eventName, callback) {
		if ((typeof (callback) !== 'function') || (this._eventNames.indexOf(eventName) < 0)) {
			return;
		}

		const index = this._callbacks[eventName].indexOf(callback);
		if (index > -1) {
			this._callbacks[eventName].splice(index, 1);
		}
	}

	/**
	 * Trigger all callbacks for an event.
	 * @param {string} eventName
	 * @param {any[]} [params=[]] - Parameters for callback
	 */
	triggerCallbacks(eventName, params = []) {
		for (let i = this._callbacks[eventName].length - 1; i >= 0; i--) {
			const callbackFn = this._callbacks[eventName][i];
			callbackFn(...params);
		}
	}

	/**
	 * Bind functions to class.
	 * @param {string[]} [fns=[]] - Names of functions.
	 */
	bindFunctions(fns = []) {
		const thisAsObject = /** @type {Object<string, any>} */(this);
		for (let i = 0; i < fns.length; i++) {
			const fn = fns[i];
			thisAsObject[fn] = thisAsObject[fn].bind(this);
		}
	}

	/**
	 * Destroy the manager.
	 */
	destroy() {
		this.__destroy();
	}

	/**
	 * Destroy the manager.
	 * @private
	 */
	__destroy() {
	}
}


/***/ }),

/***/ "../eyes/src/managers/camera_follow_manager.js":
/*!*****************************************************!*\
  !*** ../eyes/src/managers/camera_follow_manager.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraFollowManager": function() { return /* binding */ CameraFollowManager; }
/* harmony export */ });
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");





/**
 * Camera-Follow is when you're on a space object or event view and you want the camera to automatically align / follow an additional object.
 * This tracking is remains dynamic whilst the followId is set.
 * Although there are UI components for this (Search and Toast), the follow logic will be determined here.
 *
 * State notes:
 * The followId, followEntity, and followName states are all set when the follow function is called.
 * The targetId and targetEntity are not technically states as they are always directly attached to the current view.
 */

/**
 * CameraFollowOptions type.
 * @typedef CameraFollowOptions
 * @property {string} placeholder - The placeholder text for the search component.
 * @property {number} maxFeatured - The maximum number of featured items to show.
 * @property {number} hideSearchDelay - The delay in milliseconds to hide the search component.
 * @property {number} cameraDuration - The duration in seconds for the camera animation.
 */

/**
 *
 */
class CameraFollowManager extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} options
	 */
	constructor(app, options = {}) {
		super(app);

		/**
		 * @type {CameraFollowOptions}
		 * @private
		 */
		this._options = {
			placeholder: 'Search target to follow...',
			maxFeatured: 5,
			hideSearchDelay: 1000,
			cameraDuration: 1.5,
			...options
		};

		/**
		 * @type {boolean}
		 * @private
		 */
		this._isEnabled = null;

		/**
		 * @type {string}
		 * @public
		 */
		this.followId = null;

		/**
		 * @type {string}
		 * @public
		 */
		this.followName = null;

		/**
		 * @type {HTMLElement}
		 * @public
		 */
		this.optionElement = null;

		/**
		 * @type {BaseComponent}
		 * @public
		 */
		this.search = null;

		/**
		 * @type {Function}
		 * @private
		 */
		this._returnToPreviousCamView = null;

		/**
		 * Hide search timeout.
		 * @type {number}
		 * @private
		 */
		this._hideSearchTimeout = null;

		/**
		 * Store the previous entity label weights.
		 * @type {object}
		 * @private
		 */
		this._prevValues = {
			weights: {},
			occRadii: {},
			labelsClickable: {},
			occlusion: {},
			timeLimits: { min: null, max: null }
		};

		/**
		 * Monitor screen resizes
		 */
		this._resizeObserver = new ResizeObserver(() => {
			this.setYawPitchLimits();
		});


		/**
		 * We're going to add a mutation observer to the body to see when the offset has changed.
		 * This is because the existing callback system is not called in the expected order.
		 * Instead of adding a callback to the offsetPanel, we're going to add a callback to the body when the class changes.
		 */
		this._offsetObserver = new MutationObserver(mutations => {
			mutations.forEach(mutation => {
				if (mutation.attributeName === 'class') {
					this.setYawPitchLimits();
				}
			});
		});

		// Create the sum parent entity.
		this._sumParent = this._createSumParent();

		// Create the reframing element.
		this._createReframeElement();

		this.bindFunctions(['update', 'setSearchOptions', 'goToPreviousCamView', 'updateOccludedEntities']);

		this.pioneer.addCallback(this.update, true);
	}


	/**
	 * Sets the local followId, followEntity and followName.
	 * Also updates the search input.
	 * @param {string} followId
	 */
	setFollowVars(followId) {
		const contentManager = this.app.getManager('content');
		const { input: searchInput } = this.search?._children || {};

		// Determine DistanceEntity properties.
		const { altName, displayName, iauName } = contentManager.getEntityInfo(followId) ?? {};
		const followName = altName || displayName || iauName || '';

		if (searchInput) {
			searchInput.value = followName;
		}

		// Set the local follow id and name.
		this.followId = followId;
		this.followEntity = followId ? this.app.scene.get(followId) : null;
		this.followName = followName;
	}

	/**
	 * Sets the toast content.
	 * @param {object} options
	 * @param {boolean} options.reset
	 */
	setToastContent({ reset = false } = {}) {
		const toast = this.app.getComponent('toast');

		if (reset) {
			toast.hide();
			toast.setContent('');
			return;
		}

		// Determine the content.
		const prefix = ['Sun', 'Moon', 'ISS'].includes(this.followName) ? 'the ' : '';
		const textHtmlStr = `<span class="content-text">Camera is following ${prefix}${this.followName}</span>`;
		const buttonHtmlStr = '<button class="clickable undo" aria-label="Undo camera follow">Undo</button>';
		toast.setContent(`<div>${textHtmlStr}${buttonHtmlStr}</div>`);


		// Add event listener to the button.
		const { toastContent } = toast._children;
		const undoButton = toastContent.querySelector('button');

		undoButton?.addEventListener('click', () => {
			this.setEnabled(false);
		});
	}

	/**
	 * Show the toast.
	 */
	showToast() {
		const toast = this.app.getComponent('toast');
		toast.show();
	}

	/**
	 * Determine whether the time limits are valid.
	 * Re-directs if necessary.
	 * @returns {object}
	 */
	validateTimeLimits() {
		const timeManager = this.app.getManager('time');
		const currentTime = timeManager.getTime();
		const { currentView } = this.app.getManager('router');

		// Get the position coverage for the target and follow entities in ET.
		const { min: targetMinET, max: targetMaxET } = this.targetEntity?.getPositionCoverage() || {};
		const { min: followMinET, max: followMaxET } = this.followEntity?.getPositionCoverage() || {};

		// Make sure we have all the values.
		if (!targetMinET || !targetMaxET || !followMinET || !followMaxET) {
			return { isValid: false };
		}

		// Get moment values.
		let targetMin = isFinite(targetMinET) ? timeManager.etToMoment(targetMinET) : targetMinET;
		let targetMax = isFinite(targetMaxET) ? timeManager.etToMoment(targetMaxET) : targetMaxET;
		const followMin = isFinite(followMinET) ? timeManager.etToMoment(followMinET) : followMinET;
		const followMax = isFinite(followMaxET) ? timeManager.etToMoment(followMaxET) : followMaxET;

		// Determine if we use the event limits.
		const useEventLimits = currentView === 'event' && this.app.getView('event')._eventName;

		if (useEventLimits) {
			const { min: limitMin, max: limitMax } = timeManager.getLimits() || {};
			targetMin = limitMin;
			targetMax = limitMax;
		}


		// Determine the min and max times.
		const minTime = Math.max(followMin, targetMin);
		const maxTime = Math.min(followMax, targetMax);

		// If there is no overlap between the target limits and the followEntity limits, we cannot follow the entity.
		const noOverlap = followMin > targetMax || followMax < targetMin;
		if (noOverlap) {
			// Display limit message
			this.app.getComponent('clock')?.setLimitMessage(null, 'Entity timelines do not overlap');
			this.setEnabled(false);
			return { isValid: false };
		}

		// If the current time is not within the followMin and followMax, go to the min time.
		const updateTime = currentTime < followMin || currentTime > followMax;
		if (updateTime) {
			const time = timeManager.getTimeUrl(minTime);
			this.app.getManager('router').navigate({ time });
		}

		return {
			isValid: true,
			minTime,
			maxTime
		};
	}

	/**
	 * Activates the camera follow, given the followId.
	 * @param {string} followId
	 */
	async follow(followId) {
		// Get current and prev targets.
		const { currentRoute, previousRoute } = this.app.getManager('router');
		const { params: prevParams } = previousRoute || {};
		const { params } = currentRoute || {};
		const { spaceObject: prevTargetId } = prevParams || {};
		const { spaceObject: targetId } = params || {};
		const { cameraDuration } = this._options;

		// Set enabled.
		this._isEnabled = true;

		// Make sure the search is initialized.
		!this.search && this.initSearch();

		// If there was a previous followId, reset the label weight.
		this.followId && this.setLabelWeight(this.followId, true);

		// If there was a previous followId, reset the time limits.
		this.setTimeLimits({ reset: true });

		// If there was a different previous targetId, reset the occlusion radius, and clickable state.
		if (prevTargetId && prevTargetId !== targetId) {
			this.setTargetNotClickable(prevTargetId, true);
		}

		// Force entity visible.
		this.app.getManager('scene').setEntitiesForceVisible([followId]);

		// Update the follow vars.
		this.setFollowVars(followId);

		// Make sure it doesn't fade.
		const divComponent = this.followEntity?.get('div');
		divComponent.setFadeWhenCloseToEntity(false);

		/**
		 * Trigger the radio button selection in the content panel
		 * (when just changing the query, onRouteChange in the view options block is not triggered)
		 */
		this.triggerViewOptionUpdate();

		// Set the toast content.
		this.setToastContent();

		// Start observing the body for offset class changes.
		this._offsetObserver.observe(document.body, { attributes: true });

		// Start observing the body for resize changes.
		this._resizeObserver.observe(document.body);

		// Wait for the entities to be in place.
		await this.entitiesInPlace();

		// Determine validity of the time limits.
		const { isValid, minTime, maxTime } = this.validateTimeLimits();

		// Return if not valid or no longer enabled.
		if (!isValid || !this.isEnabled) {
			return;
		}

		// Add parentChanged callbacks.
		this.setParentsChangedCallbacks();


		const startAnimation = () => {
			// We need to pause time to prevent weird offsets.
			const timeManager = this.app.getManager('time');
			timeManager.pause();

			// Show the toast.
			if (this.followName) {
				this.showToast();
			}


			// Animate camera and apply remaining settings.
			this.animateCamera(cameraDuration)
				.then(() => {
					// Resume time.
					timeManager.play();

					// If it's been disabled, return early.
					if (!this._isEnabled) {
						return false;
					}

					// Set the time limits.
					this.setTimeLimits({ minTime, maxTime });

					// Set the yaw and pitch limits.
					this.setYawPitchLimits();

					// Set higher label weight for the followId.
					this.setLabelWeight(this.followId);

					// Update occluded entities.
					this.updateOccludedEntities();

					// Make sure target is not clickable
					this.setTargetNotClickable(this.targetId);

					// Hide content panel of we're on mobile.
					_internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isMobile() && this.app.getComponent('contentPanel')?.hide();

					// Hide the search.
					this.hideSearch();

					return true;
				})
				.catch(e => e);
		};

		// If viewOptionsBlock is already loaded, trigger animation, otherwise wait for it to load.
		const { isLoaded, onLoaded } = this.app.getComponent('viewOptionsBlock');
		isLoaded ? startAnimation() : onLoaded.push(startAnimation);
	}

	/**
	 * Stop the follow and reset the state.
	 */
	unfollow() {
		const { previousRoute, currentView } = this.app.getManager('router');
		const { params } = previousRoute || {};
		const { spaceObject: prevTargetId } = params || {};

		// Reset the toast.
		this.setToastContent({ reset: true });

		// Reset label weights.
		this.setLabelWeight(this.followId, true);

		// Reset occluded entities
		this.updateOccludedEntities({ reset: true });

		// Reset target clickable.
		this.setTargetNotClickable(prevTargetId, true);

		// Remove parentChanged callbacks.
		const prevTargetEntity = this.app.scene.get(prevTargetId);
		this.setParentsChangedCallbacks({ targetEntity: prevTargetEntity, reset: true });

		// Reset follow vars.
		this.setFollowVars(null);

		// Reset search options
		this.setSearchOptions({ reset: true });

		// Stop observing the body for offset class changes.
		this._offsetObserver.disconnect();

		// Stop observing the body for resize changes.
		this._resizeObserver.disconnect();
	}

	/**
	 * There are 2 animations that occur simultaneously.
	 * The first is animating the position, alignment, and parenting of the sum parent.
	 * The second is calling followEntity from the camera manager.
	 * @param {number} duration
	 * @returns {Promise<boolean>}
	 */
	animateCamera(duration) {
		// Clear controllers.
		this._sumParent.clearControllers();

		// Calculate the sumParent distance according to the target entity's extents radius
		const sumParentDist = this.targetEntity?.getExtentsRadius() || 0.1;

		// Add a position sum controller to the sumParent, using the target and follow entities
		const psController = this._sumParent.addControllerByClass(pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.PositionSumController);
		psController.addEntity(this.targetId, 1, 0);
		psController.addEntity(this.followId, 0, -sumParentDist);

		// Add an align controller to the camLockParent, using the source entity
		const alignController = this._sumParent.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
		alignController.setPrimaryAlignType('point');
		alignController.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis);
		alignController.setPrimaryTargetEntity(this.targetId);

		// Add and setup the transition controller.
		const transitionController = this._sumParent.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TransitionController);
		transitionController.setTransitionTime(duration);
		transitionController.setParent(this.targetId);

		const { _easeOutExpoTransition: transitionFunction } = this.app.cameraScripts;
		transitionController.setTransitionFunction(transitionFunction);

		// Call followEntity
		const camManager = this.app.getManager('camera');
		return camManager.followTheEntity(this.targetId, this.followId, this._sumParent.getName(), duration);
	}


	/**
	 * When the parent of the followEntity changes, we need to update the sumParent.
	 * @param {object} options
	 * @param {Entity} options.targetEntity
	 * @param {boolean} options.reset
	 */
	setParentsChangedCallbacks({ targetEntity = this.targetEntity, reset = false } = {}) {
		if (reset) {
			// Remove the parent changed callback for the targetEntity.
			targetEntity?.removeParentChangedCallback(this.updateOccludedEntities);
			this.followEntity?.removeParentChangedCallback(this.updateOccludedEntities);
			return;
		}

		// Set the parent changed callback for the targetEntity.
		targetEntity?.addParentChangedCallback(this.updateOccludedEntities);
		this.followEntity?.addParentChangedCallback(this.updateOccludedEntities);
	}

	/**
	 * Sets the label weight to high value or previous value
	 * @param {string} id
	 * @param {boolean} resetToPrevious
	 * @param {string} weight
	 */
	setLabelWeight(id, resetToPrevious = false, weight = '201') {
		const labelManager = this.app.getManager('label');
		const currWeight = labelManager.getWeight(id);

		// Create the weight if it doesn't exist.
		if (currWeight === 0) {
			labelManager._weights[id] = {};
		}

		if (resetToPrevious) {
			if (this._prevValues.weights[id]) {
				labelManager._weights[id].weight = this._prevValues.weights[id];
				delete this._prevValues.weights[id];
			}
		}
		else {
			labelManager._weights[id].weight = weight;
			this._prevValues.weights[id] = currWeight;
		}
	}

	/**
	 * Update the occluded and unnoccluded entities.
	 * @param {object} options
	 * @param {boolean} options.reset
	 */
	updateOccludedEntities({ reset = false } = {}) {
		const entitiesToUnocclude = !reset && this.getEntitiesToUnocclude();
		this.setOcclusionProps(entitiesToUnocclude);
	}

	/**
	 * Determine which entities should not be occluding.
	 * @returns {string[]}
	 */
	getEntitiesToUnocclude() {
		const followParent = this.followEntity?.getParent()?.getName();
		const targetParent = this.app.scene.get(this.targetId)?.getParent()?.getName();
		const entitiesToSet = [this.followId, followParent, this.targetId, targetParent];

		// Return unique entities.
		return [...new Set(entitiesToSet)].filter(Boolean);
	}

	/**
	 * Store the canOcclude value for the entity, then set it to false.
	 * If resetting, set the canOcclude value back to the stored value.
	 * @param {string[]} entitiesToUnocclude
	 */
	setOcclusionProps(entitiesToUnocclude) {
		const { occlusion } = this._prevValues;

		// Reset all stored occlusion values.
		Object.keys(occlusion).forEach(entityId => {
			const entity = this.app.scene.get(entityId);
			entity?.setCanOcclude(occlusion[entityId]);
		});

		// Clear the occlusion object.
		this._prevValues.occlusion = {};

		// Store the canOcclude value for the entity, then set it to false.
		entitiesToUnocclude?.length && entitiesToUnocclude.forEach(entityId => {
			const entity = this.app.scene.get(entityId);
			if (!entity) {
				return;
			}

			// Store the canOcclude value.
			this._prevValues.occlusion[entityId] = entity.canOcclude();

			// Set the canOcclude value to false.
			entity.setCanOcclude(false);
		});
	}

	/**
	 * The current target should not be clickable as the follow target.
	 * @param {string} entityId
	 * @param {boolean} resetToPrevious
	 */
	setTargetNotClickable(entityId, resetToPrevious = false) {
		const labelManager = this.app.getManager('label');
		const label = labelManager._labels[entityId];
		if (!label) {
			return;
		}

		const { labelsClickable } = this._prevValues;

		if (resetToPrevious) {
			if (labelsClickable[entityId] !== undefined) {
				labelManager.setLabelClickable(entityId, labelsClickable[entityId]);
				delete labelsClickable[entityId];
			}
		}
		else {
			// Make sure the label is not clickable.
			labelsClickable[entityId] = label.isClickable;
			labelManager.setLabelClickable(entityId, false);
		}
	}

	/**
	 * Create a reframing element.
	 */
	_createReframeElement() {
		const { staticElement } = this.app;

		const elementExists = staticElement.querySelector('.follow-reframe');
		if (elementExists) {
			return;
		}

		this._reframeElement = document.createElement('div');
		this._reframeElement.classList.add('follow-reframe');

		staticElement.appendChild(this._reframeElement);
	}

	/**
	 * Create the camLockParent entity.
	 * @returns {Entity}
	 */
	_createSumParent() {
		const sumParentName = 'follow_sum_parent';

		// Create the between position entity.
		const sumParentEntity = pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Entity.createFromOptions(sumParentName, { parents: [] }, this.app.scene);

		// Make sure it's positioned at zero (the source).
		sumParentEntity.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);
		sumParentEntity.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity);

		return sumParentEntity;
	}


	/**
	 * Appends the search component element to the optionElement.
	 * @param {HTMLElement} optionElement
	 */
	initSearch(optionElement) {
		if (!this.search) {
			this.search = this.app.getComponent('cameraFollowSearch');

			// Add a listener to the search element so we can catch the event before it bubbles up.
			this.search.element.addEventListener('click', e => {
				e.stopPropagation();
			});

			// Set the placeholder text.
			const { placeholder } = this._options;
			const { input: searchInput } = this.search._children;
			searchInput && searchInput.setAttribute('placeholder', placeholder);

			// Set the default info text.
			const defaultInfo = 'related';
			this.search._config.infoText.default = defaultInfo;
			this.search.setState({ searchInfo: defaultInfo });
		}

		// Append the search element to the optionElement if passed.
		if (optionElement) {
			optionElement.appendChild(this.search.element);
			this.search.setParent(optionElement);
		}
	}

	/**
	 * Show and open the search component.
	 */
	showSearch() {
		this.stopHideTimeout();
		this.search?.show();
		this.search?.open();
	}

	/**
	 * Hide and close the search component.
	 */
	hideSearch() {
		this.search?.hide();
		this.search?.close();
	}

	/**
	 * Trigger radio button selection in viewOptionsBlock once it's loaded.
	 */
	triggerViewOptionUpdate() {
		const viewOptionsBlock = this.app.getComponent('viewOptionsBlock');
		const { isLoaded, onLoaded } = viewOptionsBlock;

		const triggerSelection = () => {
			const { _currentView: currentSelection, selectCameraView, setOptionInnerHTML } = viewOptionsBlock;
			currentSelection !== 'cameraFollow' && selectCameraView('cameraFollow');
			// Update the inner HTML.
			setOptionInnerHTML('cameraFollow', this.followInnerHtml);
		};

		// If viewOptionsBlock is already loaded, trigger radio button selection.
		isLoaded ? triggerSelection() : onLoaded.push(triggerSelection);
	}

	/**
	 * Set the previous camera view return function.
	 */
	setReturnToPreviousCamView() {
		// Set reference to previous view if it's not already cameraFollow
		const viewOptionsBlock = this.app.getComponent('viewOptionsBlock');
		const { _currentView: prevView } = viewOptionsBlock;
		if (prevView !== 'cameraFollow') {
			const { optionTitle } = viewOptionsBlock._viewOptionsList.find(({ id }) => id === prevView) || {};

			// Set function to return to previous view.
			this._returnToPreviousCamView = () => viewOptionsBlock.selectCameraView(optionTitle);
		}
	}

	/**
	 * Navigate to the previous camera view and reset the function to null.
	 */
	goToPreviousCamView() {
		typeof this._returnToPreviousCamView === 'function' && this._returnToPreviousCamView();
		this._returnToPreviousCamView = null;
	}

	/**
	 * Sets time limits.
	 * @param {object} params
	 * @param {import('moment').Moment} params.minTime
	 * @param {import('moment').Moment} params.maxTime
	 * @param {boolean} params.reset
	 */
	setTimeLimits({ minTime, maxTime, reset = false } = {}) {
		const timeManager = this.app.getManager('time');

		if (!reset) {
			// Store the current time limits.
			const { min, max } = timeManager.getLimits();
			this._prevValues.timeLimits = { min, max };

			// Set time limits.
			timeManager.setMin(minTime);
			timeManager.setMax(maxTime);
		}
		else {
			// Reset the time limits.
			const { min, max } = this._prevValues.timeLimits;

			if (min !== null && max !== null) {
				timeManager.setMin(min);
				timeManager.setMax(max);
			}
		}
	}


	/**
	 * Set the yaw and pitch limits for the orbit controller.
	 */
	setYawPitchLimits() {
		const isOffsetRight = document.body.classList.contains('offset-right');
		const isOffsetUp = document.body.classList.contains('offset-up');

		const cameraEntity = this.app.scene.get('camera');
		// Camera field of view.
		const camComponent = cameraEntity.getComponentByType('camera');
		const hFov = camComponent.getHorizontalFieldOfView();
		const vFov = camComponent.getVerticalFieldOfView();
		const orbitController = cameraEntity.getControllerByType('orbit');

		if (!orbitController) {
			return;
		}

		// If the content is expanded, we need to know if it's offset vertically of horizontally.
		const yawOffset = isOffsetRight ? hFov * 0.05 : 0;
		const pitchOffset = isOffsetUp ? vFov * 0.2 : 0;

		// YaW center-point is -Math.PI/2
		const yawCP = Math.PI * -0.5;
		const yawLimitDiff = hFov * 0.45;
		const pitchLimitDiff = vFov * 0.4;

		const yawMin = yawCP - yawLimitDiff + yawOffset;
		const yawMax = yawCP + yawLimitDiff - yawOffset;
		const pitchMin = -pitchLimitDiff + pitchOffset;
		const pitchMax = pitchLimitDiff - pitchOffset;

		orbitController.setYawAngleLimits(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(yawMin, yawMax));
		orbitController.setPitchAngleLimits(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(pitchMin, pitchMax));
	}

	/**
	 * Set specific search options for current target.
	 * @param {object} options
	 * @param {string} options.targetId
	 * @param {string} options.followId
	 * @param {boolean} options.reset
	 */
	async setSearchOptions({ targetId = this.targetId, followId = this.followId, reset = false } = {}) {
		if (reset) {
			// Set search excludeResults list.
			this.search?.setExcludeResults([]);
			return;
		}

		// Await entities.
		await this.entitiesInPlace();

		// Determine entity list.
		const entityList = [targetId, followId].filter(Boolean);

		const { maxFeatured } = this._options;
		// Build list of featured suggestions.
		const allRelated = [];

		// Get the parent/ancestor and featured moon details at the current time if available.
		const timeManager = this.app.getManager('time');
		const time = timeManager.getTime();
		const etTime = timeManager.momentToET(time);
		const targetEntity = this.targetEntity || this.app.scene.get(targetId);

		const ancestorId = this.followEntity
			? targetEntity.getLowestCommonAncestorAtTime(this.followEntity, etTime)?.getName()
			: targetEntity.getParentAtTime(etTime);

		const contentManager = this.app.getManager('content');
		const { featuredMoons = [] } = ancestorId ? await contentManager.getEntityDesc(ancestorId).catch(() => ({})) : {};

		// After the await, return early if no entities or if we're no longer enabled.
		if (!entityList.length || !this.isEnabled) {
			return;
		}

		allRelated.push(ancestorId, ...featuredMoons);

		// Get the entity description from the current view.
		const { currentView } = this.app.getManager('router');
		const { _entityDesc, _eventDesc } = this.app.getView(currentView);
		const { related: descRelated = [] } = _entityDesc || {};
		const { related: eventRelated = [] } = _eventDesc || {};
		allRelated.push(...descRelated, ...eventRelated);

		// Always add the sun at the end.
		allRelated.push('sun');

		// Remove duplicates.
		const uniqueRelated = [...new Set(allRelated)];

		// Remove the targetId and followId from the list.
		const filteredRelated = uniqueRelated.filter(entityName => ![targetId, followId].includes(entityName));

		// Limit the number of featured items.
		const limitedRelated = filteredRelated.slice(0, maxFeatured);

		// Map to text and url.
		const featuredItems = limitedRelated.map(entityName => {
			const { id, iauName, displayName } = this.app.getManager('content')?.getEntityInfo(entityName) || {};
			const text = displayName || iauName;

			// Rreturn false if no id or text.
			if (!id || !text) {
				return false;
			}

			return { text, url: `/${id}` };
		}).filter(Boolean);

		// Set search excludeResults list.
		this.search?.setExcludeResults(entityList);

		// Set search featured suggestions.
		this.search?.setupFeaturedSuggestion(featuredItems);
	}

	/**
	 * Awaits for target and follow entities to be in place.
	 * Maybe be required multiple times, as some functions are called from different places.
	 */
	async entitiesInPlace() {
		const entityList = [this.targetId, this.followId].filter(Boolean);
		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.SceneHelpers.waitTillEntitiesInPlace(this.app.scene, entityList);
	}

	/**
	 * Update is called every frame.
	 */
	update() {
		const offset = this._pioneer.getInput().getDraggedOffset();
		const isDragging = !offset.isZero();
		const isFollowing = this.followId;

		if (!isFollowing) {
			return;
		}

		// Toggle the following-dragging class on the dynamicElement.
		const { staticElement } = this.app;
		staticElement.classList.toggle('follow-dragging', isDragging);

		// Show the toast again if dragging.
		isDragging && this.showToast();
	}

	/**
	 * Sets whether the cam follow is enabled and ready to follow.
	 * This will essentially show or hide the search component.
	 * The boolean is also used in the link manager to determine how to handle links.
	 * @param {boolean} enabled
	 * @param {object} params
	 * @param {boolean} params.resetCam
	 * @param {boolean} params.resetLimits
	 * @param {boolean} params.removeQueries
	 */
	setEnabled(enabled, { resetCam = true, resetLimits = true, removeQueries = true } = {}) {
		const alreadyEnabled = this._isEnabled;
		this._isEnabled = enabled;

		const { currentRoute, currentView } = this.app.getManager('router');
		const { params } = currentRoute || {};

		// Make sure the search is initialized.
		!this.search && this.initSearch();

		if (enabled) {
			// Set the return to previous view function
			this.setReturnToPreviousCamView();

			// Determine whether to show the search.
			const showSearch = !this.followId || alreadyEnabled;
			showSearch && this.showSearch();

			// If we're already following something, we can trigger the hideSearch timeout.
			this.followId && this.setHideTimeout();
		}
		else if (alreadyEnabled) {
			// Go to the previous cam view if resetCam
			resetCam && this.goToPreviousCamView();

			// If we're following something, unfollow it.
			this.followId && this.unfollow();

			// Reset stored time limits
			resetLimits && this.setTimeLimits({ reset: true });

			// Remove the followId, tie and rate queries from the URL.
			removeQueries && this.app.getManager('router').navigate({ __remove: ['followId', 'time', 'rate'] });

			// Hide the search
			this.hideSearch();

			// Reset the viewOptionsBlock inner HTML.
			this.app.getComponent('viewOptionsBlock').setOptionInnerHTML('cameraFollow', this.followInnerHtml);
		}
	}

	/**
	 * Set a timeout to hide the search.
	 */
	setHideTimeout() {
		// Stop the existing timeout.
		this.stopHideTimeout();

		// Set a new timeout.
		this._hideSearchTimeout = setTimeout(() => {
			this.hideSearch();
			this.stopHideTimeout();
		}, this._options.hideSearchDelay);
	}

	/**
	 * Stop the hide search timeout.
	 */
	stopHideTimeout() {
		clearTimeout(this._hideSearchTimeout);
		this._hideSearchTimeout = null;
	}

	/**
	 * Gets the targetId from the current view.
	 * @returns {string}
	 */
	get targetId() {
		const { currentView } = this.app.getManager('router');
		const { _target } = this.app.getView(currentView);
		return _target;
	}

	/**
	 * Gets the target entity from the current view.
	 * @returns {Entity}
	 */
	get targetEntity() {
		return this.app.scene.get(this.targetId);
	}

	/**
	 * Returns the inner html for the follow name.
	 * @returns {string}
	 */
	get followInnerHtml() {
		return this.followName ? `Following <span class='camera-follow-name'>${this.followName}</span>` : 'Follow Target';
	}

	/**
	 * Gets whether the cam follow is enabled.
	 * @returns {boolean}
	 */
	get isEnabled() {
		return this._isEnabled;
	}
}


/***/ }),

/***/ "../eyes/src/managers/camera_manager.js":
/*!**********************************************!*\
  !*** ../eyes/src/managers/camera_manager.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraManager": function() { return /* binding */ CameraManager; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");




/**
 * Callback for 3D object selection.
 * @callback selectionCallback
 * @callback TransitionFunction
 * @param {Pioneer.Entity} entity
 */

/**
 * Callback for after camera transition.
 * @callback transitionCallback
 * @param {string} id
 * @param {Pioneer.Scene} scene
 */

/**
 * @typedef ContextBase
 * @property {string} id
 * @property {number} [context]
 */

/**
 * @typedef {ContextBase & Object<string, any>} Context
 */

/**
 * @typedef OrbitKeyframePositionOption
 * @property {number} frame
 * @property {Pioneer.Vector3} position
 * @property {string} relativeTo
 */

/**
 * @typedef OrbitKeyframeUpOption
 * @property {number} frame
 * @property {Pioneer.Vector3} up
 */

/**
 * @typedef OrbitKeyframeFocusOption
 * @property {number} frame
 * @property {string} name
 */

/**
 * @typedef OrbitKeyframeOptions
 * @property {OrbitKeyframePositionOption[]} position
 * @property {OrbitKeyframeUpOption[]} up
 * @property {OrbitKeyframeFocusOption[]} focus
 */

/**
 * Camera Manager class.
 * @extends BaseManager
 */
class CameraManager extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app - Main app
	 * @param {Pioneer.Scene} scene - The default scene to use
	 */
	constructor(app, scene) {
		super(app);

		/**
		 * Default viewport.
		 * @type {Pioneer.Viewport}
		 */
		this._viewport = null;

		/**
		 * Default scene to use in the camera.
		 * Can be overriden in some functions.
		 * @type {Pioneer.Scene}
		 */
		this._defaultScene = scene;

		/**
		 * The default camera Entity.
		 * @type {Pioneer.Entity}
		 */
		this._cameraEntity = null;

		/**
		 * // TODO: We should update this in this class
		 * Camera target id.
		 * @type {string}
		 */
		this._id = null;

		/**
		 * // TODO: We should update this in this class
		 * Camera previous target id.
		 * @type {string}
		 */
		this._previousId = null;

		/**
		 * Camera context object
		 * @type {Context} - context.id is required
		 */
		this._context = { id: '' };

		/**
		 * Internal variable to keep track of the transition status of the camera.
		 * @type {boolean}
		 */
		this._isTransitioning = false;

		/**
		 * The default maximum distance for zooming out.
		 * @type {number}
		 */
		this._defaultMaxDistance = 2.0e18;

		/**
		 * A selection callback to be called on an object click after camera transition.
		 * @type {selectionCallback}
		 */
		this._selectionCallback = null;

		/**
		 * Dynamic environment map component.
		 * @type {Pioneer.DynamicEnvironmentMapComponent}
		 */
		this._dynEnvMap = null;

		/**
		 * Camera is in free fly.
		 * @type {boolean}
		 * @default
		 */
		this._isFreeFly = false;

		/**
		 * Zoom sensitivity for zoom functions.
		 * @type {{ click: number, hold: number }}
		 * @default
		 */
		this._zoomSensitivity = {
			click: 0.3,
			hold: 0.1
		};

		this._fullLightColor = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._shadowLightColor = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(0.15, 0.15, 0.15, 1);

		this.bindFunctions(['zoomIn', 'zoomOut', 'addDynamicEnvMap', 'getShadowLightColor', 'getFullLightColor']);
	}

	/**
	 * Creates camera and viewport.
	 * @param {Pioneer.Scene} scene
	 */
	createViewportAndCamera(scene) {
		if (scene) {
			this._defaultScene = scene;
		}

		// Create main viewport
		if (this.pioneer.getViewport('main-viewport') === null) {
			this._viewport = this.pioneer.addViewport('main-viewport');
			this._viewport.getDiv().style.width = '100%';
			this._viewport.getDiv().style.height = '100%';
			this._viewport.getDiv().style.left = '0';
			this._viewport.getDiv().style.top = '0';
		}

		// Create camera entity
		if (this._defaultScene.get('camera') === null) {
			this._cameraEntity = this._defaultScene.addEntity('camera');
		}

		// Create camera component
		this._cameraEntity.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		let camera = /** @type {Pioneer.CameraComponent} */(this._cameraEntity.getComponentByType('camera'));
		if (camera === null) {
			camera = /** @type {Pioneer.CameraComponent} */(this._cameraEntity.addComponent('camera'));
		}
		this._viewport.setCamera(camera);

		// Create camera light component
		this._cameraLight = /** @type {Pioneer.LightSourceComponent} */(this._cameraEntity.get('lightSource'));
		if (this._cameraLight === null) {
			this._cameraLight = /** @type {Pioneer.LightSourceComponent} */(this._cameraEntity.addComponent('lightSource'));
			this._cameraLight.setEnabled(false);
			this.toggleCameraLight(true, this._shadowLightColor);
		}

		// Add dynamic env map
		if (this._dynEnvMap === null) {
			this._dynEnvMap = /** @type {Pioneer.DynamicEnvironmentMapComponent} */(this._cameraEntity.addComponent('dynEnvMap'));
		}
	}

	/**
	 * Returns camera context object.
	 * @returns {object}
	 */
	getContext() {
		return this._context;
	}

	/**
	 * Return isTransitioning
	 * @returns {boolean}
	 */
	getIsTransitioning() {
		return this._isTransitioning;
	}

	/**
	 * set isTransitioning
	 * @param {boolean} isTransitioning
	 */
	setIsTransitioning(isTransitioning) {
		this._isTransitioning = isTransitioning;
	}

	/**
	 * Wait until transition completes
	 *	@returns {Promise<boolean>}
	 */
	waitForTransitionComplete() {
		return new Promise(resolve => {
			let transitionCheckInterval = setInterval(() => {
				// Resolve once transition is complete
				if (!this._isTransitioning) {
					clearInterval(transitionCheckInterval);
					transitionCheckInterval = null;

					resolve(true);
				}
			}, 1000);
		});
	}

	/**
	 * Sets camera context.
	 * @param {Object<string, any> & { id: string }} context - id required
	 */
	setContext(context) {
		this._context = context;
		this._previousId = this._id;
		this._id = this._context.id;

		const event = new CustomEvent('cameraupdate', { detail: { target: this._id, context: this._context } });
		window.dispatchEvent(event);
	}

	/**
	 * Gets the current camera target id.
	 * @returns {string}
	 */
	getCurrentId() {
		return this._id;
	}

	/**
	 * Gets the shadow light color
	 * @returns {Pioneer.Color} Returns the shadow light color
	 */
	getShadowLightColor() {
		return this._shadowLightColor;
	}

	/**
	 * Gets the full light color
	 * @returns {Pioneer.Color} Returns the full light color
	 */
	getFullLightColor() {
		return this._fullLightColor;
	}

	/**
	 * Gets the default main scene.
	 * @returns {Pioneer.Scene}
	 */
	get defaultScene() {
		return this._defaultScene;
	}

	/**
	 * Gets the main camera entity.
	 * @returns {Pioneer.Entity}
	 */
	get cameraEntity() {
		return this._cameraEntity;
	}

	/**
	 * Gets default camera light
	 * @returns {Pioneer.LightSourceComponent}
	 */
	get cameraLight() {
		return this._cameraLight;
	}

	/**
	 * Gets dynamic environment map
	 * @returns {Pioneer.DynamicEnvironmentMapComponent}
	 */
	get dynamicEnvMap() {
		return this._dynEnvMap;
	}

	/**
	 * Toggles main camera light.
	 * @param {boolean} active
	 * @param {Pioneer.Color} color
	 */
	toggleCameraLight(active, color) {
		if (this._cameraLight !== null) {
			this._cameraLight.setEnabled(active);
			if (color !== undefined) {
				this._cameraLight.setColor(color);
			}
		}
	}

	/**
	 * Gets the selection callback on an object click after camera transition.
	 * @returns {Function}
	 */
	getSelectionCallback() {
		return this._selectionCallback;
	}

	/**
	 * Sets the selection callback to be called on an object click after camera transition.
	 * @param {selectionCallback} callback - Callback function with parameter entity clicked
	 */
	setSelectionCallback(callback) {
		if (typeof callback === 'function') {
			this._selectionCallback = callback;
		}
	}

	/**
	 * Enter free fly mode.
	 */
	enterFreeFly() {
		if (this._context && this._context.id && this._context.id != "") cameraFreeFlyParameters.context = this._context;
		else cameraFreeFlyParameters.context.id = "inner_solar_system";
		this._isFreeFly = true;
		this._cameraEntity.clearControllers();
		this._cameraEntity.addController('freeFly');
		this._cameraEntity.addController('look');
		this._cameraEntity.addController('roll');
	}

	// /**
	//  * Exit free fly mode.
	//  */
	// async exitFreeFly() {
	// 	this._isFreeFly = false;
	// 	switch (this._context.context) {
	// 		case CameraScripts.CONTEXT.CELESTIAL_OBJECT:
	// 			await this.app.cameraScripts.goToCelestialObject(this._id);
	// 			break;
	// 		case CameraScripts.CONTEXT.SPACECRAFT:
	// 			await this.app.cameraScripts.goToSpacecraft(this._id);
	// 			break;
	// 		case CameraScripts.CONTEXT.INSTRUMENT:
	// 			await this.app.cameraScripts.goToInstrument(this._id);
	// 			break;
	// 		case CameraScripts.CONTEXT.ALIGN_SPACECRAFT:
	// 			await this.app.cameraScripts.alignSpacecraftPlanet(this._id);
	// 			break;
	// 		case CameraScripts.CONTEXT.LOCATION:
	// 			await this.app.cameraScripts.showLocation(this._id, '', '', this._context['options']);
	// 			break;
	// 		case CameraScripts.CONTEXT.SYSTEM:
	// 			await this.app.cameraScripts.goToSystem(this._id);
	// 			break;
	// 		case CameraScripts.CONTEXT.LOOK_AT:
	// 			await this.app.cameraScripts.spacecraftLookAtTarget(this._id, this._context['target']);
	// 			break;
	// 		case CameraScripts.CONTEXT.LOCKED_ON:
	// 			await this.app.cameraScripts.spacecraftLockedOnTarget(this._id, this._context['target']);
	// 			break;
	// 		default:
	// 			console.error('exitFreeFly: Unsupported camera context - ' + this._context.context);
	// 			break;
	// 	}
	// }

	exitFreeFly() {
		this._isFreeFly = false;
		this._cameraEntity.clearControllers();
		flyTo(cameraFreeFlyParameters.context.id);
	}

	/**
	 * Toggle free fly mode.
	 */
	toggleFreeFly() {
		if (this._isFreeFly) {
			this.exitFreeFly();
		}
		else {
			this.enterFreeFly();
		}
	}

	/**
	 * Internal go to entity function.
	 * Must be called by all other camera transitions.
	 * @param {string} id
	 * @param {object} options
	 * @param {Pioneer.Entity} [options.camera = undefined] - Camera entity to use
	 * @param {Pioneer.Scene} [options.scene = undefined] - Scene to use
	 * @param {Pioneer.Vector3} [options.destination = undefined] - Custom position vector for the camera
	 * @param {number} [options.distance = undefined] - Specify distance from target
	 * @param {boolean} [options.cinematic = false] - Activate cinematic component
	 * @param {number} [options.minRadius = undefined] - Specify minimum distance from target
	 * @param {number} [options.maxRadius = undefined] - Specify maximum distance from target
	 * @param {number} [options.duration = undefined] - Duration of the transition
	 * @param {Pioneer.Vector3} [options.destinationUp = undefined] - Custom up vector
	 * @param {boolean} [options.zoom = true] - Activate zoom component
	 * @param {boolean} [options.select = true] - Activate selection component
	 * @param {boolean} [options.slowWhenCloseToParent = true] - Activate selection component
	 * @param {boolean} [options.useSpheroidRadiusForDistance = false] - Activate selection component
	 * @param {boolean} [options.roll = false] - Activate selection component
	 * @param {OrbitKeyframeOptions} [options.keyframes = undefined] - Custom orbit key frames
	 * @param {TransitionFunction} [options.transitionFunction = undefined]
	 */
	async goToEntity(id, {
		camera = undefined, scene = undefined, destination = undefined, distance = undefined, cinematic = false, minRadius = 0.001, maxRadius = this._defaultMaxDistance, duration = 0.75, destinationUp = undefined, zoom = true, select = true,
		slowWhenCloseToParent = true, useSpheroidRadiusForDistance = false, roll = false, keyframes = undefined, transitionFunction = undefined
	} = {}) {
		// Pre transition checks
		const cameraEntity = camera || this._cameraEntity;
		const currentScene = scene || this._defaultScene;

		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(currentScene, [id]);

		this._isTransitioning = true;
		if (destination !== undefined) {
			const checkDist = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			checkDist.sub(cameraEntity.getPosition(), destination);

			const cameraParent = cameraEntity.getParent();
			if (cameraParent !== null) {
				const cameraParentName = cameraParent.getName();

				// Adjust duration
				if (!isNaN(checkDist.magnitude())) {
					// Use the distance to reach the new destination compared to the distance to target ratio
					const factor = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(checkDist.magnitude() / cameraEntity.getPosition().magnitude());
					// Do not use less than the original duration divided by 5
					duration = Math.max(duration / 5, duration * factor);
				}

				// If already at destination dont launch transition
				if (!isNaN(checkDist.magnitude()) && checkDist.magnitude() <= 0.001 && id === cameraParentName) {
					this._isTransitioning = false;
					return;
				}
			}
		}

		try {
			// Run through keyframes
			if (keyframes !== undefined) {
				// Setup the orbit keyframe controller
				cameraEntity.clearControllers();
				const orbitKeyframe = /** @type {Pioneer.OrbitKeyframeController} */(cameraEntity.addController('orbitKeyframe'));
				if (keyframes.position) {
					for (let i = 0; i < keyframes.position.length; i++) {
						const frameData = keyframes.position[i];
						orbitKeyframe.setPositionKeyframe(frameData.frame, frameData.position, frameData.relativeTo);
					}
				}
				if (keyframes.up) {
					for (let i = 0; i < keyframes.up.length; i++) {
						const frameData = keyframes.up[i];
						orbitKeyframe.setUpKeyframe(frameData.frame, frameData.up);
					}
				}
				if (keyframes.focus) {
					for (let i = 0; i < keyframes.focus.length; i++) {
						const frameData = keyframes.focus[i];
						orbitKeyframe.setFocusKeyframe(frameData.frame, frameData.name);
					}
				}
				await orbitKeyframe.getEndPromise();
				cameraEntity.clearControllers();
			}

			// Go to entity
			await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.goToEntity(cameraEntity, currentScene.getEntity(id), {
				destination,
				distance,
				up: false,
				duration,
				destinationUp,
				zoom,
				transitionFunction
			});

			// Add a select controller for selection
			if (select) {
				const selectController = /** @type {Pioneer.SelectController} */(cameraEntity.addController('select'));
				// Set callback on 3D object click
				if (this._selectionCallback !== null) {
					selectController.setCallback(this._selectionCallback);
				}
			}

			const orbit = cameraEntity.get('orbit');
			if (orbit instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitController) {
				orbit.slowWhenCloseToParent(slowWhenCloseToParent);
			}

			const zoomController = cameraEntity.get('zoom');
			// Zoom clamping
			if (zoomController) {
				if (zoomController instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.ZoomController) {
					zoomController.setDistanceClamp(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(minRadius, maxRadius));
					zoomController.setUseSpheroidRadiusForDistance(useSpheroidRadiusForDistance);
				}
			}

			if (roll) {
				const rollController = cameraEntity.get('roll');
				if (!(rollController instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.RollController)) {
					cameraEntity.addController('roll');
				}
			}

			// Cinematic controller
			if (cinematic) {
				const align = cameraEntity.getControllerByType('align');
				const spin = cameraEntity.addController('spin', undefined, align);
				if (spin instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.SpinController) {
					spin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, true);
					spin.setRate(0.01);
					spin.setUsingRealTime(true);
					spin.setRotatingPosition(true);
				}
				const tap = cameraEntity.addController('tap');
				if (tap instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.TapController) {
					tap.setTapCallback(() => {
						cameraEntity.removeController(spin);
						cameraEntity.removeController(tap);
					});
				}
			}
		}
		catch (err) {
			if (err) {
				console.error(err);
			}
		}
		finally {
			this._isTransitioning = false;
		}
	}

	/**
	 * Make camera follow the followId entity.
	 * Assumes entities are in place.
	 * @param {string} targetId
	 * @param {string} followId
	 * @param {string} sumParentId
	 * @param {number} duration
	 */
	async followTheEntity(targetId, followId, sumParentId, duration) {
		const targetEntity = this._defaultScene.getEntity(targetId);
		const followEntity = this._defaultScene.getEntity(followId);


		// Clear controllers.
		this.cameraEntity.clearControllers();

		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		// Get norm vector from followEntity to target
		targetEntity.getPositionRelativeToEntity(dest, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, followEntity);

		/**
		 * Calculate the up distance - it needs to be high enough to view the followed entity.
		 * The tan of the angle is the extents radius divided by the distance.
		 * The larger the extents radius, the further up the camera needs to be to see the followed entity.
		 */
		const camHeight = targetEntity.getExtentsRadius() * 1.25;
		const distanceBetween = dest.magnitude();
		const angleRadians = Math.atan(camHeight / distanceBetween);

		const closestCamDistance = targetEntity.getExtentsRadius() * 5;
		const camDistFromFollowed = distanceBetween + closestCamDistance;
		const upDistance = Math.tan(angleRadians) * camDistFromFollowed;


		dest.normalize(dest);


		const scUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);

		const scParent = targetEntity.getParent();
		if (scParent) {
			scParent.getOrientation().getAxis(scUp, 2);
			if (scParent.getName() === followId) {
				const objectOrbitOri = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
				const dynController = /** @type {Pioneer.DynamoController} */(this.pioneer.get('main', followId, 'dynamo'));

				// If we have dynamo for the parent take the orbit orientation for the up vector.
				if (dynController) {
					dynController.getOrbitOrientation(objectOrbitOri, this.pioneer.getTime());
					objectOrbitOri.getAxis(scUp, 2);
				}

				// Reset up vector if it's NaN
				scUp.isNaN() && scUp.copy(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1));
			}
			else {
				// Get parent up
				scParent.getOrientation().getAxis(scUp, 2);
			}
		}
		scUp.normalize(scUp);

		// If destination vector is too close to zero
		if (dest.magnitude() < 0.0001) {
			targetEntity.getOrientation().getAxis(dest, 0);
			dest.normalize(dest);
		}


		/**
		 * The up distance is related to the target entity's extents radius.
		 * The larger the extents radius, the further up the camera needs to be to see the followed entity.
		 */

		// Mult up by upDistance.
		scUp.mult(scUp, upDistance);

		dest.mult(dest, closestCamDistance);

		// Add up distance to dest.
		dest.add(dest, scUp);

		scUp.normalize(scUp);

		const fixedController = this.cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.FixedController);
		fixedController.setPosition(dest);

		// Set the destination orientation for the end of the transition.
		const destinationForward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const destUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		destinationForward.neg(dest);
		destinationForward.normalize(destinationForward);
		destUp.setNormalTo(destinationForward, scUp);
		const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		orientation.setFromAxes(undefined, destinationForward, destUp);
		fixedController.setOrientation(orientation);


		pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.focusOnEntity(this.cameraEntity, followEntity, { up: false });


		// Add and setup the transition controller.
		const transitionController = this.cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.TransitionController);
		transitionController.setTransitionTime(duration);
		transitionController.setParent(sumParentId);

		const { _easeOutExpoTransition: transitionFunction } = this.app.cameraScripts;
		if (transitionFunction) {
			transitionController.setTransitionFunction(transitionFunction);
		}
		await transitionController.getEndPromise();

		// Clear controllers.
		this.cameraEntity.clearControllers();

		// Add orbit controller.
		const orbitController = this.cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitController);
		orbitController.setDragSensitivity(0.0005);

		// // Add fixedToParent, roll, and zoom controllers.
		this.cameraEntity.addController('fixedToParent');
		this.cameraEntity.addController('roll');

		// Determine zoom limits
		const zoomCoeff = 10;
		const zoomMin = targetEntity.getExtentsRadius();
		const zoomMax = Math.max(targetEntity.getExtentsRadius() * zoomCoeff, followEntity.getExtentsRadius() * zoomCoeff, zoomMin * zoomCoeff);
		const zoomInterval = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(zoomMin, zoomMax);

		// Add zoom controller and set distance clamps.
		const zoomController = this.cameraEntity.addController('zoom');
		zoomController.setDistanceClamp(zoomInterval);

		// Add select controller.
		const selectController = /** @type {Pioneer.SelectController} */(this.cameraEntity.addController('select'));
		// Set callback on 3D object click
		if (this._selectionCallback !== null) {
			selectController.setCallback(this._selectionCallback);
		}

		pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.focusOnEntity(this.cameraEntity, followEntity, { up: false });
	}

	/**
	 * Currently just for the distance tool.
	 * Transitions the camera to a position where we're focused on between entity,
	 * and zoom out far enough to see the source and target.
	 * @param {Pioneer.Entity} betweenEntity - the entity that the camera will focus on
	 * @param {object} options - the options used to setup the camera
	 * @param {number} [options.duration] - seconds to do the transition
	 * @param {Pioneer.Vector3} [options.destination] - the location relative to the focus entity to transition to; if undefined it goes to the nearest spot from the camera's current position; this overrides distance
	 * @param {Pioneer.Vector3} [options.destinationUp] - where the camera up vector ends up
	 * @param {TransitionFunction} [options.transitionFunction] - a manual transition function to use
	 * @param {Pioneer.Interval} [options.zoomInterval] - a min and max zoom
	 * @returns {Promise<void>}
	 */
	async goToBetweenPos(betweenEntity, { duration, destination, destinationUp, transitionFunction, zoomInterval }) {
		const cameraEntity = this._cameraEntity;

		// Set the destination position for the end of the transition.
		cameraEntity.clearControllers();
		const fixedController = /** @type {Pioneer.FixedController} */(cameraEntity.addController('fixed'));
		fixedController.setPosition(destination);

		// Make sure orientation is so source entity is on top to match the UI panel.
		const destinationForward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const destUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		destinationForward.neg(destination);
		destinationForward.normalize(destinationForward);
		destUp.setNormalTo(destinationForward, destinationUp);
		const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		orientation.setFromAxes(undefined, destinationForward, destUp);
		fixedController.setOrientation(orientation);

		pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.focusOnEntity(cameraEntity, betweenEntity, { up: false, orbiter: false });

		// Setup the transition.
		const transitionController = /** @type {Pioneer.TransitionController} */(cameraEntity.addController('transition'));
		transitionController.setTransitionTime(duration);
		transitionController.setParent(betweenEntity.getName());
		if (transitionFunction) {
			transitionController.setTransitionFunction(transitionFunction);
		}
		await transitionController.getEndPromise();

		cameraEntity.clearControllers();

		// Add select controller.
		const selectController = /** @type {Pioneer.SelectController} */(cameraEntity.addController('select'));
		// Set callback on 3D object click
		if (this._selectionCallback !== null) {
			selectController.setCallback(this._selectionCallback);
		}

		// Add orbit controller.
		cameraEntity.addController('orbit');

		// Add roll controller.
		cameraEntity.addController('roll');

		// Add zoom controller and set distance clamps.
		const zoomController = /** @type {Pioneer.ZoomController} */(cameraEntity.addController('zoom'));
		zoomInterval && zoomController.setDistanceClamp(zoomInterval);

		pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.focusOnEntity(cameraEntity, betweenEntity, { up: false, orbiter: false });
	}

	/**
	 * Zoom camera according to some amount.
	 * @param {number} zoomChange
	 * @param {Pioneer.Entity} cameraEntity
	 */
	zoom(zoomChange, cameraEntity = this._cameraEntity) {
		let currentDistance = cameraEntity.getPosition().magnitude();
		if (Number.isNaN(currentDistance)) {
			currentDistance = 1.0;
		}

		// Update the current distance.
		currentDistance *= zoomChange;

		// Set the position from the current distance.
		const currentPosition = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		currentPosition.normalize(cameraEntity.getPosition());
		currentPosition.mult(currentPosition, currentDistance);
		cameraEntity.setPosition(currentPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(currentPosition);
	}

	/**
	 * Zoom camera in 1 step.
	 * @param {boolean} [isContinuous=false] - Zoom continuously
	 */
	zoomIn(isContinuous = false) {
		let zoomChange = 1.0;
		const zoomSensitivity = isContinuous ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
		zoomChange /= Math.pow(2, zoomSensitivity);
		this.zoom(zoomChange);
	}

	/**
	 * Zoom camera out 1 step.
	 * @param {boolean} [isContinuous=false] - Zoom continuously
	 */
	zoomOut(isContinuous = false) {
		let zoomChange = 1.0;
		const zoomSensitivity = isContinuous ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
		zoomChange *= Math.pow(2, zoomSensitivity);
		this.zoom(zoomChange);
	}

	/**
	 * Gets default max distance.
	 * @returns {number}
	 */
	get defaultMaxDistance() {
		return this._defaultMaxDistance;
	}

	/**
	 * Set default max distance.
	 * @param {number} distance
	 */
	set defaultMaxDistance(distance) {
		this._defaultMaxDistance = distance;
	}

	/**
	 * Adds the dynamic environment map to the entity model.
	 * @param {Pioneer.Entity} entity
	 */
	addDynamicEnvMap(entity) {
		if (!this.dynamicEnvMap) {
			return;
		}
		// Activate dynamic env map on models
		const model = /** @type {Pioneer.ModelComponent} */(entity.get('model'));
		if (model !== null) {
			model.setDynamicEnvironmentMapComponent(this.dynamicEnvMap);
		}
	}
}


/***/ }),

/***/ "../eyes/src/managers/camera_scripts.js":
/*!**********************************************!*\
  !*** ../eyes/src/managers/camera_scripts.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraScripts": function() { return /* binding */ CameraScripts; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");





/**
 * Camera helper scripts class.
 * @extends BaseManager
 */
class CameraScripts extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * @type {CameraManager}
		 * @private
		 */
		this._cameraManager = null;

		/**
		 * Stores custom system distances.
		 * @type {object}
		 */
		this._customSystemDistances = {
			mercury: 425648,
			venus: 862136,
			earth: 1040264,
			mars: 80000,
			jupiter: 7157638,
			saturn: 4869142,
			uranus: 1886367,
			neptune: 2407045,
			'134340_pluto': 122231,
			'136199_eris': 180309,
			'1_ceres': 87225,
			'136108_haumea': 126609,
			'136472_makemake': 118584
		};

		/**
		 * Function that is called during a camera move that is using a custom transition function
		 */
		this._onCameraTransition = null;

		this._easeInOutExpoTransition = this._easeInOutExpoTransition.bind(this);
		this._easeOutExpoTransition = this._easeOutExpoTransition.bind(this);
	}

	/**
	 * Setup the camera scripts with a camera manager.
	 * @param {CameraManager} cameraManager
	 */
	setCameraManager(cameraManager) {
		this._cameraManager = cameraManager;
	}

	/**
	 * Gets Pioneer scene.
	 * @returns {Pioneer.Scene}
	 */
	get scene() {
		return this._scene;
	}

	/**
	 * Sets Pioneer scene.
	 * @param {Pioneer.Scene} scene
	 */
	set scene(scene) {
		this._scene = scene;
	}

	/**
	 * Gets the main camera entity.
	 * @returns {Pioneer.Entity}
	 */
	get cameraEntity() {
		return this._cameraEntity;
	}

	/**
	 * Sets the main camera entity.
	 * @param {Pioneer.Entity} cameraEntity
	 */
	set cameraEntity(cameraEntity) {
		this._cameraEntity = cameraEntity;
	}

	/**
	 * Get normal to ecliptic plane.
	 * @param {Pioneer.Vector3} outNormal - The normal vector that will be modified
	 * @param {string} id - Target entity id
	 */
	getNormalToEcliptic(outNormal, id) {
		const objectOrbitOri = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		/** @type {Pioneer.DynamoController} */(this._cameraManager.pioneer.get('main', id, 'dynamo')).getOrbitOrientation(objectOrbitOri, this._cameraManager.pioneer.getTime());
		objectOrbitOri.getAxis(outNormal, 2);
	}

	/**
	 * Returns true if the entity id has barycenter.
	 * @param {string} id - The entity id.
	 * @returns {boolean}
	 */
	isBarycenter(id) {
		if (id.includes('_barycenter')) {
			return true;
		}
		return false;
	}

	/**
	 * Returns a string stripped of the barycenter keyword.
	 * @param {string} id - The entity id.
	 * @returns {string}
	 */
	removeBarycenter(id) {
		if (this.isBarycenter(id)) {
			return id.replace('_barycenter', '');
		}
		return id;
	}

	/**
	 * Go to a planet, sunny side and rotates around it
	 * @param {string} id - Target entity id
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined] - Custom scene, default to main
	 * @param {string} [options.starId = 'sun'] - A star id to include in the view
	 * @param {boolean} [options.cinematic = true] - Cinematic mode
	 * @param {number} [options.duration = 1.5] - Duration of transition
	 * @param {number} [options.distance = 1.3] - Distance of the camera
	 */
	async goToCelestialObject(id, { scene = undefined, starId = 'sun', cinematic = true, duration = 1.5, distance = 1.3 } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.CELESTIAL_OBJECT });

		if (scene === undefined) {
			scene = this._scene;
		}

		const planet = scene.getEntity(id);
		const star = scene.getEntity(starId);

		let dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		planet.getPositionRelativeToEntity(dest, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, star);

		if (dest.magnitude() === 0) { // If the magnitude is zero due to object-is-root or objects-overlap
			dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0); // set the vector to be along the Y-Axis and allow rest of logic to continue calculation
		}

		// Get planet up
		const planetUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		planet.getOrientation().getAxis(planetUp, 2);

		// Calculate destination
		dest.neg(dest);
		dest.normalize(dest);
		let radius = planet.getOcclusionRadius();
		const spheroid = planet.getComponentByType('spheroid');
		if (spheroid !== null) {
			radius = /** @type {Pioneer.SpheroidComponent} */(planet.getComponentByType('spheroid')).getEquatorialRadius();
		}
		const minRadius = 1.2 * radius;

		// Determine distance
		const cameraOrientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		cameraOrientation.setFromAxes(undefined, dest, planetUp);
		let dist = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.getDistanceToFitEntities(this._cameraEntity, cameraOrientation, planet, [planet]);

		dist *= distance;
		dest.mult(dest, dist);


		// Go to planet straight and then align camera with sun
		await this._cameraManager.goToEntity(id, { distance: dist, duration: duration / 2 });
		await this._cameraManager.goToEntity(id, { destination: dest, cinematic, minRadius, destinationUp: planetUp, duration: duration / 2 });
	}

	/**
	 * Ease-out cam transition function
	 * @param {Pioneer.Entity} entity
	 * @param {Pioneer.Vector3} initialPosition
	 * @param {Pioneer.Vector3} finalPosition
	 * @param {Pioneer.Quaternion} initialOrientation
	 * @param {Pioneer.Quaternion} finalOrientation
	 * @param {number} u
	 */
	_easeOutExpoTransition(entity, initialPosition, finalPosition, initialOrientation, finalOrientation, u) {
		const position = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const orientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();

		// Apply exponent ease-out function. // https://github.com/d3/d3-ease/tree/main/src
		const e = 4;
		const easedT = 1 - Math.pow(1 - u, e);

		position.lerp(initialPosition, finalPosition, easedT);
		orientation.slerp(initialOrientation, finalOrientation, easedT);

		// Call _onCameraTransition if exists.
		this._onCameraTransition?.(easedT);

		// Set the new position and orientation.
		entity.setPosition(position);
		entity.setOrientation(orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
	}

	/**
	 * Ease in-out expo cam transition function - TODO: need a cleaner way to apply transition with just basic function code
	 * @param {Pioneer.Entity} entity
	 * @param {Pioneer.Vector3} initialPosition
	 * @param {Pioneer.Vector3} finalPosition
	 * @param {Pioneer.Quaternion} initialOrientation
	 * @param {Pioneer.Quaternion} finalOrientation
	 * @param {number} u
	 */
	_easeInOutExpoTransition(entity, initialPosition, finalPosition, initialOrientation, finalOrientation, u) {
		const position = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const orientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();

		// Apply ease-in-out function. // https://github.com/d3/d3-ease/tree/main/src
		const e = 4;
		const easedT = ((u *= 2) <= 1 ? Math.pow(u, e) : 2 - Math.pow(2 - u, e)) / 2;

		position.lerp(initialPosition, finalPosition, easedT);
		orientation.slerp(initialOrientation, finalOrientation, easedT);

		// Call _onCameraTransition if exists.
		this._onCameraTransition?.(easedT);

		// Set the new position and orientation.
		entity.setPosition(position);
		entity.setOrientation(orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
	}

	/**
	 * Go to spacecraft, with planet in background.
	 * Or from Sun point of view if Sun is parent.
	 * @param {string} id - Target entity id
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined] - Custom scene, default to main
	 * @param {string} [options.starId = 'sun'] - A star id to include in the view
	 * @param {string} [options.planeId = 'earth'] - A planet id used to calculate normal to ecliptic
	 * @param {number} [options.distance = undefined] - Distance of the camera
	 * @param {boolean} [options.cinematic = true] - Cinematic mode
	 * @param {number} [options.duration = 1.5] - Duration of transition
	 * @param {number} [options.verticalOffset=0] - Offset camera up/down along horizontal axis
	 * @param {number} [options.horizontalOffset=0] - Offset camera left/right along vertical axis
	 */
	async goToSpacecraft(id, { scene = undefined, starId = 'sun', planeId = 'earth', distance = undefined, cinematic = true, duration = 1.5, verticalOffset = 0, horizontalOffset = 0 } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.SPACECRAFT });

		// Get default scene
		if (scene === undefined) {
			scene = this._scene;
		}

		// Get camera distance
		const entityInfo = this._app.getManager('content').getEntityInfo(id);
		const camDistance = entityInfo?.customDistance || distance;

		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(scene, [id]);

		const sc = scene.getEntity(id);
		const scRadius = sc.getOcclusionRadius();
		const minRadius = 1.2 * scRadius;
		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		dest.normalize(sc.getPosition());
		const scUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		// Todo: scParent is sometimes null. Why?
		const scParent = sc.getParent();
		// If spacecraft parent is star
		// look at spacecraft from star perspective
		if (scParent) {
			if (scParent.getName() === starId && scene.get(planeId) !== null) {
				this.getNormalToEcliptic(scUp, planeId);
				if (scUp.isNaN()) {
					scUp.copy(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1));
				}
			}
			else {
				// Get parent up
				scParent.getOrientation().getAxis(scUp, 2);
			}
		}
		scUp.normalize(scUp);

		// If destination vector is too close to zero
		if (dest.magnitude() < 0.0001) {
			sc.getOrientation().getAxis(dest, 0);
			dest.normalize(dest);
		}

		// Cross between dest and planet up
		const horizontal = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		horizontal.cross(dest, scUp);
		horizontal.normalize(horizontal);

		// Rotate fwd
		const rotation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		rotation.setFromAxisAngle(horizontal, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(verticalOffset));
		dest.rotate(rotation, dest);

		// Rotate up
		rotation.setFromAxisAngle(scUp, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(horizontalOffset));
		dest.rotate(rotation, dest);

		// Calculate distance
		let dist = 0.0;
		if (camDistance !== undefined) {
			dist = camDistance;
		}
		else {
			const cameraOrientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			cameraOrientation.setFromAxes(undefined, dest, scUp);
			const distToFit = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.getDistanceToFitEntities(this._cameraEntity, cameraOrientation, sc, [sc]);
			dist = distToFit * 1.3;
		}

		dest.mult(dest, dist);

		// Go to spacecraft and then align with parent or sun
		await this._cameraManager.goToEntity(id, { distance: dist });
		await this._cameraManager.goToEntity(id, { destination: dest, cinematic, minRadius, destinationUp: scUp, duration });
	}

	/**
	 * Go to spacecraft, with planet in background.
	 * Or from Sun point of view if Sun is parent.
	 * @param {string} id - Target entity id
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined] - Custom scene, default to main
	 * @param {number} [options.distance = undefined] - Distance of the camera
	 * @param {number} [options.duration = 1.5] - Duration of transition
	 * @param {string} [options.upVector = 'y-axis'] - Which axis of spacecraft to set up vector
	 * @param {string} [options.forwardVector = 'x-axis'] - Which axis of spacecraft to set forward vector
	 */
	async goToInstrument(id, { scene = undefined, distance = undefined, duration = 1.5, upVector = 'z-axis', forwardVector = 'y-axis' } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.INSTRUMENT });

		if (scene === undefined) {
			scene = this._scene;
		}

		// Get camera distance
		const entityInfo = this._app.getManager('content').getEntityInfo(id);
		const camDistance = entityInfo?.customDistance || distance;

		const instrument = scene.getEntity(id);
		const spacecraft = instrument.getParent();
		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(scene, [spacecraft.getName(), id]);

		const iRadius = instrument.getOcclusionRadius();
		const sRadius = spacecraft.getOcclusionRadius();

		const minRadius = 1.2 * iRadius;
		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		instrument.getPositionRelativeToEntity(dest, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, spacecraft);

		// Get parent forward
		const forward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const forwardVectorIndex = forwardVector.endsWith('y-axis')
			? 1
			: forwardVector.endsWith('z-axis')
				? 2
				: 0;
		spacecraft.getOrientation().getAxis(forward, forwardVectorIndex);
		if (forwardVector.startsWith('-')) {
			forward.mult(forward, -1);
		}
		dest.mult(forward, -1);

		// Get parent up
		const scUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		let upVectorIndex = forwardVector.endsWith('y-axis') ? 2 : 1;
		if (upVector.endsWith('x-axis')) {
			upVectorIndex = 0;
		}
		else if (upVector.endsWith('z-axis')) {
			upVectorIndex = 2;
		}
		spacecraft.getOrientation().getAxis(scUp, upVectorIndex);
		if (upVector.startsWith('-')) {
			scUp.mult(scUp, -1);
		}

		// Calculate distance
		let dist = minRadius * 4.0;
		if (camDistance !== undefined) {
			dist = camDistance;
		}
		dest.mult(dest, dist);

		// Go to spacecraft and then align
		await this._cameraManager.goToEntity(spacecraft.getName(), { destinationUp: scUp, distance: sRadius * 1.2 });
		await this._cameraManager.goToEntity(id, { destination: dest, minRadius, destinationUp: scUp, duration });
	}

	/**
	 * Compare two objects.
	 * @param {string} left - Left object id
	 * @param {string} right - Right object id
	 * @param {object} options
	 * @param {Pioneer.Entity} [options.cameraLeft = undefined]
	 * @param {Pioneer.Entity} [options.cameraRight = undefined]
	 * @param {Pioneer.Vector3} [options.cameraLeftPosition = undefined]
	 * @param {Pioneer.Vector3} [options.cameraRightPosition = undefined]
	 * @param {Pioneer.Vector3} [options.cameraUp = undefined]
	 * @param {Pioneer.Scene} [options.scene = undefined]
	 * @param {number} [options.minRadius = undefined]
	 * @param {number} [options.maxRadius = undefined]
	 * @param {number} [options.duration = 0.75]
	 */
	async compareObjects(left, right, { cameraLeft = undefined, cameraRight = undefined, cameraLeftPosition = undefined, cameraRightPosition = undefined, cameraUp = undefined, scene = undefined, minRadius = undefined, maxRadius = undefined, duration = 0.75 }) {
		// Always update context first
		this._cameraManager.setContext({ id: left, context: CameraScripts.CONTEXT.COMPARE, to: right });

		const event = new CustomEvent('cameracompare', { detail: { left, right } });
		window.dispatchEvent(event);

		const leftTransition = this._cameraManager.goToEntity(
			left,
			{
				minRadius,
				maxRadius,
				camera: cameraLeft,
				destination: cameraLeftPosition,
				destinationUp: cameraUp,
				scene,
				select: false,
				duration,
				zoom: true,
				cinematic: true
			}
		);

		const rightTransition = this._cameraManager.goToEntity(
			right,
			{
				minRadius,
				maxRadius,
				camera: cameraRight,
				destination: cameraRightPosition,
				destinationUp: cameraUp,
				scene,
				select: false,
				duration,
				zoom: true,
				cinematic: true
			}
		);

		await Promise.all([leftTransition, rightTransition]);
	}

	/**
	 * Show where object is located in the system.
	 * @param {string} targetEntityName - Target entity id
	 * @param {string} forwardEntityName - A parent id used to calculate normal to ecliptic or north pole
	 * @param {string} upOrRightEntityName - An entity used to orient the up or right of the camera (depending on aspect ratio).
	 * @param {string} [mode='northPole'] - Whether to have the forward be based on the north pole or the orbital plane normal of the forwardEntity ('northPole' or 'planeNormal').
	 * @param {object} options
	 * @param {number} [options.duration=1.5] - How long to do the transition
	 * @param {string[]} [options.otherEntityNames=[]] - Other entities to include in the view.
	 * @param {number} [options.distance=undefined] - Distance of the camera
	 * @param {boolean} [options.rotateByScreenRatio=true] - Rotate up vector -90 degree if the view is wider than it is tall
	 * @returns {Promise<void>}
	 */
	async showLocation(targetEntityName, forwardEntityName, upOrRightEntityName, mode = 'northPole', { duration = 2, otherEntityNames = [], distance = undefined, rotateByScreenRatio = true } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id: '', targetEntityName, context: CameraScripts.CONTEXT.LOCATION, options: { otherEntityNames } });

		// Get the various entities.
		const targetEntity = this._scene.getEntity(targetEntityName);
		const forwardEntity = this._scene.getEntity(forwardEntityName);
		const upOrRightEntity = this._scene.getEntity(upOrRightEntityName);
		if (targetEntity === null || forwardEntity === null || upOrRightEntity === null) {
			return;
		}

		// Push all of the involved entities into a giant list. It'll be used for fitting them all into view.
		const entities = [];
		entities.push(targetEntity);
		entities.push(forwardEntity);
		entities.push(upOrRightEntity);
		for (let i = 0, l = otherEntityNames.length; i < l; i++) {
			const otherEntity = this._scene.getEntity(otherEntityNames[i]);
			if (otherEntity !== null) {
				entities.push(otherEntity);
			}
		}

		// Get the final position direction.
		const position = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		if (mode === 'northPole') {
			forwardEntity.getOrientation().getAxis(position, 2);
		}
		else if (mode === 'planeNormal') {
			position.cross(forwardEntity.getPosition(), forwardEntity.getVelocity());
			position.normalize(position);
		}

		// Get the forward vector.
		const forward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		forward.neg(position);

		// Get the up vector.
		const up = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		targetEntity.getPositionRelativeToEntity(up, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, upOrRightEntity);
		up.normalize(up);
		up.setNormalTo(forward, up);
		up.neg(up);

		// If the view is wider than it is tall, rotate the up by -90 degrees.
		const cameraComponent = /** @type {Pioneer.CameraComponent} */(this._cameraEntity.getComponentByType('camera'));
		if (rotateByScreenRatio && cameraComponent.getHorizontalFieldOfView() > cameraComponent.getVerticalFieldOfView()) {
			up.cross(up, forward);
		}

		// Set the orientation based on the forward and up vectors.
		const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		orientation.setFromAxes(undefined, forward, up);

		// Using the orientation and entity list, set the position to a good distance to see all of the entities.
		let dist = distance || pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.getDistanceToFitEntities(this._cameraEntity, orientation, targetEntity, entities);
		// If the view is taller than it is wide, increase distance.
		if (cameraComponent.getHorizontalFieldOfView() < cameraComponent.getVerticalFieldOfView()) {
			dist *= cameraComponent.getVerticalFieldOfView() * 1.3;
		}
		dist *= 2;
		position.setMagnitude(position, dist);

		// If camera's parent is null, fly to target first.
		if (this._cameraEntity.getParent() === null) {
			await this._cameraManager.goToEntity(targetEntityName, { distance: dist });
		}

		// Setup keyframes
		const keyframes = /** @type {import('./managers/camera_manager').OrbitKeyframeOptions} */({
			up: [{ frame: duration, up }],
			position: [{ frame: duration, position, relativeTo: targetEntity.getName() }],
			focus: [{ frame: duration, name: targetEntityName }]
		});

		await this._cameraManager.goToEntity(targetEntityName, { keyframes, destination: position, destinationUp: up, cinematic: false, duration: 0.2 });
	}

	/**
	 * Align an object with another.
	 * @param {string} targetEntityName - Camera's target
	 * @param {string} focusEntityName - Entity to align with
	 * @param {object} [options={}]
	 * @param {number} [options.duration=1.5] - Duration for both transition and alignment
	 * @param {number} [options.transitionDuration=undefined] - Duration of transition
	 * @param {number} [options.alignDuration=undefined] - Duration of alignment
	 * @param {number} [options.distance=1] - Distance from default position
	 * @param {boolean} [options.cinematic=false]
	 * @param {number} [options.verticalOffset=0] - Offset camera up/down along horizontal axis
	 * @param {number} [options.horizontalOffset=0] - Offset camera left/right along vertical axis
	 * @param {boolean} [options.useEase=false] - Use ease in transitions
	 */
	async alignObjects(targetEntityName, focusEntityName, { verticalOffset = 0, horizontalOffset = 0, duration = 1.5, transitionDuration = undefined, alignDuration = undefined, distance = 1, cinematic = false, useEase = true } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id: '', targetEntityName, context: CameraScripts.CONTEXT.ALIGN_OBJECTS, focus: focusEntityName });

		const targetEntity = this._scene.getEntity(targetEntityName);
		const focusEntity = this._scene.getEntity(focusEntityName);
		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(this._scene, [targetEntityName, focusEntityName]);

		const minRadius = targetEntity.getOcclusionRadius();

		// Get destination vector
		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const time = this._cameraManager.pioneer.getTime();
		targetEntity.getPositionRelativeToEntity(dest, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, focusEntity, time);
		if (dest.isNaN()) {
			dest.copy(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0));
		}
		else {
			dest.normalize(dest);
		}

		dest.mult(dest, distance);

		// Get up vector
		const up = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		focusEntity.getOrientation().getAxis(up, 2);

		// Cross between dest and planet up
		const horizontal = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		horizontal.cross(dest, up);
		horizontal.normalize(horizontal);

		// Rotate fwd
		const rotation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		rotation.setFromAxisAngle(horizontal, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(verticalOffset));
		dest.rotate(rotation, dest);

		// Rotate up
		rotation.setFromAxisAngle(up, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(horizontalOffset));
		dest.rotate(rotation, dest);

		// Go to focus entity first and then align target entity with it
		await this._cameraManager.goToEntity(targetEntityName, { distance, destinationUp: up, duration: transitionDuration || duration * 0.5, transitionFunction: useEase ? this._easeOutExpoTransition : undefined });
		await this._cameraManager.goToEntity(targetEntityName, { destination: dest, cinematic, minRadius, destinationUp: up, duration: alignDuration || duration * 0.5, transitionFunction: useEase ? this._easeOutExpoTransition : undefined });
	}

	/**
	 * Align spacecraft and planet.
	 * @param {string} id - Target entity id
	 * @param {object} options
	 * @param {number} [options.duration = 1.5] - Duration of transition
	 * @param {number} [options.minRadius = 50]
	 * @param {number} [options.distanceMultiplier = 3] - Multiply the parent's radius as distance
	 */
	async alignSpacecraftPlanet(id, { duration = 1.5, minRadius = 50, distanceMultiplier = 3 } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.ALIGN_SPACECRAFT });

		const sc = this._scene.getEntity(id);
		let planet = sc.getParent();
		while (planet !== null && planet.getComponentByType('spheroid') === null && planet.getComponentByType('model') === null) {
			planet = planet.getParent();
		}

		let radius = planet.getOcclusionRadius();
		const spheroid = planet.getComponentByType('spheroid');
		if (spheroid !== null) {
			radius = /** @type {Pioneer.SpheroidComponent} */(planet.getComponentByType('spheroid')).getEquatorialRadius();
		}

		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		sc.getPositionRelativeToEntity(dest, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, planet);
		dest.normalize(dest);
		// If destination vector is too close to zero
		if (dest.magnitude() < 0.0001) {
			sc.getOrientation().getAxis(dest, 0);
			dest.normalize(dest);
		}
		dest.mult(dest, Math.max(minRadius, distanceMultiplier * radius));

		const planetUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		planet.getOrientation().getAxis(planetUp, 2);

		// Go to parent first and then align object with parent
		await this._cameraManager.goToEntity(planet.getName());
		await this._cameraManager.goToEntity(id, { destination: dest, cinematic: false, minRadius: Math.min(radius, minRadius), destinationUp: planetUp, duration });
	}

	/**
	 * View from side of entity.
	 * @param {string} id
	 * @param {object} [options={}]
	 * @param {string} [options.planeId='earth']
	 * @param {number} [options.distance=undefined]
	 * @param {boolean} [options.cinematic=false]
	 * @param {number} [options.duration=0.75]
	 * @param {number} [options.verticalOffset=0]
	 * @param {number} [options.horizontalOffset=0]
	 * @param {string} [options.forwardVector='x-axis']
	 * @param {string} [options.upVector=''] - Get up vector from position by default. Otherwise from parent's axis.
	 */
	async viewFromSide(id, { planeId = 'earth', distance = undefined, cinematic = false, duration = 0.75, verticalOffset = 0, horizontalOffset = 0, forwardVector = 'x-axis', upVector = '' } = {}) {
		// Entities
		const targetEntity = this._scene.get(id);
		const planeEntity = this._scene.get(planeId) || targetEntity.getParent();
		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(this._scene, [id, planeId]);

		const targetRadius = targetEntity.getOcclusionRadius();
		const minRadius = 1.2 * targetRadius;

		// View from side
		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const forward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		let forwardIndex = 0;
		if (forwardVector === 'z-axis') {
			forwardIndex = 2;
		}
		else if (forwardVector === 'y-axis') {
			forwardIndex = 1;
		}
		targetEntity.getOrientation().getAxis(forward, forwardIndex);
		forward.normalize(forward);
		const targetPosition = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		targetEntity.getPositionRelativeToEntity(targetPosition, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, planeEntity);
		targetPosition.normalize(targetPosition);
		dest.cross(forward, targetPosition);
		dest.normalize(dest);
		dest.mult(dest, -1);

		const up = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		if (upVector) {
			// Parent up
			let upVectorIndex = 1;
			if (upVector.includes('x-axis')) {
				upVectorIndex = 0;
			}
			else if (upVector.includes('z-axis')) {
				upVectorIndex = 2;
			}
			targetEntity.getOrientation().getAxis(up, upVectorIndex);
			if (upVector.startsWith('-')) {
				up.mult(up, -1);
			}
		}
		else {
			// Position up
			targetEntity.getPositionRelativeToEntity(up, targetEntity, planeEntity);
			up.normalize(up);
		}

		// Horizontal
		const horizontal = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		horizontal.cross(dest, up);
		horizontal.normalize(horizontal);

		// Make sure up is orthogonal
		up.cross(horizontal, dest);

		// Offset dest vector so target is below or above
		if (verticalOffset !== 0) {
			const orientationOffset = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			const angleOffset = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(verticalOffset);
			orientationOffset.setFromAxisAngle(horizontal, angleOffset);
			dest.rotate(orientationOffset, dest);
		}

		// TODO: Optional: Update up after rotation
		up.cross(horizontal, dest);

		// Offset dest vector so target is on the left or right
		if (horizontalOffset !== 0) {
			const orientationOffset = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			const angleOffset = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(horizontalOffset);
			orientationOffset.setFromAxisAngle(up, angleOffset);
			dest.rotate(orientationOffset, dest);
		}

		// Update horizontal axis
		horizontal.cross(dest, up);
		horizontal.normalize(horizontal);

		// Distance
		if (distance === undefined) {
			dest.mult(dest, 10 * targetRadius);
		}
		else {
			dest.mult(dest, distance);
		}

		await this._cameraManager.goToEntity(id, { destination: dest, cinematic, minRadius, destinationUp: up, duration });
	}

	/**
	 * Go to spacecraft look at a target.
	 * @param {string} id - Spacecraft entity id
	 * @param {string} target - Target entity id
	 */
	async spacecraftLookAtTarget(id, target) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.LOOK_AT, target });
		// TODO: Add function & params
	}

	/**
	 * Go to spacecraft locked on a target.
	 * @param {string} id - Spacecraft entity id
	 * @param {string} target - Target entity id
	 */
	async spacecraftLockedOnTarget(id, target) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.LOCKED_ON, target });
		// TODO: Add function & params
	}

	/**
	 * Go to a system sideway (looking at terminator line instead of sunny side).
	 * @param {string} id
	 * @param {object} options
	 * @param {number} [options.distance = undefined] - Distance from the target
	 * @param {number} [options.minDistance = 0] - Minimum distance the camera can be from target
	 * @param {number} [options.duration = 1] - Duration of the transition and alignment
	 * @param {string[]} [options.otherEntityNames = []] - Other entities to include in the view
	 * @param {boolean} [options.includeChildren = true] - Include children in the view
	 * @param {number} [options.angleInDegree = 0] - Angle of the camera
	 * @param {boolean} [options.cinematic = false] - Cinematic mode
	 */
	async goToSystemSideway(id, { distance = undefined, minDistance = 0, duration = 1, otherEntityNames = [], includeChildren = true, angleInDegree = 0, cinematic = false } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.SYSTEM });

		const systemObject = this._scene.getEntity(id);

		// Get min distance
		const systemId = this.isBarycenter(id)
			? this.removeBarycenter(id)
			: id;
		const minDist = systemId in this._customSystemDistances
			? this._customSystemDistances[systemId]
			: 0;

		// List entities that have to be displayed on screen
		const entities = [systemObject];
		for (let i = 0; i < otherEntityNames.length; i++) {
			entities.push(this._scene.getEntity(otherEntityNames[i]));
		}
		if (includeChildren) {
			for (let i = 0; i < systemObject.getNumChildren(); i++) {
				const child = systemObject.getChild(i);
				// Ignore camera
				if (child.getComponentByType('camera') !== null) {
					continue;
				}
				// Ignore spacecraft
				if (child.getName().startsWith('sc')) {
					continue;
				}
				// Ignore objects without valid positions
				if (child.getPosition().isNaN()) {
					continue;
				}
				entities.push(child);
			}
		}

		// Create an xyz frame from the object's velocity and position
		// Get y-axis
		const yAxis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		yAxis.normalize(systemObject.getVelocity());

		// Get x-axis
		const xAxis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		xAxis.normalize(systemObject.getPosition());

		// Force x-axis to be normal to y-axis
		xAxis.setNormalTo(yAxis, xAxis);

		// Get z-axis
		const zAxis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		zAxis.cross(xAxis, yAxis);

		// Get negative of y-axis + fraction of z-axis
		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		dest.mult(yAxis, -1);
		dest.addMult(dest, zAxis, Math.tan(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(angleInDegree)));

		// Determine min radius
		let radius = systemObject.getOcclusionRadius();
		const spheroid = /** @type {Pioneer.SpheroidComponent} */(systemObject.getComponentByType('spheroid'));
		if (spheroid !== null) {
			radius = spheroid.getEquatorialRadius();
		}
		else if (this.isBarycenter(id)) {
			const newId = this.removeBarycenter(id);
			const newSystemObject = this._scene.getEntity(newId);
			const newSpheroid = /** @type {Pioneer.SpheroidComponent} */(newSystemObject.getComponentByType('spheroid'));
			if (spheroid !== null) {
				radius = newSpheroid.getEquatorialRadius();
			}
		}
		const minRadius = 1.2 * radius;

		// Determine viewing distance
		let dist = distance;
		if (dist === undefined) {
			const cameraOrientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			cameraOrientation.setFromAxes(xAxis, dest, undefined);
			dist = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.getDistanceToFitEntities(this._cameraEntity, cameraOrientation, systemObject, entities);
			dist *= 1.3;
		}
		dist = Math.max(minDist, dist);
		// If the view is taller than it is wide, increase distance.
		const cameraComponent = /** @type {Pioneer.CameraComponent} */(this._cameraEntity.getComponentByType('camera'));
		if (cameraComponent.getHorizontalFieldOfView() < cameraComponent.getVerticalFieldOfView()) {
			dist *= cameraComponent.getVerticalFieldOfView() * 1.3;
		}
		dest.setMagnitude(dest, dist);

		// Go to system view
		await this._cameraManager.goToEntity(id, { destination: dest, cinematic, minRadius, destinationUp: zAxis, duration });
	}

	/**
	 * Go to a system, sunny side and rotates around it
	 * @param {string} id - Target entity id
	 * @param {object} options
	 * @param {number} [options.distance = undefined] - Distance from the target
	 * @param {number} [options.angle = 25] - Angle of the camera
	 * @param {number} [options.minDistance = 0] - Minimum distance the camera can be from target
	 * @param {number} [options.duration = 1] - Duration of the transition and alignment (x2)
	 * @param {string} [options.planeId = ''] - A planet id used to calculate normal to ecliptic
	 * @param {string[]} [options.otherEntityNames = []] - Other entities to include in the view
	 * @param {boolean} [options.includeChildren = true] - Include children in the view
	 * @param {boolean} [options.isRelativeToPreviousCamera = false] - Align to previous camera
	 */
	async goToSystem(id, options = {}) {
		if (id === 'inner_solar_system') {
			Object.assign(options, { distance: 7e8, angle: 25, planeId: 'earth' });
			await this._goToSystem('sun', options);
		}
		else if (id === 'outer_solar_system') {
			Object.assign(options, { distance: 1e10, angle: 25, planeId: 'earth' });
			await this._goToSystem('sun', options);
		}
		else {
			const systemId = this.isBarycenter(id)
				? this.removeBarycenter(id)
				: id;
			const minDist = systemId in this._customSystemDistances
				? this._customSystemDistances[systemId]
				: 0;
			const entityInfo = this._app.getManager('content').getEntityInfo(id);
			const planeId = 'planeId' in options
				? options.planeId
				: (entityInfo?.planeEntity || '');
			Object.assign(options, { minDistance: minDist, planeId });
			await this._goToSystem(id, options);
		}
	}

	/**
	 * Go to a system, sunny side and rotates around it.
	 * @param {string} id - Target entity id
	 * @param {object} options
	 * @param {number} [options.distance = undefined] - Distance from the target
	 * @param {number} [options.angle = 25] - Angle of the camera
	 * @param {number} [options.minDistance = 0] - Minimum distance the camera can be from target
	 * @param {number} [options.duration = 1] - Duration of the transition and alignment (x2)
	 * @param {string} [options.planeId = ''] - A planet id used to calculate normal to ecliptic
	 * @param {string[]} [options.otherEntityNames = []] - Other entities to include in the view
	 * @param {boolean} [options.includeChildren = true] - Include children in the view
	 * @param {boolean} [options.isRelativeToPreviousCamera = false] - Align to previous camera
	 */
	async _goToSystem(id, { distance = undefined, angle = 25, minDistance = 0, duration = 1, planeId = '', otherEntityNames = [], includeChildren = true, isRelativeToPreviousCamera = true } = {}) {
		// Always update context first
		this._cameraManager.setContext({ id, context: CameraScripts.CONTEXT.SYSTEM });

		this.app.getManager('camera').setIsTransitioning(true);

		const systemObject = this._scene.getEntity(id);

		// List entities that have to be displayed on screen
		const entities = [systemObject];
		for (let i = 0; i < otherEntityNames.length; i++) {
			entities.push(this._scene.getEntity(otherEntityNames[i]));
		}
		if (includeChildren) {
			for (let i = 0; i < systemObject.getNumChildren(); i++) {
				const child = systemObject.getChild(i);
				// Ignore camera
				if (child.getComponentByType('camera') !== null) {
					continue;
				}
				// Ignore spacecraft
				if (child.getName().startsWith('sc')) {
					continue;
				}
				// Ignore objects without valid positions
				if (child.getPosition().isNaN()) {
					continue;
				}
				entities.push(child);
			}
		}

		// Fwd vector from previous camera position
		const dest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const camPosition = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		if (isRelativeToPreviousCamera) {
			this._cameraEntity.getPositionRelativeToEntity(camPosition, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, systemObject);
			// If no camera position
			// force position to this vector
			if (camPosition.isNaN()) {
				dest.copy(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0));
				dest.mult(dest, 1e10);
			}
			else {
				dest.copy(camPosition);
			}
		}
		else {
			dest.normalize(systemObject.getPosition());
			dest.mult(dest, -1);
		}

		// Get the up vector
		const up = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		if (planeId !== '' && this._scene.get(planeId) !== null) {
			this.getNormalToEcliptic(up, planeId);
			if (up.isNaN()) {
				up.copy(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1));
			}
		}
		else {
			systemObject.getOrientation().getAxis(up, 2);
		}

		// Cross between dest and planet up
		const horizontal = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		horizontal.cross(dest, up);
		horizontal.normalize(horizontal);

		// Update dest to be normal to up
		dest.setNormalTo(up, dest);
		dest.normalize(dest);

		// Rotate fwd
		const rotation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		rotation.setFromAxisAngle(horizontal, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(angle));
		dest.rotate(rotation, dest);

		// Determine min radius
		let radius = systemObject.getOcclusionRadius();
		const spheroid = /** @type {Pioneer.SpheroidComponent} */(systemObject.getComponentByType('spheroid'));
		if (spheroid !== null) {
			radius = spheroid.getEquatorialRadius();
		}
		else if (this.isBarycenter(id)) {
			const newId = this.removeBarycenter(id);
			const newSystemObject = this._scene.getEntity(newId);
			const newSpheroid = /** @type {Pioneer.SpheroidComponent} */(newSystemObject.getComponentByType('spheroid'));
			if (spheroid !== null) {
				radius = newSpheroid.getEquatorialRadius();
			}
		}
		const minRadius = 1.2 * radius;

		// Determine viewing distance
		let dist = distance;
		if (dist === undefined) {
			const cameraOrientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			cameraOrientation.setFromAxes(horizontal, dest, undefined);
			dist = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Cameras.getDistanceToFitEntities(this._cameraEntity, cameraOrientation, systemObject, entities);
			dist *= 1.3;
		}
		dist = Math.max(minDistance, dist);
		// If the view is taller than it is wide, increase distance.
		const cameraComponent = /** @type {Pioneer.CameraComponent} */(this._cameraEntity.getComponentByType('camera'));
		if (cameraComponent.getHorizontalFieldOfView() < cameraComponent.getVerticalFieldOfView()) {
			dist *= cameraComponent.getVerticalFieldOfView() * 1.3;
		}

		if (isRelativeToPreviousCamera) {
			// Determine first destination
			// Look at the system object first
			const firstDest = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			this._cameraEntity.getPositionRelativeToEntity(camPosition, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, systemObject);
			if (camPosition.isNaN()) {
				firstDest.copy(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0));
				firstDest.setNormalTo(up, firstDest);
				firstDest.mult(firstDest, 1e10);
				firstDest.rotate(rotation, firstDest);
			}
			else {
				firstDest.copy(camPosition);
			}

			// Align camera with target first
			await this._cameraManager.goToEntity(id, { destination: firstDest, destinationUp: up, duration });
		}
		else {
			// Go to object at system distance first
			await this._cameraManager.goToEntity(id, { distance, duration: duration / 2 });
		}

		// Go to system view
		dest.mult(dest, dist);
		await this._cameraManager.goToEntity(id, { destination: dest, cinematic: false, minRadius, destinationUp: up, duration });
		this.app.getManager('camera').setIsTransitioning(false);
	}

	/**
	 * Go to a location in center of entities.
	 * @param {string[]} entityNames
	 * @param {string} parentName
	 * @param {number} time - Pioneer time
	 * @param {Object<string, any>} options - Options for goToSystem function
	 */
	async goToCenter(entityNames, parentName, time, options = {}) {
		// Always update context first
		this._cameraManager.setContext({ id: 'centerSystem', context: CameraScripts.CONTEXT.CENTER_SYSTEM });

		const position = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const parent = this._scene.getEntity(parentName);
		const tempPosition = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const entities = [];

		// Get position in center of entities
		for (let i = 0; i < entityNames.length; i++) {
			const entity = this._scene.getEntity(entityNames[i]);
			entities.push(entity);
			entity.getPositionRelativeToEntity(tempPosition, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, parent, time);
			position.addMult(position, tempPosition, 1 / entityNames.length);
		}

		// Create center entity
		let center = this._scene.getEntity('center');
		if (center === null) {
			center = this._scene.addEntity('center');
			center.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		center.setParent(parent);
		center.setPosition(position);
		await this._scene.getLoadedPromise();
		await this._cameraManager.pioneer.waitUntilNextFrame();

		// Go to system view at center
		options['otherEntityNames'] = entityNames;
		await this._goToSystem(center.getName(), options);
	}

	/**
	 * Show center location of multiple entities.
	 * @param {string[]} entityNames
	 * @param {string} parentName
	 * @param {number} time - Pioneer time
	 * @param {string} forwardEntityName - A parent id used to calculate normal to ecliptic or north pole
	 * @param {string} upOrRightEntityName - An entity used to orient the up or right of the camera (depending on aspect ratio).
	 * @param {string} mode - Whether to have the forward be based on the north pole or the orbital plane normal of the forwardEntity ('northPole' or 'planeNormal').
	 * @param {Object<string, any>} options - Options for showLocation function
	 */
	async showLocationCenter(entityNames, parentName, time, forwardEntityName, upOrRightEntityName, mode, options = {}) {
		// Always update context first
		this._cameraManager.setContext({ id: 'centerLocation', context: CameraScripts.CONTEXT.CENTER_LOCATION });

		const position = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const parent = this._scene.getEntity(parentName);
		const tempPosition = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const entities = [];

		// Get position in center of entities
		for (let i = 0; i < entityNames.length; i++) {
			const entity = this._scene.getEntity(entityNames[i]);
			entities.push(entity);
			entity.getPositionRelativeToEntity(tempPosition, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, parent, time);
			position.addMult(position, tempPosition, 1 / entityNames.length);
		}

		// Create center entity
		let center = this._scene.getEntity('center');
		if (center === null) {
			center = this._scene.addEntity('center');
			center.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		center.setParent(parent);
		center.setPosition(position);
		await this._scene.getLoadedPromise();
		await this._cameraManager.pioneer.waitUntilNextFrame();

		// Go to location view at center
		options['otherEntityNames'] = entityNames;
		await this.showLocation(center.getName(), forwardEntityName, upOrRightEntityName, mode, options);
	}

	/**
	 * Show where object is located in the parent's system.
	 * @param {string} id - Target entity id
	 * @param {object} [options={}]
	 */
	async showLocationInParentSystem(id, options = {}) {
		const parentId = this._app.getManager('scene').getParent(id);
		await this.showLocation(id, parentId, parentId, 'northPole', options);
	}

	/**
	 * Show where object is located in the Solar system.
	 * @param {string} id - Target entity id
	 * @param {object} [options={}]
	 */
	async showLocationInSolarSystem(id, options = {}) {
		let parent = this._scene.getEntity(id).getParent();
		if (parent.getName() !== 'sun') {
			while (parent.getParent().getName() !== 'sun') {
				parent = parent.getParent();
			}
		}
		else {
			parent = this._scene.getEntity('earth');
		}

		await this.showLocation(id, parent.getName(), 'sun', 'planeNormal', options);
	}
}

CameraScripts.CONTEXT = {
	CELESTIAL_OBJECT: 0,
	SPACECRAFT: 1,
	ALIGN_SPACECRAFT: 2,
	LOCATION: 3,
	SYSTEM: 4,
	COMPARE: 5,
	LOOK_AT: 6,
	LOCKED_ON: 7,
	INSTRUMENT: 8,
	ALIGN_OBJECTS: 9,
	CENTER_SYSTEM: 10,
	CENTER_LOCATION: 11
};


/***/ }),

/***/ "../eyes/src/managers/comparison_manager.js":
/*!**************************************************!*\
  !*** ../eyes/src/managers/comparison_manager.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComparisonManager": function() { return /* binding */ ComparisonManager; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");




/**
 * The Comparison Manager class.
 */
class ComparisonManager extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * The left viewport.
		 * @type {Pioneer.Viewport}
		 * @private
		 */
		this._viewportLeft = null;

		/**
		 * The right viewport.
		 * @type {Pioneer.Viewport}
		 * @private
		 */
		this._viewportRight = null;

		/**
		 * The left scene.
		 * @type {Pioneer.Scene}
		 * @private
		 */
		this._sceneLeft = null;

		/**
		 * The right scene.
		 * @type {Pioneer.Scene}
		 * @private
		 */
		this._sceneRight = null;

		/**
		 * The left anchor entity.
		 * @type {Pioneer.Entity}
		 * @private
		 */
		this._anchorEntityLeft = null;

		/**
		 * The right anchor entity.
		 * @type {Pioneer.Entity}
		 * @private
		 */
		this._anchorEntityRight = null;

		/**
		 * The left entity.
		 * @type {Pioneer.Entity}
		 * @private
		 */
		this._entityLeft = null;

		/**
		 * The right entity.
		 * @type {Pioneer.Entity}
		 * @private
		 */
		this._entityRight = null;

		/**
		 * The left sun.
		 * @type {Pioneer.Entity}
		 * @private
		 */
		this._sunLeft = null;

		/**
		 * The right sun.
		 * @type {Pioneer.Entity}
		 * @private
		 */
		this._sunRight = null;

		/**
		 * A list of viewports that were active before comparison started, so they can be re-enabled later.
		 * @type {number[]}
		 * @private
		 */
		this._activeViewports = [];

		/**
		 * Custom rotations for comparing objects.
		 * @type {Record<string, [string, number][]>}
		 * @private
		 */
		this._customRotations = {
			rose_bowl: [['x', 45], ['z', 180]],
			sc_juno: [['x', 45], ['z', 180]],
			saturn: [['x', 25]],
			sc_lucy: [['z', -90], ['y', -25]],
			sc_ixpe: [['z', -90], ['y', 180]],
			sc_hubble_space_telescope: [['x', 90], ['z', 90]],
			sc_jwst: [['x', 180], ['y', 180]],
			sc_psyche: [['x', 90], ['z', 90]],
			sc_stardust: [['x', 90]],
			sc_osiris_rex_src: [['x', 90]],
			sc_stardust_src: [['z', 90]],
			sc_acs3: [['x', 90]]
		};

		/**
		 * Zoom sensitivity for zoom functions.
		 * @type {{click: number, hold: number}}
		 * @private
		 */
		this._zoomSensitivity = {
			click: 0.3,
			hold: 0.1
		};

		// Setup the bind functions.
		this.bindFunctions(['_adjustZoomFromViewport', 'zoomIn', 'zoomOut']);

		// Create the left and right scenes.
		this._sceneLeft = this.pioneer.addScene('comparisonLeft');
		this._sceneLeft.setAmbientLightColor(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(0.005, 0.005, 0.005));
		this._sceneRight = this.pioneer.addScene('comparisonRight');
		this._sceneRight.setAmbientLightColor(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(0.005, 0.005, 0.005));

		// Create scene backgrounds.
		pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create('observable_universe', this._sceneLeft);
		pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create('milky_way', this._sceneLeft);
		pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create('observable_universe', this._sceneRight);
		pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create('milky_way', this._sceneRight);

		// Create the suns.
		this._sunLeft = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create('sun', this._sceneLeft, { nameSuffix: '_compare' });
		this._sunRight = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create('sun', this._sceneRight, { nameSuffix: '_compare' });

		// Create the compare entity locations.
		this._anchorEntityLeft = this._sceneLeft.addEntity('anchorLeft');
		this._anchorEntityLeft.setParent(this._sceneLeft.getEntity('sun_compare'));
		this._anchorEntityLeft.setPosition(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(1e8, 0, 0));
		this._anchorEntityLeft.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity);
		this._anchorEntityRight = this._sceneRight.addEntity('anchorRight');
		this._anchorEntityRight.setParent(this._sceneRight.getEntity('sun_compare'));
		this._anchorEntityRight.setPosition(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(1e8, 0, 0));
		this._anchorEntityRight.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity);

		// Create the left and right cameras.
		this._cameraEntityLeft = this._sceneLeft.addEntity('cameraLeft');
		this._cameraEntityLeft.setParent(this._anchorEntityLeft);
		this._cameraLeft = /** @type {Pioneer.CameraComponent} */(this._cameraEntityLeft.addComponent('camera'));
		this._cameraLightLeft = /** @type {Pioneer.LightSourceComponent} */(this._cameraEntityLeft.addComponent('lightSource'));
		this._cameraLightLeft.setEnabled(false);
		this._cameraEntityRight = this._sceneRight.addEntity('cameraRight');
		this._cameraEntityRight.setParent(this._anchorEntityRight);
		this._cameraRight = /** @type {Pioneer.CameraComponent} */(this._cameraEntityRight.addComponent('camera'));
		this._cameraLightRight = /** @type {Pioneer.LightSourceComponent} */(this._cameraEntityRight.addComponent('lightSource'));
		this._cameraLightRight.setEnabled(false);

		// Create left and right viewports
		this._viewportLeft = this.pioneer.addViewport('left-viewport');
		this._viewportLeft.getDiv().className = 'compare-viewport left-desktop';
		this._viewportLeft.setEnabled(false);
		this._viewportLeft.setCamera(this._cameraLeft);
		this._viewportRight = this.pioneer.addViewport('right-viewport');
		this._viewportRight.getDiv().className = 'compare-viewport right-desktop';
		this._viewportRight.setEnabled(false);
		this._viewportRight.setCamera(this._cameraRight);

		// Add a callback to adjust the zooms.
		this.pioneer.addCallback(this._adjustZoomFromViewport.bind(this), true);
	}

	/**
	 * Gets the left entity.
	 * @returns {Pioneer.Entity}
	 */
	get entityLeft() {
		return this._entityLeft;
	}

	/**
	 * Gets the right entity.
	 * @returns {Pioneer.Entity}
	 */
	get entityRight() {
		return this._entityRight;
	}

	/**
	 * Zooms In
	 * @param {boolean} isContinuous
	 */
	zoomIn(isContinuous = false) {
		let zoomChange = 1.0;
		const zoomSensitivity = isContinuous ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
		zoomChange /= Math.pow(2, zoomSensitivity);

		const camera = /** @type {CameraManager} */(this.app.getManager('camera'));
		camera.zoom(zoomChange, this._cameraEntityLeft);
		camera.zoom(zoomChange, this._cameraEntityRight);
	}

	/**
	 * Zooms Out
	 * @param {boolean} isContinuous
	 */
	zoomOut(isContinuous = false) {
		let zoomChange = 1.0;
		const zoomSensitivity = isContinuous ? this._zoomSensitivity.hold : this._zoomSensitivity.click;
		zoomChange *= Math.pow(2, zoomSensitivity);

		const camera = /** @type {CameraManager} */(this.app.getManager('camera'));
		camera.zoom(zoomChange, this._cameraEntityLeft);
		camera.zoom(zoomChange, this._cameraEntityRight);
	}

	/**
	 * Compare two objects.
	 * @param {string} entityNameLeft
	 * @param {string} entityNameRight
	 */
	async compare(entityNameLeft, entityNameRight) {
		// Remove any old entities, if needed.
		if (this._entityLeft && this._entityLeft.getName() !== entityNameLeft) {
			this._sceneLeft.removeEntity(this._entityLeft);
			this._entityLeft = null;
		}
		if (this._entityRight && this._entityRight.getName() !== entityNameRight) {
			this._sceneRight.removeEntity(this._entityRight);
			this._entityRight = null;
		}

		// Create the entities, if needed.
		const contentManager = this.app.getManager('content');
		const labelManager = this.app.getManager('label');
		if (!this._entityLeft) {
			this._entityLeft = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create(entityNameLeft, this._sceneLeft);
			this._entityLeft.clearParentingTableEntries();
			this._entityLeft.clearControllers();
			this._entityLeft.setParent(this._anchorEntityLeft);
			this._entityLeft.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);
			const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
			this._getCustomRotation(orientation, entityNameLeft, 'left');
			this._entityLeft.setOrientation(orientation);
			this._entityLeft.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent).setFadeWhenCloseToEntity('sun');

			labelManager.setLabelProps({
				getLabelClass: entityName => `no-select ${contentManager.getClassName(entityName, '') ?? ''}`,
				handleTouch: null,
				handleClick: null
			}, [entityNameLeft], this._sceneLeft, this._cameraEntityLeft);
		}
		if (!this._entityRight) {
			this._entityRight = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create(entityNameRight, this._sceneRight);
			this._entityRight.clearParentingTableEntries();
			this._entityRight.clearControllers();
			this._entityRight.setParent(this._anchorEntityRight);
			this._entityRight.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);
			const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
			this._getCustomRotation(orientation, entityNameRight, 'right');
			this._entityRight.setOrientation(orientation);
			this._entityRight.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent).setFadeWhenCloseToEntity('sun');

			labelManager.setLabelProps({
				getLabelClass: entityName => `no-select ${contentManager.getClassName(entityName, '') ?? ''}`,
				handleTouch: null,
				handleClick: null
			}, [entityNameRight], this._sceneRight, this._cameraEntityRight);
		}

		// Update the suns based on the lighting and if an entity is the sun.
		this._updateSuns();

		// Activate viewports, if needed.
		if (!this._viewportLeft.isEnabled()) {
			// Disable all other active viewports.
			for (let i = 0, l = this.pioneer.getNumViewports(); i < l; i++) {
				const viewport = this.pioneer.getViewport(i);
				if (viewport.isEnabled()) {
					this._activeViewports.push(i);
					viewport.setEnabled(false);
				}
			}
			// Enable compare viewports
			this._viewportLeft.setEnabled(true);
			this._viewportRight.setEnabled(true);
			// Turn off the camera light for default.
			this.setCameraLight(true);
			// Send out an event.
			const event = new CustomEvent('comparisonenter', { detail: { } });
			window.dispatchEvent(event);
		}

		// Calculate a good initial distance.
		const distLeft = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Cameras.getDistanceToFitEntities(this._cameraEntityLeft, pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity, this._entityLeft, [this._entityLeft]);
		const distRight = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Cameras.getDistanceToFitEntities(this._cameraEntityRight, pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity, this._entityRight, [this._entityRight]);
		let dist = Math.max(distRight, distLeft);
		dist *= 1.6;

		// Calculate positions from the distance.
		const cameraPositionLeft = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
		cameraPositionLeft.setMagnitude(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg, dist);
		const cameraPositionRight = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
		cameraPositionRight.setMagnitude(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg, dist);

		// Clear out the camera controllers so that any existing transition doesn't continue.
		this._cameraEntityLeft.clearControllers();
		this._cameraEntityRight.clearControllers();

		// Send out an event.
		const event = new CustomEvent('cameracompare', { detail: { left: entityNameLeft, right: entityNameRight } });
		window.dispatchEvent(event);

		// Do the camera transitions.
		const cameraManager = /** @type {CameraManager} */(this.app.getManager('camera'));
		const transitionLeftPromise = cameraManager.goToEntity('anchorLeft', {
			minRadius: dist * 0.5,
			maxRadius: dist * 10,
			camera: this._cameraEntityLeft,
			destination: cameraPositionLeft,
			destinationUp: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			scene: this._sceneLeft,
			select: false,
			zoom: true,
			cinematic: true
		});
		const transitionRightPromise = cameraManager.goToEntity('anchorRight', {
			minRadius: dist * 0.5,
			maxRadius: dist * 10,
			camera: this._cameraEntityRight,
			destination: cameraPositionRight,
			destinationUp: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			scene: this._sceneRight,
			select: false,
			zoom: true,
			cinematic: true
		});
		await Promise.all([transitionLeftPromise, transitionRightPromise]);

		// Wait until everything is loaded.
		const sceneManager = /** @type {SceneManager} */(this.app.getManager('scene'));
		sceneManager.addLoading(this._entityLeft.getName(), 'compare');
		sceneManager.addLoading(this._entityRight.getName(), 'compare');
		await Promise.all([this._entityLeft.getLoadedPromise(), this._entityRight.getLoadedPromise()]);
		sceneManager.removeLoading(this._entityLeft.getName(), 'compare');
		sceneManager.removeLoading(this._entityRight.getName(), 'compare');
	}

	/**
	 * Toggles between camera and sun lights
	 * @param {boolean} active
	 * @param {Pioneer.Color} [color]
	 */
	setCameraLight(active, color) {
		this._cameraLightLeft.setEnabled(active);
		this._cameraLightRight.setEnabled(active);
		if (color !== undefined) {
			this._cameraLightLeft.setColor(color);
			this._cameraLightRight.setColor(color);
		}
		this._updateSuns();
	}

	/**
	 * Exit comparison
	 */
	exit() {
		// Remove any old entities.
		if (this._entityLeft) {
			this._sceneLeft.removeEntity(this._entityLeft);
			this._entityLeft = null;
		}
		if (this._entityRight) {
			this._sceneRight.removeEntity(this._entityRight);
			this._entityRight = null;
		}

		// Disable compare viewports
		this._viewportLeft.setEnabled(false);
		this._viewportRight.setEnabled(false);

		// Enable previously active viewports
		for (let i = 0; i < this._activeViewports.length; i++) {
			const viewportNum = this._activeViewports[i];
			const viewport = this.pioneer.getViewport(viewportNum);
			viewport.setEnabled(true);
		}
		this._activeViewports = [];

		// Send the event.
		const event = new CustomEvent('comparisonexit', { detail: { } });
		window.dispatchEvent(event);
	}

	/**
	 * Update the suns based on the camera light and if the comparison object is the sun.
	 * @private
	 */
	_updateSuns() {
		// If one of them is the sun, turn off the background sun.
		const sunLeftEnabled = this._entityLeft?.getName() !== 'sun' && (!this._cameraLightLeft.isEnabled() || this._cameraLightLeft.getColor().min() < 1);
		const sunRightEnabled = this._entityRight?.getName() !== 'sun' && (!this._cameraLightRight.isEnabled() || this._cameraLightRight.getColor().min() < 1);
		this._sunLeft.getComponentByType('spheroidLOD').setEnabled(sunLeftEnabled);
		this._sunLeft.getComponentByType('atmosphere').setEnabled(sunLeftEnabled);
		this._sunLeft.getComponentByType('sprite').setEnabled(sunLeftEnabled);
		this._sunLeft.getComponentByType('lightSource').setEnabled(sunLeftEnabled);
		this._sunRight.getComponentByType('spheroidLOD').setEnabled(sunRightEnabled);
		this._sunRight.getComponentByType('atmosphere').setEnabled(sunRightEnabled);
		this._sunRight.getComponentByType('sprite').setEnabled(sunRightEnabled);
		this._sunRight.getComponentByType('lightSource').setEnabled(sunRightEnabled);
	}

	/**
	 * Adjust both viewport distances based on the camera distance.
	 * @private
	 */
	_adjustZoomFromViewport() {
		// If the viewports are disabled, return.
		if (!this._viewportLeft.isEnabled()) {
			return;
		}
		if (!this._viewportRight.isEnabled()) {
			return;
		}
		// Get the current distance of the left camera.
		let currentDistance = this._cameraEntityLeft.getPosition().magnitude();
		if (Number.isNaN(currentDistance)) {
			currentDistance = 1.0;
		}
		const activeViewport = this.app.pioneer.getInput().getActiveViewport();
		if (activeViewport && activeViewport.getName() === 'right-viewport') {
			currentDistance = this._cameraEntityRight.getPosition().magnitude();
			if (Number.isNaN(currentDistance)) {
				currentDistance = 1.0;
			}
		}
		// Set the positions to be the current distance.
		const currentLeftPosition = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.get();
		currentLeftPosition.setMagnitude(this._cameraEntityLeft.getPosition(), currentDistance);
		const currentRightPosition = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.get();
		currentRightPosition.setMagnitude(this._cameraEntityRight.getPosition(), currentDistance);
		this._cameraEntityLeft.setPosition(currentLeftPosition);
		this._cameraEntityRight.setPosition(currentRightPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.release(currentLeftPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.release(currentRightPosition);
	}

	/**
	 * Applies custom rotations to certain entities, so they look good.
	 * @param {Pioneer.Quaternion} outRotation
	 * @param {string} entityName
	 * @param {'left' | 'right'} side
	 * @private
	 */
	_getCustomRotation(outRotation, entityName, side) {
		outRotation.set(1, 0, 0, 0);
		if (this._customRotations[entityName] !== undefined) {
			const customRotation = this._customRotations[entityName];
			for (let i = 0, l = customRotation.length; i < l; i++) {
				let axis;
				if (customRotation[i][0] === 'x') {
					axis = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis;
				}
				else if (customRotation[i][0] === 'y') {
					axis = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis;
				}
				else if (customRotation[i][0] === 'z') {
					axis = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis;
				}
				else {
					throw new Error(`Invalid model rotate axis "${customRotation[i][0]}".`);
				}
				let angle = customRotation[i][1];

				angle = pioneer__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degToRad(angle);
				const rotation = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
				rotation.setFromAxisAngle(axis, angle);
				outRotation.mult(outRotation, rotation);
			}
		}
	}
}


/***/ }),

/***/ "../eyes/src/managers/content_manager.js":
/*!***********************************************!*\
  !*** ../eyes/src/managers/content_manager.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ContentManager": function() { return /* binding */ ContentManager; }
/* harmony export */ });
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment-timezone */ "../eyes/node_modules/moment-timezone/index.js");
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment_timezone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");



/**
 * @typedef EntityInfo
 * @property {string} id
 * @property {string} displayName
 * @property {string} category
 * @property {string} [iauName]
 * @property {string} [subcategory]
 * @property {boolean} [searchable]
 * @property {string[]} [keywords]
 * @property {boolean} [hasMoons]
 * @property {Object<string, string[]>} [related]
 * @property {string} [landingDate]
 * @property {number} [customDistance]
 * @property {boolean} [hasEvents]
 * @property {string[]} [forceVisibleEntities]
 * @property {string[]} [ignoreDependentWhenUnloading]
 */

/**
 * Content Manager class.
 * @extends BaseManager
 */
class ContentManager extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseManager {
	/**
	 * Constructor
	 * @param {BaseApp} app
	 * @private
	 */
	constructor(app) {
		super(app);

		/**
		 * The list of all entities.
		 * @type {Object<string, EntityInfo>}
		 * @private
		 */
		this._entityList = null;

		/**
		 * The list of entities grouped by categories.
		 * @type {Object<string, Array<EntityInfo>>}
		 * @private
		 */
		this._entitiesByCategory = {};

		/**
		 * The list of entities grouped by sub-categories.
		 * @type {Object<string, Array<EntityInfo>>}
		 * @private
		 */
		this._entitiesBySubCategory = {};

		/**
		 * Content of all stories.
		 * @type {object}
		 * @private
		 */
		this._stories = {};

		/**
		 * The list of all available story cards.
		 * @type {object}
		 * @private
		 */
		this._storyList = null;

		/**
		 * The target to load corresponding contents.
		 * Mostly used to prevent duplicated fetch.
		 * @type {string}
		 * @private
		 */
		this._target = null;

		/**
		 * Context of current target.
		 * @type {object}
		 * @private
		 */
		this._context = {};

		/**
		 * All events of a target.
		 * @type {object}
		 * @private
		 */
		this._context.events = {};

		/**
		 * All events of a target, ordered by start date.
		 * @type {object}
		 * @private
		 */
		this._context.orderedEvents = {};

		/**
		 * Description of an event.
		 * @type {object}
		 * @private
		 */
		this._context.eventDesc = {};

		/**
		 * Currently loaded story.
		 * @type {object}
		 * @private
		 */
		this._context.story = {};

		/**
		 * Folders to fetch files from.
		 * @type {object}
		 * @property {string} [description='/'] - Folder containing description files
		 * @property {string} [event='/'] - Folder containing event files
		 * @private
		 */
		this._folders = {
			description: '/',
			event: '/',
			stories: '/'
		};
	}

	/**
	 * Gets the entity list.
	 * @returns {object}
	 */
	getEntityList() {
		return this._entityList;
	}

	/**
	 * Sets the entity list.
	 * @param {object} entityList - List of entities
	 */
	setEntityList(entityList) {
		for (const [key, value] of Object.entries(entityList)) {
			if (value.disabled === true) {
				delete entityList[key];
			}
		}
		this._entityList = entityList;

		Object.keys(this._entityList).forEach(k => {
			const { category } = this._entityList[k];

			// Category
			if (this._entitiesByCategory[category]) {
				// Populate category list
				this._entitiesByCategory[category].push(this._entityList[k]);
			}
			else {
				// Create category list
				this._entitiesByCategory[category] = [this._entityList[k]];
			}

			// Subcategory
			let { subcategory } = this._entityList[k];
			if (!subcategory || subcategory === '') {
				subcategory = category;
			}
			if (this._entitiesBySubCategory[subcategory]) {
				// Populate subcategory list
				this._entitiesBySubCategory[subcategory].push(this._entityList[k]);
			}
			else {
				// Create subcategory list
				this._entitiesBySubCategory[subcategory] = [this._entityList[k]];
			}
		});
	}

	/**
	 * Returns the entity global information from the entity list file, or null if it is not found.
	 * @param {string} id - The entity id.
	 * @returns {EntityInfo | null}
	 */
	getEntityInfo(id) {
		if (id in this._entityList) {
			return this._entityList[id];
		}
		else {
			return null;
		}
	}

	/**
	 * Returns an entity description.
	 * @param {string} id - The entity id.
	 * @returns {object}
	 */
	async getEntityDesc(id) {
		let entityDesc = null;
		try {
			entityDesc = await _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.loadJSON("https://eyes.nasa.gov/apps/asteroids/descriptions/" + id + '.json');
		}
		catch (err) {
			entityDesc = null;
		}
		return entityDesc;
	}

	/**
	 * Sets/Updates folders for fetching files.
	 * @param {object} [folders={}]
	 */
	setFolders(folders = {}) {
		for (const key in folders) {
			if (Object.prototype.hasOwnProperty.call(folders, key)) {
				folders[key] = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.addEndToPath(folders[key]);
				this._folders[key] = folders[key];
			}
		}
	}

	/**
	 * Gets the list of cards.
	 * @returns {object}
	 */
	getStoryList() {
		return this._storyList;
	}

	/**
	 * Set the cards
	 * @param {object} allStories - List of cards
	 */
	setStoryList(allStories) {
		this._storyList = allStories;
	}

	/**
	 * Get a story from story list.
	 * @param {string} id - Story ID
	 * @returns {object}
	 */
	getStory(id) {
		if (!id) {
			throw new Error('[ContentManager.getStory]: id is required.');
		}
		if (!this._stories[id]) {
			throw new Error(`[ContentManager.getStory]: Cannot find story with id ${id}.`);
		}

		this._context.story = this._stories[id];
		return this._context.story;
	}

	/**
	 * Set stories content.
	 * @param {object} stories
	 */
	setStories(stories) {
		this._stories = stories;
	}

	/**
	 * Load multiple description files.
	 * @param {string[]} itemsList - a name or a list of names
	 * @param {CancelToken} cancelToken
	 * @returns {Promise}
	 */
	async loadDescriptions(itemsList, cancelToken) {
		for (let i = 0; i < itemsList.length; i++) {
			const item = itemsList[i];
			const desc = await this.getEntityDesc(item);
			if (cancelToken && cancelToken.isCanceled) {
				return;
			}
			this._context[item] = desc;
		}
	}

	/**
	 * Load event files of a target.
	 * @param {string} target
	 * @param {string} [fileNames={}] - JSON files
	 * @param {CancelToken} cancelToken
	 */
	async loadEvents(target, fileNames = {}, cancelToken) {
		if (!target) {
			return;
		}

		const eventFolder = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.addEndToPath(this._folders.event + target);

		if (fileNames.all) {
			if (this._target !== target || _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.isEmptyObject(this._context.events)) {
				let allEvents = null;
				try {
					allEvents = await _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.loadJSON(eventFolder + fileNames.all);
				}
				catch (err) {
					allEvents = null;
				}
				if (cancelToken && cancelToken.isCanceled) {
					return;
				}

				this._context.events = allEvents;

				if (this._context.events !== null) {
					// Convert object to array
					const orderedEvents = [];
					for (const [key, value] of Object.entries(this._context.events)) {
						if (value.start) {
							value.start = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().tz(value.start, 'Etc/UTC');
						}
						else {
							console.error('[Content Manager] Error: event missing start date ' + target + ' ' + key);
							continue;
						}
						if (value.end) {
							value.end = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().tz(value.end, 'Etc/UTC');
						}
						orderedEvents.push(value);
					}

					// Sort by start time
					orderedEvents.sort((a, b) => a.start.valueOf() - b.start.valueOf());
					this._context.orderedEvents = orderedEvents;
				}
				else {
					this._context.orderedEvents = null;
				}
			}
		}

		if (fileNames.event) {
			// Check for template file
			const event = this._context.events[fileNames.event];
			const eventFile = (event && event.template) ? event.template : fileNames.event;

			let eventDesc = null;
			try {
				eventDesc = await _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.loadJSON(eventFolder + eventFile);
			}
			catch (err) {
				eventDesc = null;
			}
			if (cancelToken && cancelToken.isCanceled) {
				return;
			}
			this._context.eventDesc = eventDesc;
		}

		this._target = target;
	}

	/**
	 * Returns an array of spheroidLayers for an entity (or undefined)
	 * @param {string} entityId
	 * @returns {object}
	 */
	getSpheroidLayers(entityId) {
		return this._entityShperoidLayersList[entityId];
	}

	/**
	 * Load WMTS, CMS and surface map info
	 * @param {object} layersArray
	 */
	setSpheroidLayers(layersArray) {
		this._entityShperoidLayersList = layersArray;
	}

	/**
	 * Returns an array of spheroidFeatures for an entity (or empty array if none exist for the entity).
	 * @param {string} entityId
	 * @returns {object}
	 */
	getSpheroidFeatures(entityId) {
		return this._entityShperoidFeaturesList[entityId] || [];
	}

	/**
	 * Load Features info (Magnetosphere, Auroras, radiation belts).
	 * @param {object} featuresArray
	 */
	setSpheroidFeatures(featuresArray) {
		this._entityShperoidFeaturesList = featuresArray;
	}

	/**
	 * Returns the css classname of the color associated with this entityId in color.css
	 * @param {string} entityId
	 * @returns {string}
	 */
	getColorClass(entityId) {
		let colorClass = '';
		if (!this.getEntityInfo(entityId)) {
			return colorClass;
		}

		const entityInfoCategory = this.getEntityInfo(entityId).category;

		switch (entityInfoCategory) {
			case 'Asteroid': {
				colorClass = 'asteroid';
				break;
			}
			case 'Instrument':
			case 'Spacecraft': {
				colorClass = 'spacecraft';
				break;
			}
			case 'Planet': {
				colorClass = entityId;
				break;
			}
			case 'Dwarf Planet': {
				colorClass = 'dwarf-planet';
				break;
			}
			case 'Comet': {
				colorClass = 'comet';
				break;
			}
			case 'Barycenter':
			case 'Moon': {
				colorClass = 'moon';
				break;
			}
			case 'Universe':
			case 'Galaxy':
			case 'Star': {
				colorClass = 'sun';
				break;
			}
			default: {
				colorClass = '';
			}
		}

		return colorClass;
	}

	/**
	 * Returns true if the entity has a landed.
	 * @param {object} entityInfo
	 * @returns {boolean}
	 */
	hasLanded(entityInfo) {
		if (!entityInfo.landingDate || entityInfo.landingDate === '') {
			return false;
		}

		// Check if category match lander categories
		const categories = ['Lander', 'Rover'];
		if (categories.indexOf(entityInfo.subcategory) < 0) {
			return false;
		}

		// Check if landing date is after current time
		const landing = this._app.getManager('time').parseTime(entityInfo.landingDate);
		const current = this._app.getManager('time').getTime();
		if (current.isSameOrAfter(landing)) {
			return true;
		}
		else {
			return false;
		}
	}

	// TODO: Rework / currently used by labels
	/**
	 * getClassName
	 * @param {*} id
	 * @param {string} category - optional category
	 * @returns {string}
	 */
	getClassName(id, category) {
		const entityInfo = this.getEntityInfo(id);

		let className = id;

		// Add category
		if (category) {
			className += ' ' + category.toLowerCase().replace(/ /g, '-');
		}
		else if (entityInfo !== null && entityInfo.category !== undefined) {
			const category = entityInfo.category.toLowerCase().replace(/ /g, '-');
			className += ' ' + category;
		}

		// Cant start with a number
		if (className.match(/^\d/)) {
			className = '_' + className;
		}

		return className;
	}

	/**
	 * Returns true if the entity information has a specific keyword.
	 * @param {string} id - The entity id.
	 * @param {string} keyword - The keyword searched.
	 * @returns {boolean}
	 */
	hasKeyword(id, keyword) {
		if (this.getEntityInfo(id) !== undefined) {
			return this.getEntityInfo(id).keywords.includes(keyword);
		}
	}

	/**
	 * Resets the context.
	 */
	resetContext() {
		this._context = {};
		this._context.events = {};
		this._context.eventDesc = {};
		this._context.orderedEvents = {};
		this._context.story = {};
	}

	/**
	 * Hide external links
	 * @param {string} text
	 * @returns {string}
	 */
	hideExternalLinksInText(text) {
		// Remove all external links/replcae them with the text that was already there
		return text.replaceAll(/<a.*?href=['"](https?:)?\/\/[^>]*>(.*?)<\/a>/g, '$2');
	}

	/**
	 * Hide external link stories from story list
	 */
	hideExternalLinkStoryList() {
		const stories = this.getStoryList();
		const internalStories = {};
		const externalStoryIds = stories['external'] ? Object.keys(stories['external']) : [];

		for (const [category, storyListItems] of Object.entries(stories)) {
			if (category !== 'external') {
				internalStories[category] = storyListItems;

				// Remove any external story from other story categories in list, such as 'featured'
				const storyListIsArray = Array.isArray(storyListItems);
				if (storyListIsArray) {
					const listWithoutExternal = storyListItems.filter(id => !externalStoryIds.includes(id));
					if (listWithoutExternal.length > 0) {
						internalStories[category] = listWithoutExternal;
					}
				}
				else {
					// If the story list item is an object, remove any keys that match the external stories
					const externalStoriesInKeys = Object.keys(storyListItems).filter(key => externalStoryIds.includes(key));
					for (let i = 0; i < externalStoriesInKeys.length; i++) {
						delete storyListItems[externalStoriesInKeys[i]];
					}
				}
			}
		}

		this.setStoryList(internalStories);
	}

	/**
	 * Display error message and throw previous url.
	 * @param {string} err - Original error message
	 * @param {string} [message=''] - Message to concate in front of error message
	 * @throws {string}
	 */
	_handleError(err, message = '') {
		console.error(message + err);
		let url = this.app.getManager('router').previousRoute.url;
		if (!url) {
			url = this.app.getManager('router').homeRoute;
		}
		err.previousRoute = url;
		throw err;
	}

	/**
	 * Get entities grouped by category.
	 * @returns {object}
	 */
	get entitiesByCategory() {
		return this._entitiesByCategory;
	}

	/**
	 * Get entities grouped by category.
	 * @returns {object}
	 */
	get entitiesBySubCategory() {
		return this._entitiesBySubCategory;
	}

	/**
	 * Get context of current target.
	 * @returns {object}
	 */
	get context() {
		return this._context;
	}

	/**
	 * Get all events for current target.
	 * @returns {object}
	 */
	get events() {
		return this._context.events;
	}

	/**
	 * Get all events for current target ordered by start date.
	 * @returns {object}
	 */
	get orderedEvents() {
		return this._context.orderedEvents;
	}

	/**
	 * Get description for current event.
	 * @returns {object}
	 */
	get eventDesc() {
		return this._context.eventDesc;
	}
}


/***/ }),

/***/ "../eyes/src/managers/ert_manager.js":
/*!*******************************************!*\
  !*** ../eyes/src/managers/ert_manager.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ERTManager": function() { return /* binding */ ERTManager; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");

/** @typedef {import('moment-timezone')} moment */

/**
 * ERT manager class.
 * @extends BaseManager
 */
class ERTManager extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseManager {
	/**
	 * @inheritdoc
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 * @param {boolean} [options.isERT=false]
	 * @param {string} [options.ertTarget='']
	 * @param {SceneManager} [options.sceneMgr=null]
	 */
	constructor(app, { isERT = false, ertTarget = '', sceneMgr = null } = {}) {
		super(app);

		this._isERT = isERT;
		this._ertTarget = ertTarget;
		this._sceneMgr = sceneMgr;

		this.getNow = this.getNow.bind(this);
	}

	/**
	 * Get status on/off of Earth Received Time mode.
	 * @returns {boolean}
	 */
	isERT() {
		return this._isERT;
	}

	/**
	 * Sets Earth Received Time mode on/off for time display.
	 * @param {boolean} isERT - on/off
	 */
	setERT(isERT) {
		this._isERT = isERT;
	}

	/**
	 * Get target for Earth Received Time.
	 * @returns {string}
	 */
	getERTTarget() {
		return this._ertTarget;
	}

	/**
	 * Set target for Earth Received Time.
	 * @param {string} target
	 */
	setERTTarget(target) {
		this._ertTarget = target;
	}

	/**
	 * Get scene manager for Earth Received Time.
	 * @returns {SceneManager}
	 */
	getERTScene() {
		return this._sceneMgr;
	}

	/**
	 * Set scene manager for Earth Received Time.
	 * @param {SceneManager} sceneMgr
	 */
	setERTScene(sceneMgr) {
		this._sceneMgr = sceneMgr;
	}

	/**
	 * Get ERT offset in seconds.
	 * @returns {number}
	 */
	getERTOffset() {
		if (this._sceneMgr !== null) {
			const distance = this._sceneMgr.getDistance(this._ertTarget, 'earth', { subtractRadius: true });
			return distance / _internal__WEBPACK_IMPORTED_MODULE_0__.AppUtils.constants.speedOfLight;
		}
		else {
			console.warn('Clock: could not get scene manager.');
			return 0;
		}
	}

	/**
	 * Get ERT from time.
	 * @param {moment} time - Time at target
	 * @returns {moment}
	 */
	getERTFromTime(time) {
		const offset = this.getERTOffset();
		time.add(offset, 's');
		return time;
	}

	/**
	 * Get time at target from ERT.
	 * @param {moment} time - Earth Received Time
	 * @returns {moment}
	 */
	getTimeFromERT(time) {
		const offset = this.getERTOffset();
		time.subtract(offset, 's');
		return time;
	}

	/**
	 * Get now time based on ERT mode.
	 * @param {moment} time
	 * @returns {moment}
	 */
	getNow(time) {
		if (this._isERT) {
			return this.getTimeFromERT(time);
		}
		else {
			return time;
		}
	}
}


/***/ }),

/***/ "../eyes/src/managers/label_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/label_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelManager": function() { return /* binding */ LabelManager; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");
/* harmony import */ var _lib_quadtree__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib/quadtree */ "../eyes/src/lib/quadtree.js");

// Import locals



/**
 * Label Manager class.
 * @extends BaseManager
 */
class LabelManager extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {Pioneer.Scene} scene
	 */
	constructor(app, scene) {
		super(app);

		/**
		 * Main Pioneer scene.
		 * @type {Pioneer.Scene}
		 */
		this._scene = scene;

		this._eventNames.push('hoverchange', 'labelclicked');
		this._initCallbacks();

		/**
		 * Classname for icons based on category.
		 * @type {Object<string>}
		 */
		this._iconMap = {
			Universe: 'no-icon',
			Galaxy: 'no-icon',
			Star: 'no-icon',
			Barycenter: 'icon-circle-white-small',
			'Landing site': 'icon-hexagon',
			Moon: 'icon-circle-white-small',
			Asteroid: 'icon-circle-white-small',
			'Dwarf Planet': 'icon-circle-white-small',
			Comet: 'icon-circle-white-small',
			Spacecraft: 'icon-hexagon',
			Planet: 'icon-circle-',
			Default: 'icon-circle-white-small'
		};

		/**
		 * Weight map for label priority.
		 * @type {Object<string>}
		 */
		this._weightMap = {
			Universe: '100',
			Galaxy: '100',
			Star: '100',
			Barycenter: '0',
			'Landing site': '5',
			Asteroid: '15',
			Comet: '15',
			Moon: '25',
			'Dwarf Planet': '28',
			Spacecraft: '30',
			Planet: '50'
		};

		/**
		 * An object storing weights of labels.
		 * @type {object} - { id: { weight: num }}
		 */
		this._weights = {};

		/**
		 * TODO: Seems to be unused
		 * Method for finding conflicting labels
		 * @type {number}
		 */
		this._algorithm = this.Quadtree;

		/**
		 * Quadtree object.
		 * @type {Quadtree}
		 * @private
		 */
		this._quadTree = new Quadtree({ // TODO: Quadtree is not defined nearby.
			x: 0,
			y: 0,
			width: window.innerWidth,
			height: window.innerHeight
		}, 2, 8);

		/**
		 * Custom label object storing various label information.
		 * @type {object}
		 */
		this._labels = {};

		/**
		 * Array to store collinding labels ordered by weight.
		 * @type {string[]}
		 */
		this._collidingLabels = [];

		// Manage multiple frame operations
		this._frameCount = 0;
		this._frameStep = 1;
		this._frameCycle = this._frameStep * 3;

		/**
		 * Sets name for active label class.
		 * @type {string}
		 */
		this._activeClass = 'active';

		/**
		 * Sets name for hidden label class.
		 * @type {string}
		 */
		this._hiddenClass = 'hidden';

		/**
		 * Sets default overlap percentage threshold to hide conflicting labels.
		 * @type {number} - between 0.0 and 1.0
		 */
		this._overlapThreshold = 0.25;

		/**
		 * All labels are clickable or not.
		 * @type {boolean}
		 */
		this._isClickable = true;

		/**
		 * Update loop is stopped or not.
		 * @type {boolean}
		 */
		this._isPaused = false;

		/**
		 * Stores if the label was clicked to prevent conflict with select controller.
		 * @type {boolean}
		 */
		this._allLabelsHidden = false;

		/**
		 * Exceptions on hiding labels.
		 * @type {Set}
		 */
		this._exceptions = new Set();

		/**
		 * Center bouding rect object.
		 * @type {object}
		 */
		this._centerBoundingRect = {
			name: 'center',
			x: 0,
			y: 0,
			width: 50,
			height: 50
		};

		this.bindFunctions([
			'update',
			'toggleLabels',
			'toggleLabelForEntity',
			'toggleIcons',
			'toggleIconForEntity',
			'_clickCallback',
			'setUpLabel',
			'removeLabel',
			'setUpIcon'
		]);
	}

	/**
	 * Sets the list of all entities.
	 * @param {Pioneer.Collection} entities
	 */
	setEntities(entities) {
		this._labels = {};
		for (let i = entities.size - 1; i >= 0; i--) {
			const entity = entities.get(i);
			this.addEntity(entity);
		}
	}

	/**
	 * Adds an entity to the label manager.
	 * @param {Pioneer.Entity} entity
	 */
	addEntity(entity) {
		if (entity.getComponentByType('div')) {
			this._labels[entity.getName()] = {
				name: entity.getName(),
				el: entity.getComponentByType('div').getDiv(),
				x: 0,
				y: 0,
				width: 0,
				height: 0,
				check: false,
				collisions: [],
				isHidden: false,
				isClickable: true
			};
		}
	}

	/**
	 * Removes an entity to the label manager.
	 * @param {Pioneer.Entity} entity
	 */
	removeEntity(entity) {
		if (this._labels[entity.getName()] !== undefined) {
			delete this._labels[entity.getName()];
		}
	}

	/**
	 * TODO Variable is not used anywhere
	 * Sets type of algorithm to use.
	 * @param {number} algo
	 */
	setAlgorithm(algo) {
		this._algorithm = algo;
	}

	/**
	 * Sets the scene.
	 * @param {Pioneer.Scene} scene
	 */
	setScene(scene) {
		this._scene = scene;
	}

	/**
	 * Sets weights for labels.
	 * @param {object} weights
	 * @param {boolean} reset
	 */
	setWeights(weights, reset = true) {
		if (reset) this._weights = {};
		for (const name of Object.keys(weights)) {
			// Use category weight
			const category = weights[name].category;
			this._weights[name] = {};
			if (this._weightMap[category] !== undefined) {
				this._weights[name].weight = this._weightMap[category];
			}
			else {
				this._weights[name].weight = 1;
			}
		}
	}

	/**
	 * Removes label weights.
	 * @param {object} weights
	 */
	removeWeights(weights) {
		for (const name of Object.keys(weights)) {
			if (this._weights[name]) {
				delete this._weights[name];
			}
		}
	}

	/**
	 * Gets weight for a label.
	 * @param {string} name
	 * @returns {number}
	 */
	getWeight(name) {
		if (Object.keys(this._weights).length <= 0) {
			return 0;
		}
		if (this._weights[name] !== undefined) {
			return this._weights[name].weight;
		}
		return 0;
	}

	/**
	 * Check if a label exists.
	 * @param {string} name
	 * @returns {boolean}
	 */
	isExisting(name) {
		if (this._labels[name] === undefined) {
			delete this._labels[name];
			return false;
		}
		return true;
	}

	/**
	 * Setup labels.
	 * @param {Pioneer.Entity} entity
	 * @private
	 */
	setUpLabel(entity) {
		const contentManager = /** @type {ContentManager} */ (this._app.getManager('content'));
		const layerManager = /** @type {LayerManager} */ (this._app.getManager('layer'));
		this.addEntity(entity);
		this.setLabelProps({
			getLabelClass: entityName => `no-select ${contentManager.getClassName(entityName) ?? ''}`
		}, [entity.getName()]);

		const targetId = entity.getName();
		const labelsLayer = layerManager.getLayer('labels');

		// Reset visibility of trails
		if (labelsLayer !== null && !labelsLayer.visible) {
			this.toggleLabelForEntity(false, targetId);
		}
	}

	/**
	 * Removes the label on an entity.
	 * @param {Pioneer.Entity} entity
	 * @private
	 */
	removeLabel(entity) {
		this.removeEntity(entity);
	}

	/**
	 * Callback to execute custom code for icons after entity is created.
	 * @param {Pioneer.Entity} entity
	 * @private
	 */
	setUpIcon(entity) {
		// Check status of icons with the layer manager
		// Whatever custom code for icons we need to call after entity is created.
		const layerManager = /** @type {LayerManager} */ (this._app.getManager('layer'));
		const targetId = entity.getName();
		const iconsLayer = layerManager.getLayer('icons');

		// Reset visibility of trails
		if (iconsLayer !== null && !iconsLayer.visible) {
			this.toggleIconForEntity(false, targetId);
		}
	}

	/**
	 * Sets the clickable boolean flag for a label of given label name.
	 * @param {string} labelName
	 * @param {boolean} clickable
	 */
	setLabelClickable(labelName, clickable) {
		if (this._labels[labelName]) {
			this._labels[labelName].isClickable = clickable;
			this._labels[labelName].el.classList.toggle('clickable', clickable);
		}
	}

	/**
	 * Enable/disable all labels click.
	 * @param {boolean} isClickable
	 */
	setClickable(isClickable) {
		this._isClickable = isClickable;

		for (let i = 0, l = this._scene.getNumEntities(); i < l; i++) {
			const entity = this._scene.getEntity(i);
			const divComponent = entity.get('div');
			if (divComponent !== null) {
				const div = divComponent.getDiv();
				if (isClickable) {
					div.classList.remove('unclickable');
				}
				else {
					div.classList.add('unclickable');
				}
			}
		}
	}

	/**
	 * Add label to hiding exceptions.
	 * @param {string} label
	 */
	addException(label) {
		this._exceptions.add(label);
	}

	/**
	 * Remove label from hiding exceptions.
	 * @param {string} label
	 */
	removeException(label) {
		this._exceptions.delete(label);
	}

	/**
	 * Add labels to hiding exceptions.
	 * @param {string[]} labels
	 */
	addExceptions(labels) {
		labels.forEach(label => this._exceptions.add(label));
	}

	/**
	 * Remove labels from hiding exceptions.
	 * @param {string[]} labels
	 */
	removeExceptions(labels) {
		labels.forEach(label => this._exceptions.delete(label));
	}

	/**
	 * Toggles all the label names in the scene.
	 * @param {boolean} active
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined]
	 */
	toggleLabels(active, { scene = undefined } = {}) {
		if (scene === undefined) {
			scene = this._scene;
		}

		for (let i = 0; i < scene.getNumEntities(); i++) {
			this.toggleLabelForEntity(active, scene.getEntity(i).getName(), { scene });
		}
	}

	/**
	 * Toggles the label name for the specified entity.
	 * @param {boolean} active
	 * @param {string} entityId
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined]
	 */
	toggleLabelForEntity(active, entityId, { scene = undefined } = {}) {
		let currentScene = scene;
		if (currentScene === undefined) {
			currentScene = this._scene;
		}
		const entity = currentScene.getEntity(entityId);
		const div = entity.get('div');
		if (this._exceptions.has(entity.getName())) {
			return;
		}
		if (div !== null) {
			if (active) {
				div.getDiv().lastElementChild?.classList.remove('hidden');
			}
			else {
				div.getDiv().lastElementChild?.classList.add('hidden');
			}
		}
	}

	/**
	 * Toggles all the icons in the scene.
	 * @param {boolean} active
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined]
	 */
	toggleIcons(active, { scene = undefined } = {}) {
		if (scene === undefined) {
			scene = this._scene;
		}
		for (let i = 0; i < scene.getNumEntities(); i++) {
			this.toggleIconForEntity(active, scene.getEntity(i).getName(), { scene });
		}
	}

	/**
	 * Toggles the icon for the specified entity.
	 * @param {boolean} active
	 * @param {string} entityId
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined]
	 */
	toggleIconForEntity(active, entityId, { scene = undefined } = {}) {
		let currentScene = scene;
		if (currentScene === undefined) {
			currentScene = this._scene;
		}
		const entity = currentScene.getEntity(entityId);
		const div = entity.get('div');
		if (this._exceptions.has(entity.getName())) {
			return;
		}
		if (div !== null) {
			if (active) {
				div.getDiv().firstElementChild?.classList.remove('hidden');
			}
			else {
				div.getDiv().firstElementChild?.classList.add('hidden');
			}
		}
	}

	/**
	 * Gets link from entity's name.
	 * @param {string} entityName
	 * @returns {string}
	 */
	_getLink(entityName) {
		return `/${entityName}`;
	}

	/**
	 * Callback to handle label click.
	 * @param {Pioneer.Entity} entity
	 */
	_clickCallback(entity) {
		const router = this._app.getManager('router');

		// Get parsed link if available.
		const parsedLink = this._getLink(entity.getName());

		const linkPath = typeof parsedLink === 'string' ? parsedLink : (parsedLink.path ?? '');

		const {
			options = { keepTime: true },
			query = {}
		} = typeof parsedLink === 'object' && parsedLink;

		// Go to the object, maintaining time query if it exists.
		router.navigate(query, linkPath, options);
	}

	/**
	 * setLabelProps (previously Prepare labels)
	 * @param {object} options
	 * @param {(name: string) => string} [options.getLabelClass]
	 * @param {(name: string) => string} [options.getIconClass]
	 * @param {(name: string) => string} [options.getTextClass]
	 * @param {(event: MouseEvent, name: string) => void} [options.handleClick]
	 * @param {(event: TouchEvent, name: string) => void} [options.handleTouch]
	 * @param {(event: MouseEvent, name: string) => void} [options.handleMouseEnter]
	 * @param {(event: MouseEvent, name: string) => void} [options.handleMouseLeave]
	 * @param {Array<string>} labelNames
	 * @param {Pioneer.Scene} sceneParam
	 * @param {Pioneer.Entity} cameraParam
	 */
	setLabelProps({ getLabelClass, getIconClass, getTextClass, handleClick, handleTouch, handleMouseEnter, handleMouseLeave } = {}, labelNames = Object.keys(this._labels), sceneParam, cameraParam) {
		let scene = sceneParam;
		if (!scene) {
			scene = this._scene;
		}

		let cameraEntity = cameraParam;
		if (!cameraEntity) {
			cameraEntity = scene.get('camera');
		}

		const camera = cameraEntity.getComponentByType('camera');

		// Create labels
		for (const name of labelNames) {
			const entity = scene.getEntity(name);
			const entityInfo = this._app.getManager('content').getEntityInfo(name);
			const divComponent = entity.get('div');

			if (divComponent === null) continue;

			// Set active camera
			divComponent.setActiveCamera(camera);

			// Get label element.
			const labelEl = divComponent.getDiv();

			// Call the getLabelClass if it's passed.
			const labelClass = typeof getLabelClass === 'function' ? getLabelClass(name) : '';
			labelEl.className += ` ${labelClass} clickable`;

			// Create icon and text child elements.
			const iconEl = document.createElement('span');
			const textEl = document.createElement('span');

			// Determine icon classes.
			const iconMapClass = this._iconMap[entityInfo?.category] ?? this._iconMap.Default;
			const iconNameClass = entityInfo?.category === 'Planet' ? name : '';
			const iconCallbackClass = typeof getIconClass === 'function' ? getIconClass(name) : '';
			iconEl.className = `icon ${iconMapClass}${iconNameClass} ${iconCallbackClass}`;
			// Determine textEl classes and inner html.
			textEl.className = `text ${typeof getTextClass === 'function' ? getTextClass(name) : ''}`;
			textEl.innerHTML = entityInfo?.displayName || entityInfo?.iauName || labelEl.innerHTML;

			// Clear any labelEl html.
			labelEl.innerHTML = '';

			// Append the babes.
			labelEl.appendChild(iconEl);
			labelEl.appendChild(textEl);

			// Define default click/touch/hover handlers
			const defaultOnClick = async event => {
				const labelInfo = this._labels[name];

				if (!this._isClickable || !labelInfo?.isClickable) {
					return;
				}

				if (this._clickCallback !== null) {
					console.log(this._clickCallback)
					this._clickCallback(entity);
					event.preventDefault();
					this.triggerCallbacks('labelclicked', [true]);
				}
			};

			const defaultOnTouchEnd = async event => {
				const labelInfo = this._labels[name];

				if (!this._isClickable || !labelInfo?.isClickable) {
					return;
				}
				if (!this.app.isDragging() && !this.app.isTouchMax() && this._clickCallback !== null) {
					this._clickCallback(entity);
					event.preventDefault();
					this.triggerCallbacks('labelclicked', [true]);
				}
			};

			// Prevent touch or mouse conflict, trigger callbacks for labelclicked state.
			labelEl.addEventListener('mousedown', event => {
				event.preventDefault();
				this.triggerCallbacks('labelclicked', [false]);
			});
			labelEl.addEventListener('touchstart', event => {
				event.preventDefault();
				this.triggerCallbacks('labelclicked', [false]);
			});

			const defaultOnMouseEnter = () => this.triggerCallbacks('hoverchange', [name, true]);
			const defaultOnMouseLeave = () => this.triggerCallbacks('hoverchange', [name, false]);

			// Determine handlers if they are passed as options
			const onClick = typeof handleClick === 'function' ? event => handleClick(event, name) : defaultOnClick;
			const onTouchEnd = typeof handleTouch === 'function' ? event => handleTouch(event, name) : defaultOnTouchEnd;
			const onMouseEnter = typeof handleMouseEnter === 'function' ? event => handleMouseEnter(event, name) : defaultOnMouseEnter;
			const onMouseLeave = typeof handleMouseLeave === 'function' ? event => handleMouseLeave(event, name) : defaultOnMouseLeave;

			// There's probably a neater way to do this.
			if (handleClick !== null && labelEl.getAttribute('hasClickListener') !== 'true') {
				labelEl.setAttribute('hasClickListener', 'true');
				labelEl.addEventListener('click', onClick);
			}
			if (handleTouch !== null && labelEl.getAttribute('hasTouchEndListener') !== 'true') {
				labelEl.setAttribute('hasTouchEndListener', 'true');
				labelEl.addEventListener('touchend', onTouchEnd);
			}
			if (handleMouseEnter !== null && labelEl.getAttribute('hasMouseEnterListener') !== 'true') {
				labelEl.setAttribute('hasMouseEnterListener', 'true');
				labelEl.addEventListener('mouseenter', onMouseEnter);
			}
			if (handleMouseLeave !== null && labelEl.getAttribute('hasMouseLeaveListener') !== 'true') {
				labelEl.setAttribute('hasMouseLeaveListener', 'true');
				labelEl.addEventListener('mouseleave', onMouseLeave);
			}
			if (labelEl.getAttribute('hasMouseMoveListener') !== 'true') {
				labelEl.setAttribute('hasMouseMoveListener', 'true');
				labelEl.addEventListener('mousemove', event => {
					event.preventDefault();
				}, true);
			}
		}
	}

	/**
	 * Adds specific class to list of label divs
	 * @param {string} className
	 * @param {Array<string>} labelNames
	 */
	addClassToLabels(className, labelNames) {
		for (const name of labelNames) {
			const entity = this._scene.getEntity(name);
			const labelEl = entity?.get('div')?.getDiv();

			labelEl?.classList.add(className);
		}
	}

	/**
	 * Removes specific class from list of label elements
	 * @param {string} className
	 * @param {Array<string>} labelNames
	 */
	removeClassFromLabels(className, labelNames) {
		for (const name of labelNames) {
			const entity = this._scene.getEntity(name);
			const labelEl = entity?.get('div')?.getDiv();

			labelEl?.classList.remove(className);
		}
	}

	/**
	 * Gets the item at the center of the screen.
	 * @returns {object}
	 */
	getItemAtCenter() {
		this._centerBoundingRect.x = (window.innerWidth / 2 - this._centerBoundingRect.width / 2);
		this._centerBoundingRect.y = (window.innerHeight / 2 - this._centerBoundingRect.height / 2);

		const candidates = this._quadTree.retrieve(this._centerBoundingRect);
		// Loop through candidates
		for (let i = 0; i < candidates.length; i++) {
			const candidate = candidates[i];

			candidate.y += candidate.height / 2;
			candidate.width = this._centerBoundingRect.width;
			candidate.height = this._centerBoundingRect.height;

			if (this._checkCollision(candidate, this._centerBoundingRect)) {
				return candidate;
			}
		}
		return null;
	}

	/**
	 * Builds a quadtree and update all labels.
	 */
	_buildQuadtree() {
		this._quadTree.clear();
		for (const [key, label] of Object.entries(this._labels)) {
			if (this._isPaused) {
				return;
			}
			const div = label.el;
			const rect = div.getBoundingClientRect();

			// Skip if div is not displayed
			if (div.style.opacity === '0') {
				label.check = false;
				continue;
			}
			// Skip if div is out of window
			if (this._isOutOfWindow(rect)) {
				label.check = false;
				continue;
			}

			// Set label info
			label.x = rect.x;
			label.y = rect.y;
			label.width = rect.width;
			label.height = rect.height;
			label.check = true;
			label.collisions = [];
			label.isHidden = false;
			const camera = this._scene.get('camera', 'camera');
			const entity = this._scene.get(label.name);
			label.z = entity?.getCameraSpacePosition(camera).magnitude() || 0;
			// Insert into quad tree
			this._quadTree.insert(label);
		}
	}

	/**
	 * Checks collisions with Quadtree method.
	 */
	_checkWithQuadtree() {
		// Check collision for each label
		for (const key of Object.keys(this._labels)) {
			if (this._isPaused) {
				return;
			}
			const label = this._labels[key];
			if (!label.check) {
				continue;
			}
			const candidates = this._quadTree.retrieve(label);

			// Loop through candidates
			for (let i = 0; i < candidates.length; i++) {
				const candidate = candidates[i];
				if (candidate.check && this._checkCollision(candidate, label) && label.name !== candidate.name) {
					if (this._overlap(candidate, label) >= this._overlapThreshold) {
						this._addCollision(candidate.name, label.name);
					}
				}
			}
		}
	}

	// Debug function
	// _drawQuadtree(node) {
	// 	let bounds = node.bounds;
	// 	let ctx = document.getElementById('canvas').getContext('2d');
	// 	if (node.nodes.length === 0) {
	// 		ctx.strokeStyle = 'rgba(255,0,0,0.5)';
	// 		ctx.strokeRect(bounds.x, bounds.y, bounds.width, bounds.height);
	// 	}
	// 	else {
	// 		for (let i = 0; i < node.nodes.length; i = i + 1) {
	// 			this._drawQuadtree(node.nodes[i]);
	// 		}
	// 	}
	// }

	/**
	 * Adds a collision to the temporary array.
	 * @param {string} label1
	 * @param {string} label2
	 */
	_addCollision(label1, label2) {
		if (this._collidingLabels.indexOf(label1) < 0) {
			this._collidingLabels.push(label1);
		}
		if (this._collidingLabels.indexOf(label2) < 0) {
			this._collidingLabels.push(label2);
		}
		this._labels[label1]?.collisions.push(label2);
	}

	/**
	 * Helper function to check if there is a collision between two rects.
	 * @param {object} rect1
	 * @param {object} rect2
	 * @returns {boolean}
	 */
	_checkCollision(rect1, rect2) {
		if (rect1.x < rect2.x + rect2.width
			&& rect1.x + rect1.width > rect2.x
			&& rect1.y < rect2.y + rect2.height
			&& rect1.y + rect1.height > rect2.y) {
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * Solves collisions.
	 */
	_fixCollisions() {
		// Sort colliding labels
		this._sort();

		// For each label ordered by weight and z order
		// determine if we need to show it or not
		for (let i = 0; i < this._collidingLabels.length; i++) {
			if (this._isPaused) {
				return;
			}
			const label = this._collidingLabels[i];
			if (!this.isExisting(label)) {
				continue;
			}

			// Skip already hidden labels
			// to avoid waterfall effect
			if (this._labels[label].isHidden) {
				continue;
			}
			else {
				// Show label
				this._showLabel(label);
			}
			// Hide its collisions
			for (let j = 0; j < this._labels[label].collisions.length; j++) {
				const collision = this._labels[label].collisions[j];
				this._hideLabel(collision);
			}
		}

		// Restore labels that are not conflicting
		this._restoreLabels();
	}

	/**
	 * Sorts colliding labels.
	 */
	_sort() {
		// Order labels by weight or z order
		this._collidingLabels.sort((a, b) => {
			if (this.getWeight(b) - this.getWeight(a) !== 0) {
				return this.getWeight(b) - this.getWeight(a);
			}
			else {
				return this.getZ(a) - this.getZ(b);
			}
		});
	}

	/**
	 * Calculates overlap percentage on two rects.
	 * @param {object} rect1
	 * @param {object} rect2
	 * @returns {number}
	 */
	_overlap(rect1, rect2) {
		const overlap = (Math.min(rect1.x + rect1.width, rect2.x + rect2.width) - Math.max(rect1.x, rect2.x))
		* (Math.min(rect1.y + rect1.height, rect2.y + rect2.height) - Math.max(rect1.y, rect2.y));
		const a1 = rect1.width * rect1.height;
		const a2 = rect2.width * rect2.height;
		const percentage = overlap / (a1 + a2 - overlap);
		return percentage;
	}

	/**
	 * Helper function to check if rect is outside of window.
	 * @param {object} rect
	 * @returns {boolean}
	 */
	_isOutOfWindow(rect) {
		if (rect.x > window.innerWidth || rect.x + rect.width < 0 || rect.y > window.innerHeight || rect.y + rect.height < 0) {
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * Restores label visibility.
	 */
	_restoreLabels() {
		if (this._allLabelsHidden === true) {
			return;
		}
		for (const key of Object.keys(this._labels)) {
			const label = this._labels[key];
			if (!label.isHidden) {
				this._showLabel(label.name);
			}
			if (label.collisions.length === 0) {
				this._showLabel(label.name);
			}
		}
	}

	/**
	 * Shows a label.
	 * @param {string} label
	 */
	_showLabel(label) {
		const object = this.pioneer.get('main', label);
		const div = object?.getComponentByType('div').getDiv();
		div?.classList.add(this._activeClass);
		div?.classList.remove(this._hiddenClass);
		this._labels[label].isHidden = false;
	}

	/**
	 * Hides a label.
	 * @param {string} label
	 */
	_hideLabel(label) {
		if (this._exceptions.has(label)) {
			return;
		}
		const object = this.pioneer.get('main', label);
		if (object === null) {
			return;
		}
		const div = object.getComponentByType('div').getDiv();
		div.classList.add(this._hiddenClass);
		div.classList.remove(this._activeClass);
		this._labels[label].isHidden = true;
	}

	/**
	 * Gets Z position in camera space.
	 * @param {string} name
	 * @returns {number}
	 */
	getZ(name) {
		if (this.isExisting(name)) {
			return this._labels[name].z;
		}
	}

	/**
	 * Stops the update loop.
	 */
	stop() {
		this._isPaused = true;
	}

	/**
	 * Starts the update loop.
	 */
	start() {
		this._isPaused = false;
	}

	/**
	 * Called every frame to update the labels.
	 */
	update() {
		if (this._isPaused) {
			return;
		}

		// Spread operations accross multiple frames
		if (this._frameCount === 0) {
			this._collidingLabels = [];
			this._buildQuadtree();
		}
		else if (this._frameCount === this._frameCycle / 3) {
			this._checkWithQuadtree();
		}
		else if (this._frameCount === 2 * this._frameCycle / 3) {
			this._fixCollisions();
		}

		this._frameCount++;
		this._frameCount %= this._frameCycle;
	}
}

// Label manager algorithm modes
// TODO Seems to be used by setAlgorithm, which has unused this._algorithm
LabelManager.Quadtree = 1;
LabelManager.BruteForce = 0;


/***/ }),

/***/ "../eyes/src/managers/layer_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/layer_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LayerManager": function() { return /* binding */ LayerManager; }
/* harmony export */ });
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");




/**
 * @typedef ToggleParams
 * @property {string} [layerId]
 * @property {string} [parentId]
 * @property {string} [group]
 */

/**
 * @typedef {(visible: boolean, params: ToggleParams) => void} ToggleCallback
 */

/**
 * @typedef Layer
 * @property {string} name
 * @property {string} group
 * @property {boolean} defaultVisibility
 * @property {boolean} visible
 * @property {string[]} categories
 * @property {string[]} sublayers
 * @property {string} [parent]
 * @property {Array<ToggleCallback>} toggleCallback
 */

/**
 * Layer manager class.
 */
class LayerManager extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * The scene manager.
		 * @type {SceneManager}
		 * @private
		 */
		this._sceneManager = /** @type {SceneManager} */(app.getManager('scene'));

		/**
		 * The content manager
		 * @type {ContentManager}
		 * @private
		 */
		this._contentManager = /** @type {ContentManager} */(app.getManager('content'));

		/**
		 * @type {Object<string, Layer>}
		 * @private
		 */
		this._layers = {};

		/**
		 * List of possible contextual layers to check when parent entity changes.
		 * @type {string[]}
		 */
		this._contextualLayersList = ['majorMoons', 'minorMoons', 'landers', 'orbiters', 'satelliteGroup', 'heliosphere'];

		this._targetId = '';
		this._previousTarget = /** @type {string[]} */([]);
		this._dependencies = new Set();
		this._previousDependencies = new Set();

		this.bindFunctions([
			'resetContextualVisibility',
			'toggleLayer',
			'changeSpheroidMap',
			'resetContextualLayers'
		]);

		// Add toggle layer
		this._eventNames.push('toggleLayer');
		this._initCallbacks();
	}

	/**
	 * Adds a layer to the layer manager.
	 * @param {string} id
	 * @param {object} options - the options used to setup the layer
	 * @param {string} [options.name = ''] - layer name
	 * @param {string} [options.group = ''] - pioneer scripts group
	 * @param {string | string[]} [options.categories = []] - entity info categories
	 * @param {boolean} [options.defaultVisibility = true] - default visibility
	 * @param {ToggleCallback | Array<ToggleCallback>} [options.toggleCallback = []] - callback list
	 * @param {string[]} [options.sublayers = []] - layers that will be overriden by this one
	 */
	addLayer(id, { name = '', group = '', categories = [], defaultVisibility = true, toggleCallback = [], sublayers = [] }) {
		if (this._layers[id] === undefined) {
			this._layers[id] = /** @type {Layer} */({});
		}
		this._layers[id].name = name;
		this._layers[id].group = group;
		this._layers[id].defaultVisibility = defaultVisibility;
		this._layers[id].visible = defaultVisibility;

		// Categories
		if (!Array.isArray(categories)) {
			categories = [categories];
		}
		this._layers[id].categories = categories;

		// Sublayers
		if (!Array.isArray(sublayers)) {
			sublayers = [sublayers];
		}
		this._layers[id].sublayers = sublayers;
		for (let i = 0; i < sublayers.length; i++) {
			const sublayer = sublayers[i];
			if (this._layers[sublayer] === undefined) {
				this._layers[sublayer] = /** @type {Layer} */({});
			}
			this._layers[sublayer].parent = id;
		}

		// Callbacks
		if (!Array.isArray(toggleCallback)) {
			toggleCallback = [toggleCallback];
		}
		this._layers[id].toggleCallback = toggleCallback;
	}

	/**
	 * Adds a toggle callback to a layer.
	 * @param {string} id
	 * @param {ToggleCallback} toggleCallback
	 */
	addCallback(id, toggleCallback) {
		const layer = this.getLayer(id);
		if (layer === null) {
			return;
		}
		layer.toggleCallback.push(toggleCallback);
	}

	/**
	 * Removes a toggle callback from a layer.
	 * @param {string} id
	 * @param {ToggleCallback} toggleCallback
	 * @override
	 */
	removeCallback(id, toggleCallback) {
		const layer = this.getLayer(id);
		if (layer === null) {
			return;
		}
		const index = layer.toggleCallback.indexOf(toggleCallback);
		layer.toggleCallback.splice(index, 1);
	}

	/**
	 * Gets a layer.
	 * @param {string} id
	 * @returns {Layer}
	 */
	getLayer(id) {
		if (this._layers[id] === undefined) {
			return null;
		}
		return this._layers[id];
	}

	/**
	 * Change the spheroid texture to new map
	 * @param {string} id
	 * @param {any} textureDescription
	 */
	async changeSpheroidMap(id, textureDescription) {
		if (textureDescription.type === 'cmts') {
			console.error('This function does not yet handle CMTS texture');
			return;
		}
		const sceneManager = /** @type {SceneManager} */(this.app.getManager('scene'));
		const spheroidLOD = /** @type {SpheroidLODComponent} */ (sceneManager.get('main').getEntity(id)?.getComponentByType('spheroidLOD'));
		const atmosphere = /** @type {AtmosphereComponent} */ (sceneManager.get('main').getEntity(id)?.getComponentByType('atmosphere'));
		const wmts = /** @type {WMTSComponent} */ (sceneManager.get('main').getEntity(id)?.getComponentByType('wmts'));

		if (spheroidLOD && textureDescription.type === 'texture') {
			spheroidLOD.setEnabled(true);
			sceneManager.addLoading(id, 'spheroidLOD');
			Object.keys(textureDescription.textures).forEach(key => {
				const url = '$STATIC_ASSETS_URL/maps/' + textureDescription.textures[key].url;
				spheroidLOD.setTexture(key, url, textureDescription.textures[key].sizes);
			});
			await sceneManager.pioneer.waitUntilNextFrame();
			await spheroidLOD.getLoadedPromise();
			if (wmts !== null) {
				wmts.setEnabled(false);
			}
			sceneManager.removeLoading(id, 'spheroidLOD');
		}
		else if (textureDescription.type === 'wmts') {
			// Add WMTS components
			if (wmts === null) {
				await sceneManager.addWMTSComponent(id, textureDescription);
			}
			else if (wmts.isEnabled() === false) {
				await sceneManager.enableWMTSComponent(id, wmts);
			}
		}
		if (atmosphere !== null && atmosphere !== undefined) {
			atmosphere.setEnabled(textureDescription.features.includes('atmosphere'));
		}
		/** @type {ContentPanel} */(this.app.getComponent('contentPanel'))?.updateHDButton();

		// Flip Titan surface map 180 deg until we can fix it officially in Pioneer (TODO)
		if (id === 'titan') {
			this.app.pioneer.get('main', 'titan', 'spheroidLOD').setLongitudeRotation(pioneer__WEBPACK_IMPORTED_MODULE_1__.MathUtils.degToRad(180));
		}
	}

	/**
	 * Toggles a layer on and off.
	 * @param {string} id
	 * @param {ToggleParams} [params={}]
	 * @param {boolean} [forceVisibility]
	 */
	async toggleLayer(id, params = {}, forceVisibility) {
		const { spout, spoutFontSize } = this.app.getManager('router').configs;

		if (this._layers[id] === undefined) {
			return;
		}
		params.layerId = id;
		if (forceVisibility !== undefined && this._layers[id].visible === forceVisibility) {
			return;
		}
		this._layers[id].visible = !this._layers[id].visible;
		for (let i = 0; i < this._layers[id].toggleCallback.length; i++) {
			const callback = this._layers[id].toggleCallback[i];
			callback(this._layers[id].visible, params);
		}

		for (let i = 0; i < this._layers[id].sublayers.length; i++) {
			const sublayer = this.getLayer(this._layers[id].sublayers[i]);
			sublayer.visible = this._layers[id].visible;
			this.triggerCallbacks('toggleLayer', [this._layers[id].sublayers[i], this._layers[id].visible, params]);
		}

		this.triggerCallbacks('toggleLayer', [id, this._layers[id].visible, params]);

		const sceneManager = /** @type {SceneManager} */(this.app.getManager('scene'));

		// Make sure the scene is showing the right layers.
		if (params.parentId !== null && params.parentId !== undefined) {
			sceneManager.updateEntityLayerVisibilityForChildren(params.parentId, params.satelliteGroup);
		}
		else {
			sceneManager.updateEntityLayerVisibility(params.satelliteGroup);
		}

		// Add Spout labels to layers
		if (spout === true && this._layers[id].visible) {
			const relevantEntities = [];
			await this.pioneer.waitUntilNextFrame();

			if (id.toLowerCase().includes('constellations')) {
				const constellations = this.app.pioneer.get('main', 'sun').getComponentByType('constellations');
				constellations.getNames().forEach(name => {
					relevantEntities.push(this.app.pioneer.get('main').getEntity(`constellation_label_${name}`));
				});
			}

			await this.app.getManager('spout').setUpSpoutLabels(spoutFontSize, relevantEntities?.[0]?.id);
		}
	}

	/**
	 * Sets target entity id.
	 * @param {string} entityId
	 */
	setTarget(entityId) {
		// Store previous targets and dependencies
		this._previousTarget.push(this._targetId);
		this._previousDependencies = new Set([...this._previousDependencies, ...this._dependencies]);
		// Update target id
		this._targetId = entityId;
		this._dependencies.clear();

		if (this._targetId !== '') {
			// Check for dependencies and activate them if needed
			const dependencies = this._sceneManager.getDependencies(this._targetId);
			this._dependencies = new Set(dependencies);
		}
	}

	/**
	 * Clean previous targets and dependencies visibility status.
	 */
	resetTarget() {
		// Dont clean if the camera is using one of the previous target
		// Cleanup will happen in a later call to resetTarget
		for (let i = 0; i < this._previousTarget.length; i++) {
			const previousTarget = this._previousTarget[i];
			const cameraEntity = /** @type {CameraManager} */(this.app.getManager('camera')).cameraEntity;
			if (cameraEntity === null || cameraEntity.getParent() === null) {
				return;
			}
			if (cameraEntity.getParent().getName() === previousTarget) {
				return;
			}
		}

		// Clean all the previous targets
		for (let i = 0; i < this._previousTarget.length; i++) {
			const previousTarget = this._previousTarget[i];

			// Reset contextual layers of the previous target to their original value
			this.resetContextualVisibility(previousTarget);
		}
		this._previousTarget = [];

		this._previousDependencies.clear();
	}

	/**
	 * Resets visibility defaults for contextual toggles
	 * @param {string} previousTarget
	 */
	resetContextualVisibility(previousTarget) {
		// Get the first ancestor of the previous target with contextual layers.
		const time = this._sceneManager.main.getEngine().getTime();
		let contextualLayers = this.getContextualLayers(previousTarget);
		while (previousTarget !== '' && contextualLayers.length === 0) {
			previousTarget = pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Parenting.getParentOfEntity(previousTarget, time);
			contextualLayers = this.getContextualLayers(previousTarget);
		}
		// Get the first ancestor of the current target with contextual layers.
		let currentTarget = this._targetId;
		contextualLayers = this.getContextualLayers(currentTarget);
		while (currentTarget !== '' && contextualLayers.length === 0) {
			currentTarget = pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Parenting.getParentOfEntity(currentTarget, time);
			contextualLayers = this.getContextualLayers(currentTarget);
		}
		if (currentTarget === previousTarget) {
			return;
		}
		this._contextId = previousTarget;
		for (let i = 0; i < contextualLayers.length; i++) {
			const layerName = contextualLayers[i];
			const layer = this.getLayer(layerName);

			// Parent visibility overrides default values
			if (layer.parent !== undefined) {
				const parentLayer = this.getLayer(layer.parent);
				if (parentLayer.visible !== layer.visible) {
					this.toggleLayer(layerName, { parentId: previousTarget, group: layer.group });
				}
			}
			else if (layer.visible !== layer.defaultVisibility) {
				// Otherwise restore to default value
				this.toggleLayer(layerName, { parentId: previousTarget, group: layer.group });
			}
		}
	}

	/**
	 * Gets the target entity id.
	 * @returns {string}
	 */
	getTarget() {
		return this._targetId;
	}

	/**
	 * Gets an entity layer.
	 * @param {*} id
	 * @returns {Layer|null}
	 */
	getEntityLayer(id) {
		const entityInfo = this._contentManager.getEntityInfo(id);
		if (entityInfo === null) {
			return null;
		}
		const category = entityInfo.category;
		const subcategory = entityInfo.subcategory;
		const layer = this.getLayerFromCategory(subcategory) || this.getLayerFromCategory(category);
		return layer;
	}

	/**
	 * Gets a layer tied to a category.
	 * @param {string} category
	 * @returns {Layer|null}
	 */
	getLayerFromCategory(category) {
		if (!category) {
			return null;
		}
		for (const [key, value] of Object.entries(this._layers)) {
			if (value.categories.includes(category)) {
				return this._layers[key];
			}
		}
		return null;
	}

	/**
	 * Gets a layer tied to a satellite group.
	 * @param {string} group
	 * @returns {Layer|null}
	 */
	getLayerFromSatelliteGroup(group) {
		if (!group) {
			return null;
		}
		for (const [key, value] of Object.entries(this._layers)) {
			if (value.categories.includes(group)) {
				return this._layers[key];
			}
		}
		return null;
	}

	/**
	 * Get a list of contextual layers available for a planet. (Major Moons, Minor Moons, Landers, Orbiters, Rovers, Heliosphere)
	 * @param {string} parent
	 * @returns {Array<string>} layerList
	 */
	getContextualLayers(parent) {
		const availableLayers = /** @type {string[]} */([]);
		if (parent === '') {
			return availableLayers;
		}

		const contentManager = /** @type {ContentManager} */(this.app.getManager('content'));
		const entityInfo = contentManager.getEntityInfo(parent);
		const moons = entityInfo?.hasMoons ? pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Entity.getEntityNamesInGroup(parent + ', moons') : new Set();
		const spacecraft = pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Entity.getEntityNamesInGroup(parent + ', spacecraft');
		// Include heliosphere for Sun
		if (parent === 'sun') {
			if (availableLayers.includes('heliosphere') === false) {
				availableLayers.push('heliosphere');
			}
		}
		// Include major and minor moons if have
		moons.forEach(moon => {
			const moonEntityInfo = contentManager.getEntityInfo(moon);
			if (moonEntityInfo !== null) {
				const category = moonEntityInfo.subcategory || moonEntityInfo.category;
				switch (category) {
					case 'Major Moon':
						if (availableLayers.includes('majorMoons') === false) {
							availableLayers.push('majorMoons');
						}
						break;
					case 'Minor Moon':
						if (availableLayers.includes('minorMoons') === false) {
							availableLayers.push('minorMoons');
						}
						break;
					default:
						break;
				}
			}
		});
		// Include orbiters and landers if has spacecrafts
		const time = this._app.pioneer.getTime();
		spacecraft.forEach(sc => {
			const entityInfo = contentManager.getEntityInfo(sc);
			if (entityInfo !== null) {
				const category = entityInfo.subcategory || entityInfo.category;
				switch (category) {
					case 'Orbiter':
						if (availableLayers.includes('orbiters') === false) {
							if (pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Parenting.getParentOfEntity(sc, time) === parent) {
								availableLayers.push('orbiters');
							}
						}
						break;
					case 'Landing Site':
					case 'Lander':
					case 'Rover':
						if (availableLayers.includes('landers') === false) {
							if (pioneer_scripts__WEBPACK_IMPORTED_MODULE_0__.Parenting.getParentOfEntity(sc, time) === parent) {
								availableLayers.push('landers');
							}
						}
						break;
					default:
						break;
				}
			}
		});

		// Include satellite group if have
		if (entityInfo?.constellation) {
			availableLayers.push('satelliteGroup');
		}

		availableLayers.sort((a, b) => {
			const layers = Object.keys(this._layers);
			return layers.indexOf(a) - layers.indexOf(b);
		});

		return availableLayers;
	}

	/**
	 * Resets all contextual layers of the old parent to their default state.
	 * Used in the case of an entity changing parents (Object View).
	 * @param {string} newParent
	 * @param {string} oldParent
	 */
	resetContextualLayers(newParent, oldParent) {
		const newLayers = this.getContextualLayers(newParent);
		this._contextualLayersList.forEach(layer => {
			if (newLayers.includes(layer) === false) {
				if (layer === 'heliosphere') {
					this.toggleLayer(layer, { parentId: undefined }, false);
				}
				else {
					this.toggleLayer(layer, { parentId: oldParent }, this.getLayer(layer).defaultVisibility || false);
				}
			}
		});
	}

	/**
	 * Returns true if the entity should be visible with the currently visible layers. If there's no valid layer, it returns true.
	 * @param {string} entityName
	 * @param {string} satelliteGroup - The satellite group to check against entities
	 * @returns {boolean}
	 */
	isEntityVisibleWithCurrentLayers(entityName, satelliteGroup) {
		const entityInfo = this._contentManager.getEntityInfo(entityName);
		if (entityInfo !== null) {
			const layer = this.getLayerFromCategory(entityInfo.category);
			const sublayer = this.getLayerFromCategory(entityInfo.subcategory);
			const satelliteGroupLayer = this.getLayerFromSatelliteGroup(entityInfo.constellation);

			// Check status of spacecraft constellation first if in it
			if (satelliteGroupLayer !== null && entityInfo.constellation === satelliteGroup) {
				return satelliteGroupLayer.visible;
			}
			// Check status of sublayer first
			if (sublayer !== null) {
				return sublayer.visible;
			}
			// Check status of layer
			if (layer !== null) {
				return layer.visible;
			}
			// If no layer then it is visible
			if (layer === null && sublayer === null) {
				return true;
			}

			return false;
		}
		// If it doesn't have an entity info, then it has no layer, so it's always visible.
		else {
			return true;
		}
	}
}


/***/ }),

/***/ "../eyes/src/managers/route_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/route_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RouteManager": function() { return /* binding */ RouteManager; }
/* harmony export */ });
/* harmony import */ var navigo__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! navigo */ "../eyes/node_modules/navigo/lib/navigo.min.js");
/* harmony import */ var navigo__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(navigo__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");



/**
 * Route Manager class.
 * @extends BaseManager
 */
class RouteManager extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * Router instance that handles all routing.
		 * @type {Navigo}
		 * @private
		 * @default
		 */
		this._router = new (navigo__WEBPACK_IMPORTED_MODULE_0___default())(null, true);

		/**
		 * Information of previous route.
		 * @type {null|object}
		 * @private
		 * @default
		 */
		this._previousRoute = null;

		/**
		 * Information of current route.
		 * @type {object}
		 * @private
		 * @default
		 */
		this._currentRoute = {};

		/**
		 * Flag indicating first app load or not.
		 * @type {boolean}
		 * @private
		 * @default
		 */
		this._firstLoad = true;

		/**
		 * Stored queries.
		 * @type {object}
		 * @private
		 * @default
		 */
		this._query = {};

		/**
		 * Persistent queries. Can only be removed by function.
		 * @type {object}
		 * @private
		 * @default
		 */
		this._configs = {};

		/**
		 * List of valid query keys.
		 * @type {Array}
		 * @private
		 * @default
		 */
		this._validQueries = [];

		/**
		 * Route for home.
		 * @type {string}
		 * @private
		 * @default
		 */
		this._homeRoute = '/home';

		/**
		 * A way to subscribe to query changes in all views
		 */
		this._queryCallbacks = {};

		/**
		 * Previous view.
		 * @type {string}
		 */
		this._previousView = null;

		/**
		 * Current view.
		 * @type {string}
		 */
		this._currentView = null;
		/**
		 * Components that are always hidden on first load, even on view change
		 * @type {Array<string>}
		 */
		this._alwaysHiddenComponents = [];


		this.bindFunctions([
			'navigate',
			'onRootRoute',
			'onNotFound',
			'leave'
		]);
	}

	/**
	 * Get the route for home.
	 * @returns {string}
	 */
	get homeRoute() {
		return this._homeRoute;
	}

	/**
	 * Getter for previous route.
	 * @returns {object}
	 */
	get previousRoute() {
		return this._previousRoute;
	}

	/**
	 * Getter for current route.
	 * @returns {object}
	 */
	get currentRoute() {
		return this._currentRoute;
	}

	/**
	 * Getter for current query.
	 * @returns {object}
	 */
	get query() {
		return this._query;
	}

	/**
	 * Getter for current configs.
	 * @returns {object}
	 */
	get configs() {
		return this._configs;
	}

	/**
	 * Gets the current view.
	 * @returns {string}
	 */
	get currentView() {
		return this._currentView;
	}

	/**
	 * Sets the current view.
	 * @param {string} view
	 */
	set currentView(view) {
		this._currentView = view;
	}

	/**
	 * Gets the previous view.
	 * @returns {string}
	 */
	get previousView() {
		return this._previousView;
	}

	/**
	 * Initialize the router.
	 * @param {Function} onBefore
	 * @param {Function} onAfter
	 */
	init(onBefore, onAfter) {
		this._router.hooks({
			before: async done => {
				this._previousRoute = { ...this._currentRoute };
				this._currentRoute = this._router.lastRouteResolved() || {};

				// Remove extra slash
				if (this._currentRoute.url) {
					this._currentRoute.url = this._currentRoute.url.replace(/(\/)+/, '/');
				}

				// Update query
				this.addQuery(this.parseQuery(this.currentRoute.query));

				if (typeof onBefore === 'function') {
					await onBefore(this._currentRoute, this._previousRoute);
				}

				done();
			},
			after: async () => {
				if (typeof onAfter === 'function') {
					await onAfter(this._currentRoute, this._previousRoute);
				}

				this._firstLoad = false;
			}
		});

		this._router
			.on(this.onRootRoute)
			.notFound(this.onNotFound)
			.on('milky_way', this.onNotFound)
			.on('observable_universe', this.onNotFound);
	}

	/**
	 * Execute on leaving a route.
	 * @param {object} params - Parameters from url
	 */
	leave(params) {
		// Cancel token
		params.cancelToken.cancel();
	}

	/**
	 * Handle root route.
	 * @param {string} query
	 */
	onRootRoute(query) {
		this.reroute(this._homeRoute, query);
	}

	/**
	 * Handle not found routes.
	 * @param {string} query
	 */
	onNotFound(query) {
		// Called when there is path specified but
		// there is no route matching
		let newRoute = this._homeRoute;
		// Try to pass the query stored in the params
		// to the new route
		if (query) {
			newRoute += '?' + query;
		}
		this._router.navigate(newRoute);
	}

	/**
	 * A way to replace a history state which essentially makes the back button skip the current route
	 * @param {string} replaceStr
	 */
	replaceState(replaceStr) {
		history.replaceState({}, '', replaceStr);
	}

	/**
	 * Reroute to a new path without adding a new step in the history.
	 * @param {string} path
	 * @param {string|object} [query='']
	 */
	reroute(path, query = '') {
		let queryString;
		if (typeof query === 'string') {
			query = this.parseQuery(query);
		}
		const configs = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.filterObject(this._configs, val => val !== undefined);
		queryString = this.buildQuery({ ...query, ...configs });
		const pathname = window.location.pathname;
		history.replaceState(queryString, '', `${pathname}#${path}${queryString}`);
		this._router.resolve();
	}

	/**
	 * Add cancel token to params. Create params for route without one.
	 * @param {object} params
	 * @returns {object}
	 */
	addCancelToken(params) {
		const output = params || {};
		output.cancelToken = new _internal__WEBPACK_IMPORTED_MODULE_1__.CancelToken();
		return output;
	}

	/**
	 * Get the last resolved route.
	 * @returns {object}
	 */
	lastRouteResolved() {
		return this._router.lastRouteResolved();
	}

	/**
	 * Get the last resolved path.
	 * @returns {string}
	 */
	lastPathResolved() {
		const lastRoute = this._router.lastRouteResolved();
		return lastRoute.query ? lastRoute.url + '?' + lastRoute.query : lastRoute.url;
	}

	/**
	 * Get only the path part, or first hash part if path is hash.
	 * @param {string} url
	 * @returns {string}
	 */
	getOnlyURL(url) {
		let onlyURL = url;
		const split = url.split('#');
		onlyURL = split.length > 1 ? this._cleanGETParam(split[1]) : this._cleanGETParam(split[0]);
		return onlyURL;
	}

	/**
	 * Get the first part of a url, also remove query.
	 * @private
	 * @param {string} url
	 * @returns {string}
	 */
	_cleanGETParam(url) {
		return url.split(/\?(.*)?$/)[0];
	}

	/**
	 * Get the list of valid query keys.
	 * @returns {Array}
	 */
	getValidQueries() {
		return this._validQueries;
	}

	/**
	 * Set the list of valid query keys.
	 * @param {Array} list
	 */
	setValidQueries(list) {
		this._validQueries = list;
	}

	/**
	 * Parse a string and return a query object.
	 * @param {string} queryString
	 * @returns {object}
	 */
	parseQuery(queryString) {
		if (!queryString) {
			return {};
		}
		queryString.replace('?', '');

		const query = queryString.split('&').reduce((obj, str) => {
			const parts = str.split('=');
			if (parts.length > 1) {
				let val = decodeURIComponent(parts[1].trim());
				switch (val.toLowerCase()) {
					case 'true':
						val = true;
						break;
					case 'false':
						val = false;
						break;
					case 'undefined':
						val = undefined;
						break;
					case 'null':
						val = null;
						break;
					case '':
						val = undefined;
						break;
					default: {
						const num = Number(val);
						if (!Number.isNaN(num)) {
							val = num;
						}
						break;
					}
				}
				// Only update query, not configs
				const key = decodeURIComponent(parts[0].trim());
				if (key in this._configs) {
					if (this._configs[key] === undefined) {
						this._configs[key] = val;
					}
				}
				else {
					obj[key] = val;
				}
			}
			return obj;
		}, {});

		return query;
	}

	/**
	 * Build a query string from a query object.
	 * @param {object} query
	 * @returns {string}
	 */
	buildQuery(query) {
		let queryString = '';

		for (const [key, value] of Object.entries(query)) {
			queryString += '&' + key + '=' + value;
		}

		// Replace the first `&` with `?`
		queryString = queryString.replace('&', '?');

		return queryString;
	}

	/**
	 * Add query to the stored query.
	 * @param {object} query
	 * @returns {object} Updated query
	 */
	addQuery(query) {
		this._query = { ...this._query, ...query };
		return this._query;
	}

	/**
	 * Remove query from the stored query.
	 * @param {Array} [keys=[]] - Query keys to remove
	 * @returns {object} Updated query
	 */
	removeQuery(keys = []) {
		keys.forEach(key => delete this._query[key]);
		return this._query;
	}

	/**
	 * Add configs to the stored configs.
	 * @param {object} configs
	 * @returns {object} Updated configs
	 */
	addConfigs(configs) {
		this._configs = { ...this._configs, ...configs };
		return this._configs;
	}

	/**
	 * Set specific config value
	 * @param {string} key
	 * @param {any} value
	 */
	setConfig(key, value) {
		this.configs[key] = value;
	}

	/**
	 * Remove config from the stored configs.
	 * @param {Array} [keys=[]] - Config keys to remove
	 * @returns {object} Updated configs
	 */
	removeConfigs(keys = []) {
		keys.forEach(key => delete this._configs[key]);
		return this._configs;
	}

	/**
	 * Update, add to, or remove from the stored query.
	 * { __remove: 'all' } will empty query before adding new query.
	 * { __remove: string[] } will remove only queries in the list.
	 * @param {object} query
	 * @returns {object} Updated query
	 */
	updateQuery(query) {
		if (query.__remove) {
			if (query.__remove === 'all') {
				this._query = {};
			}
			else {
				this.removeQuery(query.__remove);
			}
			delete query.__remove;
		}

		const configs = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.filterObject(this._configs, val => val !== undefined);
		return { ...this.addQuery(query), ...configs };
	}

	/**
	 * Update, add to, or remove from path query.
	 * @param {object} query
	 * @param {string} [pathname=''] - Base path
	 * @returns {string} Updated path
	 */
	updateQueryPath(query, pathname = '') {
		const output = pathname || this._router.lastRouteResolved().url;

		return output.replace(/(\/)(?=\/*\1)/, '') + this.buildQuery(this.updateQuery(query));
	}

	/**
	 * Reset to new view.
	 * @param {string} currentView - Current view
	 * @param {object} params
	 */
	async resetView(currentView, params) {
		this._previousView = this._currentView;
		this._currentView = currentView;

		// Update only when view change
		if (this._currentView !== this._previousView) {
			// Leave the previous view
			if (this._previousView !== null) {
				await this._app.getView(this._previousView).onLeave(params);
			}

			// Enter the current view
			await this._app.getView(this._currentView).onEnter(params);

			const views = this._app.getViews();
			for (let i = views.length - 1; i >= 0; i--) {
				const view = views[i];
				this._app.getView(view).setEnabled(view === currentView);
			}
		}
	}

	/**
	 * Execute actions in a route.
	 * @param {string} view - Which view the route corresponds to
	 * @param {object} params - Parameters from url
	 * @param {string} query - Query from url
	 */
	async handleRoute(view, params, query) {
		if (!params) {
			params = this.addCancelToken(params);
			this._currentRoute.params = params;
		}

		let objectQuery = {};
		if (query) {
			objectQuery = this.parseQuery(query);
		}
		await this.resetView(view, { ...params, ...objectQuery, ...this._configs });
		await this.goToView(view, params, { ...objectQuery, ...this._configs });
	}

	/**
	 * Check if app is still on route.
	 * Useful for route with async actions in before hook to check if user leaves route abruptly.
	 * @param {string} url - Url to check against current route
	 * @returns {boolean}
	 */
	stillOnRoute(url) {
		const regex = /^\/([^!/]*)/;
		const match = this._currentRoute.url.match(regex);
		if (match === null || match[1] === undefined) {
			return false;
		}

		return match[1] === url;
	}

	/**
	 * Check if url has changed or not.
	 * Compare only the first part of 2 urls, nested route or query are not considered.
	 * @param {string} a - First url
	 * @param {string} b - Second url
	 * @returns {boolean}
	 */
	urlChanged(a, b) {
		return this.getOnlyURL(a) !== this.getOnlyURL(b);
	}

	/**
	 * Check if a route has changed.
	 * @param {object} current
	 * @param {object} previous
	 * @returns {boolean}
	 */
	routeChanged(current, previous) {
		if (current === '' && !previous) {
			return true;
		}
		if (!previous || _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.isEmptyObject(previous)) {
			return true;
		}

		// Route check
		if (current.url) {
			return current.url !== previous.url;
		}

		// Object check
		const currentRoute = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.deepCopy(current);
		const previousRoute = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.deepCopy(previous);
		return !_internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.deepEqual(currentRoute, previousRoute);
	}

	/**
	 * Check if a query has changed.
	 * @param {object} current - Like {time: '2020-03-10T20:52:10.904-07:00', rate: 1}
	 * @param {string} previous - Like 'time=2020-02-10T07:14:45.000-08:00&rate=1'
	 * @returns {boolean}
	 */
	queryChanged(current, previous) {
		if (!previous) {
			return true;
		}

		const currentQuery = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.deepCopy(current);
		const previousQuery = {};
		for (const p in currentQuery) {
			if (typeof currentQuery[p].toString === 'function') {
				currentQuery[p] = currentQuery[p].toString();
			}
		}
		previous.split('&').forEach(param => {
			const paramSplit = param.split('=');
			previousQuery[paramSplit[0]] = paramSplit[1];
		});

		// Object check
		return !_internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.deepEqual(currentQuery, previousQuery);
	}

	/**
	 * Go to a view.
	 * @param {string} view - View's name
	 * @param {object} params
	 * @param {object} query
	 */
	async goToView(view, params, query) {
		// Check if it's a new route
		if (this.routeChanged(this.currentRoute, this.previousRoute)) {
			await this._app.getView(view).onRouteChange({ ...params, ...query });
		}
		else if (this.queryChanged(query, this.previousRoute.query)) {
			await this._app.getView(view).onQueryChange({ ...params, ...query });
		}
	}

	/**
	 * Add routes to router.
	 * @param {object[]} routes
	 * @param {string} routes[].route - The route to add.
	 * @param {string} routes[].view - The view corresponding to the route.
	 */
	addRoutes(routes) {
		for (let i = 0; i < routes.length; i++) {
			const { route, view } = routes[i];
			this._router.on(
				route,
				async (params, query) => {
					await this.handleRoute(view, params, query);
				},
				{
					before: async (done, params) => {
						await this.before(done, params, view);
					},
					leave: this.leave
				}
			);
		}
	}

	/**
	 * Execute before every route.
	 * @param {Function} done - Callback on done
	 * @param {object} params - Parameters from url
	 * @param {string} view - Which view the route corresponds to
	 */
	before(done, params, view) {
		let objectQuery = {};
		if (this._currentRoute.query) {
			objectQuery = this.parseQuery(this._currentRoute.query);
		}

		params = this.addCancelToken(params);

		const isValid = this._app.getView(view)?.validateQuery({ ...params, ...objectQuery });
		if (!isValid) {
			params.cancelToken.cancel();
			if (typeof done === 'function') {
				// Don't resolve route
				done(false);
			}
		}

		if (typeof done === 'function') {
			done();
		}
	}

	/**
	 * Method to subscribe to specific query key
	 * See processQuery method in base_view.js to see when these callbacks are called
	 * @param {string} key
	 * @param {Function} callback
	 * @returns {Function} unsubscribe function
	 */
	subscribeToQuery(key, callback) {
		// Check callback is a function
		if (typeof callback !== 'function') return;

		// Create array for key if necessary.
		if (!this._queryCallbacks[key]) {
			this._queryCallbacks[key] = [];
		}
		// Push callback into array  if it's not already there
		if (!this._queryCallbacks[key].includes(callback)) {
			this._queryCallbacks[key].push(callback);
		}

		// Return the unsubscribe function.
		return () => {
			const i = this._queryCallbacks[key].indexOf(callback);
			this._queryCallbacks[key].splice(i, 1);
		};
	}

	/**
	 * Start the routing
	 */
	start() {
		this._router.resolve();

		this.handleEmbedQueries();
	}

	/**
	 * Handle embed queries from URL that should only be handled once
	 */
	handleEmbedQueries() {
		const { hideFullScreenToggle, lighting, noKeyboard, search } = this._configs;
		const hideSearch = noKeyboard === true || search === false;
		const searchComponent = this.app.getComponent('search');
		const settingsComponent = this.app.getComponent('settings');

		// Custom tutorial slides if certain embed queries are true
		let updatedTutorials = [];
		let tutorialsWithVariables = null;
		const tutorialOverlay = this.app.getComponent('tutorialOverlay');

		if (hideFullScreenToggle === true) {
			// Called on update of components in case a component updates the settings itself, like Compare View
			settingsComponent?.hideFullScreenOption?.();
		}
		if (lighting === 'flood' || lighting === 'natural') {
			settingsComponent?.toggleLightOptions?.(lighting);
		}

		// Hide search component and relevant tutorials
		if (hideSearch) {
			this._alwaysHiddenComponents.push('search');
			searchComponent?.hide();
			updatedTutorials = tutorialOverlay?.hideTutorialSlide?.('search');
		}
		if (this._configs.hideFullScreenToggle === true) {
			const settingsTutorial = this.app.tutorials?.find(slide => slide.id === 'settings');
			// Remove mention of full screen in settings tutorial
			if (settingsTutorial) {
				settingsTutorial.description = settingsTutorial.description.replace(settingsTutorial.description, settingsTutorial.alternateDescription);
			}
		}


		tutorialsWithVariables = this.app.setTutorialVariables?.(updatedTutorials.length ? updatedTutorials : this.app.tutorials);
		// Hydrate tutorials with replaced function patterns, then set them in the tutorial overlay component.
		tutorialOverlay?.setTutorials?.(tutorialsWithVariables);
	}

	/**
	 * Navigate to a path if it is not the current path. Path is adjusted to current base.
	 * @param {string|object} route - Full path to navigate or query object. To remove query, use { __remove: 'all' } for every query, or { __remove: string[] } for queries in the list.
	 * @param {string} [base=''] - Base path if navigate with query. If not provided, will only update query.
	 * @param {object} [options={}]
	 * @param {boolean} [options.keepTime = false] - If keepTime == true, populates the time again for the url
	 * @returns {boolean} Navigated or not
	 */
	navigate(route, base = '', options = {}) {
		if (!_internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.isEmptyObject(options)) {
			if (typeof route === 'string') {
				base = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.cleanPathDuplicate(`${base}/${route}`);
				route = {};
			}
		}

		if (options.__remove) {
			route.__remove = options.__remove;
		}

		if (options.keepTime) {
			const timeManager = this._app.getManager('time');
			if (this.query.time && timeManager) {
				if (!base.includes('time=')) {
					route.time = route.time || timeManager.getTimeUrl();
				}
				if (!base.includes('rate=')) {
					route.rate = route.rate || timeManager.getTimeRate();
				}
			}
		}

		return this._navigate(route, base);
	}

	/**
	 * Navigate to a path if it is not the current path.
	 * @param {string|object} route - Full path to navigate or query object. To remove query, use { __remove: 'all' } for every query, or { __remove: string[] } for queries in the list.
	 * @param {string} [base=''] - Base path if navigate with query. If not provided, will only update query.
	 * @returns {boolean} Navigated or not
	 */
	_navigate(route, base = '') {
		if (typeof route === 'string') {
			const current = this.lastPathResolved();
			let outputRoute = route;
			if (!route.startsWith('/')) {
				outputRoute = '/' + route;
			}
			if (!route.includes(base)) {
				outputRoute = base + route;
			}
			if (current !== outputRoute) {
				const parts = outputRoute.split('?');
				if (parts.length > 1) {
					this._query = this.parseQuery(parts[1]);
				}
				else {
					this._query = {};
					const configs = _internal__WEBPACK_IMPORTED_MODULE_1__.AppUtils.filterObject(this._configs, val => val !== undefined);
					outputRoute += this.buildQuery(configs);
				}

				this._router.navigate(outputRoute);
				return true;
			}
			return false;
		}
		else {
			return this.navigate(this.updateQueryPath(route, base), base);
		}
	}

	/**
	 * Return to home, optionally keeping query
	 * @param {boolean} keepCurrentQuery
	 */
	returnHome(keepCurrentQuery = true) {
		const currentQuery = keepCurrentQuery ? this.buildQuery(this.query) : '';
		this.navigate(currentQuery);
	}

	/**
	 * Reload current route.
	 * @param {boolean} [onQueryChange=true] - Call onQueryChange by default, otherwise call onRouteChange
	 * @param {boolean} [clearQuery=false] - Clear all queries when reload
	 */
	async reload(onQueryChange = true, clearQuery = false) {
		const view = await this._app.getView(this._currentView);
		const { params, query } = this._router.lastRouteResolved();
		let objectQuery = {};
		if (!clearQuery && query) {
			objectQuery = this.parseQuery(query);
		}

		if (onQueryChange) {
			view.onQueryChange({ ...params, ...objectQuery });
		}
		else {
			view.onRouteChange({ ...params, ...objectQuery });
		}
	}
}


/***/ }),

/***/ "../eyes/src/managers/scene_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/scene_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SceneManager": function() { return /* binding */ SceneManager; }
/* harmony export */ });
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! moment-timezone */ "../eyes/node_modules/moment-timezone/index.js");
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(moment_timezone__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");





/**
 * @typedef {import('../../../pioneer-scripts/src/entity').ExtraOptions} ExtraOptions
 */

/**
 * Nomenclature:
 * Added* means that an entity name is in the entity statuses, but not necessarily loaded into the scene.
 * Loaded* means that an entity is in the entity statuses and is also loaded into the scene.
 * Visible* means that an entity's components are visible (or would be if the entity were loaded).
 */

/**
 * Every app has a _sceneInfo object and it is passed in to populate the scene.
 * @typedef SceneInfo
 * @property {string[]} [dynamicEntityGroups] - Entity groups that are loaded depending on layers and distance.
 * @property {string[]} [dynamicEntities] - Individual entities that are loaded depending on layers and distance.
 * @property {string[]} [staticEntityGroups] - Entity groups that are loaded depending only on layers.
 * @property {string[]} [staticEntities] - Individual entities that are  lodaed depending only on layers.
 * @property {ExtraOptions} [entityOptions] - Extra options that are passed to PioneerScripts.Entity.createEntity().
 * @property {number} [zoomMax]
 * @property {object} [meta]
 * @property {string} meta.titlePrefix
 * @property {string} meta.titleSuffix
 * @property {string} meta.url
 * @property {string} meta.description
 */

/**
 * A record of the current load status flags of the entities in the scene.
 * @typedef EntityStatus
 * @property {boolean} forceVisible - If true, it will always be loaded and visible no matter what.
 * @property {boolean} dynamic - If true, it will only be loaded when its parent has a large enough pixel-space system radius.
 * @property {boolean} layerVisibility - Whether or not the entity is in a visible layer.
 * @property {string[]} dependentEntities - The list of entities that are dependent on this. Only populated when loaded.
 * @property {Set<string>} entitiesForcingThisVisible - The list of entities that when visible should also show this entity.
 * @property {boolean} visible - Whether or not the entity is actually visible (components enabled), taking into account layers, camera, and forceVisible of other entities.
 * @property {Set<string>} componentTypesNotVisible - These components are forced invisible even when the entity is visible.
 */

/**
 * Scene Manager class.
 * @extends BaseManager
 */
class SceneManager extends _internal__WEBPACK_IMPORTED_MODULE_3__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * List of scenes.
		 * @type {object}
		 */
		this._scenes = {};

		/**
		 * Main scene.
		 * @type {Pioneer.Scene}
		 */
		this._scene = this.add('main');

		/**
		 * Stores HD status.
		 * @type {boolean}
		 */
		this._isHD = false;

		/**
		 * Maps entity ids to HD WMTS components.
		 * @type {object}
		 */
		this._hdWMTSMap = {};

		/**
		 * List of loading items.
		 * @type {string[]}
		 */
		this._loadingItems = [];

		/**
		 * List of forced loaded components.
		 * @type {Pioneer.BaseComponent[]}
		 */
		this._loadedComponents = [];

		/**
		 * Below or equal to this size, it's low resolution.
		 * Above it's high resolution.
		 * @type {number}
		 */
		this._hdBreakpointSize = 512;

		/**
		 * Maximum texture size.
		 * @type {number}
		 */
		this._maxTextureSize = 4096;

		/**
		 * Array of possible event names.
		 * @type {string[]}
		 * @default
		 */
		this._eventNames.push('loading', 'loaded');
		this._initCallbacks();

		/**
		 * Indicator that there is a component(s) loading.
		 * @type {boolean}
		 */
		this._isLoading = false;

		/**
		 * A list of entities that are possible in the scene, loaded depending on their load style and visibilities.
		 * @type {Pioneer.FastMap<string, EntityStatus>}
		 */
		this._entityStatuses = new pioneer__WEBPACK_IMPORTED_MODULE_1__.FastMap();

		/**
		 * The extra options to use when adding new Entities from PioneerScripts.
		 * @type {ExtraOptions}
		 * @private
		 */
		this._entityExtraOptions = undefined;

		/**
		 * A list of entity added callbacks.
		 * @type {((entity: Pioneer.Entity) => void)[]}
		 * @private
		 */
		this._entityLoadedCallbacks = [];

		/**
		 * A list of entity will be removed callbacks.
		 * @type {((entity: Pioneer.Entity) => void)[]}
		 * @private
		 */
		this._entityWillBeUnloadedCallbacks = [];

		/**
		 * These components are not visible even when the entities are visible.
		 * @type {Set<string>}
		 * @private
		 */
		this._componentTypesNotVisible = new Set();

		/**
		 * Mobile Texture Size
		 * TODO: Set this value to less than the max texture size to improve performance of HD textures on mobile.
		 * @type {number}
		 * @private
		 */
		this._mobileTextureSize = 1024;

		this.bindFunctions([
			'addLoading',
			'removeLoading',
			'update',
			'toggleStarfield',
			'toggleHeliosphere',
			'toggleConstellations',
			'addWMTSComponent',
			'tileIsReady',
			'enableWMTSComponent',
			'forceTextureSizeForEntity',
			'toggleHDTextureForEntity',
			'isEntityHD'
		]);

		/**
		 * List of temporary entities.
		 * @type {Pioneer.Entity[]}
		 */
		this._tempEntities = [];
	}

	// FUNCTIONS THAT DEAL WITH ADDING AND REMOVING.

	/**
	 * Adds a new scene.
	 * @param {string} name
	 * @returns {Pioneer.Scene}
	 */
	add(name) {
		if (name === 'main' && this._scene) {
			return this._scene;
		}

		this._scenes[name] = this.pioneer.addScene(name);
		this._scenes[name].setAmbientLightColor(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(0.005, 0.005, 0.005));
		return this._scenes[name];
	}

	/**
	 * Adds an entity to the scene manager.
	 * @param {string} entityName - The name of the entity.
	 * @param {boolean} dynamic - If true, it will only be loaded when its parent has a large enough pixel-space system radius.
	 */
	addEntity(entityName, dynamic) {
		if (this._entityStatuses.has(entityName)) {
			throw new Error(`Error adding entity: The entity ${entityName} has already been added.`);
		}
		this._entityStatuses.set(entityName, {
			forceVisible: false,
			layerVisibility: /** @type {LayerManager} */(this.app.getManager('layer')).isEntityVisibleWithCurrentLayers(entityName),
			dynamic,
			dependentEntities: [],
			entitiesForcingThisVisible: new Set(),
			visible: true,
			componentTypesNotVisible: new Set()
		});
	}

	/**
	 * Removes an entity from the scene manger.
	 * @param {string} entityName
	 */
	removeEntity(entityName) {
		if (!this._entityStatuses.delete(entityName)) {
			throw new Error(`Error removing entity: The entity ${entityName} was not in the scene manager.`);
		}
		// If it's in the scene, remove it, calling the callbacks beforehand.
		const entity = this._scene.getEntity(entityName);
		if (entity !== null) {
			for (let i = 0, k = this._entityWillBeUnloadedCallbacks.length; i < k; i++) {
				this._entityWillBeUnloadedCallbacks[i](entity);
			}
			this._scene.removeEntity(entityName);
		}
	}


	/**
	 * Gets an entity's status object.
	 * @param {string} entityName
	 * @returns {EntityStatus}
	 */
	getEntityStatus(entityName) {
		return this._entityStatuses.get(entityName);
	}

	/**
	 * Sets the entities from the scene info.
	 * @param {SceneInfo} sceneInfo
	 */
	addEntitiesFromSceneInfo(sceneInfo) {
		// Get a big list of entity names from the static and dynamic entity names and groups.
		const entityNames = /** @type {Map<string, boolean>} */(new Map()); // name => is dynamic

		// Do it for static entities.
		if (sceneInfo.staticEntities !== undefined) {
			if (sceneInfo.staticEntities.length === 1 && sceneInfo.staticEntities[0] === 'all') {
				// It was ['all'] so get every entity in PioneerScripts.
				pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityNamesInGroup('').forEach(entityName => entityNames.set(entityName, false));
			}
			else {
				sceneInfo.staticEntities.forEach(entityName => entityNames.set(entityName, false));
			}
		}
		if (sceneInfo.staticEntityGroups !== undefined) {
			sceneInfo.staticEntityGroups.forEach(entityGroupName => {
				pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityNamesInGroup(entityGroupName).forEach(entityName => entityNames.set(entityName, false));
			});
		}

		// Do it for dynamic entities. If an entity was already in the static list, don't add it here.
		if (sceneInfo.dynamicEntities !== undefined) {
			if (sceneInfo.dynamicEntities.length === 1 && sceneInfo.dynamicEntities[0] === 'all') {
				// It was ['all'] so get every entity in PioneerScripts.
				pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityNamesInGroup('').forEach(entityName => {
					if (!entityNames.has(entityName)) {
						entityNames.set(entityName, true);
					}
				});
			}
			else {
				sceneInfo.dynamicEntities.forEach(entityName => {
					if (!entityNames.has(entityName)) {
						entityNames.set(entityName, true);
					}
				});
			}
		}
		if (sceneInfo.dynamicEntityGroups !== undefined) {
			sceneInfo.dynamicEntityGroups.forEach(entityGroupName => {
				pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityNamesInGroup(entityGroupName).forEach(entityName => {
					if (!entityNames.has(entityName)) {
						entityNames.set(entityName, true);
					}
				});
			});
		}

		// Remove anything that doesn't have an entity info in the content manager.
		const contentManager = /** @type {ContentManager} */(this.app.getManager('content'));
		for (const entityName of entityNames.keys()) {
			if (contentManager.getEntityInfo(entityName) === null) {
				entityNames.delete(entityName);
			}
		}

		// Add all of the entity names to the scene manager.
		entityNames.forEach((dynamic, entityName) => this.addEntity(entityName, dynamic));

		// Add the entity options.
		this.setExtraEntityOptions(sceneInfo.entityOptions);

		// Update the visibility of the layers.
		this.updateEntityLayerVisibility();
	}

	// FUNCTIONS THAT DEAL WITH LOADING AND UNLOADING.

	/**
	 * Adds an entity loaded callback.
	 * @param {(entity: Pioneer.Entity) => void} callback
	 */
	addEntityLoadedCallback(callback) {
		this._entityLoadedCallbacks.push(callback);
	}

	/**
	 * Removes an entity loaded callback.
	 * @param {(entity: Pioneer.Entity) => void} callback
	 */
	removeEntityLoadedCallback(callback) {
		for (let i = 0, l = this._entityLoadedCallbacks.length; i < l; i++) {
			if (this._entityLoadedCallbacks[i] === callback) {
				this._entityLoadedCallbacks.splice(i, 1);
				return;
			}
		}
	}

	/**
	 * Adds an entity will be unloaded callback.
	 * @param {(entity: Pioneer.Entity) => void} callback
	 */
	addEntityWillBeUnloadedCallback(callback) {
		this._entityWillBeUnloadedCallbacks.push(callback);
	}

	/**
	 * Removes an entity will be unloaded callback.
	 * @param {(entity: Pioneer.Entity) => void} callback
	 */
	removeEntityWillBeUnloadedCallback(callback) {
		for (let i = 0, l = this._entityWillBeUnloadedCallbacks.length; i < l; i++) {
			if (this._entityWillBeUnloadedCallbacks[i] === callback) {
				this._entityWillBeUnloadedCallbacks.splice(i, 1);
				return;
			}
		}
	}

	/**
	 * Sets a list of entities to be force loaded, regardless of layer or distance.
	 * Previously force-loaded entities can be removed if desired.
	 * @param {string[]} entityNames - The list of entities to be force loaded.
	 * @param {boolean} removeExisting - If true, remove previous force loaded flags.
	 */
	setEntitiesForceVisible(entityNames, removeExisting) {
		if (removeExisting) {
			for (let i = 0, l = this._entityStatuses.size; i < l; i++) {
				const entityStatus = this._entityStatuses.getAt(i).value;
				entityStatus.forceVisible = false;
			}
		}
		for (let i = 0, l = entityNames.length; i < l; i++) {
			const entityName = entityNames[i];
			const entityStatus = this._entityStatuses.get(entityName);
			if (entityStatus === undefined) {
				throw new Error(`Entity ${entityName} was set to force load, but isn't in the scene manager. Use addEntity().`);
			}
			entityStatus.forceVisible = true;
		}
		// Do an update to get the entities created.
		this.update();
	}

	/**
	 * Sets the extra options to use when loading new Entities from PioneerScripts.
	 * @param {ExtraOptions} extraOptions
	 */
	setExtraEntityOptions(extraOptions) {
		this._entityExtraOptions = { ...extraOptions };
	}

	// FUNCTIONS THAT DEAL LAYER VISIBILITY.

	/**
	 * Update the layer visibility for only the children of parentId
	 * @param {string} parentId
	 * @param {string} satelliteGroup - The satellite group to check against entities
	 */
	updateEntityLayerVisibilityForChildren(parentId, satelliteGroup) {
		const layerManager = /** @type {LayerManager} */(this.app.getManager('layer'));
		const now = this._scene.getEngine().getTime();
		for (let i = 0, l = this._entityStatuses.size; i < l; i++) {
			const entry = this._entityStatuses.getAt(i);
			if (pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Parenting.getAllAncestorsOfEntity(entry.key, now).has(parentId)) {
				entry.value.layerVisibility = layerManager.isEntityVisibleWithCurrentLayers(entry.key, satelliteGroup);
			}
		}
	}

	/**
	 * Updates the entity-layer visibility mapping, which is used in the loading of entities.
	 * Called when a layer is toggled.
	 * @param {string} satelliteGroup - The satellite group to check against entities
	 */
	updateEntityLayerVisibility(satelliteGroup) {
		const layerManager = /** @type {LayerManager} */(this.app.getManager('layer'));
		for (let i = 0, l = this._entityStatuses.size; i < l; i++) {
			const entry = this._entityStatuses.getAt(i);
			entry.value.layerVisibility = layerManager.isEntityVisibleWithCurrentLayers(entry.key, satelliteGroup);
		}
	}

	// THE MAIN UPDATE FUNCTION AND ITS HELPERS.

	/**
	 * Updates the loaded entities, both static and dynamic, keeping into account layers.
	 * Makes loaded entities visible or invisible, depending on layers and other factors.
	 * Runs every frame.
	 */
	update() {
		// Get the camera entity.
		const cameraEntity = /** @type {CameraManager} */(this.app.getManager('camera')).cameraEntity;
		const contentManager = /** @type {ContentManager} */(this.app.getManager('content'));

		// Go through each of the entities.
		for (let i = 0, l = this._entityStatuses.size; i < l; i++) {
			const entry = this._entityStatuses.getAt(i);
			const entityName = entry.key;
			const entityStatus = entry.value;

			// Figure out if it should be loaded or not.
			const shouldBeLoaded = entityStatus.forceVisible // force loaded (always loaded)
				|| (!entityStatus.dynamic // static loaded (checks layer)
					&& entityStatus.layerVisibility)
				|| (entityStatus.dynamic // dynamic loaded (checks layer and distance)
					&& entityStatus.layerVisibility
					&& this._isEntityVisibleWithinParent(entityName))
				|| cameraEntity?.getParent()?.getName() === entityName;

			// Load or unload the entity if needed, calling the appropriate callbacks.
			let entity = this._scene.getEntity(entityName);
			if (shouldBeLoaded && entity === null) {
				this._createEntity(entityName);
				// Also do all of its dependencies.
				const dependentEntityNames = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.SceneHelpers.getDependentEntities(entityName);
				for (const dependentEntityName of dependentEntityNames) {
					if (this._scene.getEntity(dependentEntityName) === null) {
						this._createEntity(dependentEntityName);
					}
				}
			}
			else if (!shouldBeLoaded && entity !== null) {
				// First check if it isn't depended on by anything else that is in the scene.
				const focusedEntityName = cameraEntity.getParent()?.getName();
				const ignoreDependents = contentManager.getEntityInfo(entityName).ignoreDependentWhenUnloading;
				let hasLoadedDependents = false;
				for (let j = 0, m = entityStatus.dependentEntities.length; j < m; j++) {
					const dependentEntityName = this._scene.get(entityStatus.dependentEntities[j])?.getName();
					if (dependentEntityName) {
						if (dependentEntityName === focusedEntityName && ignoreDependents?.includes(focusedEntityName)) {
							hasLoadedDependents = false;
							break;
						}
						hasLoadedDependents = true;
					}
				}
				if (!hasLoadedDependents) {
					for (let j = 0, m = this._entityWillBeUnloadedCallbacks.length; j < m; j++) {
						this._entityWillBeUnloadedCallbacks[j](entity);
						entity = null;
					}
					entityStatus.dependentEntities = [];
					this._scene.removeEntity(entityName);
				}
			}

			// If it's visible but should be invisible, make sure the components are hidden.
			const visible = entityStatus.forceVisible || entityStatus.layerVisibility || this._isAncestorOfCamera(cameraEntity, entityName) || entityStatus.entitiesForcingThisVisible.size > 0;
			if (entity !== null && entityStatus.visible !== visible) {
				// Keep the entity loaded, but hide the components.
				this.setVisibility(visible, entityName);
			}
		}
	}

	/**
	 * Create an entity.
	 * @param {string} entityName
	 * @returns {Pioneer.Entity}
	 * @private
	 */
	_createEntity(entityName) {
		// Create the entity and set its components on/off, depending on its visibility.
		const entity = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.create(entityName, this._scene, this._entityExtraOptions);
		if (!this._entityStatuses.get(entityName).visible) {
			this.setVisibility(false, entityName);
		}
		// Populate its dependencies.
		const dependentEntityNames = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.SceneHelpers.getDependentEntities(entityName);
		for (const dependentEntityName of dependentEntityNames) {
			let entityStatus = this._entityStatuses.get(dependentEntityName);
			if (entityStatus === undefined) {
				this.addEntity(dependentEntityName, this._entityStatuses.get(entityName).dynamic);
				entityStatus = this._entityStatuses.get(dependentEntityName);
			}
			entityStatus.dependentEntities.push(entityName);
		}
		// Call the callbacks.
		for (let j = 0, m = this._entityLoadedCallbacks.length; j < m; j++) {
			this._entityLoadedCallbacks[j](entity);
		}
		return entity;
	}

	/**
	 * Returns true if the entityName is an ancestor of the camera for any time.
	 * @param {Pioneer.Entity} cameraEntity
	 * @param {string} entityName
	 * @returns {boolean}
	 * @private
	 */
	_isAncestorOfCamera(cameraEntity, entityName) {
		let cameraAncestor = cameraEntity;
		while (cameraAncestor !== null) {
			if (cameraAncestor.getName() === entityName) {
				return true;
			}
			// Check the all possible parents of the ancestor as well.
			for (let i = 0, l = cameraAncestor.getNumParentingTableEntries(); i < l; i++) {
				if (cameraAncestor.getParentingTableEntry(i)[1] === entityName) {
					return true;
				}
			}
			cameraAncestor = cameraAncestor.getParent();
		}
		return false;
	}

	/**
	 * Sets the visibility of an entity.
	 * @param {boolean} visible
	 * @param {string} entityName
	 * @private
	 */
	setVisibility(visible, entityName) {
		// Update the visibility in the entity statuses.
		const entityStatus = this._entityStatuses.get(entityName);
		if (entityStatus !== undefined) {
			entityStatus.visible = visible;
		}

		// Get the entity in the scene. If not loaded, we've got nothing to do.
		const entity = this._scene.getEntity(entityName);
		if (entity === null) {
			return;
		}

		// Enable or disable the components. Trails and labels are treated as a separate case.
		const layerManager = /** @type {LayerManager} */(this.app.getManager('layer'));
		const trailsVisible = layerManager.getLayer('trails').visible;
		const divsVisible = layerManager.getLayer('labels').visible;
		for (let i = 0; i < entity.getNumComponents(); i++) {
			const component = entity.getComponent(i);
			const type = component.getType();
			if (entity.getName() === 'sun') {
				continue;
			}
			if (visible && type === 'trail') {
				component.setEnabled(visible && trailsVisible && !entityStatus.componentTypesNotVisible.has('trail'));
			}
			else if (visible && type === 'div') {
				component.setEnabled(visible && divsVisible && !entityStatus.componentTypesNotVisible.has('div'));
			}
			else {
				component.setEnabled(visible && !entityStatus.componentTypesNotVisible.has(component.getType()));
			}
		}

		// If this forces other entities to be visible, mark them as forced visible.
		const contentManager = /** @type {ContentManager} */(this.app.getManager('content'));
		const entityInfo = contentManager.getEntityInfo(entityName);
		if (entityInfo.forceVisibleEntities !== undefined) {
			for (let i = 0, l = entityInfo.forceVisibleEntities.length; i < l; i++) {
				const entityStatus = this._entityStatuses.get(entityInfo.forceVisibleEntities[i]);
				if (entityStatus === undefined) {
					throw new Error(`Entity ${entityName} was set to force load, but isn't in the scene manager. Use addEntity().`);
				}
				if (visible) {
					entityStatus.entitiesForcingThisVisible.add(entityName);
				}
				else {
					entityStatus.entitiesForcingThisVisible.delete(entityName);
				}
			}
		}
	}

	/**
	 * Checks if the entity is visible from the point of view of its parent.
	 * @param {string} entityName
	 * @returns {boolean}
	 * @private
	 */
	_isEntityVisibleWithinParent(entityName) {
		const parentName = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Parenting.getParentOfEntity(entityName, this._scene.getEngine().getTime());
		const parent = this._scene.getEntity(parentName);

		// If the parent isn't already in the scene, we can't test the entity.
		if (parent === null) {
			return false;
		}

		const parentOptions = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityOptions(parentName);
		const systemRadius = parentOptions.systemRadius
			|| parentOptions.radius * 25
			|| parentOptions.extentsRadius * 25;
		const pixelSpaceSystemRadius = systemRadius / parent.getExtentsRadius() * parent.getGreatestPixelSpaceExtentsRadius();
		return pixelSpaceSystemRadius >= 20;
	}

	// OTHER HELPING FUNCTIONS.

	/**
	 * Gets a scene.
	 * @param {*} name
	 * @returns {Pioneer.Scene|null}
	 */
	get(name) {
		if (this._scenes[name] !== undefined) {
			return this._scenes[name];
		}
		return null;
	}

	/**
	 * Get names of entities in current scene.
	 * @returns {string[]}
	 */
	getEntitiesNames() {
		const entityNames = [];
		// Looping through all entities
		for (let i = 0; i < this._scene.getNumEntities(); i++) {
			const entity = this._scene.getEntity(i);
			entityNames.push(entity.getName());
		}
		return entityNames;
	}

	/**
	 * Gets the parent of an object.
	 * @param {string} id - object of which to return parent.
	 * @returns {string|null}
	 */
	getParent(id) {
		const entity = this._scene.getEntity(id);
		if (entity !== null) {
			const parent = entity.getParent();
			if (parent !== null) {
				return parent.getName();
			}
		}
		return null;
	}

	/**
	 * Returns a list of parents.
	 * @param {string} entityName
	 * @returns {string[]}
	 */
	getParentList(entityName) {
		let parent = this.getParent(entityName);
		const parentList = [];
		while (parent !== null && parent !== '') {
			parentList.push(parent);
			parent = this.getParent(parent);
		}
		return parentList;
	}

	/**
	 * Gets entity dependencies of entity.
	 * @param {string} entityName
	 * @returns {string[]}
	 */
	getDependencies(entityName) {
		const entity = this._scene.getEntity(entityName);
		const dependencies = new Set();
		// Parents from parenting table are dependencies
		if (entity !== null) {
			for (let i = 0; i < entity.getNumParentingTableEntries(); i++) {
				const parentName = entity.getParentingTableEntry(i)[1];
				if (parentName !== '') {
					dependencies.add(parentName);
				}
			}
		}

		// Look through options to get additional dependencies
		const options = pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.Entity.getEntityOptions(entityName);
		if (options !== undefined) {
			for (const optionName of Object.keys(options)) {
				// @ts-ignore
				const option = options[optionName];

				// Check parents from parenting table
				if (optionName === 'parents') {
					for (let i = 0; i < option.length; i++) {
						const parentName = option[i][1];
						if (parentName !== '') {
							dependencies.add(parentName);
						}
					}
				}

				// Check align targets
				if (optionName === 'align') {
					if (option.primary && option.primary.target && option.primary.target !== entityName) {
						dependencies.add(option.primary.target);
					}
					if (option.secondary && option.secondary.target && option.secondary.target !== entityName) {
						dependencies.add(option.secondary.target);
					}
				}
			}
		}

		return Array.from(dependencies);
	}

	/**
	 * Returns a promise to check when an object is ready for a certain time.
	 * @param {string} id - Id of the object
	 * @param {moment} time - Moment time
	 */
	async isReady(id, time) {
		if (time === undefined) {
			time = this.pioneer.getTime();
		}
		else {
			time = this.app.getManager('time').momentToET(time);
		}

		await pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.SceneHelpers.waitTillEntitiesInPlace(this._scene, [id], time);
	}

	/**
	 * Checks multiple ids over multiple times given.
	 * @param {string[]} objectIds
	 * @param {moment[]} times
	 */
	async isListReady(objectIds, times) {
		const promises = [];
		if (times === undefined) {
			times = [undefined];
		}
		for (let i = 0; i < objectIds.length; i++) {
			for (let j = 0; j < times.length; j++) {
				promises.push(this.isReady(objectIds[i], times[j]));
			}
		}

		await Promise.all(promises);
	}

	/**
	 * Checks if the WMTS tile component is ready.
	 * @param {WMTSComponent} wmtsComponent
	 * @returns {Promise<boolean>}
	 */
	async tileIsReady(wmtsComponent) {
		let loadedPromise = /** @type {Promise<void>} */(null);
		const promise = new Promise((resolve, reject) => {
			const check = setInterval(() => {
				// Reject if component is disabled
				if (!wmtsComponent.isEnabled() || !wmtsComponent.getEntity().isEnabled()) {
					clearInterval(check);
					reject(new Error('disabled'));
				}
				if (loadedPromise === null && wmtsComponent.getTilesLoadedPromise() !== null) {
					loadedPromise = wmtsComponent.getTilesLoadedPromise().then(() => {
						clearInterval(check);
						resolve(true);
					});
				}
			}, 30);
		});

		return promise;
	}

	/**
	 * Checks if the CMTS terrain tile component is ready.
	 * @param {Pioneer.CMTSComponent} cmtsComponent
	 * @returns {Promise}
	 */
	async terrainIsReady(cmtsComponent) {
		let loadedPromise = null;
		const promise = new Promise(resolve => {
			const check = setInterval(() => {
				// Stop checking if component is disabled during check
				if (!cmtsComponent.isEnabled() || !cmtsComponent.getEntity().isEnabled()) {
					clearInterval(check);
					resolve(true);
				}
				if (loadedPromise === null && cmtsComponent._loadedPromise !== null) {
					loadedPromise = cmtsComponent.getTilesLoadedPromise().then(() => {
						clearInterval(check);
						resolve(true);
					});
				}
			}, 30);
		});

		return promise;
	}

	/**
	 * Checks if the component is ready.
	 * @param {Pioneer.BaseComponent} component
	 * @returns {Promise}
	 */
	async componentIsReady(component) {
		if (component.isEnabled() && component.getLoadState() === 'loaded') {
			return;
		}
		const promise = new Promise(resolve => {
			const check = setInterval(() => {
				// Stop checking if component is disabled during check
				if (!component.isEnabled() || !component.getEntity().isEnabled()) {
					clearInterval(check);
					resolve(true);
				}
				// Return true if component is loaded
				if (component.getLoadState() === 'loaded') {
					clearInterval(check);
					resolve(true);
				}
			}, 30);
		});

		return promise;
	}

	/**
	 * Toggles Starfields
	 * @param {boolean} visible
	 */
	toggleStarfield(visible) {
		for (let i = 0; i < 7; i++) {
			this._scene.get('sun', 'starfield', i).setEnabled(visible);
		}
	}

	/**
	 * Toggle's heliosphere for the sun
	 * @param {boolean} visible
	 */
	toggleHeliosphere(visible) {
		this._scene.get('sun', 'model').setEnabled(visible);
	}

	/**
	 * Toggles Constellations
	 * @param {boolean} visible
	 */
	async toggleConstellations(visible) {
		const sun = /** @type {Pioneer.Entity} */(this._scene.get('sun'));
		if (sun === null) {
			return;
		}
		let constellations = /** @type {ConstellationsComponent} */(sun.getComponentByType('constellations'));
		if (visible && constellations === null) {
			// Create
			constellations = /** @type {ConstellationsComponent} */(sun.addComponent('constellations'));
			if (constellations instanceof pioneer_scripts__WEBPACK_IMPORTED_MODULE_2__.ConstellationsComponent) {
				constellations.setUrl('$STATIC_ASSETS_URL/stars/constellations.bin');
				constellations.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(0.35, 0.7, 1, 0.5));
			}
			await this.pioneer.waitUntilNextFrame();
			await constellations.getLoadedPromise();

			// Add to label manager
			const labelManager = /** @type {LabelManager} */ (this.app.getManager('label'));
			const contentManager = /** @type {ContentManager} */ (this.app.getManager('content'));
			labelManager.stop();
			const highlightColor = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(0.35, 0.7, 1, 1);
			const cameraComponent = /** @type {Pioneer.CameraComponent} */ (this.get('main').getEntity('camera').getComponentByType('camera'));
			constellations.getNames().forEach(name => {
				const entityName = `constellation_label_${name}`;
				const entity = this._scene.getEntity(entityName);
				labelManager.addEntity(entity);
				labelManager.setLabelProps({
					getLabelClass: entityName => `no-select ${contentManager.getClassName(entityName, 'constellation') ?? 'constellation'}`,
					handleTouch: null,
					handleMouseEnter: event => {
						// Handles constellation line highlight for hover on desktop and touch on mobile.
						constellations.setHighlight(constellations.getNearestConstellationIndex(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector2(event.x, event.y), cameraComponent), highlightColor, 2.5);
					},
					handleMouseLeave: () => {
						// Handles constellation line un-highlight for hover exit on desktop and (second) touch outside of constellation label on mobile.
						constellations.setHighlight(undefined, highlightColor, 2.5);
					},
					handleClick: null
				}, [entityName]);
			});
			labelManager.start();
		}
		else if (!visible && constellations !== null) {
			// Remove from label manager
			const labelManager = /** @type {LabelManager} */ (this.app.getManager('label'));
			labelManager.stop();
			constellations.getNames().forEach(name => {
				const entityName = `constellation_label_${name}`;
				const entity = this._scene.getEntity(entityName);
				labelManager.removeEntity(entity);
			});
			labelManager.start();

			// Delete
			sun.removeComponent(constellations);
		}
	}

	/**
	 * Returns true if HD is enabled.
	 * @returns {boolean}
	 */
	isHD() {
		return this._isHD;
	}

	/**
	 * Checks if an entity has HD available.
	 * @param {string} id - The Entity id
	 * @returns {boolean}
	 */
	hasHD(id) {
		const entity = this._scene.get(id);
		if (entity === null) {
			return false;
		}
		// Check WMTS
		if (Object.prototype.hasOwnProperty.call(this._hdWMTSMap, id)) {
			return true;
		}
		// Check WMTS for parent too
		if (entity.getParent() !== null && Object.prototype.hasOwnProperty.call(this._hdWMTSMap, entity.getParent().getName())) {
			return true;
		}
		// Check for high resolution textures
		if (entity.get('spheroidLOD') !== null) {
			const spheroidLOD = entity.get('spheroidLOD');
			const sizes = spheroidLOD.getTextureSizes('color');
			for (let i = 0; i < sizes.length; i++) {
				if (sizes[i] > this._hdBreakpointSize) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Sets the HD breakpoint sizes.
	 * Below is Low resolution, above will be considered HD.
	 * @param {number} breakPointSize - Size (default 512)
	 * @param {number} maxTextureSize - Size (default 4096)
	 */
	setHDBreakpoints(breakPointSize, maxTextureSize) {
		this._hdBreakpointSize = breakPointSize;
		this._maxTextureSize = maxTextureSize;
	}

	/**
	 * Toggles HD features.
	 */
	async toggleHD() {
		this._isHD = !this._isHD;

		// Toggle low resolution textures
		if (!this._isHD) {
			this.pioneer.getConfig().setValue('maxTextureSize', this._hdBreakpointSize);
		}

		// Toggle WMTS
		for (const name in this._hdWMTSMap) {
			const wmts = this._hdWMTSMap[name];
			const entity = this._scene.get(name);
			const spheroidLOD = entity.getComponentByType('spheroidLOD');
			const wmtsComponent = entity.getComponent(wmts);
			if (_internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.isMobileMode()) {
				// Mobile limit
				wmtsComponent.setMaxLevel(5);
			}
			wmtsComponent.setEnabled(this._isHD);
			if (this._isHD) {
				// Add it to the loading list
				this.addLoading(name, 'wmts');
				// Wait for first level to be loaded
				await this.pioneer.waitUntilNextFrame();
				const ready = await this.tileIsReady(wmtsComponent).catch(() => {
					this.removeLoading(name, 'wmts');
				});
				if (ready === true) {
					spheroidLOD.setEnabled(false);
					this.removeLoading(name, 'wmts');
				}
			}
			else {
				spheroidLOD.setEnabled(true);
			}

			// Toggle 4K textures
			if (this._isHD) {
				this.pioneer.getConfig().setValue('maxTextureSize', this._maxTextureSize);
			}
		}
	}

	/**
	 * Set the texture size for a specific entity
	 * @param {string} entityId
	 * @param {number} size
	 * @param {string} textureName
	 */
	async forceTextureSizeForEntity(entityId, size, textureName = 'color') {
		const spheroidLOD = /** @type {Pioneer.SpheroidLODComponent} */ (this.app.pioneer.get('main', entityId, 'spheroidLOD'));
		if (spheroidLOD === null || spheroidLOD === undefined) {
			return;
		}
		spheroidLOD.forceTextureSize(textureName, size);
	}

	/**
	 * Returns true if the entity's textures are larger than the HD break size point
	 * @param {string} entityId
	 * @returns {Promise<boolean>}
	 */
	async isEntityHD(entityId) {
		const spheroidLOD = /** @type {Pioneer.SpheroidLODComponent} */ (this.app.pioneer.get('main', entityId, 'spheroidLOD'));
		if (spheroidLOD === null || spheroidLOD === undefined) {
			return false;
		}
		await spheroidLOD.getLoadedPromise();
		return spheroidLOD.getTextureCurrentSize('color', 0) > this._hdBreakpointSize;
	}

	/**
	 * Toggle the textures for an an entity between the min and max texture sizes available.
	 * @param {string} entityId
	 * @returns {Promise<boolean>}
	 */
	async toggleHDTextureForEntity(entityId) {
		const spheroidLOD = /** @type {Pioneer.SpheroidLODComponent} */ (this.app.pioneer.get('main', entityId, 'spheroidLOD'));
		if (await this.isEntityHD(entityId) === false) {
			let hdTextureSize = this._maxTextureSize;
			if (_internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.isiPhone()) {
				hdTextureSize = this._mobileTextureSize;
			}
			this.addLoading(entityId, 'spheroidLOD');
			spheroidLOD.getTextureNames().forEach(element => {
				this.forceTextureSizeForEntity(entityId, hdTextureSize, element);
			});
			await this.pioneer.waitUntilNextFrame();
			await spheroidLOD.getLoadedPromise();
			this.removeLoading(entityId, 'spheroidLOD');
			return true;
		}
		else {
			this.addLoading(entityId, 'spheroidLOD');
			spheroidLOD.getTextureNames().forEach(element => {
				this.forceTextureSizeForEntity(entityId, this._hdBreakpointSize, element);
			});
			await this.pioneer.waitUntilNextFrame();
			await spheroidLOD.getLoadedPromise();
			this.removeLoading(entityId, 'spheroidLOD');
			return false;
		}
	}

	/**
	 * Create a ring or disc grid around an entity.
	 * @param {string} name - Ring entity's name
	 * @param {number} radius
	 * @param {string} entityName
	 * @param {object} [options={}]
	 * @param {string} [options.orbitPlaneEntityName] - Entity to align ring along its orbit plane
	 * @param {Pioneer.Color} [options.color]
	 * @param {number} [options.numCircles=1]
	 * @param {number} [options.numSpokes=0]
	 * @param {Pioneer.Vector3} [options.labelPosition=new Pioneer.Vector3(-radius, 0, 0)]
	 * @param {string} [options.labelText='']
	 * @param {boolean} [options.isEnable=true] - Entity is enabled  or not by default
	 */
	createRing(name, radius, entityName, { orbitPlaneEntityName, color, numCircles = 1, numSpokes = 0, labelPosition = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-radius, 0, 0), labelText = '', isEnable = true } = {}) {
		// Create ring entity
		const ringEntity = this._scene.addEntity(name);
		ringEntity.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);

		// Attach to a parent entity
		const entity = this._scene.getEntity(entityName);
		ringEntity.setParent(entity);

		// Create ring
		const ring = /** @type {DiscGridComponent} */(ringEntity.addComponent('discGrid'));
		ring.setLineWidth(6);
		ring.setSize(radius);
		ring.setNumCircles(numCircles);
		ring.setNumSpokes(numSpokes);
		ring.setIgnoreDistance(true);

		// Set orientation
		if (orbitPlaneEntityName) {
			this.setAlignPlane(ringEntity, orbitPlaneEntityName);
		}

		// Set color
		if (color instanceof pioneer__WEBPACK_IMPORTED_MODULE_1__.Color) {
			ring.setColor(color);
		}

		// Create label entity
		const labelEntity = this._scene.addEntity(`${name}Label`);
		labelEntity.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);
		labelEntity.setParent(entity);
		const fixed = /** @type {Pioneer.FixedController} */(labelEntity.addController('fixed'));
		fixed.setPosition(labelPosition);
		const divComponent = /** @type {Pioneer.DivComponent} */(labelEntity.addComponent('div'));
		divComponent.setFadeWhenCloseToCamera(false);
		const div = divComponent.getDiv();
		div.classList.add('ring-label');
		divComponent.getDiv().innerHTML = labelText;

		ringEntity.setEnabled(isEnable);
		labelEntity.setEnabled(isEnable);
	}

	/**
	 * Create a torus around an entity.
	 * @param {string} name - Torus entity's name
	 * @param {number} innerRadius
	 * @param {number} outerRadius
	 * @param {string} entityName
	 * @param {object} [options={}]
	 * @param {string} [options.orbitPlaneEntityName] - Entity to align ring along its orbit plane
	 * @param {Pioneer.Color} [options.color]
	 * @param {[number, number]} [options.visibleDistance=[Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY]]
	 * @param {Pioneer.Vector3} [options.labelPosition=new Pioneer.Vector3(-radius, 0, 0)]
	 * @param {string} [options.labelText='']
	 * @param {boolean} [options.isEnable=true] - Entity is enabled  or not by default
	 */
	createTorus(name, innerRadius, outerRadius, entityName, { orbitPlaneEntityName, color, visibleDistance = [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY], labelPosition = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-outerRadius, 0, 0), labelText = '', isEnable = true } = {}) {
		// Create torus entity
		const torusEntity = this._scene.addEntity(name);
		torusEntity.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);

		// Attach to a parent entity
		const parent = this._scene.getEntity(entityName);
		torusEntity.setParent(parent);

		// Create torus
		const torus = /** @type {TorusComponent} */(torusEntity.addComponent('torus'));
		torus.setInnerRadius(innerRadius);
		torus.setOuterRadius(outerRadius);
		torus.setVisibleDistanceInterval(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(...visibleDistance));

		// Set orientation
		if (orbitPlaneEntityName) {
			this.setAlignPlane(torusEntity, orbitPlaneEntityName);
		}

		// Set color
		if (color instanceof pioneer__WEBPACK_IMPORTED_MODULE_1__.Color) {
			torus.setColor(color);
		}

		// Create label entity
		const labelEntity = this._scene.addEntity(`${name}Label`);
		labelEntity.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);
		labelEntity.setParent(parent);
		const fixed = /** @type {Pioneer.FixedController} */(labelEntity.addController('fixed'));
		fixed.setPosition(labelPosition);
		const divComponent = /** @type {Pioneer.DivComponent} */(labelEntity.addComponent('div'));
		divComponent.setFadeWhenCloseToCamera(false);
		const div = divComponent.getDiv();
		div.classList.add('ring-label');
		divComponent.getDiv().innerHTML = labelText;

		torusEntity.setEnabled(isEnable);
		labelEntity.setEnabled(isEnable);
	}

	/**
	 * Sets the HD WMTS component for an entity.
	 * @param {string} id - Target entity id
	 * @param {string} wmts - Name of the WMTS component
	 */
	setEntityHDWMTS(id, wmts) {
		this._hdWMTSMap[id] = wmts;
	}

	/**
	 * Checks that the tiles are ready and sets the wmtsComponent to enabled.
	 * @param {string} entityId
	 * @param {WMTSComponent} wmtsComponent
	 */
	async enableWMTSComponent(entityId, wmtsComponent) {
		if (_internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.isMobileMode()) {
			wmtsComponent.setMaxLevel(5);
		}
		const spheroidLOD = this.get('main').getEntity(entityId).getComponentByType('spheroidLOD');

		this.addLoading(entityId, 'wmts');
		// Wait for first level to be loaded
		wmtsComponent.setEnabled(true);
		await this.pioneer.waitUntilNextFrame();
		const ready = await this.tileIsReady(wmtsComponent).catch(() => {
			this.removeLoading(entityId, 'wmts');
		});
		if (ready) {
			spheroidLOD.setEnabled(false);
			this.removeLoading(entityId, 'wmts');
		}
		else {
			spheroidLOD.setEnabled(true);
		}
	}

	/**
	 * Add the WMTS component to the entity
	 * @param {string} entityId
	 * @param {any} wmtsData
	 */
	async addWMTSComponent(entityId, wmtsData) {
		const entity = /** @type {Pioneer.Entity} */ (this.app.pioneer.get('main', entityId));

		// Create component if it doesn't already exist.
		let wmts = /** @type {WMTSComponent} */ (entity.getComponentByType('wmts'));
		if (wmts === null) {
			wmts = /** @type {WMTSComponent} */ (entity.addComponent('wmts', wmtsData.id));
		}
		wmts.setEnabled(false);

		// Set the end point, layer, and tile matrix set.
		wmts.setEndPoint(wmtsData.endPoint);
		wmts.setLayer(wmtsData.layer);

		if (wmtsData.tile) {
			wmts.setTileMatrixSet(wmtsData.tile);
		}

		// Set time
		const now = new Date();
		if (wmtsData.time === 'yesterday') {
			// Set the date to one day before today.
			now.setDate(now.getDate() - 1);
			wmts.setDimensionValue('Time', now.getFullYear() + '-' + (String(now.getMonth() + 1)).padStart(2, '0') + '-' + (String(now.getDate())).padStart(2, '0'));
		}
		else if (wmtsData.time === 'now') {
			wmts.setDimensionValue('Time', now.getFullYear() + '-' + (String(now.getMonth() + 1)).padStart(2, '0') + '-' + (String(now.getDate())).padStart(2, '0'));
		}

		// Set Max Level
		if (wmtsData.level) {
			wmts.setMaxLevel(wmtsData.level);
		}
		else {
			wmts.setMaxLevel(Infinity);
		}
		// Set Min level
		wmts.setMinLevel(2);

		await this.enableWMTSComponent(entityId, wmts);
	}

	/**
	 * Parses JSON file and loads WMTS components accordingly.
	 * @param {JSON} wmtsList
	 */
	loadWMTSFromJSON(wmtsList) {
		// Loop for each entity id
		for (const entityId in wmtsList) {
			let hdId = '';
			// Loop for each wmts item
			for (const key in wmtsList[entityId]) {
				if (key === 'hd' || hdId === '') {
					// Set HD WMTS id
					hdId = wmtsList[entityId][key];
					this._hdWMTSMap[entityId] = hdId;
				}
				else {
					// Parse WMTS data
					const wmtsData = wmtsList[entityId][key];
					const entity = this._scene.get(entityId);
					// Create component
					const wmts = entity.addComponent('wmts', key);
					wmts.setEnabled(false);
					// Set the end point, layer, and tile matrix set.
					wmts.setEndPoint(wmtsData.endPoint);
					wmts.setLayer(wmtsData.layer);
					if (wmtsData.tile) {
						wmts.setTileMatrixSet(wmtsData.tile);
					}
					// Set time
					const now = new Date();
					if (wmtsData.time === 'yesterday') {
						// Set the date to one day before today.
						now.setDate(now.getDate() - 1);
						wmts.setDimensionValue('Time', now.getFullYear() + '-' + (String(now.getMonth() + 1)).padStart(2, '0') + '-' + (String(now.getDate())).padStart(2, '0'));
					}
					else if (wmtsData.time === 'now') {
						wmts.setDimensionValue('Time', now.getFullYear() + '-' + (String(now.getMonth() + 1)).padStart(2, '0') + '-' + (String(now.getDate())).padStart(2, '0'));
					}
					// Set Max Level
					if (wmtsData.level) {
						wmts.setMaxLevel(wmtsData.level);
					}
					else {
						wmts.setMaxLevel(Infinity);
					}
				}
			}
		}
	}

	/**
	 * Set orientation of an entity to another entity's plane.
	 * @param {Pioneer.Entity} entity
	 * @param {string} orbitPlaneEntityName
	 */
	setAlignPlane(entity, orbitPlaneEntityName) {
		const orbitPlaneEntity = this._scene.getEntity(orbitPlaneEntityName);
		const ori = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
		const dynamoController = /** @type {Pioneer.DynamoController} */(orbitPlaneEntity.getControllerByType('dynamo'));
		dynamoController.getOrbitOrientation(ori, this.app.pioneer.getTime());
		entity.setOrientation(ori);
	}

	/**
	 * Clears all temporary entities.
	 */
	clearTempEntities() {
		const cameraManager = /** @type {CameraManager} */(this.app.getManager('camera'));
		const cameraEntity = cameraManager.cameraEntity;
		if (cameraEntity === null || cameraEntity.getParent() === null) {
			return;
		}

		const camParent = cameraEntity.getParent().getName();

		this._tempEntities = this._tempEntities.filter(tempEntity => {
			// Dont clear the temp entities if the camera is using one
			if (camParent === tempEntity.getName()) {
				return true; // it stays in the temp entity array
			}

			// Remove from label, scene and this array
			const labelManager = /** @type {LabelManager} */(this.app.getManager('label'));
			labelManager.removeEntity(tempEntity);
			this._scene.removeEntity(tempEntity?.getName());
			return false;
		});
	}

	/**
	 * Adds a temporary entity.
	 * @param {Pioneer.Entity} entity
	 */
	addTempEntity(entity) {
		this._tempEntities.push(entity);
	}

	/**
	 * Adds loading of an object.
	 * @param {string} id - Entity id
	 * @param {string} type - Could be camera or wmts
	 */
	addLoading(id, type) {
		const itemId = id + '_' + type;
		if (this._loadingItems.indexOf(itemId) < 0) {
			this._loadingItems.push(itemId);
		}
		if (this._loadingItems.length > 0) {
			this._isLoading = true;
			this.triggerCallbacks('loading');
		}
	}

	/**
	 * Removes loading of an object.
	 * @param {string} id - Entity id
	 * @param {string} type - Could be camera or wmts
	 */
	removeLoading(id, type) {
		const itemId = id + '_' + type;
		const index = this._loadingItems.indexOf(itemId);
		if (index >= 0) {
			this._loadingItems.splice(index, 1);
		}
		if (this._loadingItems.length === 0) {
			this._isLoading = false;
			this.triggerCallbacks('loaded', [id]);
		}
	}

	/**
	 * Forces a component to be loaded.
	 * @param {Pioneer.BaseComponent} component
	 */
	forceLoad(component) {
		component.setForceLoaded(true);
		this._loadedComponents.push(component);
	}

	/**
	 * Removes force load for a component.
	 * @param {Pioneer.BaseComponent} component
	 */
	removeForceLoad(component) {
		this._loadedComponents = this._loadedComponents.filter(value => {
			if (value === component) {
				component.setForceLoaded(false);
				return false;
			}
			return true;
		});
	}

	/**
	 * Clear all forced components.
	 */
	clearForceLoad() {
		for (let i = 0; i < this._loadedComponents.length; i++) {
			const component = this._loadedComponents[i];
			component.setForceLoaded(false);
		}

		this._loadedComponents = [];
	}

	/**
	 * Gets the distance between two objects.
	 * @param {string} objectA - Id of scene object A
	 * @param {string} objectB - Id of scene object B
	 * @param {object} options - the options
	 * @param {moment} [options.time = undefined] - specific time as moment object
	 * @param {boolean} [options.subtractRadius = false] - if calculation should subtract radiuses
	 * @param {boolean} [options.precision = 0] - Rounding error up to precision number
	 * @returns {number}
	 */
	getDistance(objectA, objectB, { time = undefined, subtractRadius = false, precision = 0 } = {}) {
		const positionRel = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.get();
		const entityA = this._scene.get(objectA);
		const entityB = this._scene.get(objectB);

		let distance = 0;

		if (time !== undefined) {
			const pioneerTime = pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.unixToEt(time.valueOf() / 1000);
			entityA.getPositionRelativeToEntity(positionRel, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, entityB, pioneerTime);
		}
		else {
			entityA.getPositionRelativeToEntity(positionRel, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, entityB);
		}
		distance = positionRel.magnitude();

		if (subtractRadius) {
			const radiusA = entityA.getExtentsRadius();
			const radiusB = entityB.getExtentsRadius();
			distance -= (radiusA + radiusB);
		}

		if (precision > 0) {
			const f = Math.pow(10, Math.floor(Math.log10(distance)) - precision);
			distance = Math.round(distance / f) * f;
		}

		pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.release(positionRel);
		return distance;
	}

	/**
	 * Gets the speed of an object.
	 * @param {string} objectA - Id of scene object A
	 * @param {string} objectB - Speed of A relative to B
	 * @param {object} options - the options
	 * @param {moment} [options.time = undefined] - specific time as moment object
	 * @returns {number}
	 */
	getSpeed(objectA, objectB, { time = undefined } = {}) {
		const speed = pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.get();
		const entityA = this._scene.get(objectA);
		let entityB = null;
		if (objectB === undefined) {
			entityB = entityA.getParent();
		}
		else {
			entityB = this._scene.get(objectB);
		}

		if (time !== undefined) {
			const pioneerTime = this.app.getManager('time').momentToET(time);
			entityA.getVelocityRelativeToEntity(speed, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, entityB, pioneerTime);
		}
		else {
			entityA.getVelocityRelativeToEntity(speed, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero, entityB);
		}

		pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.pool.release(speed);

		return speed.magnitude();
	}

	/**
	 * Gets min and max coverage of am object.
	 * @param {string} entityId
	 * @param {boolean} checkOrientation
	 * @returns {object}
	 */
	getCoverage(entityId, checkOrientation = true) {
		const coverage = {
			min: _internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.constants.maxDate,
			max: _internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.constants.minDate
		};
		// Get coverage for entity
		const entity = this.pioneer.get('main', entityId);
		const margin = 0.001; // Adds a margin in seconds to the min/max coverage to prevent dynamo issues

		let posOriMin = entity.getPositionCoverage().min;
		let posOriMax = entity.getPositionCoverage().max;
		if (checkOrientation) {
			// Check interval for both position and orientation
			posOriMin = Math.max(entity.getPositionCoverage().min, entity.getOrientationCoverage().min);
			posOriMax = Math.min(entity.getPositionCoverage().max, entity.getOrientationCoverage().max);
		}

		coverage.min = entity ? Math.min(posOriMin, coverage.min) : coverage.min;
		coverage.max = entity ? Math.max(posOriMax - margin, coverage.max) : coverage.max;

		// Convert to moment
		if (coverage.min === -Infinity || coverage.min < _internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.minDate) {
			coverage.min = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default()(_internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.constants.minDate);
		}
		else {
			coverage.min = Math.ceil(coverage.min * 1000) / 1000;
			let unix = pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.etToUnix(coverage.min) * 1000;
			unix = Math.ceil(unix * 1000) / 1000;
			coverage.min = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().tz(unix, 'ETC/Utc');
		}
		if (coverage.max === Infinity || coverage.max > _internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.maxDate) {
			coverage.max = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default()(_internal__WEBPACK_IMPORTED_MODULE_3__.AppUtils.constants.maxDate);
		}
		else {
			coverage.max = Math.floor(coverage.max * 1000) / 1000;
			let unix = pioneer__WEBPACK_IMPORTED_MODULE_1__.TimeUtils.etToUnix(coverage.max) * 1000;
			unix = Math.floor(unix * 1000) / 1000;
			coverage.max = moment_timezone__WEBPACK_IMPORTED_MODULE_0___default().tz(unix, 'ETC/Utc');
		}

		return coverage;
	}

	/**
	 * TODO: Toggle on/off ring of target.
	 * @param {string} target
	 * @returns {Promise<void>}
	 */
	async toggleRing(target) {
		console.log('toggleRing', target);
	}

	/**
	 * Gets main scene.
	 * @returns {Pioneer.Scene|null}
	 */
	get main() {
		return this._scene;
	}

	/**
	 * Get loading status.
	 * @returns {boolean}
	 */
	get isLoading() {
		return this._isLoading;
	}
}


/***/ }),

/***/ "../eyes/src/managers/search_manager.js":
/*!**********************************************!*\
  !*** ../eyes/src/managers/search_manager.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SearchManager": function() { return /* binding */ SearchManager; }
/* harmony export */ });
/* harmony import */ var fuse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fuse.js */ "../eyes/node_modules/fuse.js/dist/fuse.esm.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");



/**
 * Search Manager class.
 * @extends BaseManager
 * @class
 */
class SearchManager extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {object} [options={}]
	 */
	constructor(app, options = {}) {
		super(app);

		/**
		 * Maximum results returned.
		 * @type {number}
		 */
		this._maxEntries = 10;

		/**
		 * Fuse instance.
		 * @type {Fuse}
		 */
		this._fuse = null;

		/**
		 * Database to search.
		 * @type {object[]}
		 */
		this._database = null;

		/**
		 * Fuse options.
		 * @type {object}
		 */
		this._options = {
			threshold: 0.4,
			keys: [
				{
					name: 'id',
					weight: 0.99
				},
				{
					name: 'name',
					weight: 0.98
				}
			],
			includeScore: true,
			includeMatches: true,
			ignoreLocation: true,
			...options
		};
	}

	/**
	 * Set Fuse options for search.
	 * @param {object} options
	 */
	setOptions(options) {
		Object.assign(this._options, options);
		this._fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_1__["default"](this._database, this._options);
	}

	/**
	 * Set database for search.
	 * @param {object} database - Data that will be used to search
	 * @param {object} [options={}] - Fuse options
	 */
	setDatabase(database, options = {}) {
		if (!database) {
			console.error('[SearchManager.setDatabase] Missing database.');
			return;
		}

		Object.assign(this._options, options);

		this._database = Object.keys(database).filter(key => database[key].searchable !== false).map(key => {
			const keywords = database[key].keywords || [];
			keywords.map(keyword => ({
				value: keyword
			}));
			database[key].keywords = keywords;
			return database[key];
		});

		if (!Array.isArray(this._database)) {
			console.error('[SearchManager.setDatabase] Database is not an array.');
			return;
		}

		this._fuse = new fuse_js__WEBPACK_IMPORTED_MODULE_1__["default"](this._database, this._options);
	}

	/**
	 * Get entry using id.
	 * @param {string} id
	 * @returns {object}
	 */
	getEntry(id) {
		return this._database.find(entry => entry.id === id);
	}

	/**
	 * Finds a string and return searh results.
	 * @param {string} text - string that is searched
	 * @param {number} maxEntries
	 * @returns {Fuse.FuseResult|null}
	 */
	find(text, maxEntries = this._maxEntries) {
		if (text === '' || text === null || text === undefined || !this._fuse) {
			return null;
		}

		// Filtering based on negative keywords if any
		let results = this._fuse.search(text);

		// Limiting by the max entries value
		results = results.slice(0, maxEntries);

		return results;
	}
}


/***/ }),

/***/ "../eyes/src/managers/selection_manager.js":
/*!*************************************************!*\
  !*** ../eyes/src/managers/selection_manager.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectionManager": function() { return /* binding */ SelectionManager; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");



/**
 * Selection Manager class.
 * @extends BaseManager
 */
class SelectionManager extends _internal__WEBPACK_IMPORTED_MODULE_1__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {Pioneer.Scene} scene
	 */
	constructor(app, scene) {
		super(app);

		/**
		 * Main Pioneer scene.
		 * @type {Pioneer.Scene}
		 */
		this._scene = scene;

		/**
		 * Current selected id.
		 * @type {string}
		 */
		this._id = null;

		/**
		 * All 3D objects are clickable or not.
		 * @type {boolean}
		 */
		this._isClickable = true;

		/**
		 * State of suppressing 3D selection handler.
		 * @type {boolean}
		 */
		this._isSuppressed = false;

		this._eventNames.push('3dselection');
		this._initCallbacks();

		this.bindFunctions([
			'setSuppress',
			'handle3DSelection'
		]);
	}

	/**
	 * Sets the scene.
	 * @param {Pioneer.Scene} scene
	 */
	setScene(scene) {
		this._scene = scene;
	}

	/**
	 * Selects an entity.
	 * @param {string} id
	 */
	selectEntity(id) {
		const oldId = this._id;
		if (id !== oldId) {
			const event = new CustomEvent('selectionupdate', { detail: { new: id, old: this._id } });
			window.dispatchEvent(event);
			this._id = id;
			this._switchSelectionClass(this._id, oldId);
		}
	}

	/**
	 * Unselects what was selected before.
	 */
	unselect() {
		const oldId = this._id;
		if (oldId !== null) {
			const event = new CustomEvent('unselect', { old: this._id });
			window.dispatchEvent(event);
		}
		this._id = null;
		this._switchSelectionClass(this._id, oldId);
	}

	/**
	 * Returns the ID of the currently selected object.
	 * @returns {string}
	 */
	getCurrentId() {
		return this._id;
	}

	/**
	 * Enable/disable all 3D objects click.
	 * @param {boolean} isClickable
	 */
	setClickable(isClickable) {
		this._isClickable = isClickable;
	}

	/**
	 * Initializes the 3D click callback.
	 * @param {CameraManager} cameraManager
	 */
	init3Dcallback(cameraManager) {
		cameraManager.setSelectionCallback(this.handle3DSelection);
	}

	/**
	 * Gets link from entity's name.
	 * @param {string} entityName
	 * @returns {string}
	 */
	_getLink(entityName) {
		return `/${entityName}`;
	}

	/**
	 * Set state of suppressing 3D selection handler once.
	 * @param {boolean} suppress
	 */
	setSuppress(suppress) {
		this._isSuppressed = suppress;
	}

	/**
	 * A selection callback when a 3D object is clicked.
	 * @param {Pioneer.Entity} entity
	 */
	handle3DSelection(entity) {
		if (!this._isClickable) {
			return;
		}
		if (!this._isSuppressed && entity !== null) {
			const router = this._app.getManager('router');
			const entityName = entity.getName();
			const parsedLink = this._getLink(entityName);

			const linkPath = typeof parsedLink === 'string' ? parsedLink : (parsedLink.path ?? '');

			const {
				options = { keepTime: true },
				query = {}
			} = typeof parsedLink === 'object' && parsedLink;

			// Go to the object, maintaining time query if it exists.
			const navigated = router.navigate(query, linkPath, options);

			this.triggerCallbacks('3dselection', [navigated, entity]);
		}
		// Reset suppress state
		this._isSuppressed = false;
	}

	/**
	 * Updates selection class on entity div component.
	 * @param {string|null} newId
	 * @param {string|null} oldId
	 */
	_switchSelectionClass(newId, oldId) {
		// Remove old selection class
		if (oldId !== null) {
			const entity = this._scene.get(oldId);
			if (entity !== null) {
				const label = entity.getComponentByType('div').getDiv();
				if (label) {
					label.classList.remove('selection');
				}
			}
		}
		// Add new selection class
		if (newId !== null) {
			const entity = this._scene.get(newId);
			if (entity !== null) {
				const label = entity.getComponentByType('div').getDiv();
				if (label) {
					label.classList.add('selection');
				}
			}
		}
	}
}


/***/ }),

/***/ "../eyes/src/managers/spout_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/spout_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpoutManager": function() { return /* binding */ SpoutManager; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");




/**
 * Spout manager class.
 */
class SpoutManager extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		this._scene = this.app.pioneer.get('main');
		this._defaultTarget = this.getSpoutCameraTargetEntity(this.app.getManager('router').currentRoute.params);
		this._defaultTargetRadius = this._defaultTarget ? this._scene.getEntity(this._defaultTarget)?.getExtentsRadius() : this._scene.getEntity('earth').getExtentsRadius();
	}

	/**
	 * Enable Spout
	 * @param {boolean} globe
	 * @param {number} renderWidth
	 * @param {number} globeDistance
	 * @param {any} target
	 * @param {number} fontSize
	 * @param {number} lonAngleOffset
	 * @param {boolean} alignToNorthPole
	 */
	async enableSpout(globe = false, renderWidth = 2048, globeDistance = this._defaultTargetRadius * 2, target = this._defaultTarget, fontSize = 25, lonAngleOffset = 0, alignToNorthPole = false) {
		// Set up viewport as invisible
		const spoutViewport = this.app.pioneer.getViewport('spoutViewport') || this.app.pioneer.addViewport('spoutViewport');
		spoutViewport.getDiv().style.display = 'none';
		spoutViewport.getDiv().style.width = '100%';
		spoutViewport.getDiv().style.height = '100%';

		// Get the entity that will be the center for the globe spout
		const targetEntity = this._scene.getEntity(target) || this._scene.getEntity('earth');

		// Set up the Spout camera entity
		const spoutCamera = this.setUpSpoutCamera(globe, targetEntity, alignToNorthPole, lonAngleOffset);

		// Add Spout component.
		const spoutComponent = spoutCamera.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpoutComponent) || spoutCamera.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpoutComponent);
		spoutViewport.setCamera(spoutComponent); // This causes 2 computeBoundingSphere errors.
		spoutComponent.setRenderWidth(renderWidth);
		this._scene.setAmbientLightColor(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1));

		if (globe === true) {
			spoutComponent.setForGlobe(true, globeDistance || targetEntity.getExtentsRadius() * 2);
			spoutComponent.setNearDistance(targetEntity.getExtentsRadius() * 0.5);
			targetEntity.get('atmosphere')?.setExcludedFromCamera(spoutComponent, true);
		}

		// Turn divs into labels to work with Spout
		await this.setUpSpoutLabels(fontSize, targetEntity);
	}

	/**
	 * Set up spout camera.  If it's a globe, put a new entity at the target. Otherwise, just use the existing camera entity.
	 * @param {boolean} globe
	 * @param {any} targetEntity
	 * @param {boolean} alignToNorthPole
	 * @param {number} lonAngleOffset
	 * @returns {Pioneer.CameraComponent} spoutCamera
	 */
	setUpSpoutCamera(globe, targetEntity = this._defaultTarget, alignToNorthPole = false, lonAngleOffset = 0) {
		let spoutCamera;
		if (globe === true) {
			spoutCamera = this._scene.getEntity('spoutCamera') || this._scene.addEntity('spoutCamera');
			spoutCamera.clearControllers();
			spoutCamera.setParent(targetEntity);
			spoutCamera.setPosition(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);
			spoutCamera.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);

			const align = spoutCamera.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.AlignController);
			align.setPrimaryAlignType('align');
			align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
			align.setPrimaryTargetAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
			if (alignToNorthPole) {
				align.setPrimaryTargetEntity(targetEntity.getName());
			}
			else {
				align.setPrimaryTargetEntity('camera');
			}

			const xAxis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			pioneer__WEBPACK_IMPORTED_MODULE_0__.Geometry.getXYZFromLLAOnSphere(xAxis, new pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt(0, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(180 + lonAngleOffset), 1), 1);
			align.setSecondaryAlignType('align');
			align.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis);
			align.setSecondaryTargetEntity('camera');
			align.setSecondaryTargetAxis(xAxis);
		}
		else {
			spoutCamera = this._scene.getEntity('camera');
		}

		return spoutCamera;
	}

	/**
	 * Set up spout labels
	 * @param {number} fontSize
	 * @param {any} targetEntity
	 */
	async setUpSpoutLabels(fontSize = 25, targetEntity = null) {
		let target = targetEntity;
		// If no target given, grab target from URL
		if (!target) {
			target = await this.getSpoutCameraTargetEntity(this.app.getManager('router').currentRoute.params) || 'sun';
		}

		pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.waitTillEntitiesInPlace(this._scene, [target], this.app.pioneer.getTime(), 10.0, 3.0).then(() => {
			for (let i = 0; i < this._scene.getNumEntities(); i++) {
				const entity = this._scene.getEntity(i);

				const divComponent = entity.get('div');
				if (divComponent instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.DivComponent) {
					const label = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.LabelComponent) ?? entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.LabelComponent);
					label.setText((divComponent.getDiv().querySelector('.text')?.innerHTML || divComponent.getDiv()?.textContent) || '');
					label.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1));
					label.setFontSize(fontSize);
					label.setAlignment(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0.5));
					label.setPixelOffset(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(-fontSize / 4, -1));
					divComponent.setEnabled(false);
				}
			}
			return true;
		}).catch(error => {
			console.log(error);
		});
	}

	/**
	 * Logic for getting Spout camera parent
	 * @param {object} params
	 */
	async getSpoutCameraTargetEntity(params) {
		let spaceObject = null;
		const contentManager = this.app.getManager('content');
		if (params) {
			const onMoon = 'feature' in params && params['feature'] === 'moons';
			const currentObjectId = onMoon ? params.child : params.spaceObject;
			const currentObjectEntity = this.pioneer.get('main', currentObjectId) || this.pioneer.get('main', 'earth');
			const entityInfo = contentManager.getEntityInfo(currentObjectId) || {};
			const entityDesc = await contentManager.getEntityDesc(currentObjectId);
			const spaceObjParentId = currentObjectId && this.pioneer.get('main', currentObjectId)?.getParent()?.getName();

			switch (entityInfo.category) {
				case 'Spacecraft':
					spaceObject = _internal__WEBPACK_IMPORTED_MODULE_2__.AppUtils.isFutureMission(entityDesc?.dates?.start) ? 'earth' : currentObjectEntity?.getParent()?.getName();

					// If lander, use parent of landing site aka celestial body
					if (entityInfo.keywords.includes('lander') && currentObjectEntity.getParent().getName().includes('landing_site')) {
						spaceObject = this.pioneer.get('main', currentObjectId)?.getParent()?.getParent()?.getName();
					}
					break;
				case 'Landing site':
					spaceObject = spaceObjParentId;
					break;
				default:
					spaceObject = currentObjectId;
					break;
			}
		}

		return spaceObject;
	}
}


/***/ }),

/***/ "../eyes/src/managers/time_manager.js":
/*!********************************************!*\
  !*** ../eyes/src/managers/time_manager.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeManager": function() { return /* binding */ TimeManager; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! moment-timezone */ "../eyes/node_modules/moment-timezone/index.js");
/* harmony import */ var moment_timezone__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(moment_timezone__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");




/**
 * Time manager class.
 */
class TimeManager extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 */
	constructor(app) {
		super(app);

		/**
		 * Date formats object.
		 * @default
		 */
		this._dateFormats = {
			utc: {
				full: 'YYYY-MM-D HH[:]mm[:]ss',
				datetime: 'YYYY-MM-D HH[:]mm',
				date: 'YYYY MMMM D',
				time: 'HH[:]mm[:]ss',
				url: 'YYYY-MM-DDTHH:mm:ss.SSSZ'
			},
			local: {
				full: 'M/D/YY hh[:]mm[:]ss',
				datetime: 'M/D/YY hh[:]mm',
				date: 'MMMM D, YYYY',
				time: 'hh[:]mm[:]ss',
				meridiem: 'a'
			}
		};

		/**
		 * Time limits.
		 * @default
		 */
		this._timeLimits = {
			min: null,
			max: null
		};

		/**
		 * Default time limits.
		 * @default
		 */
		this._defaultLimits = {
			min: null,
			max: null
		};

		/**
		 * Start time.
		 * @type {moment}
		 * @default
		 */
		this._startTime = null;

		/**
		 * Time is forced pause.
		 * @type {boolean}
		 * @default
		 */
		this._forcedPause = false;

		/**
		 * Display UTC variable.
		 * @type {boolean}
		 * @default
		 */
		this._isUTC = true;

		/**
		 * ERT manager.
		 * @type {ERTManager}
		 */
		this._ertMgr = null;

		/**
		 * Time rate.
		 * @type {number}
		 * @default
		 */
		this._rate = 0;

		/**
		 * Default time rate.
		 * @type {number}
		 * @default
		 */
		this._defaultRate = 1.0;

		/**
		 * Stores the UTC timezone string.
		 * @type {string}
		 * @default
		 */
		this._utcTimezone = 'Etc/UTC';

		/**
		 * Stores the local timezone string.
		 * @type {string}
		 * @default
		 */
		this._localTimezone = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz.guess();

		/**
		 * Stores previous time rate.
		 * @type {number}
		 * @default
		 */
		this._previousTimeRate = this.pioneer.getTimeRate();

		/**
		 * Stores current timezone string.
		 * @type {string}
		 * @default
		 */
		this._timezone = this._utcTimezone;

		/**
		 * Array of possible event names.
		 * @type {string[]}
		 * @default
		 */
		this._eventNames.push('update', 'change', 'timezone', 'ratechange', 'forcedpause', 'forcedpauseresume', 'getnow');
		this._initCallbacks();

		// Set the time to 'now'
		this.setToNow();

		// Add Pioneer callback every frame
		this.pioneer.addCallback(() => {
			const time = this.pioneer.getTime();
			const rate = this.pioneer.getTimeRate();
			this._time = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.etToUnix(time) * 1000, this._timezone);
			let nextTime = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.etToUnix(time + rate / this.pioneer.getFPS()) * 1000, this._timezone);
			if (isNaN(nextTime)) {
				nextTime = this._time;
			}
			// Check for min/max boundaries
			// Use millisecond comparison instead of isBefore isAfter due to rounding to second
			if (this._timeLimits.max && nextTime.valueOf() > this._timeLimits.max.valueOf()) {
				console.warn('[Time Manager]: Clock has reached maximum limit.');
				this._onLimitReach('max');
			}
			else if (this._timeLimits.min && nextTime.valueOf() < this._timeLimits.min.valueOf()) {
				console.warn('[Time Manager]: Clock has reached minimum limit.');
				this._onLimitReach('min');
			}
			else if ((this._timeLimits.max && nextTime.valueOf() < this._timeLimits.max.valueOf()) && (this._timeLimits.min && nextTime.valueOf() > this._timeLimits.min.valueOf())) {
				// Resume time from previous limit reached
				if (this._forcedPause) {
					this._forcedPause = false;
					if (this.getTimeRate() === 0) {
						this.play();

						// Callbacks
						this.triggerCallbacks('forcedpauseresume', [this._time]);
					}
				}
			}

			// Callbacks
			this.triggerCallbacks('update', [this._time]);
		}, true);
	}

	/**
	 * Limit reach handler.
	 * @param {string} limit - 'min' or 'max'
	 */
	_onLimitReach(limit) {
		if (this.getTimeRate() !== 0) {
			this._forcedPause = true;
			this.pause();
			this._previousTimeRate = 0;

			// Callbacks
			this.triggerCallbacks('forcedpause', [this._time, limit]);
		}
		this.setTime(this._timeLimits[limit]);
	}

	/**
	 * Set ERT manager.
	 * @param {ERTManager} ertMgr
	 */
	setERTManager(ertMgr) {
		this._ertMgr = ertMgr;
	}

	/**
	 * Check if time is now.
	 * @returns {boolean}
	 */
	isNow() {
		return this._rate === 1 && Math.abs(this._time.valueOf() - this.getNow().valueOf()) < 1000;
	}

	/**
	 * Gets current real time as moment object.
	 * @returns {moment}
	 */
	getNow() {
		let time = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default()().tz(this._timezone);
		for (let i = this._callbacks.getnow.length - 1; i >= 0; i--) {
			const callback = this._callbacks.getnow[i];
			time = callback(time);
		}
		return time;
	}

	/**
	 * Sets the engine time to real time.
	 */
	setToNow() {
		this.setTime(this.getNow());
	}

	/**
	 * Sets start time.
	 * @param {moment} time
	 */
	setStartTime(time) {
		this._startTime = time;
	}

	/**
	 * Sets the engine time start time.
	 */
	setToStart() {
		if (this._startTime !== null) {
			this.setTime(this._startTime);
		}
	}

	/**
	 * Gets engine time as moment object.
	 * @returns {moment}
	 */
	getTime() {
		return this._time;
	}

	/**
	 * Sets current engine time.
	 * @param {moment|number|string} time - Value that can be parsed by moment
	 */
	setTime(time) {
		time = this.parseTime(time);
		const etTime = this.momentToET(time);
		this.pioneer.setTime(etTime);
		this._time = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.etToUnix(this.pioneer.getTime()) * 1000, this._timezone);

		// Callbacks
		this.triggerCallbacks('change', [this._time]);
	}

	/**
	 * Parses time and returns a moment object.
	 * @param {moment|number|string} time - Any input time]
	 * @param {string} dateFormat
	 * @returns {moment}
	 */
	parseTime(time, dateFormat = 'url') {
		let isUTC = this._isUTC;
		let format = (moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().ISO_8601); // ISO string with no fractional seconds

		if (typeof time === 'string' && time !== '') { // Check for UTC string
			const reg = /^(?:[1-9]\d{3}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1\d|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[1-9]\d(?:0[48]|[2468][048]|[13579][26])|(?:[2468][048]|[13579][26])00)-02-29)T(?:[01]\d|2[0-3]):[0-5]\d(?:|:[0-5]\d)(?:\.\d{1,6})?(?:|Z|[+-][01]\d:[0-5]\d)$/;
			isUTC = time.match(reg) !== null;
			const isUTCFormat = isUTC ? 'utc' : 'local';
			const urlFormat = this.getDateFormat(dateFormat, isUTCFormat);
			if (urlFormat) {
				format = urlFormat;
			}
		}
		else if (typeof time === 'number') {
			isUTC = true;
		}

		return isUTC
			? moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().utc(time) // This only means UTC format, time can be in any time zone, not just GMT
			: moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(time, format, true, this._localTimezone);
	}

	/**
	 * Convert ET time to moment.
	 * @param {number} time
	 * @returns {moment}
	 */
	etToMoment(time) {
		return moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.etToUnix(time) * 1000, 'Etc/UTC');
	}

	/**
	 * Convert moment to ET time in second.
	 * @param {moment} time
	 * @returns {number}
	 */
	momentToET(time) {
		const unix = time.valueOf() / 1000;
		const etTime = pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.unixToEt(unix);
		return Math.round(etTime * 1000) / 1000;
	}

	/**
	 * Gets current timezone.
	 * @returns {moment.MomentTimezone}
	 */
	getTimezone() {
		return this._timezone;
	}

	/**
	 * Gets UTC timezone.
	 * @returns {moment.MomentTimezone}
	 */
	getUTCTimezone() {
		return this._utcTimezone;
	}

	/**
	 * Gets local timezone.
	 * @returns {moment.MomentTimezone}
	 */
	getLocalTimezone() {
		return this._localTimezone;
	}

	/**
	 * Checks if time is displayed in UTC.
	 * @returns {boolean}
	 */
	isUTC() {
		return this._isUTC;
	}

	/**
	 * Sets UTC mode on/off for time display.
	 * Updates timezone as UTC or local.
	 * @param {boolean} val - on/off
	 */
	setDisplayUTC(val) {
		// TODO: Should support different timezone
		this._isUTC = val;
		this._timezone = this._isUTC ? this._utcTimezone : this._localTimezone;

		// Callbacks
		this.triggerCallbacks('timezone', [val]);
	}

	/**
	 * Gets all date formats.
	 * @returns {object}
	 */
	getDateFormats() {
		return this._dateFormats;
	}

	/**
	 * Replace all date formats.
	 * @param {object} formats
	 */
	setDateFormats(formats) {
		for (const [key, value] of Object.entries(formats)) {
			if (this._dateFormats[key] !== undefined) {
				Object.assign(this._dateFormats[key], value);
			}
			else {
				this._dateFormats[key] = value;
			}
		}
	}

	/**
	 * Gets a specific date format.
	 * @param {string} format - Format
	 * @param {string} utcLocal - Either utc or local
	 * @returns {string}
	 */
	getDateFormat(format, utcLocal) {
		if (!utcLocal) {
			utcLocal = this._isUTC ? 'utc' : 'local';
		}

		return this._dateFormats[utcLocal][format];
	}

	/**
	 * Add/update a specific date format.
	 * @param {string} name - Format name
	 * @param {object} format
	 */
	setDateFormat(name, format) {
		this._dateFormats[name] = format;
	}

	/**
	 * Get time limits
	 * @returns {object}
	 */
	getLimits() {
		return this._timeLimits;
	}

	/**
	 * Set time limits.
	 * @param {object} limits
	 */
	setLimits(limits) {
		this._timeLimits.min = limits.min.clone();
		this._timeLimits.max = limits.max.clone();
	}

	/**
	 * Get default time limits.
	 * @returns {object}
	 */
	getDefaultLimits() {
		return this._defaultLimits;
	}

	/**
	 * Set default time limits.
	 * @param {object} limits - min and max moments
	 */
	setDefaultLimits(limits) {
		this._defaultLimits.min = limits.min.clone();
		this._defaultLimits.max = limits.max.clone();
	}

	/**
	 * Reset time limits to default.
	 */
	resetLimits() {
		this._timeLimits.min = this._defaultLimits.min.clone();
		this._timeLimits.max = this._defaultLimits.max.clone();
	}

	/**
	 * Set the lower limit for time.
	 * @param {*} time - Any value that can be parsed by moment
	 */
	setMin(time) {
		this._timeLimits.min = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(time, this._timezone);
	}

	/**
	 * Reset the lower time limit to default.
	 */
	resetMin() {
		this._timeLimits.min = this._defaultLimits.min.clone();
	}

	/**
	 * Set the upper limit for time.
	 * @param {*} time - Any value that can be parsed by moment
	 */
	setMax(time) {
		this._timeLimits.max = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(time, this._timezone);
	}

	/**
	 * Reset the upper time limit to default.
	 */
	resetMax() {
		this._timeLimits.max = this._defaultLimits.max.clone();
	}

	/**
	 * Gets a url formatted string in UTC.
	 * @param {moment} [time] - Moment time
	 * @returns {string}
	 */
	getTimeUrl(time) {
		let utcTime;
		if (!time) {
			utcTime = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().utc(this._time);
		}
		else {
			utcTime = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().utc(moment_timezone__WEBPACK_IMPORTED_MODULE_1___default().tz(time, this._timezone));
		}
		// Returns UTC formatted string
		return utcTime.utc().format(this._dateFormats.utc.url);
	}

	/**
	 * Get the default time rate.
	 * @returns {number}
	 */
	getDefaultTimeRate() {
		return this._defaultRate;
	}

	/**
	 * Set the default time rate.
	 * @param {number} rate
	 */
	setDefaultTimeRate(rate) {
		this._defaultRate = rate;
	}

	/**
	 * Reset time rate to default.
	 */
	resetTimeRate() {
		this.setTimeRate(this._defaultRate);
	}

	/**
	 * Gets current time rate.
	 * @returns {number}
	 */
	getTimeRate() {
		return this.pioneer.getTimeRate();
	}

	/**
	 * Sets current time rate.
	 * @param {number} rate
	 */
	setTimeRate(rate) {
		this._rate = rate;
		this.pioneer.setTimeRate(rate);

		// Callbacks
		this.triggerCallbacks('ratechange', [this._rate]);
	}

	/**
	 * Plays previous time rate or 1 sec/sec if previous time rate is 0.
	 */
	play() {
		const rate = this._previousTimeRate === 0 ? this._defaultRate : this._previousTimeRate;
		this.setTimeRate(rate);
	}

	/**
	 * Pauses time.
	 */
	pause() {
		this._previousTimeRate = this.getTimeRate();
		this.setTimeRate(0);
	}

	/**
	 * Gets time between two moments.
	 * @param {moment} a - First moment time
	 * @param {moment} b - Second moment time
	 * @returns {moment}
	 */
	getMidTime(a, b) {
		const midTime = (a.unix() + b.unix()) / 2;
		const m = moment_timezone__WEBPACK_IMPORTED_MODULE_1___default()(midTime, 'X');
		return m;
	}

	/**
	 * Returns a list of event names.
	 * @returns {Array<string>}
	 */
	getEventNames() {
		return this._eventNames;
	}

	/**
	 * Checks if time is within app time limits.
	 * @param {moment} time
	 * @returns {number} - negative for before, positive for after and zero for in bounds
	 */
	isWithinLimits(time) {
		if (this._timeLimits.min && time.isBefore(this._timeLimits.min)) {
			return -1;
		}
		if (this._timeLimits.max && time.isAfter(this._timeLimits.max)) {
			return 1;
		}
		return 0;
	}

	/**
	 * Gets time limits.
	 * @returns {object}
	 */
	get timeLimits() {
		return this._timeLimits;
	}

	/**
	 * Gets the forced pause status.
	 * @returns {boolean}
	 */
	get forcedPause() {
		return this._forcedPause;
	}

	/**
	 * Gets the previous time rate.
	 * @returns {number}
	 */
	get previousTimeRate() {
		return this._previousTimeRate;
	}
}


/***/ }),

/***/ "../eyes/src/managers/title_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/title_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TitleManager": function() { return /* binding */ TitleManager; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");


/**
 * Every app has a _sceneInfo object and it is passed in to populate the scene.
 * @typedef TitleOptions
 * @property {string} prefix
 * @property {string} suffix
 * @property {Function} parseFn
 */

/**
 * Title Manager class.
 *
 * When initializing this class, pass in the prefex, suffix, and parse function into the options object. Eg:
 *
 * {
 * 	prefix: 'Eyes on <>',
 * 	suffix: 'NASA/JPL',
 * 	parseFn: (currentRoute) => currentRoute.url
 * }
 * @extends BaseManager
 */
class TitleManager extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {TitleOptions} options
	 */
	constructor(app, options) {
		super(app);

		/**
		 * @type {TitleOptions}
		 * @private
		 */
		this._options = options;

		/**
		 * @type {string}
		 * @private
		 */
		this._currentTitle = null;

		/**
		 * @type {string}
		 * @private
		 */
		this._fullTitle = null;

		/**
		 * @type {Function}
		 * @private
		 */
		this._parseFn = this._options.parseFn ?? null;
	}

	/**
	 * Builds the title strings and sets it.
	 * @param {object} currentRoute
	 */
	updateTitle(currentRoute) {
		const { prefix, suffix } = this._options || {};

		this._currentTitle = this._parseRoute(currentRoute);
		this._fullTitle = `${prefix} - ${this._currentTitle} - ${suffix}`;

		// In the future, we may need a customizable title format.
		document.title = this._fullTitle;
	}

	/**
	 * Parses the route string. Applies parseFn if it's set
	 * @param {string} routeStr
	 * @returns {string}
	 */
	_parseRoute(routeStr) {
		if (this._parseFn) {
			return this._parseFn(routeStr);
		}

		return 'Home';
	}

	/**
	 * Set the parse function.
	 * @param {Function} parseFn
	 */
	setParseFunction(parseFn) {
		if (typeof parseFn === 'function') {
			this._parseFn = parseFn;
		}
	}

	/**
	 * Get the current title.
	 * @returns {string}
	 */
	get currentTitle() {
		return this._currentTitle;
	}

	/**
	 * Get the current title.
	 * @returns {string}
	 */
	get fullTitle() {
		return this._fullTitle;
	}
}


/***/ }),

/***/ "../eyes/src/managers/trail_manager.js":
/*!*********************************************!*\
  !*** ../eyes/src/managers/trail_manager.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrailManager": function() { return /* binding */ TrailManager; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer-scripts */ "../pioneer/scripts/src/index.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../internal */ "../eyes/src/internal.js");


// Import locals


/**
 * The Trail Manager class.
 */
class TrailManager extends _internal__WEBPACK_IMPORTED_MODULE_2__.BaseManager {
	/**
	 * Constructor.
	 * @param {BaseApp} app
	 * @param {Pioneer.Scene} scene
	 */
	constructor(app, scene) {
		super(app);

		/**
		 * The scene that the trails are in.
		 * @type {Pioneer.Scene}
		 */
		this._scene = scene;

		/**
		 * List of entities that has trail.
		 * @type {Array}
		 * @private
		 */
		this._ids = [];

		/**
		 * List of entities that hide trail.
		 * @type {Array}
		 * @private
		 */
		this._hiddenIds = [];

		/**
		 * Trail opacities.
		 * @type {object}
		 * @private
		 * @default
		 */
		this._opacity = {
			primary: 0.75,
			secondary: 0.35,
			hover: 1.0
		};

		/**
		 * Trail width boundaries.
		 * @type {object}
		 * @private
		 * @default
		 */
		this._width = {
			default: [0, 2],
			hover: [2, 4]
		};

		this._orbitLinesOpts = {
			lineWidth: {
				default: 1.2,
				hover: 2
			},
			glowWidth: {
				default: 0,
				hover: 0
			},
			alphaFade: [22, 8]
		};

		/**
		 * Array of entity names that need orbit lines.
		 * @type {Set<string>}
		 * @private
		 * @default
		 */
		this._orbitLineEntityNames = pioneer_scripts__WEBPACK_IMPORTED_MODULE_1__.Entity.getEntityNamesInGroup('planets').add('moon');

		/**
		 * Trail colors.
		 * @type {object}
		 * @private
		 * @default
		 */
		this._colors = {
			default: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, this._opacity.secondary),
			mercury: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(151 / 255, 104 / 255, 172 / 255, this._opacity.primary),
			venus: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(176 / 255, 121 / 255, 25 / 255, this._opacity.primary),
			earth: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(0 / 255, 153 / 255, 204 / 255, this._opacity.primary),
			mars: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(154 / 255, 78 / 255, 25 / 255, this._opacity.primary),
			jupiter: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(218 / 255, 139 / 255, 114 / 255, this._opacity.primary),
			saturn: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(213 / 255, 193 / 255, 135 / 255, this._opacity.primary),
			uranus: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(104 / 255, 204 / 255, 218 / 255, this._opacity.primary),
			neptune: new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(112 / 255, 140 / 255, 227 / 255, this._opacity.primary)
		};

		// Binds
		this.bindFunctions([
			'onHoverChange',
			'setUpTrail',
			'toggleTrails',
			'toggleOrbits'
		]);
	}

	/**
	 * Sets the scene.
	 * @param {Pioneer.Scene} scene
	 */
	setScene(scene) {
		this._scene = scene;
	}

	/**
	 * Create a trail for entity.
	 * @param {string} id
	 * @returns {Pioneer.TrailComponent}
	 */
	create(id) {
		const trail = this._scene.get(id, 'trail');
		if (trail) {
			console.warn('Trail already exists for', id);
			return;
		}

		const entity = this._scene.get(id);
		const result = entity.addComponent('trail');
		this._ids.push(id);
		return result;
	}

	/**
	 * Set start time of the trails.
	 * @param {string | string[]} ids - Id or array of ids of the entities.
	 * @param {number} start - Start time.
	 */
	setStartTime(ids, start) {
		if (!Array.isArray(ids)) {
			ids = [ids];
		}

		for (let i = 0; i < ids.length; i++) {
			const trail = this._scene.get(ids[i], 'trail');

			if (trail) {
				trail.setStartTime(start);
			}
		}
	}

	/**
	 * Set end time of the trails.
	 * @param {string | string[]} ids - Id or array of ids of the entities.
	 * @param {number} end - End time.
	 */
	setEndTime(ids, end) {
		if (!Array.isArray(ids)) {
			ids = [ids];
		}

		for (let i = 0; i < ids.length; i++) {
			const trail = this._scene.get(ids[i], 'trail');

			if (trail) {
				trail.setEndTime(end);
			}
		}
	}

	/**
	 * Update trail when entity has or loses hover.
	 * @param {string} id
	 * @param {boolean} isHovered
	 * @param {boolean} setEndOpacity
	 */
	onHoverChange(id, isHovered, setEndOpacity = false) {
		const entity = this._scene.get(id);
		const trail = this._scene.get(id, 'trail');
		const orbitLine = entity?.get('orbitLine');

		if (!entity || (!trail && !orbitLine)) {
			return;
		}

		const color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color();
		const colorComponent = trail ?? orbitLine;
		const optsKey = isHovered ? 'hover' : 'default';

		// Set properties for orbit line or trail.
		if (orbitLine) {
			// Set the line and glow width.
			const { lineWidth, glowWidth } = this._orbitLinesOpts;
			orbitLine.setLineWidth(lineWidth[optsKey]);
			orbitLine.setGlowWidth(glowWidth[optsKey]);
		}
		else if (trail) {
			// Set the widths.
			const width = entity.trailHover?.width?.[optsKey] ?? this._width[optsKey];
			trail.setWidths(...width);
		}

		// Set alpha.
		const { primary, secondary, hover } = this._opacity;
		const alpha = isHovered ? hover : (this._colors[id] ? primary : secondary);

		color.copy(colorComponent.getColor());
		color.a = alpha;
		colorComponent.setColor(color);

		setEndOpacity && trail.setAlphaFade(color.a);
	}

	/**
	 * Set alpha fade of the trails.
	 * @param {string | string[]} ids - Id or array of ids of the entities.
	 * @param {number} fade - Fade amount of the trails between 0 and 1.
	 */
	setFade(ids, fade) {
		if (!Array.isArray(ids)) {
			ids = [ids];
		}

		for (let i = 0; i < ids.length; i++) {
			const trail = this._scene.get(ids[i], 'trail');

			if (trail) {
				trail.setAlphaFade(fade);
			}
		}
	}

	/**
	 * Set the trails color.
	 * @param {string | string[]} ids - Id or array of ids of the entities.
	 * @param {number} widthMin - Min width of the trails.
	 * @param {number} widthMax - Max width of the trails.
	 */
	setWidths(ids, widthMin, widthMax) {
		if (!Array.isArray(ids)) {
			ids = [ids];
		}

		for (let i = 0; i < ids.length; i++) {
			const trail = this._scene.get(ids[i], 'trail');

			if (trail) {
				trail.setWidths(widthMin, widthMax);
			}
		}
	}

	/**
	 * Set the widths of multiple trail ids
	 * @param {Array<string>} ids
	 * @param {number} minWidth
	 * @param {number} maxWidth
	 */
	setMultipleWidths(ids, minWidth, maxWidth) {
		for (const id of ids) {
			const trail = this._scene.get(id, 'trail');
			if (!trail) {
				continue;
			}

			trail.setWidths(minWidth, maxWidth);
		}
	}

	/**
	 * Get the trails color.
	 * @param {string} id - Id of the entity.
	 * @returns {Pioneer.Color}
	 */
	getColor(id) {
		const trail = this._scene.get(id, 'trail');

		if (trail) {
			return trail.getColor();
		}

		return null;
	}

	/**
	 * Set the trails color.
	 * @param {string | string[]} ids - id or array of ids of the entities
	 * @param {Pioneer.Color} [color=null] - color of the trails
	 */
	setColor(ids, color = null) {
		if (!Array.isArray(ids)) {
			ids = [ids];
		}

		for (let i = 0; i < ids.length; i++) {
			const id = ids[i];
			const trail = this._scene.get(id, 'trail');

			if (trail) {
				const trailColor = color instanceof pioneer__WEBPACK_IMPORTED_MODULE_0__.Color
					? color
					: this._colors[id] || this._colors.default;
				trail.setColor(trailColor);
			}
		}
	}

	/**
	 * Callback to execute custom code for trails after entity is created.
	 * @param {Pioneer.Entity} entity
	 * @private
	 */
	setUpTrail(entity) {
		// Check status of trails with the layer manager
		// Whatever custom code for trails we need to call after entity is created.
		const layerManager = /** @type {LayerManager} */ (this._app.getManager('layer'));
		const sceneManager = /** @type {SceneManager} */ (this._app.getManager('scene'));
		const targetId = entity.getName();
		const trailsLayer = layerManager.getLayer('trails');

		// Should the entity have orbit lines
		const createOrbitLine = this._orbitLineEntityNames.has(targetId);

		if (createOrbitLine) {
			this.createOrbitLine(entity);
		}

		// Reset visibility of trails
		if ((trailsLayer !== null && !trailsLayer.visible) || createOrbitLine) {
			sceneManager.setVisibility(false, targetId);
		}
	}

	/**
	 * Show trails.
	 * @param {string | string[] | null} [ids=null] - Id or array of ids of the entities. If none, show previously hidden or all trails.
	 */
	show(ids = null) {
		if (ids === null) {
			ids = this._hiddenIds.length > 0 ? this._hiddenIds : this._ids;
		}
		else if (!Array.isArray(ids)) {
			ids = [ids];
		}

		for (let i = 0; i < ids.length; i++) {
			const id = ids[i];
			const trail = this._scene.get(id, 'trail');

			if (trail) {
				// Remove from list of hidden trails
				const hiddenIndex = this._hiddenIds.indexOf(id);
				if (hiddenIndex !== -1) {
					this._hiddenIds.splice(hiddenIndex, 1);
				}
				trail.setEnabled(true);
			}
			else {
				console.warn('TrailManager.show: Trail does not exist - ', id);
			}
		}
	}

	/**
	 * Hide trails.
	 * @param {string | string[]} [ids=null] - Id or array of ids of the entities. If none, hide all trails.
	 */
	hide(ids = null) {
		if (ids === null) {
			ids = this._ids;
		}
		else if (!Array.isArray(ids)) {
			ids = [ids];
		}
		this._hiddenIds = ids;

		for (let i = 0; i < ids.length; i++) {
			const trail = this._scene.get(ids[i], 'trail');

			if (trail) {
				trail.setEnabled(false);
			}
		}
	}

	/**
	 * Toggles all the trails in the scene.
	 * @param {boolean} active
	 * @param {object} options
	 * @param {Pioneer.Scene} [options.scene = undefined]
	 */
	toggleTrails(active, { scene = undefined } = {}) {
		if (scene === undefined) {
			scene = this._scene;
		}
		for (let i = 0; i < scene.getNumEntities(); i++) {
			const entity = scene.getEntity(i);
			const trail = entity.get('trail');
			if (trail !== null) {
				const entityInfo = this._app.getManager('content').getEntityInfo(entity.getName());
				if (entityInfo) {
					const category = entityInfo.category;
					const subcategory = entityInfo.subcategory;

					// Check if layer for this category is disabled
					// We dont want to turn on trails of entities disabled
					// An exception should be made for forceVisibled entities.
					const layer = this._app.getManager('layer').getLayerFromCategory(subcategory) || this._app.getManager('layer').getLayerFromCategory(category);
					const { forceVisible = false } = this.app.getManager('scene').getEntityStatus(entity.getName()) || {};

					if (layer !== null && !layer.visible && !forceVisible) {
						trail.setEnabled(false);
					}
					else {
						trail.setEnabled(active);
					}
				}
				else {
					trail.setEnabled(active);
				}
			}
		}
	}

	/**
	 * Creates orbit lines
	 * @param {Pioneer.Entity} entity
	 */
	createOrbitLine(entity) {
		// First check if we have a trail and remove it.
		const trail = entity.get('trail');
		trail && entity.removeComponent(trail);

		// Add orbit line component.
		const orbitLine = entity.addComponent('orbitLine');

		// Set color, fade and line properties.
		const { lineWidth, glowWidth, alphaFade } = this._orbitLinesOpts;
		const color = this._colors[entity.getName()] ?? this._colors.default;

		orbitLine.setColor(color);
		orbitLine.setPixelSpaceRadiiAlphaFade(...alphaFade);
		orbitLine.setLineWidth(lineWidth.default);
		orbitLine.setGlowWidth(glowWidth.default);

		// Set enbaled depending on whether 'orbits' is checked in the layers manager
		const enabled = this._app.getManager('layer').getLayer('orbits').visible;
		orbitLine.setEnabled(enabled);
	}

	/**
	 * Callback for orbit line toggle
	 * @param {boolean} active
	 */
	toggleOrbits(active) {
		this._orbitLineEntityNames.forEach(entityName => {
			const orbitLine = this._scene.get(entityName, 'orbitLine');
			orbitLine?.setEnabled(active);
		});
	}

	/**
	 * Get all entity ids with trail.
	 * @returns {string[]}
	 */
	get ids() {
		return this._ids;
	}

	/**
	 * Set entity ids with trail.
	 * @param {string[]} ids
	 */
	set ids(ids) {
		if (!Array.isArray(ids)) {
			ids = [ids];
		}
		for (let i = 0; i < ids.length; i++) {
			const id = ids[i];
			if (this._ids.includes(id)) {
				continue;
			}
			const trail = this._scene.get(id, 'trail');

			if (trail) {
				this._ids.push(id);
			}
		}
	}
}


/***/ }),

/***/ "../eyes/src/types.js":
/*!****************************!*\
  !*** ../eyes/src/types.js ***!
  \****************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Types": function() { return /* binding */ Types; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../eyes/src/internal.js");


/**
 * The class that holds the mappings from component names to their corresponding constructors.
 * @type {Map<string, typeof BaseComponent>}
 */
const Types = new Map();

Types.set('TimeManager', _internal__WEBPACK_IMPORTED_MODULE_0__.TimeManager);
Types.set('SelectionManager', _internal__WEBPACK_IMPORTED_MODULE_0__.SelectionManager);
Types.set('LabelManager', _internal__WEBPACK_IMPORTED_MODULE_0__.LabelManager);
Types.set('TitleManager', _internal__WEBPACK_IMPORTED_MODULE_0__.TitleManager);
Types.set('TrailManager', _internal__WEBPACK_IMPORTED_MODULE_0__.TrailManager);
Types.set('CameraFollowManager', _internal__WEBPACK_IMPORTED_MODULE_0__.CameraFollowManager);

Types.set('LoadIcon', _internal__WEBPACK_IMPORTED_MODULE_0__.LoadIcon);
Types.set('Overlay', _internal__WEBPACK_IMPORTED_MODULE_0__.Overlay);
Types.set('Settings', _internal__WEBPACK_IMPORTED_MODULE_0__.Settings);
Types.set('Breadcrumb', _internal__WEBPACK_IMPORTED_MODULE_0__.Breadcrumb);
Types.set('Clock', _internal__WEBPACK_IMPORTED_MODULE_0__.Clock);
Types.set('ClockShortcut', _internal__WEBPACK_IMPORTED_MODULE_0__.ClockShortcut);
Types.set('Story', _internal__WEBPACK_IMPORTED_MODULE_0__.Story);
Types.set('LayerPanel', _internal__WEBPACK_IMPORTED_MODULE_0__.LayerPanel);
Types.set('Search', _internal__WEBPACK_IMPORTED_MODULE_0__.Search);
Types.set('Carousel', _internal__WEBPACK_IMPORTED_MODULE_0__.Carousel);
Types.set('TutorialOverlay', _internal__WEBPACK_IMPORTED_MODULE_0__.TutorialOverlay);

Types.set('CarouselPanel', _internal__WEBPACK_IMPORTED_MODULE_0__.CarouselPanel);
Types.set('ShareModal', _internal__WEBPACK_IMPORTED_MODULE_0__.ShareModal);
Types.set('TimeController', _internal__WEBPACK_IMPORTED_MODULE_0__.TimeController);
Types.set('KioskBase', _internal__WEBPACK_IMPORTED_MODULE_0__.KioskBase);
Types.set('Toast', _internal__WEBPACK_IMPORTED_MODULE_0__.Toast);




/***/ }),

/***/ "../eyes/src/utils/animation_utils.js":
/*!********************************************!*\
  !*** ../eyes/src/utils/animation_utils.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimationUtils": function() { return /* binding */ AnimationUtils; }
/* harmony export */ });
/**
 * The animation utils class.
 */
class AnimationUtils {
}

/**
 * Uses the Web Animations API to create, pause and return an animation
 * @param {HTMLElement} element
 * @param {object|Array} keyframes
 * @param {object|number} timings
 * @returns {Animation}
 */
AnimationUtils.createAnimation = (element, keyframes, timings) => {
	const kEffect = new KeyframeEffect(element, keyframes, timings);
	return new Animation(kEffect, element.ownerDocument.timeline);
};

AnimationUtils.directionalFade = (element, { direction = 'up', fade = 'in', yOffset = 0, xOffset = 0, timings = AnimationUtils.defaultTimings }) => {
	// Storing values
	const v = {
		x: { ori: 0, dest: 0 },
		y: { ori: 0, dest: 0 },
		opacity: { ori: 1.0, dest: 0.0 }
	};

	// Fade in/out horizontal
	// x0 > x100 / x100 > x0
	// Fade in/out vertical
	// y0 > y100 / y100 > y0
	if (direction === 'up' || direction === 'down') {
		v.y.ori = (fade === 'in') ? 100 : 0;
		v.y.dest = 100 - v.y.ori;
		if (direction === 'up') {
			v.y.ori *= -1;
			v.y.dest *= -1;
		}
	}
	else {
		v.x.ori = (fade === 'in') ? 100 : 0;
		v.x.dest = 100 - v.x.ori;
		if (direction === 'left') {
			v.x.ori *= -1;
			v.x.dest *= -1;
		}
	}

	// If fade in switch opacity values
	if (fade === 'in') {
		v.opacity.ori = 0.0;
		v.opacity.dest = 1.0;
	}

	// Apply offsets
	v.x.ori += xOffset;
	v.x.dest += xOffset;
	v.y.ori += yOffset;
	v.y.dest += yOffset;

	const keyframes = [
		{ transform: 'translate(' + v.x.ori + '%, ' + v.y.ori + '%)', opacity: v.opacity.ori },
		{ transform: 'translate(' + v.x.dest + '%, ' + v.y.dest + '%)', opacity: v.opacity.dest }
	];

	return AnimationUtils.createAnimation(element, keyframes, timings);
};

AnimationUtils.defaultTimings = {
	duration: 1000,
	iteration: 1,
	fill: 'forwards',
	easing: 'ease'
};


/***/ }),

/***/ "../eyes/src/utils/app_utils.js":
/*!**************************************!*\
  !*** ../eyes/src/utils/app_utils.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AppUtils": function() { return /* binding */ AppUtils; }
/* harmony export */ });
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! deepmerge */ "../eyes/node_modules/deepmerge/dist/cjs.js");
/* harmony import */ var deepmerge__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(deepmerge__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.debounce */ "../eyes/node_modules/lodash.debounce/index.js");
/* harmony import */ var lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_debounce__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.throttle */ "../eyes/node_modules/lodash.throttle/index.js");
/* harmony import */ var lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_throttle__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! overlayscrollbars */ "../eyes/node_modules/overlayscrollbars/js/OverlayScrollbars.js");
/* harmony import */ var overlayscrollbars__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(overlayscrollbars__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var overlayscrollbars_css_OverlayScrollbars_css__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! overlayscrollbars/css/OverlayScrollbars.css */ "../eyes/node_modules/overlayscrollbars/css/OverlayScrollbars.css");
/* harmony import */ var _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @tweenjs/tween.js */ "../eyes/node_modules/@tweenjs/tween.js/dist/tween.esm.js");







/**
 * The utils class.
 */
class AppUtils {
	static conversionTable = {
		kmToMi: 0.621371, // 1 km in miles
		kmToFt: 3280.84, // 1 km in feet
		miToFt: 5280, // 1 mile in feet
		kmToM: 1000, // 1 km in meters
		auToKm: 149597871, // 1 astromonical unit in km
		ldToKm: 384398 // 1 lunar distance in km
	};

	static constants = {
		speedOfLight: 299792.458, // km/sec,
		minDate: -8e+15, // per https://262.ecma-international.org/5.1/#sec-15.9.1.1
		maxDate: 8e+15 // per https://262.ecma-international.org/5.1/#sec-15.9.1.1
	};

	/**
	 * Check if an object is empty or not.
	 * @param {object} obj
	 * @returns {boolean}
	 */
	static isEmptyObject(obj) {
		return obj.constructor === Object && Object.keys(obj).length === 0;
	}

	/**
	 * Add starting part to path if path hasn't already started with it.
	 * @param {string} pathName
	 * @param {string} [start='/'] - Starting slash or symbol
	 * @returns {string}
	 */
	static addStartToPath(pathName, start = '/') {
		if (!pathName.startsWith(start)) {
			return start + pathName;
		}
		return pathName;
	}

	/**
	 * Remove duplicate symbol from path.
	 * @param {string} pathName
	 * @param {string} [duplicate='/']
	 * @param {string} [replacement='/']
	 * @returns {string}
	 */
	static cleanPathDuplicate(pathName, duplicate = '/', replacement = '/') {
		const re = new RegExp(`${duplicate}+`, 'g');
		return pathName.replace(re, replacement);
	}

	/**
	 * Add ending part to path if path hasn't already ended with it.
	 * @param {string} pathName
	 * @param {string} [end='/'] - Ending slash or extension
	 * @returns {string}
	 */
	static addEndToPath(pathName, end = '/') {
		if (!pathName.endsWith(end)) {
			return pathName + end;
		}
		return pathName;
	}

	/**
	 * Check if an object is HTML Element.
	 * @param {object} obj
	 * @returns {boolean}
	 */
	static isElement(obj) {
		return obj instanceof Element || obj instanceof Document;
	}

	/**
	 * Check if a string is HTML.
	 * @param {string} str
	 * @returns {boolean}
	 */
	static isHTML(str) {
		if (typeof str !== 'string') {
			return false;
		}
		return str.match(/<[^/>]+>/gm) !== null && str.match(/<\/[^>]+>/gm) !== null;
	}

	/**
	 * Check if a string has HTML tag inside.
	 * @param {string} str
	 * @returns {boolean}
	 */
	static hasHTML(str) {
		if (typeof str !== 'string') {
			return false;
		}
		const doc = new DOMParser().parseFromString(str, 'text/html');
		return Array.from(doc.body.childNodes).some(node => node.nodeType === 1);
	}

	/**
	 * Load JSON file.
	 * @param {string} fileName
	 * @returns {Promise<object>}
	 * @throws {Error} Throw error if status is not 200
	 */
	static async loadJSON(fileName) {
		fileName = AppUtils.addEndToPath(fileName, '.json');
		const response = await fetch(fileName);
		if (response.status === 200) {
			return response.json();
		}
		else {
			// Throw error
			const err = new Error(response.status + ' (' + response.statusText + ') when trying to fetch "' + fileName + '"');
			err.name = 'NotFound';
			throw err;
		}
	}

	/**
	 * Convert milliseconds to time.
	 * @param {number} [ms=0]
	 * @returns {{hour: number, minute: number, second: number, millisecond: number}} Converted time
	 */
	static msToTime(ms = 0) {
		const millisecond = ms % 1000;
		ms = (ms - millisecond) / 1000;
		const second = ms % 60;
		ms = (ms - second) / 60;
		const minute = ms % 60;
		const hour = (ms - minute) / 60;

		return {
			hour,
			minute,
			second,
			millisecond
		};
	}

	/**
	 * Format time into hh:mm:ss for session timer
	 * @param {number} maxSessionTime - in ms
	 * @param {number} incomingTime - in ms
	 * @returns {string}
	 */
	static formatCountdownTime(maxSessionTime, incomingTime) {
		// One hour in milliseconds
		const oneHour = 60 * 60 * 1000;
		const time = this.msToTime(incomingTime);

		// Pad the front with '0' until it hits 2 digits
		time.hour = time.hour.toString().padStart(2, '0');
		time.minute = time.minute.toString().padStart(2, '0');
		time.second = time.second.toString().padStart(2, '0');

		return `${maxSessionTime >= oneHour ? time.hour + ':' : ''}${time.minute || '00'}:${time.second}`;
	}

	/**
	 * Convert to sec
	 * @param {number} minutes
	 * @returns {number}
	 */
	static minToSec(minutes) {
		return minutes * 60;
	}

	/**
	 * Convert to ms
	 * @param {number} minutes
	 * @returns {number}
	 */
	static minToMS(minutes) {
		return minutes * 60000;
	}

	/**
	 * Return if the mission start date is in the future
	 * @param {string} startDate
	 * @returns {boolean}
	 */
	static isFutureMission(startDate) {
		const today = new Date();
		const missionStartDate = new Date(startDate);

		return missionStartDate > today;
	}

	/**
	 * Copies an object and its sublevels.
	 * For objects that can be stringified and parsed.
	 * @param {object} object1
	 * @returns {object}
	 */
	static deepCopy(object1) {
		return JSON.parse(JSON.stringify(object1));
	}

	/**
	 * Clones an object and its sublevels.
	 * For object that cannot be stringified and parsed.
	 * @see https://stackoverflow.com/questions/122102/what-is-the-most-efficient-way-to-deep-clone-an-object-in-javascript/10916838#10916838
	 * @param {any} obj
	 * @returns {any}
	 */
	static deepClone(obj) {
		const out = /** @type {any} */(Array.isArray(obj) ? [] : {});
		for (const key in obj) {
			const value = /** @type {any} */(obj[key]);
			out[key] = (typeof value === 'object' && value !== null) ? AppUtils.deepClone(value) : value;
		}
		return out;
	}

	/**
	 * Uses the deepmerge library from https://github.com/TehShrike/deepmerge
	 * with custom options to prevent merging of Moment objects
	 * @param {object} object1
	 * @param {object} object2
	 * @returns {object}
	 */
	static deepMerge(object1, object2) {
		const options = {
			isMergeableObject: (/** @type {any} */value) => (value && value._isAMomentObject ? false : Boolean(value) && typeof value === 'object')
		};

		return deepmerge__WEBPACK_IMPORTED_MODULE_0___default()(object1, object2, options);
	}


	/**
	 * Checks for object deep equality.
	 * @param {any} object1
	 * @param {any} object2
	 * @returns {boolean}
	 */
	static deepEqual(object1, object2) {
		if (!object1 || !object2) {
			return false;
		}
		const keys1 = Object.keys(object1);
		const keys2 = Object.keys(object2);

		if (keys1.length !== keys2.length) {
			return false;
		}

		for (const key of keys1) {
			const val1 = object1[key];
			const val2 = object2[key];
			const areObjects = AppUtils.isObject(val1) && AppUtils.isObject(val2);
			if (areObjects && !AppUtils.deepEqual(val1, val2)) {
				return false;
			}
			else if (!areObjects && val1 !== val2) {
				return false;
			}
		}

		return true;
	}

	/**
	 * Checks if element is an object.
	 * @param {any} object
	 * @returns {boolean}
	 */
	static isObject(object) {
		return object !== null && typeof object === 'object';
	}

	/**
	 * Filter an object.
	 * @param {object} obj - Original object
	 * @param {Function} callback - Condition
	 * @returns {object}
	 */
	static filterObject(obj, callback) {
		return Object.fromEntries(Object.entries(obj).filter(([key, val]) => callback(val, key)));
	}

	/**
	 * Returns lodash's debounce method
	 * @returns {Function}
	 */
	static debounce() {
		return lodash_debounce__WEBPACK_IMPORTED_MODULE_1___default()(...arguments);
	}

	/**
	 * Returns lodash's throttle method
	 * @returns {Function}
	 */
	static throttle() {
		return lodash_throttle__WEBPACK_IMPORTED_MODULE_2___default()(...arguments);
	}

	/**
	 * Waits for n millisecons.
	 * @param {number} n
	 * @returns {Promise<void>}
	 */
	static waitFor(n) {
		return new Promise(resolve => {
			setTimeout(() => {
				resolve();
			}, n);
		});
	}

	/**
	 * Check if the media query is portrait.
	 * @returns {boolean}
	 */
	static isPortrait() {
		return window.matchMedia('(orientation: portrait)').matches;
	}

	/**
	 * Check if the media query is landscape.
	 * @returns {boolean}
	 */
	static isLandscape() {
		return window.matchMedia('(orientation: landscape)').matches;
	}

	/**
	 * Check if the media query is landscape.
	 * @returns {boolean}
	 */
	static isMobileLandscape() {
		return window.matchMedia('(min-width: 320px) and (max-width: 915px) and (orientation: landscape)').matches;
	}

	/**
	 * Check if the media query is portrait.
	 * @returns {boolean}
	 */
	static isMobilePortrait() {
		return window.matchMedia('(min-width: 320px) and (max-width: 640px) and (orientation: portrait)').matches;
	}

	/**
	 * Check if the media query is mobile.
	 * @returns {boolean}
	 */
	static isMobile() {
		return AppUtils.isMobileLandscape() || AppUtils.isMobilePortrait();
	}

	/**
	 * Check if the OS is iOS on an iPhone.
	 * @returns {boolean}
	 */
	static isiPhone() {
		const platform = window.navigator?.userAgentData?.platform || window.navigator?.platform || 'unknown';
		return platform === 'iPhone';
	}

	/**
	 * Check if the OS is iOS on an iPad.
	 * @returns {boolean}
	 */
	static isiPad() {
		// TODO: Update this with a better check if we ever get an intel mac with a touchscreen.
		const platform = window.navigator?.userAgentData?.platform || window.navigator?.platform || 'unknown';
		const touchPoints = window.navigator.maxTouchPoints > 1;
		return (platform === 'MacIntel' && touchPoints);
	}

	/**
	 * Check if the media query is tablet portrait.
	 * @returns {boolean}
	 */
	static isTabletPortrait() {
		return window.matchMedia('(min-width: 641px) and (max-width: 1024px) and (orientation: portrait)').matches;
	}

	/**
	 * Check if the media query is tablet landscape.
	 * @returns {boolean}
	 */
	static isTabletLandscape() {
		return window.matchMedia('(min-width: 916px) and (max-width: 1024px) and (orientation: landscape)').matches;
	}

	/**
	 * Check if the media query is in tablet mode.
	 * @returns {boolean}
	 */
	static isTablet() {
		return AppUtils.isTabletLandscape() || AppUtils.isTabletPortrait();
	}

	/**
	 * Check if the media query is in mobile mode: mobile, tablet, or landscape.
	 * @returns {boolean}
	 */
	static isMobileMode() {
		return AppUtils.isMobilePortrait() || AppUtils.isMobileLandscape() || AppUtils.isTabletLandscape() || AppUtils.isTabletPortrait() || AppUtils.isPanorama();
	}

	/**
	 * Check if the media query is desktop.
	 * @returns {boolean}
	 */
	static isDesktop() {
		return window.matchMedia('(min-width: 1025px) and (min-height: 600px)').matches;
	}

	/**
	 * Check if the media query is panorama.
	 * @returns {boolean}
	 */
	static isPanorama() {
		return window.matchMedia('(min-width: 1025px) and (max-height: 599px) and (orientation: landscape)').matches;
	}

	/**
	 * Check if the media query is 2K.
	 * @returns {boolean}
	 */
	static is2K() {
		return window.matchMedia('(min-width: 2880px) and (min-height: 1620px)').matches;
	}

	/**
	 * Check if the media query is 2K.
	 * @returns {boolean}
	 */
	static is4K() {
		return window.matchMedia('(min-width: 3200px) and (min-height: 1800px)').matches;
	}

	/**
	 * Check if the device is using touch.
	 * @returns {boolean}
	 */
	static isTouch() {
		return ('ontouchstart' in window) || window.navigator.maxTouchPoints > 0;
	}

	/**
	 * Check if the device is primary touch.
	 * @returns {boolean}
	 */
	static isPrimaryTouch() {
		return window.matchMedia('(pointer: coarse)').matches;
	}

	/**
	 * Check if the device supports hovering.
	 * @returns {boolean}
	 */
	static canHover() {
		return !(matchMedia('(hover: none)').matches);
	}

	/**
	 * Create an element from HTML string.
	 * @param {string} html
	 * @returns {Element}
	 */
	static htmlToElement(html) {
		const template = document.createElement('template');
		template.innerHTML = html.replace(/[\t\n]+/g, '').trim(); // Never return a text node of whitespace as the result
		return template.content.firstElementChild;
	}

	/**
	 * Create sibling elements from HTML string.
	 * @param {string} html
	 * @returns {NodeList}
	 */
	static htmlToElements(html) {
		const template = document.createElement('template');
		template.innerHTML = html.replace(/[\t\n]+/g, '').trim(); // Never return a text node of whitespace as the result
		return template.content.cloneNode(true).childNodes;
	}

	/**
	 * Replace variables in HTML string with params' values.
	 * @param {string} html
	 * @param {Object<string, string>} [params={}] - Parameters to replace in HTML string
	 * @returns {string}
	 */
	static insertParamsToHTML(html, params = {}) {
		html = html.replace(/[\t\n]+/g, '').trim();
		const keys = Object.keys(params);

		for (let i = keys.length - 1; i >= 0; i--) {
			const key = keys[i];
			const param = `{$${key}}`;
			html = html.replaceAll(param, params[key]);
		}
		// Replace all unspecified params with empty string
		html = html.replaceAll(/{\$([A-Z])\w+}/gi, '');

		return html;
	}

	/**
	 * Replace variables in HTML string with params' values then create an element.
	 * Format of HTML variable: {$var}.
	 * @example
	 * // Replace <div>{$title}</div> with <div>Hello</div>
	 * htmlWithParamsToElement(html, { title: 'Hello' });
	 * @param {string} html
	 * @param {Object<string, string>} [params={}] - Parameters to replace in HTML string
	 * @returns {Element}
	 */
	static htmlWithParamsToElement(html, params = {}) {
		html = AppUtils.insertParamsToHTML(html, params);
		return AppUtils.htmlToElement(html);
	}

	/**
	 * Periodically check if an element is attached to DOM.
	 * Execute a callback if element is attached, or output error on timeout.
	 * @param {string|HTMLElement} elementQuery - Query string passed to document.querySelector or HTML element
	 * @param {Function} callback - Callback to be called on verified attachment
	 * @param {object} options
	 * @param {number} [options.interval=100] - Interval to check in ms
	 * @param {number} [options.timeout=5000] - Timeout to stop in ms
	 */
	static onAttachElement(elementQuery, callback, { interval = 100, timeout = 5000 } = {}) {
		const myInterval = setInterval(() => {
			const attached = typeof elementQuery === 'string'
				? document.querySelector(elementQuery) !== null
				: document.body.contains(elementQuery);
			if (attached) {
				clearInterval(myInterval);
				clearTimeout(myTimeout);
				callback();
			}
		}, interval);
		const myTimeout = setTimeout(() => {
			clearInterval(myInterval);
			console.error(`[AppUtils.onAttachElement] Timeout exceeded for "${elementQuery}".`);
		}, timeout);
	}

	/**
	 * A callback that is fired once the DOM has detected a node has been added to a specific element.
	 * Similar to the above util, but without the timeouts.
	 * https://stackoverflow.com/questions/5525071/how-to-wait-until-an-element-exists
	 * @param {HTMLElement} parent
	 * @param {HTMLElement} element
	 * @param {string} selector
	 * @param {() => void} callback
	 */
	static appendWithCallback(parent, element, selector, callback) {
		const promise = new Promise(resolve => {
			if (document.querySelector(selector)) {
				return resolve(document.querySelector(selector));
			}

			const observer = new MutationObserver(() => {
				if (document.querySelector(selector)) {
					resolve(document.querySelector(selector));
					observer.disconnect();
				}
			});

			observer.observe(document.body, {
				childList: true,
				subtree: true
			});
		});

		promise.then(callback);

		parent.appendChild(element);
	}

	/**
	 * Uses the mutation observer to wait for an element to be queryable in the DOM. Rejects after timeout.
	 * @param {string} selector
	 * @param {number} timeout
	 * @returns {Promise<Element>}
	 */
	static elementReady(selector, timeout = 1000) {
		return new Promise((resolve, reject) => {
			const element = document.querySelector(selector);
			if (element) {
				resolve(element);
				return;
			}

			const observer = new MutationObserver(() => {
				// Query for elements matching the specified selector
				const element = document.querySelector(selector);
				if (element) {
					observer.disconnect();
					clearTimeout(timer);
					resolve(element);
				}
			});


			observer.observe(document.body, {
				childList: true,
				subtree: true
			});

			const timer = setTimeout(() => {
				observer.disconnect();
				reject(console.warn(`${selector} not found in DOM`));
			}, timeout);
		});
	}

	/**
	 * Add a default scrollbar to an element.
	 * @param {HTMLElement} element
	 * @param {OverlayScrollbars.Options} [options={}] - Options for OverlayScrollbars
	 * @returns {OverlayScrollbars}
	 */
	static addScrollbar(element, options = {}) {
		const opts = /** @type {OverlayScrollbars.Options} */({
			className: 'os-theme-dark', // default
			resize: 'none', // default
			clipAlways: false,
			normalizeRTL: false,
			paddingAbsolute: true,
			autoUpdate: false,
			sizeAutoCapable: false,
			overflowBehavior: {
				x: 'hidden',
				y: 'scroll' // default
			},
			scrollbars: {
				clickScrolling: true,
				autoHide: 'move'
			},
			...options
		});
		return overlayscrollbars__WEBPACK_IMPORTED_MODULE_3___default()(element, opts);
	}

	/**
	 * Makes sure we can add commas and a maximum number of decimal places without float inaccuracies
	 * @param {number} number
	 * @param {number} maxDps - number of decimal places
	 * @param {number} minDps - minimum number of decimal places (ie. can include 10.0)
	 * @returns {string}
	 */
	static formatNumber(number, maxDps = 3, minDps = undefined) {
		return number.toLocaleString(undefined, { maximumFractionDigits: maxDps, minimumFractionDigits: minDps });
	}

	/**
	 * Formats a date to local style with options
	 * @param {Date} date
	 * @param {object} options
	 * @returns {string}
	 */
	static formatDate(date, options = {}) {
		return date.toLocaleString(undefined, { year: 'numeric', month: 'long', day: 'numeric', ...options });
	}

	/**
	 * Tween from one set of values to another in some duration
	 * @param {object} from - Starting values
	 * @param {object} to - Ending values
	 * @param {object} options
	 * @param {(obj: object) => void} [options.onUpdate] - Action on each update
	 * @param {() => void} [options.onComplete] - Action on complete
	 * @param {number} [options.duration=2000] - Duration of animation in milliseconds
	 * @returns {Tween<object>}
	 */
	static tween(from, to, { onUpdate, onComplete, duration = 2000 } = {}) {
		let request = /** @type {number} */(0);
		const tween = new _tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_5__.Tween(from)
			.to(to, duration)
			.onUpdate(obj => {
				if (onUpdate !== undefined) {
					onUpdate(obj);
				}
			})
			.onComplete(() => {
				if (typeof onComplete === 'function') {
					onComplete();
				}
				// Cancel request so it won't call function indefinitely
				cancelAnimationFrame(request);
			})
			.start();

		const tweenAnimationFrame = (/** @type {number} */time) => {
			request = requestAnimationFrame(tweenAnimationFrame);
			(0,_tweenjs_tween_js__WEBPACK_IMPORTED_MODULE_5__.update)(time);
		};
		tweenAnimationFrame();

		return tween;
	}

	/**
	 * Convert values from string to corresponding types in an object.
	 * @param {Object<string, any>} obj
	 * @returns {Object<string, any>}
	 */
	static convertObjType(obj) {
		Object.entries(obj).forEach(([key, value]) => {
			let outValue;
			switch (value.trim()) {
				case 'undefined':
					outValue = undefined; break;
				case 'null':
					outValue = null; break;
				case 'true':
					outValue = true; break;
				case 'false':
					outValue = false; break;
				case 'NaN':
					outValue = NaN; break;
				case '':
					break;
				default:
					outValue = isNaN(value) ? value : parseFloat(value); break;
			}
			obj[key] = outValue;
		});
		return obj;
	}
}


/***/ }),

/***/ "../eyes/src/utils/cancel_token.js":
/*!*****************************************!*\
  !*** ../eyes/src/utils/cancel_token.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CancelToken": function() { return /* binding */ CancelToken; }
/* harmony export */ });
/**
 * Cancel token class.
 */
class CancelToken {
	/**
	 * Constructor.
	 */
	constructor() {
		this._isCanceled = false;
	}

	/**
	 * Sets the state to canceled.
	 */
	cancel() {
		this._isCanceled = true;
	}

	/**
	 * Gets canceled state.
	 * @returns {boolean}
	 */
	get isCanceled() {
		return this._isCanceled;
	}
}


/***/ }),

/***/ "../eyes/src/version.js":
/*!******************************!*\
  !*** ../eyes/src/version.js ***!
  \******************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "version": function() { return /* binding */ version; }
/* harmony export */ });
// Generated by genversion.
const version = '2.4.0';


/***/ }),

/***/ "../pioneer/engine/src/capabilities.js":
/*!*********************************************!*\
  !*** ../pioneer/engine/src/capabilities.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Capabilities": function() { return /* binding */ Capabilities; }
/* harmony export */ });
/** @module pioneer */

/**
 * A class that can be used to find out the capabilities of the current device.
 * @hideconstructor
 */
class Capabilities {
	/**
	 * Returns true if the context is WebGL 2.0.
	 * @returns {boolean}
	 */
	static isWebGL2() {
		return typeof WebGL2RenderingContext !== 'undefined' && _context instanceof WebGL2RenderingContext;
	}

	/**
	 * Returns true if the context has the gl_fragDepth output variable.
	 * @returns {boolean}
	 */
	static hasFragDepth() {
		return this.isWebGL2() || this.hasGLExtension('EXT_frag_depth');
	}

	/**
	 * Returns true if the device has the GL extension enabled.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Using_Extensions}
	 * @param {string} extensionName - The extension name.
	 * @returns {boolean}
	 */
	static hasGLExtension(extensionName) {
		if (_context === null) {
			return false;
		}
		let value = _cache.get(extensionName);
		if (value === undefined) {
			value = _context.getExtension(extensionName) !== null;
			_cache.set(extensionName, value);
		}
		return value;
	}

	/**
	 * Gets the supported compressed texture extension.
	 * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Compressed_texture_formats}
	 * @returns {string}
	 * @internal
	 */
	static __getCompressedTextureExtension() {
		return _compressedTextureExtension;
	}

	/**
	 * Sets the rendering context for use in other functions. Called by Engine.
	 * @param {WebGLRenderingContext} context - The WebGL context.
	 * @internal
	 */
	static __setContext(context) {
		_context = context;

		// Check for support of compressed texture formats.
		_compressedTextureFormats.forEach((value, key) => {
			if (this.hasGLExtension('WEBGL_compressed_texture_' + key) === true
				|| this.hasGLExtension('WEBKIT_WEBGL_compressed_texture_' + key) === true) {
				if (_compressedTextureExtension === '') {
					_compressedTextureExtension = value;
				}
			}
		});
	}
}

/**
 * A cache of capabilities for performance.
 * @type {Map<string, boolean>}
 */
const _cache = new Map();

/**
 * The rendering context for use in other functions.
 * @type {WebGLRenderingContext | null}
 */
let _context = null;

/**
 * The supported compressed texture extension.
 * @type {string}
 */
let _compressedTextureExtension = '';

/**
 * A mapping from compressed texture formats to their corresponding extensions.
 * @type {Map<string, string>}
 */
const _compressedTextureFormats = new Map([
	['astc', 'astc'],
	['s3tc', 'dxt'],
	['pvrtc', 'pvrtc'],
	['etc', 'etc2'],
	['etc1', 'etc1']]);


/***/ }),

/***/ "../pioneer/engine/src/config.js":
/*!***************************************!*\
  !*** ../pioneer/engine/src/config.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Config": function() { return /* binding */ Config; }
/* harmony export */ });
/** @module pioneer */

/**
 * The global configuration. It has event triggering when values change.
 * It has the built-in default keys:
 * <ul>
 * <p>maxTextureSize = 512</p>
 * <p>useTextureCompression = true</p>
 * <p>fontFamily = 'Arial'</p>
 * <p>fontSize = 16</p>
 * <p>gammaCorrection = 1.0</p>
 * </ul>
 */
class Config {
	/**
	 * Constructor. Called by Engine.
	 */
	constructor() {
		/**
		 * The map of keys to values.
		 * @type {Map<string, string | number | boolean>}
		 * @private
		 */
		this._valueMap = new Map();

		/**
		 * The map of keys to callbacks.
		 * @type {Map<string, ((key: string, value: string | number | boolean) => any)[]>}
		 * @private
		 */
		this._callbacksMap = new Map();

		// Setup some defaults.
		this.setValue('maxTextureSize', 512);
		this.setValue('useTextureCompression', true);
		this.setValue('fontFamily', 'Arial');
		this.setValue('fontSize', 16);
		this.setValue('gammaCorrection', 1.0);
	}

	/**
	 * Gets the value for a given key, or undefined if the key is not found.
	 * @param {string} key - the key of the value to get
	 * @returns {string | number | boolean | undefined}
	 */
	getValue(key) {
		return this._valueMap.get(key);
	}

	/**
	 * Sets a value for the given key. Calls any added event listeners.
	 * @param {string} key - the key to set
	 * @param {string | number | boolean} value - the value to set
	 */
	setValue(key, value) {
		const changed = this._valueMap.get(key) !== value;
		if (changed) {
			this._valueMap.set(key, value);
			const callbacks = this._callbacksMap.get(key);
			if (callbacks) {
				for (let i = 0; i < callbacks.length; i++) {
					callbacks[i](key, value);
				}
			}
		}
	}

	/**
	 * Adds a callback to be called when the value of the key changes.
	 * @param {string} key - the key for the callback
	 * @param {(key: string, value: string | number | boolean) => any} callback - the callback
	 */
	addEventListener(key, callback) {
		let callbacks = this._callbacksMap.get(key);
		if (callbacks === undefined) {
			callbacks = [];
			this._callbacksMap.set(key, callbacks);
		}
		callbacks.push(callback);
	}

	/**
	 * Removes the callback of the key.
	 * @param {string} key - the key for the callback
	 * @param {(key: string, value: string | number | boolean) => any} callback - the callback
	 */
	removeEventListener(key, callback) {
		const callbacks = this._callbacksMap.get(key);
		if (callbacks) {
			for (let i = 0; i < callbacks.length; i++) {
				if (callbacks[i] === callback) {
					callbacks.splice(i, 1);
					break;
				}
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/downloader.js":
/*!*******************************************!*\
  !*** ../pioneer/engine/src/downloader.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Download": function() { return /* binding */ Download; },
/* harmony export */   "Downloader": function() { return /* binding */ Downloader; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */



/**
 * A download object for every download that is returned to the user.
 */
class Download {
	/**
	 * The constructor.
	 * @param {string} url
	 * @param {string} actualUrl
	 * @param {boolean} binary
	 */
	constructor(url, actualUrl, binary) {
		/**
		 * The unprocessed url given by the user.
		 * @type {string}
		 */
		this.url = url;

		/**
		 * The processed url actually sent to the browser.
		 * @type {string}
		 */
		this.actualUrl = actualUrl;

		/**
		 * The progress from 0 to 1.
		 * @type {number}
		 */
		this.progress = 0;

		/**
		 * The total content size in bytes.
		 * @type {number}
		 */
		this.totalBytes = 0;

		/**
		 * The content of the completed download.
		 * @type {string | ArrayBuffer | undefined}
		 */
		this.content = undefined;

		/**
		 * Whether or not the content is binary.
		 * @type {boolean}
		 */
		this.binary = binary;

		/**
		 * The status of the download. It can be 'downloading', 'completed', 'cancelled', or 'failed'
		 * @type {'downloading' | 'completed' | 'cancelled' | 'failed'}
		 */
		this.status = 'downloading';

		/**
		 * The error message, if there is one.
		 * @type {string}
		 */
		this.errorMessage = '';
	}
}

/**
 * A download object for every download that is used by the Downloader.
 * @private
 */
class DownloadData {
	/**
	 * The constructor.
	 * @param {string} url
	 * @param {string} actualUrl
	 * @param {boolean} binary
	 */
	constructor(url, actualUrl, binary) {
		/**
		 * The download object to be returned to the user.
		 * @type {Download}
		 */
		this.download = new Download(url, actualUrl, binary);

		/**
		 * The promise that is returned when completed or cancelled.
		 * @type {Promise<Download> | null}
		 */
		this.promise = null;

		/**
		 * The resolve function of the promise.
		 * @type {(download: Download) => void}
		 */
		this.resolve = null;

		/**
		 * The list of callbacks to call when the progress changes.
		 * @type {((download: Download) => any)[]}
		 */
		this.progressCallbacks = [];

		/**
		 * The XMLHttpRequest object.
		 * @type {XMLHttpRequest | null}
		 */
		this.request = null;
	}
}

/**
 * A class that downloads assets. It can preprocess URLs via replacement keywords.
 */
class Downloader {
	/**
	 * Constructor. Called by Engine.
	 */
	constructor() {
		/**
		 * The mapping of strings to replacements when downloading urls.
		 * @type {Map<string, string>}
		 * @private
		 */
		this._replacements = new Map();

		/**
		 * The current set of downloads, mapped from url to Download object.
		 * @type {Map<string, DownloadData>}
		 * @private
		 */
		this._currentDownloads = new Map();

		/**
		 * The download queue, sorted by priority.
		 * @type {[number, DownloadData][]}
		 * @private
		 */
		this._downloadQueue = [];

		/**
		 * The maximum number of current downloads.
		 * @type {number}
		 */
		this._maxCurrentDownloads = 20;
	}

	/**
	 * Gets the replacement for a given name, or undefined if no replacement was found.
	 * @param {string} name - The name to be replaced.
	 * @returns {string | undefined}
	 */
	getReplacement(name) {
		return this._replacements.get(name);
	}

	/**
	 * Sets a replacement so that when a URL contains <em>$name</em>, it will be replaced with the replacement.
	 * @param {string} name - The name (without the $) to be replaced.
	 * @param {string} replacement - The replacement string.
	 */
	setReplacement(name, replacement) {
		this._replacements.set(name, replacement);
	}

	/**
	 * Cancels a download for the given url. If there are multiple downloads of the same url, they are all cancelled.
	 * @param {string} url - The url of the download to cancel.
	 */
	cancel(url) {
		const actualUrl = this.processUrl(url);

		// If we're currently downloading, call the abort function.
		if (this._currentDownloads.has(actualUrl)) {
			const downloadData = this._currentDownloads.get(actualUrl);
			if (downloadData !== undefined && downloadData.request !== null) {
				downloadData.request.abort();
			}
		}
		else {

			// If we're in the queue still, there's no request, so artificially end the download as if there was.
			const queueIndex = this._downloadQueue.findIndex(([_, downloadData]) => downloadData.download.actualUrl === actualUrl);
			if (queueIndex !== -1) {

				const downloadData = this._downloadQueue[queueIndex][1];
				downloadData.download.content = undefined;
				downloadData.download.status = 'cancelled';
				this._downloadQueue.splice(queueIndex, 1);
				downloadData.resolve(downloadData.download);
			}
		}
	}

	/**
	 * Process url parameters, replacing the <code>$name</code> variables with their corresponding replacements.
	 * @param {string} url - The url to process.
	 * @returns {string}
	 */
	processUrl(url) {
		let processedUrl = url;
		for (const [name, replacement] of this._replacements) {
			processedUrl = processedUrl.replace('$' + name, replacement);
		}
		return processedUrl;
	}

	/**
	 * Downloads a file and returns a promise that resolves with a Download object.
	 * If the download is cancelled, the status will be 'cancelled'.
	 * If the download has failed, the status will be 'failed' and the errorMessage will be the error.
	 * If the download has completed, the status will be 'completed'.
	 * It replaces <code>$name</code> variables with their replacements.
	 * @param {string} url - The url to download.
	 * @param {boolean} binary - If true, the Download.content is an ArrayBuffer and is otherwise a string.
	 * @param {(download: Download) => any} [progressCallback] - The callback to be called periodically to report the progress of the download.
	 * @returns {Promise<Download>}
	 */
	download(url, binary, progressCallback) {
		// Process the urls, doing the replacements.
		const actualUrl = this.processUrl(url);

		// If the download already currently running, just return its promise.
		let downloadData = this._currentDownloads.get(actualUrl);
		if (downloadData !== undefined && downloadData.promise !== null) {
			if (progressCallback) {
				downloadData.progressCallbacks.push(progressCallback);
			}
			return downloadData.promise;
		}

		// If the download is in the queue, return its promise.
		const queueIndex = this._downloadQueue.findIndex(([_, downloadData]) => downloadData.download.actualUrl === actualUrl);
		if (queueIndex !== -1) {
			downloadData = this._downloadQueue[queueIndex][1];
			if (progressCallback) {
				downloadData.progressCallbacks.push(progressCallback);
			}
			return downloadData.promise;
		}

		// Create the download object.
		downloadData = new DownloadData(url, actualUrl, binary);

		// Set the promise.
		downloadData.promise = new Promise((resolve) => {

			// Save the resolve function for later calling.
			downloadData.resolve = resolve;

			// Add to the download queue and sort it.
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add([0, downloadData], this._downloadQueue, (a, b) => a[0] < b[0], (a, b) => a[0] === b[0]);

			// Check the download queue to see if we can start this request right away.
			this.checkDownloadQueue();
		});

		return downloadData.promise;
	}

	/**
	 * Does an actual request.
	 * @param {DownloadData} downloadData
	 * @private
	 */
	doRequest(downloadData) {

		// Create the XMLHttpRequest.
		const request = new XMLHttpRequest();

		// Load listener.
		request.addEventListener('load', () => {
			if (200 <= request.status && request.status <= 299) {
				downloadData.download.content = request.response;
				downloadData.download.status = 'completed';
			}
			else {
				downloadData.download.content = undefined;
				downloadData.download.status = 'failed';
			}
			this._currentDownloads.delete(downloadData.download.actualUrl);
			this.checkDownloadQueue();
			downloadData.resolve(downloadData.download);
		});

		// Progress listener.
		request.addEventListener('progress', (event) => {
			downloadData.download.progress = event.lengthComputable ? (event.loaded / event.total) : 0;
			downloadData.download.totalBytes = event.lengthComputable ? event.total : 0;
			for (const progressCallback of downloadData.progressCallbacks) {
				progressCallback(downloadData.download);
			}
		});

		// Abort listener.
		request.addEventListener('abort', () => {
			downloadData.download.content = undefined;
			downloadData.download.status = 'cancelled';
			this._currentDownloads.delete(downloadData.download.actualUrl);
			this.checkDownloadQueue();
			downloadData.resolve(downloadData.download);
		});

		// Error listener.
		request.addEventListener('error', () => {
			downloadData.download.content = undefined;
			downloadData.download.status = 'failed';
			downloadData.download.errorMessage = request.statusText;
			this._currentDownloads.delete(downloadData.download.actualUrl);
			this.checkDownloadQueue();
			downloadData.resolve(downloadData.download);
		});

		if (downloadData.download.binary) {
			request.responseType = 'arraybuffer';
		}
		else {
			request.responseType = 'text';
		}

		downloadData.request = request;
		request.open('GET', downloadData.download.actualUrl);
		request.send();
	}

	/**
	 * Checks the download queue for another download and starts it, if needed.
	 * @private
	 */
	checkDownloadQueue() {
		if (this._currentDownloads.size < this._maxCurrentDownloads && this._downloadQueue.length > 0) {
			const [_, downloadData] = this._downloadQueue.shift();
			this._currentDownloads.set(downloadData.download.actualUrl, downloadData);
			this.doRequest(downloadData);
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/engine.js":
/*!***************************************!*\
  !*** ../pioneer/engine/src/engine.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Engine": function() { return /* binding */ Engine; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * @callback ComponentConstructor
 * @param {string} type - The type of the component.
 * @param {string} name
 * @param {Entity} parent
 * @returns {BaseComponent}
 */

/**
 * @callback ControllerConstructor
 * @param {string} type
 * @param {string} name
 * @param {Entity} parent
 * @returns {BaseController}
 */

/**
 * The main driver of the Pioneer engine.
 */
class Engine {
	/**
	 * Constructs the Pioneer engine.
	 * @param {HTMLDivElement} rootDiv - A &lt;div&gt; element. The canvas and Pioneer UI will go inside of it.
	 */
	constructor(rootDiv) {
		// Make sure the root div is an actual div element.
		if (!(rootDiv instanceof HTMLDivElement)) {
			throw new Error('The root div param is not an actual div element.');
		}

		/**
		 * The root &lt;div&gt; element.
		 * @type {HTMLDivElement}
		 * @private
		 */
		this._rootDiv = rootDiv;

		/**
		 * The canvas created by the engine inside the root div.
		 * @type {HTMLCanvasElement}
		 * @private
		 */
		this._canvas = null;

		/**
		 * The current size of the render area as a Vector2.
		 * @type {Vector2}
		 * @private
		 */
		this._renderSize = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		this._renderSize.freeze();

		/**
		 * The input object.
		 * @type {Input}
		 * @private
		 */
		this._input = new _internal__WEBPACK_IMPORTED_MODULE_0__.Input(this);

		/**
		 * The config.
		 * @type {Config}
		 * @private
		 */
		this._config = new _internal__WEBPACK_IMPORTED_MODULE_0__.Config();

		/**
		 * The downloader object.
		 * @type {Downloader}
		 * @private
		 */
		this._downloader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Downloader();

		/**
		 * The texture loader used by all components for the loading of textures.
		 * @type {TextureLoader}
		 * @private
		 */
		this._textureLoader = null;

		/**
		 * The compressed texture loader used by all components for the loading of textures.
		 * @type {TextureLoaderCompressed}
		 * @private
		 */
		this._textureLoaderCompressed = null;

		/**
		 * The shader manager.
		 * @type {MaterialManager}
		 * @private
		 */
		this._materialManager = null;

		/**
		 * The collection of scenes.
		 * @type {Collection<Scene, Engine>}
		 * @private
		 */
		this._scenes = new _internal__WEBPACK_IMPORTED_MODULE_0__.Collection(this, new Map([['scene', _internal__WEBPACK_IMPORTED_MODULE_0__.Scene]]));

		/**
		 * The collection of viewports.
		 * @type {Collection<Viewport, Engine>}
		 * @private
		 */
		this._viewports = new _internal__WEBPACK_IMPORTED_MODULE_0__.Collection(this, new Map([['viewport', _internal__WEBPACK_IMPORTED_MODULE_0__.Viewport]]));

		/**
		 * The real-world time last frame. Used to determine the in-app time.
		 * @type {number}
		 * @private
		 */
		this._lastAppTime = Date.now();

		/**
		 * The time in seconds it took to complete the last frame.
		 * @type {number}
		 * @private
		 */
		this._realDeltaTime = 0;

		/**
		 * An FPS calculator.
		 * @type {FPS}
		 * @private
		 */
		this._fps = new _internal__WEBPACK_IMPORTED_MODULE_0__.FPS();

		/**
		 * A limit for the FPS.
		 * @type {number}
		 * @private
		 */
		this._fpsLimit = Number.POSITIVE_INFINITY;

		/**
		 * The in-app time in ET seconds.
		 * @type {number}
		 * @private
		 */
		this._time = 0;

		/**
		 * The in-app time rate in seconds per second.
		 * @type {number}
		 * @private
		 */
		this._timeRate = 0;

		/**
		 * The list of callbacks to be called at the end of the next frame.
		 * If they are not recurring, they will be removed after they are processed.
		 * @type {{ callback: () => any, recurring: boolean }[]}
		 * @private
		 */
		this._callbacks = [];

		/**
		 * A list of callbacks to remove in the next frame.
		 * @type {(() => any)[]}
		 * @private
		 */
		this._callbacksToRemove = [];

		/**
		 * This is used in requestAnimationFrame because bind (or ()=>{}) creates garbage.
		 * @type {(this: Engine) => any}
		 * @private
		 */
		this._thisLoop = this._loop.bind(this);

		/**
		 * The ThreeJS renderer.
		 * @type {THREE.WebGLRenderer}
		 * @private
		 */
		this._threeJsRenderer = null;

		/**
		 * The div element where the viewports will go.
		 * @type {HTMLDivElement}
		 * @private
		 */
		this._viewportDiv = null;

		// Add styling to the root div to make sure it will work with Pioneer.
		if (this._rootDiv.style.position !== 'relative' && this._rootDiv.style.position !== 'absolute') {
			this._rootDiv.style.position = 'relative';
		}
		this._rootDiv.style.userSelect = 'none';
		this._rootDiv.style.webkitUserSelect = 'none';
		this._rootDiv.style.touchAction = 'none';

		// Create the canvas and attach it to the root div.
		this._canvas = document.createElement('canvas');
		this._canvas.style.position = 'absolute';
		this._canvas.style.left = '0px';
		this._canvas.style.top = '0px';
		this._canvas.style.width = '100%';
		this._canvas.style.height = '100%';
		this._rootDiv.appendChild(this._canvas);

		// Create the viewport div for the viewports and attach it to the root div.
		this._viewportDiv = document.createElement('div');
		this._viewportDiv.style.position = 'absolute';
		this._viewportDiv.style.left = '0px';
		this._viewportDiv.style.top = '0px';
		this._viewportDiv.style.width = '100%';
		this._viewportDiv.style.height = '100%';
		this._viewportDiv.style.overflow = 'hidden';
		this._rootDiv.appendChild(this._viewportDiv);

		try {
			// Create ThreeJS renderer, using the canvas as a reference.
			this._threeJsRenderer = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderer({
				canvas: this._canvas,
				antialias: true
			});
			this._threeJsRenderer.setScissorTest(true);

			// Make sure the renderer is using the device pixel ratio for extra sharpness.
			this._threeJsRenderer.setPixelRatio(window.devicePixelRatio);

			// Create the texture loaders.
			this._textureLoader = new _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLoader(this._downloader, this._threeJsRenderer);
			this._textureLoaderCompressed = new _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLoaderCompressed(this._downloader, this._config, this._threeJsRenderer);

			// Disable the cache so that things don't get loaded indefinitely.
			_internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Cache.enabled = false;

			// REMOVE LATER: Fix for GLSL warning about GL_ARB_gpu_shader5 (ThreeJS bug: https://github.com/mrdoob/three.js/issues/9716).
			const origGetShaderInfoLog = this._threeJsRenderer.getContext().getShaderInfoLog.bind(this._threeJsRenderer.getContext());
			this._threeJsRenderer.getContext().getShaderInfoLog = (shader) => {
				const t = origGetShaderInfoLog(shader);
				if (t.includes('GL_ARB_gpu_shader5')) {
					return '';
				}
				else {
					return t;
				}
			};

			// Add the WebGL context to the capabilities.
			_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.__setContext(this._threeJsRenderer.getContext());

			// Create the material manager.
			this._materialManager = new _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialManager(this._downloader);
		}
		catch (error) {
			// eslint-disable-next-line no-console
			console.log(error);
			throw error;
		}

		// Start looping.
		requestAnimationFrame(this._thisLoop);
	}

	// VERSION

	/**
	 * Gets the Pioneer version.
	 * @returns {string}
	 */
	getVersion() {
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Version;
	}

	// CANVAS AND CONTAINER DIVS

	/**
	 * Returns the root div that was passed in the constructor.
	 * @returns {HTMLDivElement}
	 */
	getRootDiv() {
		return this._rootDiv;
	}

	/**
	 * Gets the size of the rendering area.
	 * @returns {Vector2}
	 */
	getRenderSize() {
		return this._renderSize;
	}

	/**
	 * Returns the canvas used for the engine.
	 * @returns {HTMLCanvasElement}
	 */
	getCanvas() {
		return this._canvas;
	}

	/**
	 * Returns the div used for the UI.
	 * @returns {HTMLDivElement}
	 */
	getViewportDiv() {
		return this._viewportDiv;
	}

	// SUB-SYSTEMS

	/**
	 * Returns the config.
	 * @returns {Config}
	 */
	getConfig() {
		return this._config;
	}

	/**
	 * Returns the input manager.
	 * @returns {Input}
	 */
	getInput() {
		return this._input;
	}

	/**
	 * Returns the downloader.
	 * @returns {Downloader}
	 */
	getDownloader() {
		return this._downloader;
	}

	/**
	 * Gets the texture loader.
	 * @returns {TextureLoader}
	 */
	getTextureLoader() {
		return this._textureLoader;
	}

	/**
	 * Gets the texture loader.
	 * @returns {TextureLoaderCompressed}
	 */
	getTextureLoaderCompressed() {
		return this._textureLoaderCompressed;
	}

	/**
	 * Get the material manager.
	 * @returns {MaterialManager}
	 */
	getMaterialManager() {
		return this._materialManager;
	}

	// SCENES

	/**
	 * Gets a scene by name.
	 * @param {string|number} nameOrIndex - The name or zero-based index of the scene.
	 * @returns {Scene}
	 */
	getScene(nameOrIndex) {
		return this._scenes.get(nameOrIndex);
	}

	/**
	 * Gets the number of scenes.
	 * @returns {number}
	 */
	getNumScenes() {
		return this._scenes.size;
	}

	/**
	 * Adds a scene.
	 * @param {string} name - The name of the scene to be added.
	 * @returns {Scene}
	 */
	addScene(name) {
		return this._scenes.add('scene', name);
	}

	/**
	 * Removes a scene.
	 * @param {Scene|string|number} sceneOrNameOrIndex - The scene, name, or index to be removed.
	 */
	removeScene(sceneOrNameOrIndex) {
		this._scenes.remove(sceneOrNameOrIndex);
	}

	/**
	 * Gets the scene, entity, component, or controller described in the parameters.
	 * @param {string} sceneNameOrIndex - The name of the scene.
	 * @param {string} [entityNameOrIndex] - The name of the entity.
	 * @param {string} [componentOrControllerType] - The type of the component or controller.
	 * @param {number} [componentOrControllerTypeIndex = 0] - The zero-based index of the component or controller of the specified type, in case there are more than one of the same type.
	 * @returns {Scene|Entity|BaseComponent|BaseController}
	 */
	get(sceneNameOrIndex, entityNameOrIndex = undefined, componentOrControllerType = undefined, componentOrControllerTypeIndex = 0) {
		const scene = this._scenes.get(sceneNameOrIndex);
		if (entityNameOrIndex === undefined || scene === null) {
			return scene;
		}
		return scene.get(entityNameOrIndex, componentOrControllerType, componentOrControllerTypeIndex);
	}

	// VIEWPORTS

	/**
	 * Returns the viewport at the index.
	 * @param {string|number} nameOrIndex - The name or zero-based index of the viewport to get.
	 * @returns {Viewport}
	 */
	getViewport(nameOrIndex) {
		return this._viewports.get(nameOrIndex);
	}

	/**
	 * Returns the number of viewports.
	 * @returns {number}
	 */
	getNumViewports() {
		return this._viewports.size;
	}

	/**
	 * Adds a viewport.
	 * @param {string} [name=''] - A optional name to give the viewport.
	 * @returns {Viewport}
	 */
	addViewport(name = '') {
		return this._viewports.add('viewport', name);
	}

	/**
	 * Removes a viewport.
	 * @param {Viewport|string|number} viewportOrNameOrIndex
	 */
	removeViewport(viewportOrNameOrIndex) {
		this._viewports.remove(viewportOrNameOrIndex);
	}

	// TIME

	/**
	 * Gets the in-app time in seconds since the J2000 epoch, which is at 2000-01-01T11:58:55.816 UTC. See {@link https://en.wikipedia.org/wiki/Epoch_(astronomy)#Julian_years_and_J2000}.
	 * @returns {number}
	 */
	getTime() {
		return this._time;
	}

	/**
	 * Sets the in-app time.
	 * @param {number} time - The time in seconds since the J2000 epoch.
	 */
	setTime(time) {
		this._time = time;
	}

	/**
	 * Gets the in-app time rate in seconds per real-time second.
	 * @returns {number}
	 */
	getTimeRate() {
		return this._timeRate;
	}

	/**
	 * Sets the in-app time rate.
	 * @param {number} timeRate - The time rate in seconds per real-time second.
	 */
	setTimeRate(timeRate) {
		this._timeRate = timeRate;
	}

	/**
	 * Gets the average FPS over the last number of frames.
	 * @returns {number}
	 */
	getFPS() {
		return this._fps.getFPS();
	}

	/**
	 * Gets a limit for the FPS.
	 * @returns {number}
	 */
	getFPSLimit() {
		return this._fpsLimit;
	}

	/**
	 * Sets a limit for the FPS.
	 * @param {number} limit
	 */
	setFPSLimit(limit) {
		this._fpsLimit = limit;
	}

	/**
	 * Gets the time in seconds it took to complete the last frame.
	 * @returns {number}
	 */
	getDeltaTime() {
		return this._realDeltaTime;
	}

	// COMPONENT REGISTRATION

	/**
	 * Returns true if a component of the type is already registered.
	 * @param {string} type
	 */
	isComponentTypeRegistered(type) {
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Types.Components.has(type);
	}

	/**
	 * Registers a component type.
	 * @param {string} type - The name of the component that will be used with the addComponent function.
	 * @param {typeof BaseComponent} typeConstructor - The component class to register.
	 */
	registerComponentType(type, typeConstructor) {
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.Types.Components.has(type)) {
			throw new Error('Already registered component type \'' + type + '\'.');
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Types.Components.set(type, typeConstructor);
	}

	/**
	 * Unregisters a component type.
	 * @param {string} type - The name of the component to unregister.
	 */
	unregisterComponentType(type) {
		_internal__WEBPACK_IMPORTED_MODULE_0__.Types.Components["delete"](type);
	}

	/**
	 * Returns true if a controller of the type is already registered.
	 * @param {string} type
	 */
	isControllerTypeRegistered(type) {
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Types.Controllers.has(type);
	}

	/**
	 * Registers a controller type.
	 * @param {string} type - The name of the controller that will be used with the addController function.
	 * @param {typeof BaseController} typeConstructor - The controller class to register.
	 */
	registerControllerType(type, typeConstructor) {
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.Types.Controllers.has(type)) {
			throw new Error('Already registered controller type \'' + type + '\'.');
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Types.Controllers.set(type, typeConstructor);
	}

	/**
	 * Unregisters a controller type.
	 * @param {string} type - The name of the controller to unregister.
	 */
	unregisterControllerType(type) {
		_internal__WEBPACK_IMPORTED_MODULE_0__.Types.Controllers["delete"](type);
	}

	// CALLBACKS AND PROMISES

	/**
	 * Returns a promise that resolves at the end of the current frame.
	 * It is useful for letting controllers and components do a single update.
	 * @returns {Promise<void>}
	 */
	waitUntilNextFrame() {
		return new Promise((resolve) => {
			this.addCallback(() => {
				resolve();
			}, false);
		});
	}

	/**
	 * Adds a callback to be called at the end of the next frame.
	 * @param {() => any} callback - The callback to be called.
	 * @param {boolean} recurring - If true it will run at the end of every frame. If not, it will only run once at the end of the next frame.
	 */
	addCallback(callback, recurring) {
		this._callbacks.push({
			callback: callback,
			recurring: recurring
		});
	}

	/**
	 * Removes a callback added via `addCallback()`. If there were multiple, only the first found will be removed.
	 * @param {() => any} callback - The callback to be removed.
	 */
	removeCallback(callback) {
		this._callbacksToRemove.push(callback);
	}

	// INTERNALS

	/**
	 * Returns the ThreeJS renderer for use by viewports and components.
	 * @returns {THREE.WebGLRenderer}
	 * @internal
	 */
	__getThreeJsRenderer() {
		return this._threeJsRenderer;
	}

	/**
	 * The main loop. The requestAnimationFrame call calls this at the start of every frame.
	 * @private
	 */
	_loop() {
		try {
			// Update the time according to the time rate and the real-world elapsed time.
			const thisAppTime = Date.now();
			this._realDeltaTime = (thisAppTime - this._lastAppTime) / 1000.0;

			// If not enough time has elapsed, don't run the loop.
			if (this._realDeltaTime < 1.0 / this._fpsLimit) {
				requestAnimationFrame(this._thisLoop);
				return;
			}

			this._lastAppTime = thisAppTime;
			this._fps.update(this._realDeltaTime);
			this._time += this._timeRate * this._realDeltaTime;

			// Update the size of the divs to fill the box when the root div has changed.
			if (this._renderSize.x !== this._rootDiv.clientWidth || this._renderSize.y !== this._rootDiv.clientHeight) {
				this._renderSize.thaw();
				this._renderSize.set(this._rootDiv.clientWidth, this._rootDiv.clientHeight);
				this._renderSize.freeze();
				this._threeJsRenderer.setSize(this._renderSize.x, this._renderSize.y, false);
			}

			// Update the scene.
			for (let i = 0; i < this._scenes.size; i++) {
				this._scenes.get(i).__update();
			}

			// Update the viewport-dependent variables.
			for (let i = 0; i < this._viewports.size; i++) {
				this._viewports.get(i).__updateViewportVariables();
			}

			// Update the camera-non-specific visual parts of the entities in each scene.
			for (let i = 0; i < this._scenes.size; i++) {
				this._scenes.get(i).__updateVisuals();
			}

			// Fill the screen with black.
			this._threeJsRenderer.setViewport(0, 0, this._renderSize.x, this._renderSize.y);
			this._threeJsRenderer.setScissor(0, 0, this._renderSize.x, this._renderSize.y);
			this._threeJsRenderer.clear();

			// Draw the viewports.
			for (let i = 0; i < this._viewports.size; i++) {
				this._viewports.get(i).__render();
			}

			// Remove any callbacks requested.
			for (let i = 0, l = this._callbacksToRemove.length; i < l; i++) {
				for (let j = 0, m = this._callbacks.length; j < m; j++) {
					if (this._callbacks[j].callback === this._callbacksToRemove[i]) {
						this._callbacks.splice(j, 1);
						break;
					}
				}
			}
			this._callbacksToRemove = [];

			// Call the callbacks.
			for (let i = 0; i < this._callbacks.length; i++) {
				this._callbacks[i].callback();
				if (!this._callbacks[i].recurring) {
					this._callbacksToRemove.push(this._callbacks[i].callback);
				}
			}

			// Make sure the input is ready for the next frame.
			this._input.__resetStatesForNextFrame();
		}
		catch (error) {
			// eslint-disable-next-line no-console
			console.log(error);
			throw error;
		}

		// Tell the browser to give us another frame.
		requestAnimationFrame(this._thisLoop);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/index.js":
/*!**************************************!*\
  !*** ../pioneer/engine/src/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AER": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.AER; },
/* harmony export */   "AlignController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.AlignController; },
/* harmony export */   "AnimdataController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.AnimdataController; },
/* harmony export */   "AtmosphereComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.AtmosphereComponent; },
/* harmony export */   "BaseComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent; },
/* harmony export */   "BaseController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController; },
/* harmony export */   "BaseRef": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.BaseRef; },
/* harmony export */   "CMTSComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CMTSComponent; },
/* harmony export */   "Cache": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Cache; },
/* harmony export */   "CameraComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CameraComponent; },
/* harmony export */   "Capabilities": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities; },
/* harmony export */   "Collection": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Collection; },
/* harmony export */   "CollectionItem": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CollectionItem; },
/* harmony export */   "Color": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Color; },
/* harmony export */   "CometTailComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CometTailComponent; },
/* harmony export */   "ComponentRef": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef; },
/* harmony export */   "Config": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Config; },
/* harmony export */   "ConnectedSpriteComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ConnectedSpriteComponent; },
/* harmony export */   "ControllerRef": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ControllerRef; },
/* harmony export */   "CoverageController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CoverageController; },
/* harmony export */   "CubeMap": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.CubeMap; },
/* harmony export */   "DependencyGraph": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.DependencyGraph; },
/* harmony export */   "DivComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.DivComponent; },
/* harmony export */   "Download": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Download; },
/* harmony export */   "Downloader": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Downloader; },
/* harmony export */   "DynamicEnvironmentMapComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.DynamicEnvironmentMapComponent; },
/* harmony export */   "DynamoController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.DynamoController; },
/* harmony export */   "Engine": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Engine; },
/* harmony export */   "Entity": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Entity; },
/* harmony export */   "EntityItem": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.EntityItem; },
/* harmony export */   "EntityRef": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef; },
/* harmony export */   "FPS": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FPS; },
/* harmony export */   "FastIterable": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FastIterable; },
/* harmony export */   "FastMap": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap; },
/* harmony export */   "FastMapEntry": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FastMapEntry; },
/* harmony export */   "FastSet": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FastSet; },
/* harmony export */   "FixedController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FixedController; },
/* harmony export */   "FixedToParentController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FixedToParentController; },
/* harmony export */   "FreeFlyController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.FreeFlyController; },
/* harmony export */   "Freezable": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable; },
/* harmony export */   "Geometry": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Geometry; },
/* harmony export */   "GizmoComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.GizmoComponent; },
/* harmony export */   "GroundClampController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.GroundClampController; },
/* harmony export */   "Input": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Input; },
/* harmony export */   "Interval": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Interval; },
/* harmony export */   "KeyframeController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.KeyframeController; },
/* harmony export */   "LabelComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LabelComponent; },
/* harmony export */   "LatLonAlt": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt; },
/* harmony export */   "LightSourceComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LightSourceComponent; },
/* harmony export */   "LineMesh": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LineMesh; },
/* harmony export */   "LookController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.LookController; },
/* harmony export */   "MaterialManager": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialManager; },
/* harmony export */   "MaterialUtils": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils; },
/* harmony export */   "MaterialUtilsPhong": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtilsPhong; },
/* harmony export */   "MaterialUtilsStandard": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtilsStandard; },
/* harmony export */   "MathUtils": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils; },
/* harmony export */   "ModelAnimateController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ModelAnimateController; },
/* harmony export */   "ModelComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ModelComponent; },
/* harmony export */   "OrbitController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitController; },
/* harmony export */   "OrbitKeyframeController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitKeyframeController; },
/* harmony export */   "OrbitalElements": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements; },
/* harmony export */   "OrbitalElementsController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElementsController; },
/* harmony export */   "OrbitalElementsKeyFrame": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElementsKeyFrame; },
/* harmony export */   "OrbitalParticlesComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalParticlesComponent; },
/* harmony export */   "ParticleSprayComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ParticleSprayComponent; },
/* harmony export */   "PickController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.PickController; },
/* harmony export */   "Pool": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Pool; },
/* harmony export */   "Quaternion": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion; },
/* harmony export */   "Reader": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Reader; },
/* harmony export */   "Rect": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Rect; },
/* harmony export */   "RingsComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.RingsComponent; },
/* harmony export */   "RollController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.RollController; },
/* harmony export */   "RotateByEntityOrientationController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.RotateByEntityOrientationController; },
/* harmony export */   "RotateController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.RotateController; },
/* harmony export */   "ScaleController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ScaleController; },
/* harmony export */   "Scene": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Scene; },
/* harmony export */   "SelectController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SelectController; },
/* harmony export */   "SetParentController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SetParentController; },
/* harmony export */   "ShaderChunkLogDepth": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth; },
/* harmony export */   "ShaderFix": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ShaderFix; },
/* harmony export */   "SkyboxComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SkyboxComponent; },
/* harmony export */   "Sort": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Sort; },
/* harmony export */   "SpheroidComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent; },
/* harmony export */   "SpheroidLODComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpheroidLODComponent; },
/* harmony export */   "SpinController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpinController; },
/* harmony export */   "SpoutComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpoutComponent; },
/* harmony export */   "SpriteComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpriteComponent; },
/* harmony export */   "SpriteParticles": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.SpriteParticles; },
/* harmony export */   "StarfieldComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.StarfieldComponent; },
/* harmony export */   "THREE": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.THREE; },
/* harmony export */   "TapController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TapController; },
/* harmony export */   "TextureLOD": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLOD; },
/* harmony export */   "TextureLoader": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLoader; },
/* harmony export */   "TextureLoaderCompressed": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLoaderCompressed; },
/* harmony export */   "ThreeJsEffectComposer": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsEffectComposer; },
/* harmony export */   "ThreeJsGLTFLoader": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsGLTFLoader; },
/* harmony export */   "ThreeJsHelper": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper; },
/* harmony export */   "ThreeJsKTXLoader": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsKTXLoader; },
/* harmony export */   "ThreeJsOutlinePass": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsOutlinePass; },
/* harmony export */   "ThreeJsRenderPass": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsRenderPass; },
/* harmony export */   "ThreeJsUnrealBloomPass": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsUnrealBloomPass; },
/* harmony export */   "Tile": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Tile; },
/* harmony export */   "TimeUtils": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TimeUtils; },
/* harmony export */   "TrailComponent": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TrailComponent; },
/* harmony export */   "TransitionController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TransitionController; },
/* harmony export */   "TranslateController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.TranslateController; },
/* harmony export */   "Types": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Types; },
/* harmony export */   "Vector2": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2; },
/* harmony export */   "Vector3": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3; },
/* harmony export */   "Version": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Version; },
/* harmony export */   "Viewport": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.Viewport; },
/* harmony export */   "ZoomController": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.ZoomController; },
/* harmony export */   "waitUntil": function() { return /* reexport safe */ _internal__WEBPACK_IMPORTED_MODULE_0__.waitUntil; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");



/***/ }),

/***/ "../pioneer/engine/src/input.js":
/*!**************************************!*\
  !*** ../pioneer/engine/src/input.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Input": function() { return /* binding */ Input; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A single touch on the device by the user.
 */
class Touch {
	/**
	 * The constructor.
	 */
	constructor() {
		/**
		 * The browser-given identifier of the touch. Each identifier is unique. 0 is always the mouse left-click.
		 * @type {number}
		 */
		this.identifier = 0;

		/**
		 * The position relative to the root div where the touch initially occurred.
		 * @type {Vector2}
		 */
		this.pressedPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		/**
		 * The duration so-far of the touch.
		 * @type {number}
		 */
		this.pressedTime = 0;

		/**
		 * The position relative to the root div where the touch was moved to last frame.
		 * @type {Vector2}
		 */
		this.lastFramePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		/**
		 * The current position relative to the root div of the touch.
		 * @type {Vector2}
		 */
		this.thisFramePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
	}
}

/**
 * The input system. Handles all the dragging, rotating, zooming, keyboard, touch, etc.
 * @hideconstructor
 */
class Input {
	/**
	 * Constructs the input manager.
	 * @param {Engine} engine - The Pioneer engine.
	 */
	constructor(engine) {
		/**
		 * The engine.
		 * @type {Engine}
		 * @private
		 */
		this._engine = engine;

		/**
		 * The active viewport. The viewport is activated when a left-click or touch happens.
		 * @type {Viewport}
		 * @private
		 */
		this._activeViewport = null;

		/**
		 * The amount that the cursor was tragged in the last frame.
		 * @type {Vector2}
		 * @private
		 */
		this._draggedOffset = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		this._draggedOffset.freeze();

		/**
		 * The amount that was zoomed in the last frame.
		 * @type {number}
		 * @private
		 */
		this._zoomedOffset = 0;

		/**
		 * The amount that was rotated in the last frame.
		 * @type {number}
		 * @private
		 */
		this._rotatedOffset = 0;

		/**
		 * Is shift pressed?
		 * @type {boolean}
		 * @private
		 */
		this._shiftPressed = false;

		/**
		 * The keys that are pressed.
		 * @type {Set<string>}
		 * @private
		 */
		this._keysPressed = new Set();

		/**
		 * The modifiers keys that are pressed.
		 * @type {Set<string>}
		 * @private
		 */
		this._modifierKeysPressed = new Set();

		/**
		 * The maximum time in seconds before it is considered a drag.
		 * @type {number}
		 * @private
		 */
		this._maxSelectTime = 0.5;

		/**
		 * Minimum distance to move the press before it is considered a drag.
		 * @type {number}
		 * @private
		 */
		this._maxSelectDistance = 5;

		/**
		 * The position of the cursor.
		 * @type {Vector2}
		 * @private
		 */
		this._cursorPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		/**
		 * Did the user select something last frame?
		 * @type {boolean}
		 * @private
		 */
		this._selected = false;

		/**
		 * If selected, this is the position of the selection.
		 * @type {Vector2}
		 * @private
		 */
		this._selectedPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		this._selectedPosition.freeze();

		/**
		 * The current touches.
		 * @type {Touch[]}
		 * @private
		 */
		this._touches = [];

		// Setup the event listeners.
		window.addEventListener('blur', () => {
			this._touches = [];
			this._keysPressed.clear();
			this._modifierKeysPressed.clear();
			this._shiftPressed = false;
		});
		window.addEventListener('keydown', event => {
			// Don't process key down events if the user is focused on writing text.
			if (event.target instanceof HTMLElement && ['INPUT', 'SELECT', 'TEXTAREA'].includes(event.target.tagName)) {
				return;
			}
			if (event.key === 'Shift') {
				this._shiftPressed = true;
			}
			// If a modifier key is hit that isn't shift, clear all pressed keys.
			else if (modifierKeys.has(event.key)) {
				this._modifierKeysPressed.add(event.key.toLowerCase());
				this._keysPressed.clear();
				this._shiftPressed = false;
			}
			else if (this._modifierKeysPressed.size === 0) {
				this._keysPressed.add(event.key.toLowerCase());
			}
		});
		window.addEventListener('keyup', event => {
			if (event.key === 'Shift') {
				this._shiftPressed = false;
			}
			else if (modifierKeys.has(event.key)) {
				this._modifierKeysPressed.delete(event.key.toLowerCase());
			}
			else {
				this._keysPressed.delete(event.key.toLowerCase());
			}
		});
		this._engine.getRootDiv().addEventListener('mousedown', event => {
			if (event.button === 0) {
				// Unfocus any other elements on the page.
				if (document.activeElement instanceof HTMLElement) {
					document.activeElement.blur();
				}

				// If this is the first touch.
				if (this._touches.length === 0) {
					const rootDivBounds = this._engine.getRootDiv().getBoundingClientRect();

					// Check for an existing touch with the same identifier.
					let touch = null;
					for (let j = 0; j < this._touches.length; j++) {
						if (this._touches[j].identifier === 0) {
							touch = this._touches[j];
						}
					}
					if (touch === null) {
						touch = new Touch();
					}

					// Create the new touch.
					touch.identifier = 0;
					touch.pressedPosition.set(event.clientX - rootDivBounds.left, event.clientY - rootDivBounds.top);
					touch.pressedTime = Date.now();
					touch.lastFramePosition.copy(touch.pressedPosition);
					touch.thisFramePosition.copy(touch.pressedPosition);
					this._touches.push(touch);

					// Updates active viewport to the one clicked
					this._updateActiveViewport();
				}
			}
		});
		window.addEventListener('mousemove', event => {
			const rootDivBounds = this._engine.getRootDiv().getBoundingClientRect();
			if (this._touches.length === 1 && this._touches[0].identifier === 0) {
				const touch = this._touches[0];
				touch.thisFramePosition.set(event.clientX - rootDivBounds.left, event.clientY - rootDivBounds.top);

				// Update the dragged offset and the latest touch position.
				this._draggedOffset.thaw();
				this._draggedOffset.sub(touch.thisFramePosition, touch.lastFramePosition);

				// If the cursor hasn't moved enough, there is no drag.
				const pressedPositionDistance = Math.max(Math.abs(touch.thisFramePosition.x - touch.pressedPosition.x), Math.abs(touch.thisFramePosition.y - touch.pressedPosition.y));
				if ((Date.now() - touch.pressedTime) / 1000 <= this._maxSelectTime && pressedPositionDistance <= this._maxSelectDistance) {
					this._draggedOffset.set(0, 0);
				}
				this._draggedOffset.freeze();
			}
			if (this._touches.length <= 1) {
				this._cursorPosition.set(event.clientX - rootDivBounds.left, event.clientY - rootDivBounds.top);
			}
		});
		window.addEventListener('mouseup', event => {
			if (event.button === 0) {
				if (this._touches.length === 1 && this._touches[0].identifier === 0) {
					const rootDivBounds = this._engine.getRootDiv().getBoundingClientRect();
					const touch = this._touches[0];
					touch.thisFramePosition.set(event.clientX - rootDivBounds.left, event.clientY - rootDivBounds.top);
					const pressedPositionDistance = Math.max(Math.abs(touch.thisFramePosition.x - touch.pressedPosition.x), Math.abs(touch.thisFramePosition.y - touch.pressedPosition.y));
					if ((Date.now() - touch.pressedTime) / 1000 <= this._maxSelectTime && pressedPositionDistance <= this._maxSelectDistance) {
						this._selected = true;
						this._selectedPosition.thaw();
						this._selectedPosition.copy(touch.thisFramePosition);
						this._selectedPosition.freeze();
					}
					this._touches.splice(0, 1);
				}
			}
		});
		this._engine.getRootDiv().addEventListener('wheel', event => {
			if (event.deltaY) {
				this._zoomedOffset += event.deltaY * 0.1;
			}
			event.preventDefault();
		}, { passive: false });
		this._engine.getRootDiv().addEventListener('touchstart', event => {
			const rootDivBounds = this._engine.getRootDiv().getBoundingClientRect();
			for (let i = 0; i < event.changedTouches.length; i++) {
				const touchEvent = event.changedTouches[i];

				// Check for an existing touch with the same identifier.
				let touch = null;
				for (let j = 0; j < this._touches.length; j++) {
					if (this._touches[j].identifier === touchEvent.identifier) {
						touch = this._touches[j];
					}
				}
				if (touch === null) {
					touch = new Touch();
				}

				// Create the new touch.
				touch.identifier = touchEvent.identifier;
				touch.pressedPosition.thaw();
				touch.pressedPosition.set(touchEvent.pageX - window.pageXOffset - rootDivBounds.left, touchEvent.pageY - window.pageYOffset - rootDivBounds.top);
				touch.pressedPosition.freeze();
				touch.pressedTime = Date.now();
				touch.lastFramePosition.copy(touch.pressedPosition);
				touch.thisFramePosition.copy(touch.pressedPosition);
				this._touches.push(touch);
				if (this._touches.length === 1) {
					this._cursorPosition.copy(touch.thisFramePosition);
				}

				// Updates active viewport to the one touched
				this._updateActiveViewport();
			}
		}, { passive: false });
		window.addEventListener('touchmove', event => {
			const rootDivBounds = this._engine.getRootDiv().getBoundingClientRect();
			for (let i = 0; i < event.changedTouches.length; i++) {
				const touchEvent = event.changedTouches[i];

				for (let j = 0; j < this._touches.length; j++) {
					const touch = this._touches[j];
					if (touch.identifier === touchEvent.identifier) {
						touch.thisFramePosition.set(touchEvent.pageX - window.pageXOffset - rootDivBounds.left, touchEvent.pageY - window.pageYOffset - rootDivBounds.top);
						if (this._touches.length === 1) {
							this._draggedOffset.thaw();
							this._draggedOffset.sub(touch.thisFramePosition, touch.lastFramePosition);
							// If the cursor hasn't moved enough, there is no drag.
							const pressedPositionDistance = Math.max(Math.abs(touch.thisFramePosition.x - touch.pressedPosition.x), Math.abs(touch.thisFramePosition.y - touch.pressedPosition.y));
							if ((Date.now() - touch.pressedTime) / 1000 <= this._maxSelectTime && pressedPositionDistance <= this._maxSelectDistance) {
								this._draggedOffset.set(0, 0);
							}
							this._draggedOffset.freeze();
							this._cursorPosition.copy(touch.thisFramePosition);
						}
						else if (this._touches.length === 2) {
							const touchDiff = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
							touchDiff.sub(this._touches[i].thisFramePosition, this._touches[1 - i].thisFramePosition);
							const touchOffset = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
							touchOffset.sub(this._touches[i].thisFramePosition, this._touches[i].lastFramePosition);
							const dot = touchOffset.dot(touchDiff) / touchDiff.magnitude() / touchOffset.magnitude();
							const cross = touchOffset.cross(touchDiff) / touchDiff.magnitude() / touchOffset.magnitude();
							if (dot < -0.7) {
								this._zoomedOffset += -(dot + 0.7) * touchOffset.magnitude();
							}
							else if (dot > 0.7) {
								this._zoomedOffset += -(dot - 0.7) * touchOffset.magnitude();
							}
							else if (Math.abs(cross) > 0.3) {
								this._rotatedOffset += cross * touchOffset.magnitude();
							}

							_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(touchOffset);
							_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(touchDiff);

							// If the touch hasn't moved enough, there is no zoom.
							const pressedPositionDistance = Math.max(Math.abs(touch.thisFramePosition.x - touch.pressedPosition.x), Math.abs(touch.thisFramePosition.y - touch.pressedPosition.y));
							if ((Date.now() - touch.pressedTime) / 1000 <= this._maxSelectTime && pressedPositionDistance <= this._maxSelectDistance) {
								this._zoomedOffset = 0;
								this._rotatedOffset = 0;
							}
						}
					}
				}
			}
		});
		window.addEventListener('touchend', event => {
			const rootDivBounds = this._engine.getRootDiv().getBoundingClientRect();
			for (let i = 0; i < event.changedTouches.length; i++) {
				const touchEvent = event.changedTouches[i];
				for (let j = 0; j < this._touches.length; j++) {
					const touch = this._touches[j];
					if (touch.identifier === touchEvent.identifier) {
						touch.thisFramePosition.set(touchEvent.pageX - window.pageXOffset - rootDivBounds.left, touchEvent.pageY - window.pageYOffset - rootDivBounds.top);
						if (this._touches.length === 1) {
							const pressedPositionDistance = Math.max(Math.abs(touch.thisFramePosition.x - touch.pressedPosition.x), Math.abs(touch.thisFramePosition.y - touch.pressedPosition.y));
							if ((Date.now() - touch.pressedTime) / 1000 <= this._maxSelectTime && pressedPositionDistance <= this._maxSelectDistance) {
								this._selected = true;
								this._selectedPosition.thaw();
								this._selectedPosition.copy(touch.thisFramePosition);
								this._selectedPosition.freeze();
							}
						}
						this._touches.splice(j, 1);
					}
				}
			}
		});
		window.addEventListener('touchcancel', () => {
		});
	}

	/**
	 * Return the current active viewport.
	 * @returns {Viewport}
	 */
	getActiveViewport() {
		return this._activeViewport;
	}

	/**
	 * Gets how much the user dragged this frame.
	 * @returns {Vector2}
	 */
	getDraggedOffset() {
		return this._draggedOffset;
	}

	/**
	 * Returns how much the user zoomed this frame.
	 * @returns {number}
	 */
	getZoomedOffset() {
		return this._zoomedOffset;
	}

	/**
	 * Returns how much the user rotated this frame.
	 * @returns {number}
	 */
	getRotatedOffset() {
		return this._rotatedOffset;
	}

	/**
	 * Returns true if the shift key is down this frame.
	 * @returns {boolean}
	 */
	isShiftPressed() {
		return this._shiftPressed;
	}

	/**
	 * Returns true if the key is pressed.
	 * @param {string} key - The key (in lower-case) to query.
	 * @returns {boolean}
	 */
	isKeyPressed(key) {
		return this._keysPressed.has(key);
	}

	/**
	 * Did the user click (or tap) last frame?
	 * @returns {boolean}
	 */
	isSelected() {
		return this._selected;
	}

	/**
	 * Gets the position when the user last selected, relative to the root div.
	 * @returns {Vector2}
	 */
	getSelectedPosition() {
		return this._selectedPosition;
	}

	/**
	 * Gets the position of the cursor or the last touch.
	 * @returns {Vector2}
	 */
	getCursorPosition() {
		return this._cursorPosition;
	}

	/**
	 * Manually set the active viewport. Called by a viewport on construction if there is no active viewport.
	 * @param {Viewport} viewport - The viewport to set.
	 * @internal
	 */
	__setActiveViewport(viewport) {
		this._activeViewport = viewport;
	}

	/**
	 * Resets all of the values for the next frame. Called by Engine only.
	 * @internal
	 */
	__resetStatesForNextFrame() {
		for (let i = 0; i < this._touches.length; i++) {
			this._touches[i].lastFramePosition.copy(this._touches[i].thisFramePosition);
		}

		this._selected = false;
		this._altSelected = false;
		this._draggedOffset.thaw();
		this._draggedOffset.set(0, 0);
		this._draggedOffset.freeze();
		this._zoomedOffset = 0;
		this._rotatedOffset = 0;
	}

	/**
	 * Automatically updates the active viewport. Called by a mouse down or touch start event.
	 * @private
	 */
	_updateActiveViewport() {
		this._activeViewport = null;
		for (let i = this._engine.getNumViewports() - 1; i >= 0; i--) {
			const pixelBounds = this._engine.getViewport(i).getBounds();
			if (this._engine.getViewport(i).isEnabled() && pixelBounds.contains(this._touches[0].pressedPosition)) {
				this._activeViewport = this._engine.getViewport(i);
				break;
			}
		}
	}
}

/**
 * All modifier keys in Javascript, from https://developer.mozilla.org/en-US/docs/Web/API/UI_Events/Keyboard_event_key_values.
 */
const modifierKeys = new Set(['Alt', 'AltGraph', 'CapsLock', 'Control', 'Fn', 'FnLock', 'Hyper', 'Meta', 'NumLock', 'ScrollLock', 'Shift', 'Super', 'Symbol', 'SymbolLock']);


/***/ }),

/***/ "../pioneer/engine/src/internal.js":
/*!*****************************************!*\
  !*** ../pioneer/engine/src/internal.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "THREE": function() { return /* reexport module object */ three__WEBPACK_IMPORTED_MODULE_0__; },
/* harmony export */   "ThreeJsEffectComposer": function() { return /* reexport safe */ three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__.EffectComposer; },
/* harmony export */   "ThreeJsGLTFLoader": function() { return /* reexport safe */ three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_2__.GLTFLoader; },
/* harmony export */   "ThreeJsKTXLoader": function() { return /* reexport safe */ three_examples_jsm_loaders_KTXLoader__WEBPACK_IMPORTED_MODULE_3__.KTXLoader; },
/* harmony export */   "ThreeJsOutlinePass": function() { return /* reexport safe */ three_examples_jsm_postprocessing_OutlinePass_js__WEBPACK_IMPORTED_MODULE_4__.OutlinePass; },
/* harmony export */   "ThreeJsRenderPass": function() { return /* reexport safe */ three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_5__.RenderPass; },
/* harmony export */   "ThreeJsUnrealBloomPass": function() { return /* reexport safe */ three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_6__.UnrealBloomPass; },
/* harmony export */   "ShaderChunkLogDepth": function() { return /* reexport safe */ _shaders_log_depth__WEBPACK_IMPORTED_MODULE_7__.ShaderChunkLogDepth; },
/* harmony export */   "BaseRef": function() { return /* reexport safe */ _utils_base_ref__WEBPACK_IMPORTED_MODULE_8__.BaseRef; },
/* harmony export */   "Collection": function() { return /* reexport safe */ _utils_collection__WEBPACK_IMPORTED_MODULE_9__.Collection; },
/* harmony export */   "CollectionItem": function() { return /* reexport safe */ _utils_collection__WEBPACK_IMPORTED_MODULE_9__.CollectionItem; },
/* harmony export */   "DependencyGraph": function() { return /* reexport safe */ _utils_dependency_graph__WEBPACK_IMPORTED_MODULE_10__.DependencyGraph; },
/* harmony export */   "FastIterable": function() { return /* reexport safe */ _utils_fast_iterable__WEBPACK_IMPORTED_MODULE_11__.FastIterable; },
/* harmony export */   "FPS": function() { return /* reexport safe */ _utils_fps__WEBPACK_IMPORTED_MODULE_12__.FPS; },
/* harmony export */   "Freezable": function() { return /* reexport safe */ _utils_freezable__WEBPACK_IMPORTED_MODULE_13__.Freezable; },
/* harmony export */   "MathUtils": function() { return /* reexport safe */ _utils_math_utils__WEBPACK_IMPORTED_MODULE_14__.MathUtils; },
/* harmony export */   "Pool": function() { return /* reexport safe */ _utils_pool__WEBPACK_IMPORTED_MODULE_15__.Pool; },
/* harmony export */   "Reader": function() { return /* reexport safe */ _utils_reader__WEBPACK_IMPORTED_MODULE_16__.Reader; },
/* harmony export */   "Sort": function() { return /* reexport safe */ _utils_sort__WEBPACK_IMPORTED_MODULE_17__.Sort; },
/* harmony export */   "Tile": function() { return /* reexport safe */ _utils_tile__WEBPACK_IMPORTED_MODULE_18__.Tile; },
/* harmony export */   "TimeUtils": function() { return /* reexport safe */ _utils_time_utils__WEBPACK_IMPORTED_MODULE_19__.TimeUtils; },
/* harmony export */   "waitUntil": function() { return /* reexport safe */ _utils_wait_until__WEBPACK_IMPORTED_MODULE_20__.waitUntil; },
/* harmony export */   "AER": function() { return /* reexport safe */ _utils_aer__WEBPACK_IMPORTED_MODULE_21__.AER; },
/* harmony export */   "Color": function() { return /* reexport safe */ _utils_color__WEBPACK_IMPORTED_MODULE_22__.Color; },
/* harmony export */   "FastMap": function() { return /* reexport safe */ _utils_fast_map__WEBPACK_IMPORTED_MODULE_23__.FastMap; },
/* harmony export */   "FastMapEntry": function() { return /* reexport safe */ _utils_fast_map__WEBPACK_IMPORTED_MODULE_23__.FastMapEntry; },
/* harmony export */   "FastSet": function() { return /* reexport safe */ _utils_fast_set__WEBPACK_IMPORTED_MODULE_24__.FastSet; },
/* harmony export */   "Geometry": function() { return /* reexport safe */ _utils_geometry__WEBPACK_IMPORTED_MODULE_25__.Geometry; },
/* harmony export */   "Interval": function() { return /* reexport safe */ _utils_interval__WEBPACK_IMPORTED_MODULE_26__.Interval; },
/* harmony export */   "OrbitalElements": function() { return /* reexport safe */ _utils_orbital_elements__WEBPACK_IMPORTED_MODULE_27__.OrbitalElements; },
/* harmony export */   "Rect": function() { return /* reexport safe */ _utils_rect__WEBPACK_IMPORTED_MODULE_28__.Rect; },
/* harmony export */   "Quaternion": function() { return /* reexport safe */ _utils_quaternion__WEBPACK_IMPORTED_MODULE_29__.Quaternion; },
/* harmony export */   "Vector2": function() { return /* reexport safe */ _utils_vector2__WEBPACK_IMPORTED_MODULE_30__.Vector2; },
/* harmony export */   "Vector3": function() { return /* reexport safe */ _utils_vector3__WEBPACK_IMPORTED_MODULE_31__.Vector3; },
/* harmony export */   "Cache": function() { return /* reexport safe */ _utils_cache__WEBPACK_IMPORTED_MODULE_32__.Cache; },
/* harmony export */   "ComponentRef": function() { return /* reexport safe */ _utils_component_ref__WEBPACK_IMPORTED_MODULE_33__.ComponentRef; },
/* harmony export */   "ControllerRef": function() { return /* reexport safe */ _utils_controller_ref__WEBPACK_IMPORTED_MODULE_34__.ControllerRef; },
/* harmony export */   "CubeMap": function() { return /* reexport safe */ _utils_cube_map__WEBPACK_IMPORTED_MODULE_35__.CubeMap; },
/* harmony export */   "EntityRef": function() { return /* reexport safe */ _utils_entity_ref__WEBPACK_IMPORTED_MODULE_36__.EntityRef; },
/* harmony export */   "LatLonAlt": function() { return /* reexport safe */ _utils_lat_lon_alt__WEBPACK_IMPORTED_MODULE_37__.LatLonAlt; },
/* harmony export */   "LineMesh": function() { return /* reexport safe */ _utils_line_mesh__WEBPACK_IMPORTED_MODULE_38__.LineMesh; },
/* harmony export */   "MaterialUtilsPhong": function() { return /* reexport safe */ _utils_material_utils_phong__WEBPACK_IMPORTED_MODULE_39__.MaterialUtilsPhong; },
/* harmony export */   "MaterialUtilsStandard": function() { return /* reexport safe */ _utils_material_utils_standard__WEBPACK_IMPORTED_MODULE_40__.MaterialUtilsStandard; },
/* harmony export */   "MaterialUtils": function() { return /* reexport safe */ _utils_material_utils__WEBPACK_IMPORTED_MODULE_41__.MaterialUtils; },
/* harmony export */   "ShaderFix": function() { return /* reexport safe */ _utils_shader_fix__WEBPACK_IMPORTED_MODULE_42__.ShaderFix; },
/* harmony export */   "SpriteParticles": function() { return /* reexport safe */ _utils_sprite_particles__WEBPACK_IMPORTED_MODULE_43__.SpriteParticles; },
/* harmony export */   "TextureLOD": function() { return /* reexport safe */ _utils_texture_lod__WEBPACK_IMPORTED_MODULE_44__.TextureLOD; },
/* harmony export */   "ThreeJsHelper": function() { return /* reexport safe */ _utils_three_js_helper__WEBPACK_IMPORTED_MODULE_45__.ThreeJsHelper; },
/* harmony export */   "Capabilities": function() { return /* reexport safe */ _capabilities__WEBPACK_IMPORTED_MODULE_46__.Capabilities; },
/* harmony export */   "Config": function() { return /* reexport safe */ _config__WEBPACK_IMPORTED_MODULE_47__.Config; },
/* harmony export */   "Download": function() { return /* reexport safe */ _downloader__WEBPACK_IMPORTED_MODULE_48__.Download; },
/* harmony export */   "Downloader": function() { return /* reexport safe */ _downloader__WEBPACK_IMPORTED_MODULE_48__.Downloader; },
/* harmony export */   "Engine": function() { return /* reexport safe */ _engine__WEBPACK_IMPORTED_MODULE_49__.Engine; },
/* harmony export */   "Entity": function() { return /* reexport safe */ _scene_entity__WEBPACK_IMPORTED_MODULE_50__.Entity; },
/* harmony export */   "EntityItem": function() { return /* reexport safe */ _scene_entity_item__WEBPACK_IMPORTED_MODULE_51__.EntityItem; },
/* harmony export */   "Input": function() { return /* reexport safe */ _input__WEBPACK_IMPORTED_MODULE_52__.Input; },
/* harmony export */   "MaterialManager": function() { return /* reexport safe */ _material_manager__WEBPACK_IMPORTED_MODULE_53__.MaterialManager; },
/* harmony export */   "Scene": function() { return /* reexport safe */ _scene_scene__WEBPACK_IMPORTED_MODULE_54__.Scene; },
/* harmony export */   "TextureLoader": function() { return /* reexport safe */ _texture_loader__WEBPACK_IMPORTED_MODULE_55__.TextureLoader; },
/* harmony export */   "TextureLoaderCompressed": function() { return /* reexport safe */ _texture_loader_compressed__WEBPACK_IMPORTED_MODULE_56__.TextureLoaderCompressed; },
/* harmony export */   "Version": function() { return /* reexport safe */ _version__WEBPACK_IMPORTED_MODULE_57__.Version; },
/* harmony export */   "Viewport": function() { return /* reexport safe */ _viewport__WEBPACK_IMPORTED_MODULE_58__.Viewport; },
/* harmony export */   "BaseComponent": function() { return /* reexport safe */ _scene_components_base_component__WEBPACK_IMPORTED_MODULE_59__.BaseComponent; },
/* harmony export */   "AtmosphereComponent": function() { return /* reexport safe */ _scene_components_atmosphere_component__WEBPACK_IMPORTED_MODULE_60__.AtmosphereComponent; },
/* harmony export */   "CameraComponent": function() { return /* reexport safe */ _scene_components_camera_component__WEBPACK_IMPORTED_MODULE_61__.CameraComponent; },
/* harmony export */   "CMTSComponent": function() { return /* reexport safe */ _scene_components_cmts_component__WEBPACK_IMPORTED_MODULE_62__.CMTSComponent; },
/* harmony export */   "CometTailComponent": function() { return /* reexport safe */ _scene_components_comet_tail_component__WEBPACK_IMPORTED_MODULE_63__.CometTailComponent; },
/* harmony export */   "ConnectedSpriteComponent": function() { return /* reexport safe */ _scene_components_connected_sprite_component__WEBPACK_IMPORTED_MODULE_64__.ConnectedSpriteComponent; },
/* harmony export */   "DivComponent": function() { return /* reexport safe */ _scene_components_div_component__WEBPACK_IMPORTED_MODULE_65__.DivComponent; },
/* harmony export */   "DynamicEnvironmentMapComponent": function() { return /* reexport safe */ _scene_components_dynamic_environment_map_component__WEBPACK_IMPORTED_MODULE_66__.DynamicEnvironmentMapComponent; },
/* harmony export */   "GizmoComponent": function() { return /* reexport safe */ _scene_components_gizmo_component__WEBPACK_IMPORTED_MODULE_67__.GizmoComponent; },
/* harmony export */   "LabelComponent": function() { return /* reexport safe */ _scene_components_label_component__WEBPACK_IMPORTED_MODULE_68__.LabelComponent; },
/* harmony export */   "LightSourceComponent": function() { return /* reexport safe */ _scene_components_light_source_component__WEBPACK_IMPORTED_MODULE_69__.LightSourceComponent; },
/* harmony export */   "ModelComponent": function() { return /* reexport safe */ _scene_components_model_component__WEBPACK_IMPORTED_MODULE_70__.ModelComponent; },
/* harmony export */   "OrbitalParticlesComponent": function() { return /* reexport safe */ _scene_components_orbital_particles_component__WEBPACK_IMPORTED_MODULE_71__.OrbitalParticlesComponent; },
/* harmony export */   "ParticleSprayComponent": function() { return /* reexport safe */ _scene_components_particle_spray_component__WEBPACK_IMPORTED_MODULE_72__.ParticleSprayComponent; },
/* harmony export */   "RingsComponent": function() { return /* reexport safe */ _scene_components_rings_component__WEBPACK_IMPORTED_MODULE_73__.RingsComponent; },
/* harmony export */   "SkyboxComponent": function() { return /* reexport safe */ _scene_components_skybox_component__WEBPACK_IMPORTED_MODULE_74__.SkyboxComponent; },
/* harmony export */   "SpheroidComponent": function() { return /* reexport safe */ _scene_components_spheroid_component__WEBPACK_IMPORTED_MODULE_75__.SpheroidComponent; },
/* harmony export */   "SpheroidLODComponent": function() { return /* reexport safe */ _scene_components_spheroid_lod_component__WEBPACK_IMPORTED_MODULE_76__.SpheroidLODComponent; },
/* harmony export */   "SpoutComponent": function() { return /* reexport safe */ _scene_components_spout_component__WEBPACK_IMPORTED_MODULE_77__.SpoutComponent; },
/* harmony export */   "SpriteComponent": function() { return /* reexport safe */ _scene_components_sprite_component__WEBPACK_IMPORTED_MODULE_78__.SpriteComponent; },
/* harmony export */   "StarfieldComponent": function() { return /* reexport safe */ _scene_components_starfield_component__WEBPACK_IMPORTED_MODULE_79__.StarfieldComponent; },
/* harmony export */   "TrailComponent": function() { return /* reexport safe */ _scene_components_trail_component__WEBPACK_IMPORTED_MODULE_80__.TrailComponent; },
/* harmony export */   "BaseController": function() { return /* reexport safe */ _scene_controllers_base_controller__WEBPACK_IMPORTED_MODULE_81__.BaseController; },
/* harmony export */   "AlignController": function() { return /* reexport safe */ _scene_controllers_align_controller__WEBPACK_IMPORTED_MODULE_82__.AlignController; },
/* harmony export */   "AnimdataController": function() { return /* reexport safe */ _scene_controllers_animdata_controller__WEBPACK_IMPORTED_MODULE_83__.AnimdataController; },
/* harmony export */   "CoverageController": function() { return /* reexport safe */ _scene_controllers_coverage_controller__WEBPACK_IMPORTED_MODULE_84__.CoverageController; },
/* harmony export */   "DynamoController": function() { return /* reexport safe */ _scene_controllers_dynamo_controller__WEBPACK_IMPORTED_MODULE_85__.DynamoController; },
/* harmony export */   "FixedController": function() { return /* reexport safe */ _scene_controllers_fixed_controller__WEBPACK_IMPORTED_MODULE_86__.FixedController; },
/* harmony export */   "FixedToParentController": function() { return /* reexport safe */ _scene_controllers_fixed_to_parent_controller__WEBPACK_IMPORTED_MODULE_87__.FixedToParentController; },
/* harmony export */   "FreeFlyController": function() { return /* reexport safe */ _scene_controllers_free_fly_controller__WEBPACK_IMPORTED_MODULE_88__.FreeFlyController; },
/* harmony export */   "GroundClampController": function() { return /* reexport safe */ _scene_controllers_ground_clamp_controller__WEBPACK_IMPORTED_MODULE_89__.GroundClampController; },
/* harmony export */   "KeyframeController": function() { return /* reexport safe */ _scene_controllers_keyframe_controller__WEBPACK_IMPORTED_MODULE_90__.KeyframeController; },
/* harmony export */   "LookController": function() { return /* reexport safe */ _scene_controllers_look_controller__WEBPACK_IMPORTED_MODULE_91__.LookController; },
/* harmony export */   "ModelAnimateController": function() { return /* reexport safe */ _scene_controllers_model_animate_controller__WEBPACK_IMPORTED_MODULE_92__.ModelAnimateController; },
/* harmony export */   "OrbitController": function() { return /* reexport safe */ _scene_controllers_orbit_controller__WEBPACK_IMPORTED_MODULE_93__.OrbitController; },
/* harmony export */   "OrbitKeyframeController": function() { return /* reexport safe */ _scene_controllers_orbit_keyframe_controller__WEBPACK_IMPORTED_MODULE_94__.OrbitKeyframeController; },
/* harmony export */   "OrbitalElementsController": function() { return /* reexport safe */ _scene_controllers_orbital_elements_controller__WEBPACK_IMPORTED_MODULE_95__.OrbitalElementsController; },
/* harmony export */   "OrbitalElementsKeyFrame": function() { return /* reexport safe */ _scene_controllers_orbital_elements_controller__WEBPACK_IMPORTED_MODULE_95__.OrbitalElementsKeyFrame; },
/* harmony export */   "PickController": function() { return /* reexport safe */ _scene_controllers_pick_controller__WEBPACK_IMPORTED_MODULE_96__.PickController; },
/* harmony export */   "RollController": function() { return /* reexport safe */ _scene_controllers_roll_controller__WEBPACK_IMPORTED_MODULE_97__.RollController; },
/* harmony export */   "RotateController": function() { return /* reexport safe */ _scene_controllers_rotate_controller__WEBPACK_IMPORTED_MODULE_98__.RotateController; },
/* harmony export */   "RotateByEntityOrientationController": function() { return /* reexport safe */ _scene_controllers_rotate_by_entity_orientation_controller__WEBPACK_IMPORTED_MODULE_99__.RotateByEntityOrientationController; },
/* harmony export */   "ScaleController": function() { return /* reexport safe */ _scene_controllers_scale_controller__WEBPACK_IMPORTED_MODULE_100__.ScaleController; },
/* harmony export */   "SelectController": function() { return /* reexport safe */ _scene_controllers_select_controller__WEBPACK_IMPORTED_MODULE_101__.SelectController; },
/* harmony export */   "SetParentController": function() { return /* reexport safe */ _scene_controllers_set_parent_controller__WEBPACK_IMPORTED_MODULE_102__.SetParentController; },
/* harmony export */   "SpinController": function() { return /* reexport safe */ _scene_controllers_spin_controller__WEBPACK_IMPORTED_MODULE_103__.SpinController; },
/* harmony export */   "TapController": function() { return /* reexport safe */ _scene_controllers_tap_controller__WEBPACK_IMPORTED_MODULE_104__.TapController; },
/* harmony export */   "TransitionController": function() { return /* reexport safe */ _scene_controllers_transition_controller__WEBPACK_IMPORTED_MODULE_105__.TransitionController; },
/* harmony export */   "TranslateController": function() { return /* reexport safe */ _scene_controllers_translate_controller__WEBPACK_IMPORTED_MODULE_106__.TranslateController; },
/* harmony export */   "ZoomController": function() { return /* reexport safe */ _scene_controllers_zoom_controller__WEBPACK_IMPORTED_MODULE_107__.ZoomController; },
/* harmony export */   "Types": function() { return /* reexport safe */ _scene_types__WEBPACK_IMPORTED_MODULE_108__.Types; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../pioneer/engine/node_modules/three/build/three.module.js");
/* harmony import */ var three_examples_jsm_postprocessing_EffectComposer_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three/examples/jsm/postprocessing/EffectComposer.js */ "../pioneer/engine/node_modules/three/examples/jsm/postprocessing/EffectComposer.js");
/* harmony import */ var three_examples_jsm_loaders_GLTFLoader__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three/examples/jsm/loaders/GLTFLoader */ "../pioneer/engine/node_modules/three/examples/jsm/loaders/GLTFLoader.js");
/* harmony import */ var three_examples_jsm_loaders_KTXLoader__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three/examples/jsm/loaders/KTXLoader */ "../pioneer/engine/node_modules/three/examples/jsm/loaders/KTXLoader.js");
/* harmony import */ var three_examples_jsm_postprocessing_OutlinePass_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three/examples/jsm/postprocessing/OutlinePass.js */ "../pioneer/engine/node_modules/three/examples/jsm/postprocessing/OutlinePass.js");
/* harmony import */ var three_examples_jsm_postprocessing_RenderPass_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three/examples/jsm/postprocessing/RenderPass.js */ "../pioneer/engine/node_modules/three/examples/jsm/postprocessing/RenderPass.js");
/* harmony import */ var three_examples_jsm_postprocessing_UnrealBloomPass_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three/examples/jsm/postprocessing/UnrealBloomPass.js */ "../pioneer/engine/node_modules/three/examples/jsm/postprocessing/UnrealBloomPass.js");
/* harmony import */ var _shaders_log_depth__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shaders/log_depth */ "../pioneer/engine/src/shaders/log_depth.js");
/* harmony import */ var _utils_base_ref__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./utils/base_ref */ "../pioneer/engine/src/utils/base_ref.js");
/* harmony import */ var _utils_collection__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils/collection */ "../pioneer/engine/src/utils/collection.js");
/* harmony import */ var _utils_dependency_graph__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils/dependency_graph */ "../pioneer/engine/src/utils/dependency_graph.js");
/* harmony import */ var _utils_fast_iterable__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./utils/fast_iterable */ "../pioneer/engine/src/utils/fast_iterable.js");
/* harmony import */ var _utils_fps__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./utils/fps */ "../pioneer/engine/src/utils/fps.js");
/* harmony import */ var _utils_freezable__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./utils/freezable */ "../pioneer/engine/src/utils/freezable.js");
/* harmony import */ var _utils_math_utils__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/math_utils */ "../pioneer/engine/src/utils/math_utils.js");
/* harmony import */ var _utils_pool__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/pool */ "../pioneer/engine/src/utils/pool.js");
/* harmony import */ var _utils_reader__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./utils/reader */ "../pioneer/engine/src/utils/reader.js");
/* harmony import */ var _utils_sort__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./utils/sort */ "../pioneer/engine/src/utils/sort.js");
/* harmony import */ var _utils_tile__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./utils/tile */ "../pioneer/engine/src/utils/tile.js");
/* harmony import */ var _utils_time_utils__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./utils/time_utils */ "../pioneer/engine/src/utils/time_utils.js");
/* harmony import */ var _utils_wait_until__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./utils/wait_until */ "../pioneer/engine/src/utils/wait_until.js");
/* harmony import */ var _utils_aer__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./utils/aer */ "../pioneer/engine/src/utils/aer.js");
/* harmony import */ var _utils_color__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./utils/color */ "../pioneer/engine/src/utils/color.js");
/* harmony import */ var _utils_fast_map__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./utils/fast_map */ "../pioneer/engine/src/utils/fast_map.js");
/* harmony import */ var _utils_fast_set__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./utils/fast_set */ "../pioneer/engine/src/utils/fast_set.js");
/* harmony import */ var _utils_geometry__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./utils/geometry */ "../pioneer/engine/src/utils/geometry.js");
/* harmony import */ var _utils_interval__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./utils/interval */ "../pioneer/engine/src/utils/interval.js");
/* harmony import */ var _utils_orbital_elements__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./utils/orbital_elements */ "../pioneer/engine/src/utils/orbital_elements.js");
/* harmony import */ var _utils_rect__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./utils/rect */ "../pioneer/engine/src/utils/rect.js");
/* harmony import */ var _utils_quaternion__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./utils/quaternion */ "../pioneer/engine/src/utils/quaternion.js");
/* harmony import */ var _utils_vector2__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./utils/vector2 */ "../pioneer/engine/src/utils/vector2.js");
/* harmony import */ var _utils_vector3__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./utils/vector3 */ "../pioneer/engine/src/utils/vector3.js");
/* harmony import */ var _utils_cache__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./utils/cache */ "../pioneer/engine/src/utils/cache.js");
/* harmony import */ var _utils_component_ref__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./utils/component_ref */ "../pioneer/engine/src/utils/component_ref.js");
/* harmony import */ var _utils_controller_ref__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./utils/controller_ref */ "../pioneer/engine/src/utils/controller_ref.js");
/* harmony import */ var _utils_cube_map__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./utils/cube_map */ "../pioneer/engine/src/utils/cube_map.js");
/* harmony import */ var _utils_entity_ref__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./utils/entity_ref */ "../pioneer/engine/src/utils/entity_ref.js");
/* harmony import */ var _utils_lat_lon_alt__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./utils/lat_lon_alt */ "../pioneer/engine/src/utils/lat_lon_alt.js");
/* harmony import */ var _utils_line_mesh__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./utils/line_mesh */ "../pioneer/engine/src/utils/line_mesh.js");
/* harmony import */ var _utils_material_utils_phong__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./utils/material_utils_phong */ "../pioneer/engine/src/utils/material_utils_phong.js");
/* harmony import */ var _utils_material_utils_standard__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./utils/material_utils_standard */ "../pioneer/engine/src/utils/material_utils_standard.js");
/* harmony import */ var _utils_material_utils__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./utils/material_utils */ "../pioneer/engine/src/utils/material_utils.js");
/* harmony import */ var _utils_shader_fix__WEBPACK_IMPORTED_MODULE_42__ = __webpack_require__(/*! ./utils/shader_fix */ "../pioneer/engine/src/utils/shader_fix.js");
/* harmony import */ var _utils_sprite_particles__WEBPACK_IMPORTED_MODULE_43__ = __webpack_require__(/*! ./utils/sprite_particles */ "../pioneer/engine/src/utils/sprite_particles.js");
/* harmony import */ var _utils_texture_lod__WEBPACK_IMPORTED_MODULE_44__ = __webpack_require__(/*! ./utils/texture_lod */ "../pioneer/engine/src/utils/texture_lod.js");
/* harmony import */ var _utils_three_js_helper__WEBPACK_IMPORTED_MODULE_45__ = __webpack_require__(/*! ./utils/three_js_helper */ "../pioneer/engine/src/utils/three_js_helper.js");
/* harmony import */ var _capabilities__WEBPACK_IMPORTED_MODULE_46__ = __webpack_require__(/*! ./capabilities */ "../pioneer/engine/src/capabilities.js");
/* harmony import */ var _config__WEBPACK_IMPORTED_MODULE_47__ = __webpack_require__(/*! ./config */ "../pioneer/engine/src/config.js");
/* harmony import */ var _downloader__WEBPACK_IMPORTED_MODULE_48__ = __webpack_require__(/*! ./downloader */ "../pioneer/engine/src/downloader.js");
/* harmony import */ var _engine__WEBPACK_IMPORTED_MODULE_49__ = __webpack_require__(/*! ./engine */ "../pioneer/engine/src/engine.js");
/* harmony import */ var _scene_entity__WEBPACK_IMPORTED_MODULE_50__ = __webpack_require__(/*! ./scene/entity */ "../pioneer/engine/src/scene/entity.js");
/* harmony import */ var _scene_entity_item__WEBPACK_IMPORTED_MODULE_51__ = __webpack_require__(/*! ./scene/entity_item */ "../pioneer/engine/src/scene/entity_item.js");
/* harmony import */ var _input__WEBPACK_IMPORTED_MODULE_52__ = __webpack_require__(/*! ./input */ "../pioneer/engine/src/input.js");
/* harmony import */ var _material_manager__WEBPACK_IMPORTED_MODULE_53__ = __webpack_require__(/*! ./material_manager */ "../pioneer/engine/src/material_manager.js");
/* harmony import */ var _scene_scene__WEBPACK_IMPORTED_MODULE_54__ = __webpack_require__(/*! ./scene/scene */ "../pioneer/engine/src/scene/scene.js");
/* harmony import */ var _texture_loader__WEBPACK_IMPORTED_MODULE_55__ = __webpack_require__(/*! ./texture_loader */ "../pioneer/engine/src/texture_loader.js");
/* harmony import */ var _texture_loader_compressed__WEBPACK_IMPORTED_MODULE_56__ = __webpack_require__(/*! ./texture_loader_compressed */ "../pioneer/engine/src/texture_loader_compressed.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_57__ = __webpack_require__(/*! ./version */ "../pioneer/engine/src/version.js");
/* harmony import */ var _viewport__WEBPACK_IMPORTED_MODULE_58__ = __webpack_require__(/*! ./viewport */ "../pioneer/engine/src/viewport.js");
/* harmony import */ var _scene_components_base_component__WEBPACK_IMPORTED_MODULE_59__ = __webpack_require__(/*! ./scene/components/base_component */ "../pioneer/engine/src/scene/components/base_component.js");
/* harmony import */ var _scene_components_atmosphere_component__WEBPACK_IMPORTED_MODULE_60__ = __webpack_require__(/*! ./scene/components/atmosphere_component */ "../pioneer/engine/src/scene/components/atmosphere_component.js");
/* harmony import */ var _scene_components_camera_component__WEBPACK_IMPORTED_MODULE_61__ = __webpack_require__(/*! ./scene/components/camera_component */ "../pioneer/engine/src/scene/components/camera_component.js");
/* harmony import */ var _scene_components_cmts_component__WEBPACK_IMPORTED_MODULE_62__ = __webpack_require__(/*! ./scene/components/cmts_component */ "../pioneer/engine/src/scene/components/cmts_component.js");
/* harmony import */ var _scene_components_comet_tail_component__WEBPACK_IMPORTED_MODULE_63__ = __webpack_require__(/*! ./scene/components/comet_tail_component */ "../pioneer/engine/src/scene/components/comet_tail_component.js");
/* harmony import */ var _scene_components_connected_sprite_component__WEBPACK_IMPORTED_MODULE_64__ = __webpack_require__(/*! ./scene/components/connected_sprite_component */ "../pioneer/engine/src/scene/components/connected_sprite_component.js");
/* harmony import */ var _scene_components_div_component__WEBPACK_IMPORTED_MODULE_65__ = __webpack_require__(/*! ./scene/components/div_component */ "../pioneer/engine/src/scene/components/div_component.js");
/* harmony import */ var _scene_components_dynamic_environment_map_component__WEBPACK_IMPORTED_MODULE_66__ = __webpack_require__(/*! ./scene/components/dynamic_environment_map_component */ "../pioneer/engine/src/scene/components/dynamic_environment_map_component.js");
/* harmony import */ var _scene_components_gizmo_component__WEBPACK_IMPORTED_MODULE_67__ = __webpack_require__(/*! ./scene/components/gizmo_component */ "../pioneer/engine/src/scene/components/gizmo_component.js");
/* harmony import */ var _scene_components_label_component__WEBPACK_IMPORTED_MODULE_68__ = __webpack_require__(/*! ./scene/components/label_component */ "../pioneer/engine/src/scene/components/label_component.js");
/* harmony import */ var _scene_components_light_source_component__WEBPACK_IMPORTED_MODULE_69__ = __webpack_require__(/*! ./scene/components/light_source_component */ "../pioneer/engine/src/scene/components/light_source_component.js");
/* harmony import */ var _scene_components_model_component__WEBPACK_IMPORTED_MODULE_70__ = __webpack_require__(/*! ./scene/components/model_component */ "../pioneer/engine/src/scene/components/model_component.js");
/* harmony import */ var _scene_components_orbital_particles_component__WEBPACK_IMPORTED_MODULE_71__ = __webpack_require__(/*! ./scene/components/orbital_particles_component */ "../pioneer/engine/src/scene/components/orbital_particles_component.js");
/* harmony import */ var _scene_components_particle_spray_component__WEBPACK_IMPORTED_MODULE_72__ = __webpack_require__(/*! ./scene/components/particle_spray_component */ "../pioneer/engine/src/scene/components/particle_spray_component.js");
/* harmony import */ var _scene_components_rings_component__WEBPACK_IMPORTED_MODULE_73__ = __webpack_require__(/*! ./scene/components/rings_component */ "../pioneer/engine/src/scene/components/rings_component.js");
/* harmony import */ var _scene_components_skybox_component__WEBPACK_IMPORTED_MODULE_74__ = __webpack_require__(/*! ./scene/components/skybox_component */ "../pioneer/engine/src/scene/components/skybox_component.js");
/* harmony import */ var _scene_components_spheroid_component__WEBPACK_IMPORTED_MODULE_75__ = __webpack_require__(/*! ./scene/components/spheroid_component */ "../pioneer/engine/src/scene/components/spheroid_component.js");
/* harmony import */ var _scene_components_spheroid_lod_component__WEBPACK_IMPORTED_MODULE_76__ = __webpack_require__(/*! ./scene/components/spheroid_lod_component */ "../pioneer/engine/src/scene/components/spheroid_lod_component.js");
/* harmony import */ var _scene_components_spout_component__WEBPACK_IMPORTED_MODULE_77__ = __webpack_require__(/*! ./scene/components/spout_component */ "../pioneer/engine/src/scene/components/spout_component.js");
/* harmony import */ var _scene_components_sprite_component__WEBPACK_IMPORTED_MODULE_78__ = __webpack_require__(/*! ./scene/components/sprite_component */ "../pioneer/engine/src/scene/components/sprite_component.js");
/* harmony import */ var _scene_components_starfield_component__WEBPACK_IMPORTED_MODULE_79__ = __webpack_require__(/*! ./scene/components/starfield_component */ "../pioneer/engine/src/scene/components/starfield_component.js");
/* harmony import */ var _scene_components_trail_component__WEBPACK_IMPORTED_MODULE_80__ = __webpack_require__(/*! ./scene/components/trail_component */ "../pioneer/engine/src/scene/components/trail_component.js");
/* harmony import */ var _scene_controllers_base_controller__WEBPACK_IMPORTED_MODULE_81__ = __webpack_require__(/*! ./scene/controllers/base_controller */ "../pioneer/engine/src/scene/controllers/base_controller.js");
/* harmony import */ var _scene_controllers_align_controller__WEBPACK_IMPORTED_MODULE_82__ = __webpack_require__(/*! ./scene/controllers/align_controller */ "../pioneer/engine/src/scene/controllers/align_controller.js");
/* harmony import */ var _scene_controllers_animdata_controller__WEBPACK_IMPORTED_MODULE_83__ = __webpack_require__(/*! ./scene/controllers/animdata_controller */ "../pioneer/engine/src/scene/controllers/animdata_controller.js");
/* harmony import */ var _scene_controllers_coverage_controller__WEBPACK_IMPORTED_MODULE_84__ = __webpack_require__(/*! ./scene/controllers/coverage_controller */ "../pioneer/engine/src/scene/controllers/coverage_controller.js");
/* harmony import */ var _scene_controllers_dynamo_controller__WEBPACK_IMPORTED_MODULE_85__ = __webpack_require__(/*! ./scene/controllers/dynamo_controller */ "../pioneer/engine/src/scene/controllers/dynamo_controller.js");
/* harmony import */ var _scene_controllers_fixed_controller__WEBPACK_IMPORTED_MODULE_86__ = __webpack_require__(/*! ./scene/controllers/fixed_controller */ "../pioneer/engine/src/scene/controllers/fixed_controller.js");
/* harmony import */ var _scene_controllers_fixed_to_parent_controller__WEBPACK_IMPORTED_MODULE_87__ = __webpack_require__(/*! ./scene/controllers/fixed_to_parent_controller */ "../pioneer/engine/src/scene/controllers/fixed_to_parent_controller.js");
/* harmony import */ var _scene_controllers_free_fly_controller__WEBPACK_IMPORTED_MODULE_88__ = __webpack_require__(/*! ./scene/controllers/free_fly_controller */ "../pioneer/engine/src/scene/controllers/free_fly_controller.js");
/* harmony import */ var _scene_controllers_ground_clamp_controller__WEBPACK_IMPORTED_MODULE_89__ = __webpack_require__(/*! ./scene/controllers/ground_clamp_controller */ "../pioneer/engine/src/scene/controllers/ground_clamp_controller.js");
/* harmony import */ var _scene_controllers_keyframe_controller__WEBPACK_IMPORTED_MODULE_90__ = __webpack_require__(/*! ./scene/controllers/keyframe_controller */ "../pioneer/engine/src/scene/controllers/keyframe_controller.js");
/* harmony import */ var _scene_controllers_look_controller__WEBPACK_IMPORTED_MODULE_91__ = __webpack_require__(/*! ./scene/controllers/look_controller */ "../pioneer/engine/src/scene/controllers/look_controller.js");
/* harmony import */ var _scene_controllers_model_animate_controller__WEBPACK_IMPORTED_MODULE_92__ = __webpack_require__(/*! ./scene/controllers/model_animate_controller */ "../pioneer/engine/src/scene/controllers/model_animate_controller.js");
/* harmony import */ var _scene_controllers_orbit_controller__WEBPACK_IMPORTED_MODULE_93__ = __webpack_require__(/*! ./scene/controllers/orbit_controller */ "../pioneer/engine/src/scene/controllers/orbit_controller.js");
/* harmony import */ var _scene_controllers_orbit_keyframe_controller__WEBPACK_IMPORTED_MODULE_94__ = __webpack_require__(/*! ./scene/controllers/orbit_keyframe_controller */ "../pioneer/engine/src/scene/controllers/orbit_keyframe_controller.js");
/* harmony import */ var _scene_controllers_orbital_elements_controller__WEBPACK_IMPORTED_MODULE_95__ = __webpack_require__(/*! ./scene/controllers/orbital_elements_controller */ "../pioneer/engine/src/scene/controllers/orbital_elements_controller.js");
/* harmony import */ var _scene_controllers_pick_controller__WEBPACK_IMPORTED_MODULE_96__ = __webpack_require__(/*! ./scene/controllers/pick_controller */ "../pioneer/engine/src/scene/controllers/pick_controller.js");
/* harmony import */ var _scene_controllers_roll_controller__WEBPACK_IMPORTED_MODULE_97__ = __webpack_require__(/*! ./scene/controllers/roll_controller */ "../pioneer/engine/src/scene/controllers/roll_controller.js");
/* harmony import */ var _scene_controllers_rotate_controller__WEBPACK_IMPORTED_MODULE_98__ = __webpack_require__(/*! ./scene/controllers/rotate_controller */ "../pioneer/engine/src/scene/controllers/rotate_controller.js");
/* harmony import */ var _scene_controllers_rotate_by_entity_orientation_controller__WEBPACK_IMPORTED_MODULE_99__ = __webpack_require__(/*! ./scene/controllers/rotate_by_entity_orientation_controller */ "../pioneer/engine/src/scene/controllers/rotate_by_entity_orientation_controller.js");
/* harmony import */ var _scene_controllers_scale_controller__WEBPACK_IMPORTED_MODULE_100__ = __webpack_require__(/*! ./scene/controllers/scale_controller */ "../pioneer/engine/src/scene/controllers/scale_controller.js");
/* harmony import */ var _scene_controllers_select_controller__WEBPACK_IMPORTED_MODULE_101__ = __webpack_require__(/*! ./scene/controllers/select_controller */ "../pioneer/engine/src/scene/controllers/select_controller.js");
/* harmony import */ var _scene_controllers_set_parent_controller__WEBPACK_IMPORTED_MODULE_102__ = __webpack_require__(/*! ./scene/controllers/set_parent_controller */ "../pioneer/engine/src/scene/controllers/set_parent_controller.js");
/* harmony import */ var _scene_controllers_spin_controller__WEBPACK_IMPORTED_MODULE_103__ = __webpack_require__(/*! ./scene/controllers/spin_controller */ "../pioneer/engine/src/scene/controllers/spin_controller.js");
/* harmony import */ var _scene_controllers_tap_controller__WEBPACK_IMPORTED_MODULE_104__ = __webpack_require__(/*! ./scene/controllers/tap_controller */ "../pioneer/engine/src/scene/controllers/tap_controller.js");
/* harmony import */ var _scene_controllers_transition_controller__WEBPACK_IMPORTED_MODULE_105__ = __webpack_require__(/*! ./scene/controllers/transition_controller */ "../pioneer/engine/src/scene/controllers/transition_controller.js");
/* harmony import */ var _scene_controllers_translate_controller__WEBPACK_IMPORTED_MODULE_106__ = __webpack_require__(/*! ./scene/controllers/translate_controller */ "../pioneer/engine/src/scene/controllers/translate_controller.js");
/* harmony import */ var _scene_controllers_zoom_controller__WEBPACK_IMPORTED_MODULE_107__ = __webpack_require__(/*! ./scene/controllers/zoom_controller */ "../pioneer/engine/src/scene/controllers/zoom_controller.js");
/* harmony import */ var _scene_types__WEBPACK_IMPORTED_MODULE_108__ = __webpack_require__(/*! ./scene/types */ "../pioneer/engine/src/scene/types.js");
// Three.js








// Shader Chunks


// Utils with 0 dependencies














// Utils with only one of the above dependencies.












// Utils with only one of the above dependencies.















// Core














// Components























// Controllers




























// The types that imports all of the above components and controllers.



/***/ }),

/***/ "../pioneer/engine/src/material_manager.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/material_manager.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaterialManager": function() { return /* binding */ MaterialManager; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/* harmony import */ var _shaders_basic__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shaders/basic */ "../pioneer/engine/src/shaders/basic.js");
/* harmony import */ var _shaders_basic_alpha__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./shaders/basic_alpha */ "../pioneer/engine/src/shaders/basic_alpha.js");
/* harmony import */ var _shaders_connected_sprite__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaders/connected_sprite */ "../pioneer/engine/src/shaders/connected_sprite.js");
/* harmony import */ var _shaders_line__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./shaders/line */ "../pioneer/engine/src/shaders/line.js");
/* harmony import */ var _shaders_plumes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./shaders/plumes */ "../pioneer/engine/src/shaders/plumes.js");
/* harmony import */ var _shaders_sprite__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./shaders/sprite */ "../pioneer/engine/src/shaders/sprite.js");
/* harmony import */ var _shaders_sprite_particles__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./shaders/sprite_particles */ "../pioneer/engine/src/shaders/sprite_particles.js");
/* harmony import */ var _shaders_trail__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./shaders/trail */ "../pioneer/engine/src/shaders/trail.js");
/** @module pioneer */


// Preloaded shaders.









/**
 * A generic resource.
 * @template Type
 */
class Resource {
	/**
	 * Constructs the class.
	 * @param {Type} value
	 */
	constructor(value) {
		/**
		 * The value of the resource.
		 * @type {Type}
		 */
		this.value = value;

		/**
		 * How many of this resource are currently being used.
		 * @type {number}
		 */
		this.useCount = 0;
	}
}

/**
 * Material manager. Constructs materials from nodes.
 */
class MaterialManager {
	/**
	 * @param {Downloader} downloader
	 */
	constructor(downloader) {
		/**
		 * The downloader.
		 * @type {Downloader}
		 * @private
		 */
		this._downloader = downloader;

		/**
		 * A mapping from urls to materials.
		 * @type {Map<string, Resource<THREE.RawShaderMaterial>>}
		 * @private
		 */
		this._cache = new Map();

		/**
		 * A mapping from cloned materials to the urls.
		 * @type {Map<THREE.RawShaderMaterial, string>}
		 * @private
		 */
		this._clonedMaterials = new Map();

		/**
		 * A mapping from urls to promises that resolve to materials.
		 * @type {Map<string, Promise<Resource<THREE.RawShaderMaterial>>>}
		 * @private
		 */
		this._promises = new Map();

		// Preload node types that are required for the built-in components.
		this._preload();
	}

	/**
	 * Gets a material.
	 * @param {string} url
	 * @returns {Promise<THREE.RawShaderMaterial>}
	 */
	async get(url) {
		// If it is already loaded, return a resolved promise.
		let resource = this._cache.get(url);

		// If it is loading right now, return the existing promise.
		if (resource === undefined) {
			const promise = this._promises.get(url);
			if (promise !== undefined) {
				resource = await promise;
			}
		}

		// Load the material.
		if (resource === undefined) {
			const download = await this._downloader.download(url, false);
			if (download.status !== 'completed' || typeof download.content !== 'string') {
				throw new Error('Failed to download material "' + url + '".');
			}
			const obj = JSON.parse(download.content);
			resource = new Resource(await this._load(url, obj));
			this._cache.set(url, resource);
		}

		// Increment the use count and return it.
		resource.useCount += 1;
		return this._clone(resource.value, url);
	}

	/**
	 * Gets a pre-loaded material without using promises.
	 * @param {string} url
	 * @returns {THREE.RawShaderMaterial}
	 */
	getPreloaded(url) {
		// If it is already loaded, return a resolved promise.
		const resource = this._cache.get(url);
		if (resource === undefined) {
			throw new Error('Invalid pre-loaded material "' + url + '".');
		}
		resource.useCount += 1;
		return this._clone(resource.value, url);
	}

	/**
	 * Releases a material, unloading it if necessary.
	 * @param {THREE.RawShaderMaterial} material
	 */
	release(material) {
		// Get the url from the material.
		const url = this._clonedMaterials.get(material);
		if (url === undefined) {
			return;
		}
		// Remove the cloned material.
		this._clonedMaterials.delete(material);
		// Get the resource from the url.
		const resource = this._cache.get(url);
		if (resource) {
			resource.useCount -= 1;
			// If it isn't be used by anyone, unload the original material.
			if (resource.useCount === 0) {
				this._unload(resource.value);
				this._cache.delete(url);
			}
		}
	}

	/**
	 * Unloads a material.
	 * @param {THREE.RawShaderMaterial} material
	 * @private
	 */
	_unload(material) {
		const uniforms = material.uniforms;
		for (const uniform in uniforms) {
			if (Object.prototype.hasOwnProperty.call(uniforms, uniform) && uniforms[uniform].value !== null && uniforms[uniform].value.dispose !== undefined) {
				uniforms[uniform].value.dispose();
			}
		}
		material.dispose();
	}

	/**
	 * Preloads a given list of shaders for quick access in the engine.
	 * @private
	 */
	_preload() {
		// Declare the preloaded shaders.
		/** @type {Map<string, any>} */
		const shaders = new Map();
		shaders.set('basic', _shaders_basic__WEBPACK_IMPORTED_MODULE_1__.BasicShader);
		shaders.set('basic_alpha', _shaders_basic_alpha__WEBPACK_IMPORTED_MODULE_2__.BasicAlphaShader);
		shaders.set('connected_sprite', _shaders_connected_sprite__WEBPACK_IMPORTED_MODULE_3__.ConnectedSpriteShader);
		shaders.set('line', _shaders_line__WEBPACK_IMPORTED_MODULE_4__.LineShader);
		shaders.set('plumes', _shaders_plumes__WEBPACK_IMPORTED_MODULE_5__.PlumesShader);
		shaders.set('sprite', _shaders_sprite__WEBPACK_IMPORTED_MODULE_6__.SpriteShader);
		shaders.set('sprite_particles', _shaders_sprite_particles__WEBPACK_IMPORTED_MODULE_7__.SpriteParticlesShader);
		shaders.set('trail', _shaders_trail__WEBPACK_IMPORTED_MODULE_8__.TrailShader);

		// Load them.
		for (const [name, json] of shaders) {
			const material = this._load(name, json);
			const resource = new Resource(material);
			resource.useCount += 1;
			this._cache.set(name, resource);
		}
	}

	/**
	 * Loads a shader from JSON.
	 * @param {string} url
	 * @param {any} json
	 * @returns {THREE.RawShaderMaterial}
	 * @private
	 */
	_load(url, json) {
		try {
			// Generate ThreeJS uniform objects
			/** @type {Object<string, THREE.Uniform>} */
			const uniforms = {};
			if (json.uniforms) {
				for (const [name, type] of Object.entries(json.uniforms)) {
					// Don't add the Three.js pre-defined uniforms, because they would overwrite them when rendering.
					if (['modelMatrix', 'modelViewMatrix', 'projectionMatrix', 'viewMatrix', 'normalMatrix', 'cameraPosition'].includes(name)) {
						continue;
					}
					uniforms[name] = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._getUniformValueFromType(type));
				}
			}

			// Process some properties.
			let transparent = false;
			let depthWrite = true;
			let side = /** @type {THREE.Side} */(_internal__WEBPACK_IMPORTED_MODULE_0__.THREE.FrontSide);
			let blending = /** @type {THREE.Blending} */(_internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NoBlending);
			if (json.properties) {
				if (json.properties.transparent === true) {
					transparent = true;
				}
				if (json.properties.depthWrite === false) {
					depthWrite = false;
				}
				switch (json.properties.side) {
					case 'front': side = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.FrontSide; break;
					case 'back': side = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BackSide; break;
					case 'double': side = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide; break;
				}
				switch (json.properties.blending) {
					case 'normal': blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NormalBlending; break;
					case 'additive': blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AdditiveBlending; break;
					case 'subtractive': blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.SubtractiveBlending; break;
					case 'multiply': blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.MultiplyBlending; break;
					case 'custom': blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CustomBlending; break;
				}
			}

			// Check for required code.
			if (typeof json.vertex !== 'object' || typeof json.vertex.code !== 'string') {
				throw new Error('Missing vertex stage code.');
			}
			if (typeof json.fragment !== 'object' || typeof json.fragment.code !== 'string') {
				throw new Error('Missing fragment stage code.');
			}

			// Set the extension code.
			if (Array.isArray(json.vertex.extensions)) {
				let extensionCode = '';
				for (const extension of json.vertex.extensions) {
					if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasGLExtension(extension)) {
						extensionCode += '#extension GL_' + extension + ': enable\n';
					}
				}
				for (const extension of json.vertex.extensions) {
					if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasGLExtension(extension)) {
						extensionCode += '#define L_' + extension + ' true\n';
					}
					if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.isWebGL2() && extension === 'EXT_frag_depth') {
						extensionCode += '#define L_' + extension + ' true\n';
					}
				}
				json.vertex.code = extensionCode + json.vertex.code;
			}
			if (Array.isArray(json.fragment.extensions)) {
				let extensionCode = '';
				for (const extension of json.fragment.extensions) {
					if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasGLExtension(extension)) {
						extensionCode += '#extension GL_' + extension + ': enable\n';
					}
				}
				for (const extension of json.fragment.extensions) {
					if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasGLExtension(extension)) {
						extensionCode += '#define L_' + extension + ' true\n';
					}
				}
				json.fragment.code = extensionCode + json.fragment.code;
			}

			// Create the material.
			const material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial({
				uniforms,
				vertexShader: json.vertex.code,
				fragmentShader: json.fragment.code,
				transparent: transparent,
				depthWrite: depthWrite,
				side: side,
				blending: blending,
				glslVersion: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.GLSL3
			});
			_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderFix.fix(material);
			material.needsUpdate = true;

			// Return the loaded material.
			return material;
		}
		catch (e) {
			if (e instanceof Error) {
				e.message = `While processing material "${url}": ${e.message}`;
			}
			throw e;
		}
	}

	/**
	 * Gets a uniform value from the type.
	 * @param {string} type
	 * @returns {any}
	 * @private
	 */
	_getUniformValueFromType(type) {
		type = type.replace(/.* /, '');
		switch (type) {
			case 'int':
			case 'float':
				return 0;
			case 'ivec2':
			case 'vec2':
				return new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2(0, 0);
			case 'ivec3':
			case 'vec3':
				return new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0);
			case 'ivec4':
			case 'vec4':
				return new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4(0, 0, 0, 0);
			case 'mat3':
				return new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix3();
			case 'mat4':
				return new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix4();
			case 'sampler2D':
				return null;
			case 'samplerCube':
				return null;
		}
		if (type.endsWith(']')) {
			const indexOfOpenBracket = type.indexOf('[');
			const indexOfCloseBracket = type.indexOf(']');
			const baseType = type.substring(0, indexOfOpenBracket);
			const numElements = Number.parseInt(type.substring(indexOfOpenBracket + 1, indexOfCloseBracket));
			const array = [];
			for (let i = 0; i < numElements; i++) {
				array.push(this._getUniformValueFromType(baseType));
			}
			return array;
		}
		throw new Error('Unrecognized type: ' + type + '.');
	}

	/**
	 * Clones a material.
	 * @param {THREE.RawShaderMaterial} material
	 * @param {string} url
	 * @returns {THREE.RawShaderMaterial}
	 * @private
	 */
	_clone(material, url) {
		// Use the built-in Three.js material clone.
		const newMaterial = material.clone();

		// Manually clone array uniforms of Three.js objects, since Three.js doesn't do this (see https://github.com/mrdoob/three.js/issues/16080).
		for (const [name, uniform] of Object.entries(material.uniforms)) {
			const value = uniform.value;
			if (Array.isArray(value)) {
				const value0 = value[0];
				if (value0 && (value0.isColor || value0.isMatrix3 || value0.isMatrix4
					|| value0.isVector2 || value0.isVector3 || value0.isVector4
					|| value0.isTexture)) {
					material.uniforms[name].value = [];
					for (let i = 0; i < value.length; i++) {
						material.uniforms[name].value[i] = value[i].clone();
					}
				}
			}
		}

		// Make sure the new material is updated.
		newMaterial.needsUpdate = true;

		// Add to the cloned materials list so that it can be found during the release.
		this._clonedMaterials.set(newMaterial, url);

		return newMaterial;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/atmosphere_component.js":
/*!**********************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/atmosphere_component.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AtmosphereComponent": function() { return /* binding */ AtmosphereComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * An atmosphere over a component with a spheroid.
 */
class AtmosphereComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The density of the atmosphere at sea level.
		 * @type {number}
		 * @private
		 */
		this._density = 0.0;

		/**
		 * The scale height of the atmosphere.
		 * @type {number}
		 * @private
		*/
		this._scaleHeight = 1.0;

		/**
		 * The emissivity of the atmosphere. 0 means not emissive and 1 means 100% emissive.
		 * @type {number}
		 * @private
		 */
		this._emissivity = 0.0;

		/**
		 * The base color of the atmosphere.
		 * @type {Color}
		 * @private
		 */
		this._color = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color();
		this._color.freeze();

		/**
		 * The brightness of the sun in the sky when looking through the atmosphere.
		 * @type {number}
		 * @private
		 */
		this._sunBrightness = 1.0;

		/**
		 * The sunset color of the atmosphere.
		 * @type {Color}
		 * @private
		 */
		this._sunsetColor = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color();
		this._sunsetColor.freeze();

		/**
		 * The sunset intensity of the atmosphere.
		 * @type {number}
		 * @private
		 */
		this._sunsetIntensity = 0.0;

		/**
		 * A reference to the spheroid component.
		 * @type {ComponentRef<SpheroidComponent>}
		 * @private
		 */
		this._spheroidComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid');
		this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this));

		// Bind the callbacks to this.
		this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this);

		// It aligns with the entity's orientation.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the spheroid that this uses.
	 * @returns {SpheroidComponent}
	 */
	getSpheroid() {
		return this._spheroidComponentRef.get();
	}

	/**
	 * Gets the density of the atmosphere at sea level.
	 * @returns {number}
	 */
	getDensity() {
		return this._density;
	}

	/**
	 * Sets the density of the atmosphere at sea level.
	 * @param {number} density
	 */
	setDensity(density) {
		this._density = density;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'density', density);
	}

	/**
	 * Gets the scale height of the atmosphere.
	 * @returns {number}
	 */
	getScaleHeight() {
		return this._scaleHeight;
	}

	/**
	 * Sets the scale height of the atmosphere.
	 * @param {number} scaleHeight
	 */
	setScaleHeight(scaleHeight) {
		this._scaleHeight = scaleHeight;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'scaleHeight', scaleHeight);
	}

	/**
	 * Gets the emissivity of the atmosphere. 0 means not emissive and 1 means 100% emissive. Defaults to 0.
	 * @returns {number}
	 */
	getEmissivity() {
		return this._emissivity;
	}

	/**
	 * Sets the emissivity of the atmosphere.
	 * @param {number} emissivity
	 */
	setEmissivity(emissivity) {
		this._emissivity = emissivity;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'emissivity', emissivity);
	}

	/**
	 * Gets the base color of the atmosphere. Default is white.
	 * @returns {Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the base color of the atmosphere. Default is white.
	 * @param {Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGB(this.getThreeJsMaterials()[0], 'color', color);
	}

	/**
	 * Gets the brightness of the sun in the sky when looking through the atmosphere.
	 * @returns {number}
	 */
	getSunBrightness() {
		return this._sunBrightness;
	}

	/**
	 * Sets the brightness of the sun in the sky when looking through the atmosphere.
	 * @param {number} sunBrightness
	 */
	setSunBrightness(sunBrightness) {
		this._sunBrightness = sunBrightness;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'sunBrightness', sunBrightness);
	}

	/**
	 * Gets the sunset color of the atmosphere. Default is white.
	 * @returns {Color}
	 */
	getSunsetColor() {
		return this._sunsetColor;
	}

	/**
	 * Sets the sunset color of the atmosphere. Default is white.
	 * @param {Color} sunsetColor
	 */
	setSunsetColor(sunsetColor) {
		this._sunsetColor.thaw();
		this._sunsetColor.copy(sunsetColor);
		this._sunsetColor.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGB(this.getThreeJsMaterials()[0], 'sunsetColor', sunsetColor);
	}

	/**
	 * Gets the sunset intensity of the atmosphere. Default is 0.
	 * @returns {number}
	 */
	getSunsetIntensity() {
		return this._sunsetIntensity;
	}

	/**
	 * Sets the sunset intensity of the atmosphere. Default is 0.
	 * @param {number} sunsetIntensity
	 */
	setSunsetIntensity(sunsetIntensity) {
		this._sunsetIntensity = sunsetIntensity;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'sunsetIntensity', sunsetIntensity);
	}

	/**
	 * Sets the reference to use for the spheroid component, by name or the type index.
	 * @param {string | number} nameOrTypeIndex
	 */
	setSpheroidReference(nameOrTypeIndex) {
		if (typeof nameOrTypeIndex === 'string') {
			this._spheroidComponentRef.setByName(this.getEntity().getName(), nameOrTypeIndex);
		}
		else {
			this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid', nameOrTypeIndex);
		}
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @package
	 */
	__destroy() {
		// Remove the spheroid changed callback.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			spheroidComponent.removeChangedCallback(this._spheroidChangedCallback);
		}

		super.__destroy();
	}

	/**
	 * Updates the camera-non-specific parts of the component.
	 * @override
	 * @internal
	 */
	__update() {
		// Update the spheroid component reference.
		this._spheroidComponentRef.update();
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// Set the camera position uniform.
		const cameraPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		cameraPosition.neg(this.getEntity().getCameraSpacePosition(camera));
		cameraPosition.rotateInverse(this.getEntity().getOrientation(), cameraPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'cameraPosition', cameraPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraPosition);

		// Set the lightPosition and lightColor uniform.
		_internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setLightSourceUniforms(this.getThreeJsMaterials(), this.getEntity(), camera);

		// Set the entity's orientation to get the lights into the entity-space.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformQuaternion(this.getThreeJsMaterials()[0], 'entityOrientation', this.getEntity().getOrientation());

		// Set the orientation to the entity's orientation.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());

		// Set the Three.js object position the entity's camera-space position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		// Create the material.
		const material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial({
			uniforms: {
				lightPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0)]),
				lightColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)]),
				lightRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
				numLights: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

				density: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._density),
				scaleHeight: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._scaleHeight),
				emissivity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._emissivity),
				equatorialRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1.0),
				polarRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1.0),
				cameraPosition: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0)),
				entityOrientation: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4(1, 0, 0, 0)),
				color: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(this._color.r, this._color.g, this._color.b)),
				sunBrightness: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._sunBrightness),
				sunsetColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(this._sunsetColor.r, this._sunsetColor.g, this._sunsetColor.b)),
				sunsetIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._sunsetIntensity),

				..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
			},
			vertexShader: vertexShader,
			fragmentShader: fragmentShader,
			transparent: true,
			depthWrite: false,
			blending: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NormalBlending
		});
		_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderFix.fix(material);
		this.getThreeJsMaterials().push(material);

		const object = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [{ name: 'position', dimensions: 3 }], false);
		this.getThreeJsObjects().push(object);

		// Create the mesh itself.
		const numLatVerts = 64;
		const numLonVerts = 128;
		const latStep = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi / (numLatVerts - 1);
		const lonStep = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi / numLonVerts;
		const numVerts = (numLonVerts + 1) * numLatVerts;
		const meshPositions = new Float32Array(numVerts * 3);
		const meshIndices = new Uint16Array(numLonVerts * (numLatVerts - 1) * 6);
		const xyz = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		for (let latI = 0; latI < numLatVerts; latI++) {
			lla.lat = latI * latStep - _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi;
			lla.alt = 0;
			const cosLat = Math.cos(lla.lat);
			const sinLat = Math.sin(lla.lat);
			for (let lonI = 0; lonI < numLonVerts + 1; lonI++) {
				lla.lon = lonI * lonStep - _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi;

				const vertexI = latI * (numLonVerts + 1) + lonI;
				meshPositions[vertexI * 3 + 0] = cosLat * Math.cos(lla.lon);
				meshPositions[vertexI * 3 + 1] = cosLat * Math.sin(lla.lon);
				meshPositions[vertexI * 3 + 2] = sinLat;

				const triangleI = latI * numLonVerts + lonI;
				if (latI < numLatVerts - 1 && lonI < numLonVerts) {
					meshIndices[triangleI * 6 + 0] = (numLonVerts + 1) * (latI + 0) + (lonI + 0);
					meshIndices[triangleI * 6 + 1] = (numLonVerts + 1) * (latI + 1) + (lonI + 0);
					meshIndices[triangleI * 6 + 2] = (numLonVerts + 1) * (latI + 1) + (lonI + 1);
					meshIndices[triangleI * 6 + 3] = (numLonVerts + 1) * (latI + 0) + (lonI + 0);
					meshIndices[triangleI * 6 + 4] = (numLonVerts + 1) * (latI + 1) + (lonI + 1);
					meshIndices[triangleI * 6 + 5] = (numLonVerts + 1) * (latI + 0) + (lonI + 1);
				}
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(xyz);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(object.geometry, 'position', meshPositions);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(object.geometry, meshIndices);

		// Make it render before other transparent objects.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setRenderOrder(object, -1);

		// Make it used in the dynamic environment map.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.useInDynEnvMap(object, true);

		// Update from the spheroid properties.
		this._spheroidChangedCallback();

		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Callback called when the spheroid reference is found or lost.
	 * @param {SpheroidComponent} oldRef
	 * @param {SpheroidComponent} newRef
	 * @private
	 */
	_spheroidRefChangedCallback(oldRef, newRef) {
		if (oldRef !== null) {
			oldRef.removeChangedCallback(this._spheroidChangedCallback);
		}
		if (newRef !== null) {
			newRef.addChangedCallback(this._spheroidChangedCallback);
		}
		this._spheroidChangedCallback();
	}

	/**
	 * Callback to be called when the spheroid component changed.
	 * @private
	 */
	_spheroidChangedCallback() {
		// Set the radii uniforms.
		const spheroidComponent = this._spheroidComponentRef.get();
		const material = this.getThreeJsMaterials()[0];
		if (spheroidComponent !== null) {
			// Set the radii.
			this.__setRadius(Math.max(spheroidComponent.getEquatorialRadius(), spheroidComponent.getPolarRadius()));
			// Set the radii uniforms.
			if (material !== undefined) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'equatorialRadius', spheroidComponent.getEquatorialRadius());
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'polarRadius', spheroidComponent.getPolarRadius());
			}
		}
		else {
			this.__setRadius(0);
			if (material !== undefined) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'equatorialRadius', 0);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'polarRadius', 0);
			}
		}
	}
}

const vertexShader = `
	attribute vec3 position;
	uniform mat4 projectionMatrix;
	uniform mat4 modelViewMatrix;

	uniform float scaleHeight;
	uniform float equatorialRadius;
	uniform float polarRadius;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

	varying vec3 localPosition;

	void main() {
		float scaleHeightMultiplier = 20.0;
		localPosition = vec3(position.x * (equatorialRadius + scaleHeight * scaleHeightMultiplier), position.y * (equatorialRadius + scaleHeight * scaleHeightMultiplier), position.z * (polarRadius + scaleHeight * scaleHeightMultiplier));
		vec4 viewPosition = modelViewMatrix * vec4(localPosition, 1.);
		gl_Position = projectionMatrix * viewPosition;
		gl_Position.w = viewPosition.y;

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
	}`;

const fragmentShader = `
	precision highp float;

	uniform vec3 lightPositions[5];
	uniform vec3 lightColors[5];
	uniform int numLights;

	uniform float density;
	uniform float scaleHeight;
	uniform float equatorialRadius;
	uniform float polarRadius;
	uniform vec3 cameraPosition;
	uniform vec4 entityOrientation;
	uniform vec3 color;
	uniform float emissivity;
	uniform float sunBrightness;
	uniform vec3 sunsetColor;
	uniform float sunsetIntensity;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

	varying vec3 localPosition;

	const int numIterations = 5;

	// Inverse rotate a vector by a quaternion.
	vec3 quatRotInv(vec4 q, vec3 v) {
		float tx = q.w * v.x - q.y * v.z + q.z * v.y;
		float ty = q.w * v.y - q.z * v.x + q.x * v.z;
		float tz = q.w * v.z - q.x * v.y + q.y * v.x;
		float tw = q.x * v.x + q.y * v.y + q.z * v.z;
		float x = tx * q.w + tw * q.x + ty * q.z - tz * q.y;
		float y = ty * q.w + tw * q.y + tz * q.x - tx * q.z;
		float z = tz * q.w + tw * q.z + tx * q.y - ty * q.x;
		return vec3(x, y, z);
	}

	// Given an origin and direction, computes the sampling start and end as distance from the origin in the direction.
	void getStartEndSamples(out float start, out float end, vec3 origin, vec3 direction, float maxDistance, float groundRadius, float atmosphereScaleHeight) {
		// Get the along the ray perpendicular to the sphere.
		float perpD = -dot(origin, direction);
		vec3 perp = origin + direction * perpD;

		// Figure out the sample distance.
		float atmosphereRadius = groundRadius + atmosphereScaleHeight * 6.0;
		float chordHalfLength = sqrt(max(0.0, atmosphereRadius * atmosphereRadius - dot(perp, perp)));

		// Figure out starting and ending sample points, and step distance.
		start = max(0.0, perpD - chordHalfLength);
		end = min(maxDistance, perpD + chordHalfLength);
	}

	// Gets the density of the atmosphere at a given position.
	float getDensity(vec3 position, float radius, float density, float atmosphereScaleHeight) {
		return density * exp(min(radius - length(position), 0.0) / atmosphereScaleHeight);
	}

	// Returns 0 if the ray does not intersect and 1.0 if the ray very intersects (with a gradient inbetween).
	float getDayLevel(vec3 origin, vec3 direction, float radius, float scaleHeight) {
		float blendHeight = scaleHeight * radius / 200.0;
		float perpD = -dot(origin, direction);
		float depth = radius - sqrt(dot(origin, origin) - sign(perpD) * perpD * perpD);
		if (depth < 0.0) { // day
			return 1.0 - max(0.0, 0.25 * depth / blendHeight + 0.25);
		}
		else { // night
			return 1.0 - min(1.0, 0.75 * depth / blendHeight + 0.25);
		}
	}

	float easeInOut(float x, float sharpness) {
		float b = sharpness;
		if (x < 0.5) {
			return max(0.0, (pow(b, 2.0 * x) - 1.0) / (2.0 * (b - 1.0)));
		}
		else {
			return min(1.0, 1.0 - (pow(b, 2.0 * (1.0 - x)) - 1.0) / (2.0 * (b - 1.0)));
		}
	}

	vec3 adjustOverbrightness(vec3 color) {
		float maxColor = max(color.r, max(color.g, color.b));
		if (maxColor > 1.0) {
			float f = (maxColor - 1.0) / maxColor;
			color.r = min(1.0, pow(color.r / maxColor, 1.0 / maxColor));
			color.g = min(1.0, pow(color.g / maxColor, 1.0 / maxColor));
			color.b = min(1.0, pow(color.b / maxColor, 1.0 / maxColor));
		}
		return color;
	}

	// Calculates a glow around the light direction (the star).
	float glow(float spread, float amount, float lightDotCamera) {
		return amount * spread / (1.0 + spread - lightDotCamera);
	}

	vec4 getEmissiveColor(float totalDensity, vec3 cameraPositionS, vec3 color, float emissivity) {

		// The color that will be added onto gl_FragColor.
		vec4 outColor;

		// Apply the total density to the transparency of the atmosphere.
		outColor.a = emissivity * clamp(totalDensity, 0.0, 1.0);

		// Multiply it all together with the source light color.
		outColor.rgb = emissivity * color * clamp(pow(15.0 * totalDensity / (density * equatorialRadius), 0.2), 0.75, 1.0);

		// Make it more opaque when lower down.
		outColor.a = mix(outColor.a, emissivity, getDensity(cameraPositionS, equatorialRadius + scaleHeight, 1.0, 2.0 * scaleHeight));

		// Clamp it to make it clean for the day/night transition.
		outColor.a = clamp(outColor.a, 0.0, 1.0);

		return outColor;
	}

	// Gets the color for an atmosphere for a light.
	vec4 getColor(float totalDensity, vec3 lightColor, vec3 lightPosition, float spheroidRatio, vec3 positionS, vec3 cameraPositionS, vec3 cameraToPositionUnit) {

		// The color starts out in full brightness (as if emissivity was 1.0).
		vec4 outColor = getEmissiveColor(totalDensity, cameraPositionS, lightColor * color, 1.0);

		// Make the alpha dependent on the brightness of the light.
		outColor.a *= length(lightColor) / sqrt(3.0);

		// Setup vectors.
		highp vec3 lightPositionS = quatRotInv(entityOrientation, lightPosition);
		lightPositionS.z *= spheroidRatio;
		highp vec3 lightToPosition = positionS - lightPositionS;
		highp vec3 lightToPositionUnit = normalize(lightToPosition / 1.0e8);

		// Get the day level, from 0 to 1, and apply it to the alpha. Lots of tricks to get it looking good on earth.
		vec3 dayRefUp = normalize(cameraPositionS - min(0.0, dot(cameraPositionS, cameraToPositionUnit)) * cameraToPositionUnit);
		float dayLevel = -dot(lightToPositionUnit, dayRefUp);
		outColor.rgb *= easeInOut(0.5 + 2.0 * dayLevel, 2.0);
		outColor.a *= easeInOut(1.0 + 2.0 * dayLevel, 2.0);

		// Brighten up the atmosphere when looking from space toward the sun.
		float lightDotCamera = max(0.0, -dot(lightToPositionUnit, cameraToPositionUnit));
		outColor.a = clamp(outColor.a * (1.0 + glow(0.004, 1.0, lightDotCamera)), 0.0, 1.0);

		// Add narrower sun glare.
		outColor.rgb *= lightColor * (1.0 + sunBrightness * outColor.a * glow(0.00004, 1.0, lightDotCamera));

		// Add broader sun glare.
		outColor.rgb *= lightColor * (1.0 + sunBrightness * outColor.a * glow(0.04, 0.125, lightDotCamera));

		// Apply the sunset.
		float lightDotHorizon = pow(clamp(1.0 - dot(lightToPositionUnit, dayRefUp), 0.0, 1.0), 2.0);
		float cameraDotHorizon = pow(clamp(1.0 - dot(cameraToPositionUnit, dayRefUp), 0.0, 1.0), 8.0);
		float sunsetAmount = sunsetIntensity * lightDotHorizon * cameraDotHorizon * glow(0.04, 0.5, lightDotCamera);
		outColor.rgb = mix(outColor.rgb, sunsetColor, clamp(sunsetAmount, 0.0, 1.0));

		return outColor;
	}

	void main(void) {
		// Convert everything into a sphere frame.
		float spheroidRatio = equatorialRadius / polarRadius;
		highp vec3 positionS = localPosition;
		highp vec3 cameraPositionS = cameraPosition;
		positionS.z *= spheroidRatio;
		cameraPositionS.z *= spheroidRatio;

		highp vec3 cameraToPosition = positionS - cameraPositionS;
		float cameraToPositionDist = length(cameraToPosition / 1.0e8) * 1.0e8;
		highp vec3 cameraToPositionUnit = cameraToPosition / cameraToPositionDist;

		// Get the start and end of the sampling from the camera to the position.
		float start;
		float end;
		getStartEndSamples(start, end, cameraPositionS, cameraToPositionUnit, 1.0e24, equatorialRadius, scaleHeight);
		float fracPerStep = 1.0 / float(numIterations - 1);
		float stepDist = fracPerStep * (end - start);

		// Do the sampling.
		float totalDensity = 0.0;
		float segmentStart = start;
		for (int j = 0; j < numIterations; j++) {
			// Get the distance that this segment covers.
			float segDist = stepDist;
			if (j == 0 || j == numIterations - 1) {
				segDist *= 0.5;
			}

			// Get the segment start that we're looking at.
			vec3 p = cameraPositionS + segmentStart * cameraToPositionUnit;

			// Get the density at that segment start. It'll be the density for the whole segment.
			float densityAtP = getDensity(p, equatorialRadius, density, scaleHeight);

			// Add it to the total density.
			totalDensity += densityAtP * segDist;

			// Next step.
			segmentStart += stepDist;
		}

		// Add emissivity lightness.
		gl_FragColor += getEmissiveColor(totalDensity, cameraPositionS, color, emissivity);

		// For each light,
		for (int i = 0; i < 5; i++) {
			if (i >= numLights) {
				break;
			}

			// If it's not a camera light,
			if (length(lightPositions[i]) > 0.0) {
				// Add on the color for the light.
				gl_FragColor += getColor(totalDensity, lightColors[i], lightPositions[i], spheroidRatio, positionS, cameraPositionS, cameraToPositionUnit);
			}
		}

		// Adjust for values that are greater than one.
		gl_FragColor.rgb = adjustOverbrightness(gl_FragColor.rgb);

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
	}`;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/base_component.js":
/*!****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/base_component.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseComponent": function() { return /* binding */ BaseComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The base class for all components.
 * */
class BaseComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.EntityItem {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The radius of the component.
		 * @type {number}
		 * @private
		 */
		this._radius = 0.5;

		/**
		 * The pixel-space radius of the component for each camera.
		 * @type {FastMap<CameraComponent, number>}
		 * @private
		 */
		this._pixelSpaceRadiusPerCamera = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The greatest pixel-space radius of the component in any camera.
		 * @type {number}
		 * @private
		 */
		this._greatestPixelSpaceRadius = 0.0;

		/**
		 * The load state of the component. It can be 'unloaded', 'loading', or 'loaded'.
		 * @type {'unloaded' | 'loading' | 'loaded'}
		 * @private
		 */
		this._loadState = 'unloaded';

		/**
		 * A flag that determines if the component should always be loaded, except if disabled.
		 * @type {boolean}
		 * @private
		 */
		this._forceLoaded = false;

		/**
		 * A callback that is called right after the mesh has been created and materials have been loaded.
		 * @type {() => any}
		 * @private
		 */
		this._resourcesLoadedCallback = null;

		/**
		 * A callback that is called right after the mesh is destroyed.
		 * @type {() => any}
		 * @private
		 */
		this._resourcesUnloadedCallback = null;

		/**
		 * A promise that resolves when the resources are loaded.
		 * @type {Promise<void>}
		 * @private
		 */
		this._loadedPromise = Promise.resolve();

		/**
		 * Camera exclusion list.
		 * @type {Set<CameraComponent>}
		 * @private
		 */
		this._excludedCameras = new Set();

		/**
		 * Whether or not the component is visible. It will still be enabled and run, just not render.
		 * @type {boolean}
		 * @private
		 */
		this._visible = true;

		/**
		 * The Three.js objects.
		 * @type {THREE.Object3D[]}
		 * @private
		 */
		this._threeJsObjects = [];

		/**
		 * The Three.js materials.
		 * @type {THREE.ShaderMaterial[]}
		 * @private
		 */
		this._threeJsMaterials = [];

		/**
		 * The flag that if true sets the root Three.js objects to have the same orientation as the entity.
		 * @type {boolean}
		 * @private
		 */
		this._usesEntityOrientation = false;
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @internal
	 */
	__destroy() {
		// Unload any resources used by the component.
		if (this._loadState === 'loaded') {
			this._unloadResources();
		}
		// Call the super.
		super.__destroy();
	}

	// ENABLED & DISABLED.

	/**
	 * Sets whether the component is enabled by the user. If false, __update and __prepareForRender will not run.
	 * Defaults to true.
	 * @param {boolean} enabled
	 * @override
	 */
	setEnabled(enabled) {
		super.setEnabled(enabled);
		this.__updateLoadState();
	}

	// RADIUS.

	/**
	 * Gets the radius of the component. No part of the component should be outside this.
	 * @returns {number}
	 */
	getRadius() {
		return this._radius;
	}

	/**
	 * Sets the radius of the component. No part of the component should be outside this. Defaults to 0.5;
	 * @param {number} radius
	 * @protected
	 */
	__setRadius(radius) {
		this._radius = radius;
	}

	/**
	 * Gets the pixel-space radius in a specific camera.
	 * @param {CameraComponent} camera
	 * @returns {number | undefined}
	 */
	getPixelSpaceRadiusInCamera(camera) {
		return this._pixelSpaceRadiusPerCamera.get(camera);
	}

	/**
	 * Gets the greatest pixel-space radius in all cameras.
	 * @returns {number}
	 */
	getGreatestPixelSpaceRadius() {
		return this._greatestPixelSpaceRadius;
	}

	// ACCESSING THREE.JS OBJECTS.

	/**
	 * Gets the Three.js objects. This includes any child objects.
	 * @returns {THREE.Object3D[]}
	 */
	getThreeJsObjects() {
		return this._threeJsObjects;
	}

	/**
	 * Gets the Three.js materials.
	 * @returns {THREE.ShaderMaterial[]}
	 */
	getThreeJsMaterials() {
		return this._threeJsMaterials;
	}

	/**
	 * Gets the first Three.js root or descendent that matches the name, or null if not found.
	 * @param {string} name
	 * @returns {THREE.Object3D | null}
	 */
	getThreeJsObjectByName(name) {
		for (let i = 0; i < this._threeJsObjects.length; i++) {
			const object = this._threeJsObjects[i];
			if (object.name === name) {
				return object;
			}
		}
		return null;
	}

	// LOADING AND UNLOADING OF RESOURCES.

	/**
	 * Returns the load state. It can be 'unloaded', 'loading', or 'loaded'.
	 * @returns {'unloaded' | 'loading' | 'loaded'}
	 */
	getLoadState() {
		return this._loadState;
	}

	/**
	 * Sets whether or not the component is always loaded, except if disabled. Defaults to false.
	 * @param {boolean} enabled
	 */
	setForceLoaded(enabled) {
		this._forceLoaded = enabled;
		if (this._forceLoaded && this._loadState === 'unloaded') {
			this._loadResources();
		}
	}

	/**
	 * Sets whether the component is visible. The __update function will run, but not the __prepareForRender function.
	 * Only called by Entity and BaseComponent.
	 * @internal
	 */
	__updateLoadState() {
		const entity = this.getEntity();
		const isEnabled = entity.isEnabled() && this.isEnabled();
		const isInTime = entity.isInPositionCoverage() && (entity.isInOrientationCoverage() || !this._usesEntityOrientation);

		// Create or destroy the rendering object based on the pixel-space radius.
		if ((isEnabled && (this._forceLoaded || (isInTime && this._greatestPixelSpaceRadius > 0.5))) && this._loadState === 'unloaded') {
			this._loadResources();
		}
		else if ((!isEnabled || (!this._forceLoaded && (!isInTime || this._greatestPixelSpaceRadius < 0.25))) && this._loadState === 'loaded') {
			this._unloadResources();
		}
	}

	/**
	 * Reloads the resources of the component. They will be loaded, if necessary, on the next __update().
	 */
	resetResources() {
		// If it was loading, set it to unloaded so any __loadResources function will stop.
		if (this._loadState === 'loading') {
			this._loadState = 'unloaded';
		}
		// Unload any loaded resources.
		else if (this._loadState === 'loaded') {
			this._unloadResources();
		}
	}

	/**
	 * Sets the callback that is called right after the resources have been loaded.
	 * @param {() => any} callback
	 */
	setResourcesLoadedCallback(callback) {
		this._resourcesLoadedCallback = callback;
	}

	/**
	 * Sets the callback that is called right after the resources are unloaded.
	 * @param {() => any} callback
	 */
	setResourcesUnloadedCallback(callback) {
		this._resourcesUnloadedCallback = callback;
	}

	/**
	 * Loads the Three.js objects, materials, and any other resources the component might need.
	 * @private
	 */
	_loadResources() {
		// Set the load state to loading.
		this._loadState = 'loading';
		// Load the resources via the user function and set the loaded promise.
		this._loadedPromise = this.__loadResources().then(() => {
			// If it has since been unloaded, unload and return.
			if (this._loadState !== 'loading') {
				this._unloadResources();
				return;
			}
			// Set the load state to loaded.
			this._loadState = 'loaded';
			// Call the callback.
			if (this._resourcesLoadedCallback !== null) {
				this._resourcesLoadedCallback();
			}
		});
	}

	/**
	 * Unloads any of the resources loaded by the component.
	 * @private
	 */
	_unloadResources() {
		// Unload the resources via the user function.
		this.__unloadResources();
		// Set the load state to unloaded.
		this._loadState = 'unloaded';
		// Clear the arrays.
		this._threeJsObjects = [];
		this._threeJsMaterials = [];
		// Call the callback.
		if (this._resourcesUnloadedCallback !== null) {
			this._resourcesUnloadedCallback();
		}
	}

	/**
	 * Loads the Three.js objects, materials, and any other resources the component might need.
	 * It should be implemented by subclasses and never called directly.
	 * It should populate the Three.js objects and materials arrays.
	 * @returns {Promise<void | void[]>}
	 * @protected
	 */
	__loadResources() {
		return Promise.resolve();
	}

	/**
	 * Unloads any of the resources loaded by the component.
	 * It should be implemented by subclasses and never called directly.
	 * It does not need to clear the Three.js objects and materials arrays.
	 * @protected
	 */
	__unloadResources() {
	}

	/**
	 * Gets a promise that resolves when the texture is loaded.
	 * @override
	 * @returns {Promise<void>}
	 */
	getLoadedPromise() {
		return this._loadedPromise;
	}

	// UPDATING

	/**
	 * Updates the camera-dependent parts of the component.
	 * @param {CameraComponent} camera - the camera being used in the render
	 * @abstract
	 */
	__updateCameraVariablesBase(camera) {
		// Get the viewport using the camera.
		const viewport = camera.getViewport();

		// Get the normal-space extents radius.
		const normalSpaceRadius = camera.getNormalSpaceRadiusFromRadius(this._radius, this.getEntity().getCameraSpacePosition(camera).magnitude());

		// Get the pixel-space extents radius.
		const pixelSpaceRadius = viewport.getPixelSpaceRadiusFromNormalSpaceRadius(normalSpaceRadius);
		this._pixelSpaceRadiusPerCamera.set(camera, pixelSpaceRadius);

		// Call the component's updateCameraVariables function.
		this.__updateCameraVariables(camera);
	}

	/**
	 * Updates the component.
	 * @internal
	 */
	__updateBase() {
		// Update the greatest pixel-space radius.
		this._greatestPixelSpaceRadius = 0.0;
		for (let i = 0, l = this._pixelSpaceRadiusPerCamera.size; i < l; i++) {
			const pixelSpaceRadius = this._pixelSpaceRadiusPerCamera.getAt(i).value;
			if (this._greatestPixelSpaceRadius < pixelSpaceRadius) {
				this._greatestPixelSpaceRadius = pixelSpaceRadius;
			}
		}

		this.__updateLoadState();

		// Call the component's update function.
		this.__update();
	}

	/**
	 * Updates the camera-dependent parts of the component. Only called by the Entity.
	 * @param {CameraComponent} camera - the camera being used in the render
	 * @abstract
	 */
	__prepareForRenderBase(camera) {
		// If the component has been loaded.
		if (this._loadState === 'loaded') {
			// If the component is not excluding this camera,
			if (!this._excludedCameras.has(camera) && this._visible) {
				// Make all objects visible.
				for (let i = 0; i < this._threeJsObjects.length; i++) {
					this._threeJsObjects[i].visible = true;
				}

				// Call the component's prepareForRender.
				this.__prepareForRender(camera);

				// Set the log-depth buffer uniforms, if they exist.
				for (let i = 0; i < this._threeJsMaterials.length; i++) {
					const uniforms = this._threeJsMaterials[i].uniforms;
					if (uniforms['invertDepth'] !== undefined) {
						uniforms['invertDepth'].value = camera.getInvertDepth();
						uniforms['nearDistance'].value = camera.getAutoNearDistance();
						uniforms['midDistance'].value = camera.getAutoMidDistance();
					}
				}

				// Update the matrix for the objects, since it isn't done automatically in Three.js (unset by a flag).
				for (let i = 0; i < this._threeJsObjects.length; i++) {
					this._threeJsObjects[i].updateMatrix();
				}
			}
			// If the component is excluded in this camera.
			else {
				// Make all objects invisible.
				for (let i = 0; i < this._threeJsObjects.length; i++) {
					this._threeJsObjects[i].visible = false;
				}
			}
		}
	}

	/**
	 * Updates the camera-dependent parts of the component.
	 * @param {CameraComponent} _camera - the camera being used in the render
	 * @abstract
	 */
	__updateCameraVariables(_camera) {
	}

	/**
	 * Updates the camera-dependent parts of the component. Implemented by the component.
	 * @param {CameraComponent} _camera
	 * @abstract
	 */
	__prepareForRender(_camera) {
	}

	/**
	 * Gets the flag that if true, the component uses the entity's orientation.
	 * @returns {boolean}
	 */
	getUsesEntityOrientation() {
		return this._usesEntityOrientation;
	}

	/**
	 * Sets the flag that if true sets the root Three.js objects to have the same orientation as the entity. Defaults to false.
	 * @param {boolean} enabled
	 * @protected
	 */
	__setUsesEntityOrientation(enabled) {
		this._usesEntityOrientation = enabled;
		this.__updateLoadState();
	}

	// VISIBILITY OF THREE.JS OBJECTS.

	/**
	 * Returns true if the component is currently excluded from the camera.
	 * @param {CameraComponent} camera
	 * @returns {boolean}
	 */
	isExcludedFromCamera(camera) {
		return this._excludedCameras.has(camera);
	}

	/**
	 * Sets whether the component is excluded from the camera. The default is false.
	 * @param {CameraComponent} camera
	 * @param {boolean} excluded
	 */
	setExcludedFromCamera(camera, excluded) {
		if (!excluded && this._excludedCameras.has(camera)) {
			this._excludedCameras.delete(camera);
		}
		else if (excluded && !this._excludedCameras.has(camera)) {
			this.__removeCameraDependents(camera);
			this._excludedCameras.add(camera);
		}
	}

	/**
	 * Returns true if the component is visible. It will still be enabled and run, just not render.
	 * @returns {boolean}
	 */
	isVisible() {
		return this._visible;
	}

	/**
	 * Sets whether or not the component is visible. It will still be enabled and run, just not render. Defaults to true.
	 * @param {boolean} visible
	 */
	setVisible(visible) {
		this._visible = visible;
	}

	/**
	 * Removes the camera from any camera-dependent variables. Called during camera clean up.
	 * @param {CameraComponent} camera
	 */
	__removeCameraDependentsBase(camera) {
		// Remove any camera-specific variables.
		this._pixelSpaceRadiusPerCamera.delete(camera);

		// Call the user-implemented function.
		this.__removeCameraDependents(camera);
	}

	/**
	 * Clears the camera from any camera-dependent variables. Called by entity when clearing its camera references.
	 * @internal
	 */
	__clearCameraDependentsBase() {
		// Clear any camera-specific variables.
		this._pixelSpaceRadiusPerCamera.clear();

		// Call the user-implemented function.
		this.__clearCameraDependents();
	}

	/**
	 * Removes the camera from any camera-dependent variables. Called during camera clean up.
	 * @param {CameraComponent} _camera
	 */
	__removeCameraDependents(_camera) {
	}

	/**
	 * Clears the camera from any camera-dependent variables. Called by entity when clearing its camera references.
	 * @internal
	 */
	__clearCameraDependents() {
	}

	// MISCELLANEOUS

	/**
	 * Converts the entity item to a nice string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		let typeIndex = 0;
		// Search the components for the type.
		for (let i = 0, l = this.getEntity().getNumComponents(); i < l; i++) {
			const component = this.getEntity().getComponent(i);
			if (this === component) {
				break;
			}
			if (this.getType() === component.getType()) {
				typeIndex += 1;
			}
		}
		return this.getEntity().getName() + '.' + this.getType() + '.' + typeIndex;
	}
}

/**
 * A temporary Three.js Quaternion.
 * @type {THREE.Quaternion}
 */
BaseComponent._tempThreeJsQuaternion = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Quaternion();


/***/ }),

/***/ "../pioneer/engine/src/scene/components/camera_component.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/camera_component.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CameraComponent": function() { return /* binding */ CameraComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Camera component. This is typically attached to a {@link Viewport}. The +y axis is forward, +x is right, and +z is up.
 */
class CameraComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The Three.js renderer.
		 * @type {THREE.WebGLRenderer}
		 * @protected
		 */
		this._threeJsRenderer = this.getEntity().getScene().getEngine().__getThreeJsRenderer();

		/**
		 * The viewport that is using this camera component.
		 * @type {Viewport}
		 * @private
		 */
		this._viewport = null;

		/**
		 * The three js scene.
		 * @type {THREE.Scene}
		 * @private
		 */
		this._threeJsScene = entity.getScene().getThreeJsScene();

		/**
		 * The field of view in radians.
		 * @type {number}
		 * @private
		 */
		this._fieldOfView = 1.0471975512;

		/**
		 * The near clipping plane distance in km.
		 * @type {number}
		 * @private
		 */
		this._nearDistance = undefined;

		/**
		 * Whether or not to invert the depth buffer.
		 * @type {number}
		 * @private
		 */
		this._invertDepth = 0;

		/**
		 * The near clipping plane distance in km.
		 * @type {number}
		 * @private
		 */
		this._autoNearDistance = 0.0;

		/**
		 * The z-buffer mid-point distance in km. Only used when frag-depth buffering isn't available.
		 * @type {number}
		 * @private
		 */
		this._midDistance = undefined;

		/**
		 * The automatically calculated z-buffer mid-point distance in km. Only used when frag-depth buffering isn't available and _midDistance is unefined.
		 * @type {number}
		 * @private
		 */
		this._autoMidDistance = 0.0;

		/**
		 * The aspect ratio given by the viewport.
		 * @type {number}
		 * @private
		 */
		this._aspectRatio = 1.0;

		/**
		 * The render size of the previous frame, used for comparing with this frame.
		 * @type {Vector2}
		 * @private
		 */
		this._renderSize = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		/**
		 * The list of entities which will occlude things like labels. Only things that are big enough on screen will be here.
		 * @type {Entity[]}
		 * @private
		 */
		this._occludingEntities = [];

		/**
		 * The three js camera.
		 * @type {THREE.PerspectiveCamera}
		 * @private
		 */
		this._threeJsCamera = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.PerspectiveCamera(75, this._aspectRatio, 0.1, 1000);

		/**
		 * The Three.js render pass composer.
		 * @type {ThreeJsEffectComposer}
		 * @private
		 */
		this._threeJsComposer = null;

		/**
		 * The Three.js outline pass.
		 * @type {ThreeJsOutlinePass}
		 * @private
		 */
		this._outlinePass = new _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsOutlinePass(undefined, this._threeJsScene, this._threeJsCamera, []);
		this._outlinePass.enabled = false;

		/**
		 * The Three.js unreal bloom pass.
		 * @type {ThreeJsUnrealBloomPass}
		 * @private
		 */
		this._threeJsUnrealBloomPass = new _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsUnrealBloomPass(undefined, 0, 0, 0);
		this._threeJsUnrealBloomPass.enabled = false;

		// Setup the pass composer.
		this.__setupEffectComposer();
	}

	// FIELDS OF VIEW

	/**
	 * Gets the viewport that is using this camera component.
	 * @returns {Viewport}
	 */
	getViewport() {
		return this._viewport;
	}

	/**
	 * Returns the field of view in radians. Defaults to PI / 3. The field of view is applied to the viewport axis (horizontal or vertical) that has the greatest length.
	 * @returns {number}
	 */
	getFieldOfView() {
		return this._fieldOfView;
	}

	/**
	 * Get the field of view in the horizontal direction. It will be less than or equal to the general field of view.
	 * @returns {number}
	 */
	getHorizontalFieldOfView() {
		if (this._aspectRatio >= 1) {
			return this._fieldOfView;
		}
		else {
			return 2.0 * Math.atan(Math.tan(this._fieldOfView / 2.0) * this._aspectRatio);
		}
	}

	/**
	 * Get the field of view in the vertical direction. It will be less than or equal to the general field of view.
	 * @returns {number}
	 */
	getVerticalFieldOfView() {
		if (this._aspectRatio > 1) {
			return 2.0 * Math.atan(Math.tan(this._fieldOfView / 2.0) / this._aspectRatio);
		}
		else {
			return this._fieldOfView;
		}
	}

	/**
	 * Sets the field of view in radians.
	 * @param {number} fieldOfView
	 */
	setFieldOfView(fieldOfView) {
		this._fieldOfView = fieldOfView;
	}

	// LOD-DEPTH BUFFERING VARIABLES

	/**
	 * Returns 1 if the depth is inverted, 0 otherwise.
	 * @returns {number}
	 */
	getInvertDepth() {
		return this._invertDepth;
	}

	/**
	 * Sets whether or not the depth is inverted. Use 1 to invert the depth, 0 otherwise.
	 * @param {number} invertDepth
	 */
	setInvertDepth(invertDepth) {
		this._invertDepth = invertDepth;
	}

	/**
	 * Returns the distance in km at which nothing closer gets rendered.
	 * @returns {number}
	 */
	getNearDistance() {
		return this._nearDistance;
	}

	/**
	 * Sets the distance in km at which nothing closer gets rendered. Set this to be greater for enhanced depth precision. If it is set to undefined, then it is auto set to 1% of the distance to the parent. The default is undefined.
	 * @param {number} nearDistance
	 */
	setNearDistance(nearDistance) {
		this._nearDistance = nearDistance;
	}

	/**
	 * Returns the auto near distance in km.
	 * @returns {number}
	 */
	getAutoNearDistance() {
		return this._autoNearDistance;
	}

	/**
	 * Returns the z-buffer mid-point distance in km. Only used when frag-depth buffering isn't available.
	 * @returns {number}
	 */
	getMidDistance() {
		return this._midDistance;
	}

	/**
	 * Sets the z-buffer mid-point distance in km. Only used when frag-depth buffering isn't available. If it is set to undefined, then it is auto set to the distance to the parent + 2 times the parent's radius. The default is undefined.
	 * @param {number} midDistance
	 */
	setMidDistance(midDistance) {
		this._midDistance = midDistance;
	}

	/**
	 * Returns the z-buffer mid-point distance in km. Only used when frag-depth buffering isn't available.
	 * @returns {number}
	 */
	getAutoMidDistance() {
		return this._autoMidDistance;
	}

	// CAMERA/NORMAL-SPACE CONVERSIONS

	/**
	 * Gets the normal-space position from a camera-space position.
	 * @param {Vector3} outNormalSpacePosition
	 * @param {Vector3} cameraSpacePosition
	 */
	getNormalSpacePositionFromCameraSpacePosition(outNormalSpacePosition, cameraSpacePosition) {
		const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		orientation.copy(this.getEntity().getOrientation());
		orientation.inverse(orientation);
		const rotatedCameraSpacePosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		rotatedCameraSpacePosition.rotate(orientation, cameraSpacePosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);

		outNormalSpacePosition.x = this._threeJsCamera.projectionMatrix.elements[0] * rotatedCameraSpacePosition.x / rotatedCameraSpacePosition.y;
		outNormalSpacePosition.y = this._threeJsCamera.projectionMatrix.elements[9] * rotatedCameraSpacePosition.z / rotatedCameraSpacePosition.y;
		outNormalSpacePosition.z = this._threeJsCamera.projectionMatrix.elements[6] + this._threeJsCamera.projectionMatrix.elements[14] / rotatedCameraSpacePosition.y;
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(rotatedCameraSpacePosition);
	}

	/**
	 * Gets the normal-space size (fraction of viewport) from a radius of a sphere and a distance to the camera.
	 * @param {number} radius - radius of object
	 * @param {number} distanceInCameraYDir - distance to camera of object along the camera's y axis.
	 * @returns {number}
	 */
	getNormalSpaceRadiusFromRadius(radius, distanceInCameraYDir) {
		return radius / Math.abs(distanceInCameraYDir) / Math.tan(this._fieldOfView / 2);
	}

	/**
	 * Gets the camera-space position from a normal-space position.
	 * @param {Vector3} outCameraSpacePosition
	 * @param {Vector3} normalSpacePosition
	 */
	getCameraSpacePositionFromNormalSpacePosition(outCameraSpacePosition, normalSpacePosition) {
		const rotatedCameraSpacePosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		rotatedCameraSpacePosition.y = this._threeJsCamera.projectionMatrix.elements[14] / (normalSpacePosition.z - this._threeJsCamera.projectionMatrix.elements[6]);
		rotatedCameraSpacePosition.x = normalSpacePosition.x * rotatedCameraSpacePosition.y / this._threeJsCamera.projectionMatrix.elements[0];
		rotatedCameraSpacePosition.z = normalSpacePosition.y * rotatedCameraSpacePosition.y / this._threeJsCamera.projectionMatrix.elements[9];

		outCameraSpacePosition.rotate(this.getEntity().getOrientation(), rotatedCameraSpacePosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(rotatedCameraSpacePosition);
	}

	/**
	 * Gets the camera/world-space size (fraction of viewport) from a radius of a sphere and a distance to the camera.
	 * @param {number} radius - normal-space radius of object
	 * @param {number} distanceInCameraYDir - distance to camera of object along the camera's y axis.
	 * @returns {number}
	 */
	getRadiusFromNormalSpaceRadius(radius, distanceInCameraYDir) {
		return radius * Math.abs(distanceInCameraYDir) * Math.tan(this._fieldOfView / 2);
	}

	// OCCLUSION

	/**
	 * Returns true if the camera-space position is occluded by any of the occluding entities.
	 * @param {Vector3} cameraSpacePosition
	 * @returns {boolean}
	 */
	isPositionOccluded(cameraSpacePosition) {
		for (let i = 0; i < this._occludingEntities.length; i++) {
			if (this._occludingEntities[i].isOccludingPosition(this, cameraSpacePosition)) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Find the nearest entity that intersects the ray form the camera to the camera-space position, or null if there is no such intersection.
	 * @param {Vector3} cameraSpacePosition
	 * @returns {Entity}
	 */
	getNearestIntersectingEntity(cameraSpacePosition) {
		let minDistance = Number.POSITIVE_INFINITY;
		let minEntity = null;
		const interval = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
		for (let i = 0; i < this._occludingEntities.length; i++) {
			const entityCameraSpacePosition = this._occludingEntities[i].getCameraSpacePosition(this);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(interval, cameraSpacePosition, entityCameraSpacePosition, this._occludingEntities[i].getOcclusionRadius());
			if (!Number.isNaN(interval.min) && interval.min >= 0) {
				const distance = interval.min * entityCameraSpacePosition.magnitude();
				if (distance < minDistance) {
					minDistance = distance;
					minEntity = this._occludingEntities[i];
				}
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(interval);
		return minEntity;
	}

	// POST-PROCESSING

	/**
	 * Sets the bloom value.
	 * @param {number} strength
	 */
	setBloom(strength) {
		this._threeJsUnrealBloomPass.enabled = (strength > 0);
		this._threeJsUnrealBloomPass.strength = strength;
	}

	/**
	 * Sets the outline pass. Works with any component that has implemented getThreeJsObjects(). If component is null, it is disabled.
	 * @param {Color} color
	 * @param {BaseComponent} component
	 * @param {string} [subObjectName='']
	 */
	setOutline(color, component, subObjectName) {
		this._outlinePass.enabled = (component !== null);
		if (component !== null) {
			if (subObjectName !== undefined) {
				const subObject = component.getThreeJsObjectByName(subObjectName);
				if (subObject === null) {
					throw new Error(`Could not set outline on component ${component} sub-object ${subObjectName}.`);
				}
				this._outlinePass.selectedObjects = [subObject];
			}
			else {
				const objects = component.getThreeJsObjects();
				this._outlinePass.selectedObjects = [];
				for (let i = 0, l = objects.length; i < l; i++) {
					if (objects[i].parent === this._threeJsScene) {
						this._outlinePass.selectedObjects.push(objects[i]);
					}
				}
			}
			this._outlinePass.visibleEdgeColor.setRGB(color.r, color.g, color.b);
			this._outlinePass.hiddenEdgeColor.setRGB(color.r / 4, color.g / 4, color.b / 4);
		}
		this.__setupEffectComposer();
	}

	// INTERNALS

	/**
	 * Add an entity to the list of occluding entities. This is called by the entity during its prepareForRender, and used by occlusion and intersection functions.
	 * @param {Entity} entity
	 * @internal
	 */
	__addToOccludingEntities(entity) {
		// Check to see if it already exists.
		for (let i = 0; i < this._occludingEntities.length; i++) {
			if (this._occludingEntities[i] === entity) {
				return;
			}
		}
		// If not, add it.
		this._occludingEntities.push(entity);
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @internal
	 */
	__destroy() {
		super.__destroy();

		// Remove any camera-dependent variables in the scene that reference this camera.
		this.getEntity().getScene().__removeCameraDependents(this);

		// If it has a viewport, unlink it.
		if (this._viewport !== null) {
			this._viewport.setCamera(null);
		}
	}

	/**
	 * Prepares the camera-dependent variables and those of its connected entities.
	 * @internal
	 */
	__updateCameraVariablesForConnectedScene() {
		// Update the aspect ratio.
		const renderSize = this._viewport.getBounds().size;
		if (!renderSize.equals(this._renderSize)) {
			const aspectRatio = renderSize.x / renderSize.y;
			if (this._aspectRatio !== aspectRatio) {
				this._aspectRatio = aspectRatio;
			}

			// Set the resolution of the render passes.
			this._threeJsComposer.setSize(renderSize.x, renderSize.y);
			this._renderSize.copy(renderSize);
		}

		// Set the auto mid-point distance, if necessary.
		if (this._midDistance === undefined) {
			if (this.getEntity().getParent() !== null) {
				this._autoMidDistance = this.getEntity().getPosition().magnitude() + this.getEntity().getParent().getExtentsRadius() * 10.0;
			}
		}
		else {
			this._autoMidDistance = this._midDistance;
		}

		// Set the near-point distance, if necessary.
		if (this._nearDistance === undefined) {
			if (this.getEntity().getParent() !== null) {
				this._autoNearDistance = Math.max(0.00001, (this.getEntity().getPosition().magnitude() - this.getEntity().getParent().getExtentsRadius()) * 0.01);
			}
			else {
				this._autoNearDistance = Math.max(0.00001, this.getEntity().getPosition().magnitude() * 0.01);
			}
		}
		else {
			this._autoNearDistance = this._nearDistance;
		}

		// Update the projection matrix.
		this._updateProjectionMatrix();

		// Update the camera-dependent variables of entities in the scene that are connected to the camera.
		this.getEntity().__updateCameraVariables(this, null, false);

		// Remove any objects that are too small visually from the occluding list.
		for (let i = 0; i < this._occludingEntities.length; i++) {
			if (this._occludingEntities[i].getPixelSpaceOcclusionRadius(this) < 1 || !this._occludingEntities[i].isEnabled() || !this._occludingEntities[i].canOcclude() || this.getEntity().getScene().get(this._occludingEntities[i].getName()) === null) {
				this._occludingEntities.splice(i, 1);
				i--;
			}
		}
	}

	/**
	 * Prepares the camera for rendering.
	 * @override
	 */
	__prepareForRender() {
		// Prepare each entity in the scene for rendering using this.
		const scene = this.getEntity().getScene();
		for (let i = 0; i < scene.getNumEntities(); i++) {
			const entity = scene.getEntity(i);
			if (entity.isEnabled()) {
				entity.__prepareForRender(this);
			}
		}

		// If there is a dynamic environment map component, render it first.
		const dynEnvMapComponent = /** @type {DynamicEnvironmentMapComponent} */(this.getEntity().get('dynEnvMap'));
		if (dynEnvMapComponent !== null) {
			dynEnvMapComponent.__render();
		}
	}

	/**
	 * Renders the camera. Called by Viewport.
	 * @internal
	 */
	__render() {
		// Set the camera's orientation.
		const orientation = this.getEntity().getOrientation();
		CameraComponent._tempThreeJsQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
		this._threeJsCamera.setRotationFromQuaternion(CameraComponent._tempThreeJsQuaternion);

		// Do the render!
		this._threeJsComposer.render();
	}

	/**
	 * Sets the viewport that is using this camera component. Only used by Viewport itself.
	 * @param {Viewport} viewport
	 * @internal
	 */
	__setViewport(viewport) {
		// Unlink from any previous other viewport.
		if (this._viewport !== null && this._viewport !== viewport) {
			this._viewport.setCamera(null);
		}

		this._viewport = viewport;
	}

	/**
	 * Updates the render targets and sets up the effect composer. Can be called multiple times when conditions change.
	 * @private
	 */
	__setupEffectComposer() {
		// Create the render target.
		const size = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2();
		this._threeJsRenderer.getSize(size);
		const renderTargetOptions = {
			samples: (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.isWebGL2() && !this._outlinePass.enabled) ? 4 : 0
		};
		const renderTarget = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(size.x, size.y, renderTargetOptions);
		if (this._threeJsComposer !== null) {
			this._threeJsComposer.reset(renderTarget);
		}
		else {
			// Create the Three.js effect composer.
			this._threeJsComposer = new _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsEffectComposer(this._threeJsRenderer, renderTarget);

			// Add the render passes.
			const renderPass = new _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsRenderPass(this._threeJsScene, this._threeJsCamera);
			this._threeJsComposer.addPass(renderPass);
			this._threeJsComposer.addPass(this._outlinePass);
			this._threeJsComposer.addPass(this._threeJsUnrealBloomPass);
		}
	}

	/**
	 * Updates the projection.
	 * @private
	 */
	_updateProjectionMatrix() {
		if (this._fieldOfView > 0 && this._fieldOfView < 180 && this._aspectRatio > 0) {
			const tanHalfFov = Math.tan(this._fieldOfView / 2);
			let sx = 0;
			let sz = 0;
			if (this._aspectRatio >= 1) {
				sx = 1 / tanHalfFov;
				sz = this._aspectRatio / tanHalfFov;
			}
			else {
				sx = 1 / (tanHalfFov * this._aspectRatio);
				sz = 1 / tanHalfFov;
			}
			const f1 = Number.EPSILON - 1.0;
			const f2 = this._autoNearDistance * (2.0 - Number.EPSILON);
			const projectionMatrix = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix4();
			projectionMatrix.set(
				sx, 0, 0, 0,
				0, 0, sz, 0,
				0, f1, 0, f2,
				0, 1, 0, 0);
			this._threeJsCamera.projectionMatrix = projectionMatrix;
			const projectionMatrixInverse = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix4();
			projectionMatrixInverse.set(
				1 / sx, 0, 0, 0,
				0, 0, 0, 1,
				0, 1 / sz, 0, 0,
				0, 0, 1 / f2, -f1 / f2);
			this._threeJsCamera.projectionMatrixInverse = projectionMatrixInverse;
		}
	}

	/**
	 * Required by BaseComponent, does nothing.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		return Promise.resolve();
	}

	/**
	 * Required by BaseComponent, does nothing.
	 * @override
	 * @protected
	 */
	__unloadResources() {
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/cmts_component.js":
/*!****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/cmts_component.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CMTSComponent": function() { return /* binding */ CMTSComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The CMTS component.
 */
class CMTSComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The ThreeJS scene.
		 * @type {THREE.Scene}
		 * @private
		 */
		this._threeJsScene = this.getEntity().getScene().getThreeJsScene();

		/**
		 * The end points for the texture names.
		 * @type {FastMap<string, { url: string, configuration: CMTSConfiguration }>}
		 * @private
		 */
		this._endPoints = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The height scale if a height texture is used.
		 * @type {number}
		 * @private
		 */
		this._heightScale = 1;

		/**
		 * The number of end points still loading.
		 * @type {number}
		 * @private
		 */
		this._numEndPointsLoading = 0;

		/**
		 * The minimum level to which the tiles must split.
		 * @type {number}
		 * @private
		 */
		this._minLevel = Number.NEGATIVE_INFINITY;

		/**
		 * The maximum level to which the tiles can split.
		 * @type {number}
		 * @private
		 */
		this._maxLevel = Number.POSITIVE_INFINITY;

		/**
		 * The tileOffsets in the CMTS.
		 * @type {Array<{offset: Vector3, face: number, level: number, min: Vector2, max: Vector2}>}
		 * @private
		 */
		this._tileOffsets = [];

		/**
		 * A factor that determines when to split the tiles. Higher means more splits.
		 * @type {number}
		 * @private
		 */
		this._splitJoinThresholdFactor = 512.0;

		/**
		 * The tile size of the color configuration.
		 * @type {number}
		 * @private
		 */
		this._colorTileSize = 512;

		/**
		 * The entities used for shadows. Derived from the shadow entity names.
		 * @type {EntityRef[]}
		 * @private
		 */
		this._shadowEntities = [];

		/**
		 * The downloader for easier future access.
		 * @private
		 */
		this._engine = this.getEntity().getScene().getEngine();

		/**
		 * The positions of all active cameras.
		 * @type {Vector3[]}
		 * @private
		 */
		this._cameraPositions = [];

		/**
		 * The fields of view of all active cameras.
		 * @type {number[]}
		 * @private
		 */
		this._cameraFieldsOfView = [];

		/**
		 * The root tile.
		 * @type {CMTSTile[]}
		 * @private
		 */
		this._rootTiles = [null, null, null, null, null, null];

		/**
		 * A promise that resolves when all tiles are no longer transitioning.
		 * @type {Promise<void>}
		 * @private
		 */
		this._tilesLoadedPromise = null;

		/**
		 * The callback that gets called when all tiles are no longer transitioning.
		 * @type {() => any}
		 * @private
		 */
		this._transitionsCompleteCallback = null;

		/**
		 * A cache of textures, one for each tile.
		 * @type {Cache<Promise<THREE.Texture>>}
		 * @private
		 */
		this._textureCache = new _internal__WEBPACK_IMPORTED_MODULE_0__.Cache((textureUrl) => {
			return this.getEntity().getScene().getEngine().getTextureLoader().loadTexture(textureUrl, true);
		}, (texturePromise) => {
			texturePromise.then((texture) => {
				texture.dispose();
			});
		});

		/**
		 * A counter that ensures that we don't do too many splits or joins at once.
		 * @type {number}
		 * @private
		 */
		this._numCurrentLoads = 0;

		/**
		 * Get the maximum number of loads that can happen at one time.
		 * @type {number}
		 * @private
		 */
		this._maxCurrentLoads = 10;

		/**
		 * A reference to the atmosphere component.
		 * @type {ComponentRef<AtmosphereComponent>}
		 * @private
		 */
		this._atmosphereComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._atmosphereComponentRef.setByType(this.getEntity().getName(), 'atmosphere');

		/**
		 * A reference to the spheroid component.
		 * @type {ComponentRef<SpheroidComponent>}
		 * @private
		 */
		this._spheroidComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid');
		this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this));

		// Bind the callbacks to this.
		this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this);

		// Lets the base component to check for valid orientation when determining whether this is visible.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Sets a base url for the CMTS protocol for a given texture.
	 * @param {string} textureName
	 * @param {string} endPoint
	 */
	setBaseUrl(textureName, endPoint) {
		this.resetResources();

		// Set the end point.
		this._endPoints.set(textureName, { url: endPoint, configuration: null });
	}

	/**
	 * Gets the height scale if a height texture is used.
	 * @returns {number}
	 */
	getHeightScale() {
		return this._heightScale;
	}

	/**
	 * Sets the height scale if a height texture is used.
	 * @param {number} heightScale
	 */
	setHeightScale(heightScale) {
		this._heightScale = heightScale;
		this.resetResources();
	}

	/**
	 * Gets the minimum level to which the tiles must split.
	 * @returns {number}
	 */
	getMinLevel() {
		return this._minLevel;
	}

	/**
	 * Sets the minimum level to which the tiles must split. Defaults to negative infinity.
	 * @param {number} minLevel
	 */
	setMinLevel(minLevel) {
		this._minLevel = minLevel;
	}

	/**
	 * Gets the maximum level to which the tiles can split.
	 * @returns {number}
	 */
	getMaxLevel() {
		return this._maxLevel;
	}

	/**
	 * Sets the maximum level to which the tiles can split. Defaults to positive infinity.
	 * @param {number} maxLevel
	 */
	setMaxLevel(maxLevel) {
		this._maxLevel = maxLevel;
	}

	/**
	 * Adds a tileOffset to the CMTS.
	 * @param {Vector3} offset
	 * @param {number} face
	 * @param {number} level
	 * @param {number} minX
	 * @param {number} minY
	 * @param {number} maxX
	 * @param {number} maxY
	 */
	addTileOffset(offset, face, level, minX, minY, maxX, maxY) {
		this._tileOffsets.push({ offset, face, level, min: new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(minX, minY), max: new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(maxX, maxY) });
		this.resetResources();
	}

	/**
	 * Removes a tileOffset from the CMTS.
	 * @param {number} face
	 * @param {number} level
	 * @param {number} minX
	 * @param {number} minY
	 * @param {number} maxX
	 * @param {number} maxY
	 */
	removeTileOffset(level, face, minX, minY, maxX, maxY) {
		for (let i = 0; i < this._tileOffsets.length; i++) {
			const tileOffset = this._tileOffsets[i];
			if (tileOffset.face === face && tileOffset.level === level && tileOffset.min.x === minX && tileOffset.min.y === minY && tileOffset.max.x === maxX && tileOffset.max.y === maxY) {
				this._tileOffsets.splice(i, 1);
				this.resetResources();
				return;
			}
		}
	}

	/**
	 * Gets the number of shadow entities. Can be used to enumerate the shadow entities.
	 * @returns {number}
	 */
	getNumShadowEntities() {
		return this._shadowEntities.length;
	}

	/**
	 * Returns the shadow entity or its name at the index.
	 * @param {number} index
	 * @returns {string | undefined}
	 */
	getShadowEntity(index) {
		return this._shadowEntities[index]?.getName();
	}

	/**
	 * Sets the shadow entities. Each element can be either the name of an entity or an entity itself.
	 * @param {string[]} shadowEntities
	 */
	setShadowEntities(shadowEntities) {
		this._shadowEntities = [];
		for (const shadowEntity of shadowEntities) {
			this._shadowEntities.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), shadowEntity));
		}
		const shadowEntitiesEnabled = (shadowEntities.length > 0);
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[i], 'shadowEntities', shadowEntitiesEnabled);
		}
	}

	/**
	 * Gets the frame-space position and height direction on the surface at the given frame-space position.
	 * Note that the height direction is not up with planetocentric coordinates.
	 * @param {Vector3} outPosition
	 * @param {Vector3} outHeightDir
	 * @param {Vector3} position
	 */
	getGroundPosition(outPosition, outHeightDir, position) {
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent === null) {
			outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			return;
		}
		// Get the position on the surface of the spheroid.
		const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		spheroidComponent.llaFromXYZ(lla, position);
		lla.alt = 0;
		spheroidComponent.xyzFromLLA(outPosition, lla);
		// Get the height direction.
		if (spheroidComponent.isPlanetographic()) {
			spheroidComponent.upFromLLA(outHeightDir, lla);
		}
		else {
			outHeightDir.normalize(position);
		}
		// If there is height data, add on the height.
		const heightEndPoint = this._endPoints.get('height');
		if (heightEndPoint !== undefined) {
			// Get the position is in "sphere" space and get the cmts coord uvFace.
			const uvFace = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const posOnSphere = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			lla.alt = 1;
			_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getXYZFromLLAOnSphere(posOnSphere, lla, 0);
			_internal__WEBPACK_IMPORTED_MODULE_0__.CubeMap.xyzToUVFace(uvFace, posOnSphere);
			// Get the corresponding root tile.
			let tile = this._rootTiles[uvFace.z];
			// Check if it is a valid tile.
			if (tile === undefined || tile === null) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posOnSphere);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(uvFace);
				_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
				return;
			}
			// Get the lowest level tile that the uv is within and has height data.
			while (tile.children.length > 0) {
				const levelFactor = 1 << (tile.getLevel() + 1);
				const xTile = Math.floor(uvFace.x * levelFactor - tile.getTileCoord().x * 2);
				const yTile = Math.floor(uvFace.y * levelFactor - tile.getTileCoord().y * 2);
				tile = tile.children[yTile * 2 + xTile];
			}
			while (tile.getHeightData() === null && tile.getParent() !== null) {
				tile = tile.getParent();
			}
			// Get the height within that tile.
			const heightData = tile.getHeightData();
			if (heightData !== null) {
				const levelFactor = 1 << tile.getLevel();
				const pixelX = (uvFace.x * levelFactor - tile.getTileCoord().x) * (heightData.width - 4) + 2;
				const pixelY = (1 - (uvFace.y * levelFactor - tile.getTileCoord().y)) * (heightData.width - 4) + 2;
				const height = CMTSTile.getLinearInterpolatedHeightPixel(pixelX, pixelY, heightData.data, heightData.width);
				// Get the new height offset and scale.
				const configuration = heightEndPoint.configuration;
				const heightOffset = configuration['height_range'].min * this._heightScale;
				const heightScale = (configuration['height_range'].max - configuration['height_range'].min) * this._heightScale;
				// Set the height and convert back to xyz.
				lla.alt = heightOffset + height * heightScale;
				spheroidComponent.xyzFromLLA(outPosition, lla);
			}
			// Cleanup.
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posOnSphere);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(uvFace);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
	}

	/**
	 * Returns true if tiles are all loaded.
	 * @returns {boolean}
	 */
	areTilesLoaded() {
		return this._tilesLoadedPromise === null;
	}

	/**
	 * Returns a promise when no more tiles are loading.
	 * @returns {Promise<void>}
	 */
	getTilesLoadedPromise() {
		return this._tilesLoadedPromise ?? Promise.resolve();
	}

	/**
	 * Sets the reference to use for the spheroid component, by name or the type index.
	 * @param {string | number} nameOrTypeIndex
	 */
	setSpheroidReference(nameOrTypeIndex) {
		if (typeof nameOrTypeIndex === 'string') {
			this._spheroidComponentRef.setByName(this.getEntity().getName(), nameOrTypeIndex);
		}
		else {
			this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid', nameOrTypeIndex);
		}
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @internal
	 */
	__destroy() {
		// Remove the spheroid changed callback.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			spheroidComponent.removeChangedCallback(this._spheroidChangedCallback);
		}

		super.__destroy();
	}

	/**
	 * Updates the component.
	 * @override
	 * @internal
	 */
	__update() {
		// Update the spheroid component reference.
		this._spheroidComponentRef.update();

		// If the end points are not loaded, there's nothing more to do.
		if (this.getLoadState() !== 'loaded' || this._spheroidComponentRef.get() === null) {
			return;
		}

		if (this._rootTiles[0] === null) {
			if (this._numEndPointsLoading === 0) {
				// Create the root tiles to start.
				for (let face = 0; face < 6; face++) {
					this._rootTiles[face] = new CMTSTile(this, null, face, 0, new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0));
					this._rootTiles[face].forceLoad();
				}
			}
			else {
				return;
			}
		}

		// Set to true if any tile or configuration is still loading or unloading.
		let transitioning = false;

		// Get the positions of all cameras as lat, lon, alt in the frame of the spheroid.
		while (this._cameraPositions.length > this._engine.getNumViewports()) {
			this._cameraPositions.pop();
			this._cameraFieldsOfView.pop();
		}
		while (this._cameraPositions.length < this._engine.getNumViewports()) {
			this._cameraPositions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3());
			this._cameraFieldsOfView.push(1);
		}
		for (let i = 0, l = this._engine.getNumViewports(); i < l; i++) {
			const cameraPosition = this._cameraPositions[i];
			const cameraComponent = this._engine.getViewport(i).getCamera();
			cameraComponent.getEntity().getPositionRelativeToEntity(cameraPosition, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity());
			cameraPosition.rotateInverse(this.getEntity().getOrientation(), cameraPosition);
			this._cameraFieldsOfView[i] = cameraComponent.getFieldOfView();
		}

		// Do the update on all of the tiles recursively.
		// If any tile is still transitioning, set transitioning to true.
		for (let face = 0; face < 6; face++) {
			transitioning = this._rootTiles[face].update() || transitioning;
		}

		// If there is no current promise (there were no tiles or configuration transitioning) and now there are,
		// Create the loaded promise and record its resolve callback.
		if (this._tilesLoadedPromise === null && transitioning) {
			this._tilesLoadedPromise = new Promise((resolve) => {
				this._transitionsCompleteCallback = resolve;
			});
		}

		// If the loaded promise callback exists and we're no longer transitioning,
		// Clear the loaded promise and callback and call the callback (the resolve function of the promise).
		if (this._tilesLoadedPromise !== null && !transitioning) {
			const callback = this._transitionsCompleteCallback;
			this._tilesLoadedPromise = null;
			this._transitionsCompleteCallback = null;
			callback();
		}
	}

	/**
	 * Prepares the component for render.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		if (this._rootTiles[0] === null) {
			return;
		}

		// Set the orientation to the entity's orientation.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects(), this.getEntity());

		// Prepare the root tiles for rendering.
		for (let face = 0; face < 6; face++) {
			this._rootTiles[face].prepareForRender(camera);
		}

		// Get the atmosphere.
		const atmosphere = this._atmosphereComponentRef.get();

		// Setup the regular uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setUniforms(this.getThreeJsMaterials(), camera, this.getEntity(), this._shadowEntities, atmosphere, true);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void[]>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		/** @type {Array<Promise<void>>} */
		const promises = [];
		for (let i = 0, l = this._endPoints.size; i < l; i++) {
			const entry = this._endPoints.getAt(i);
			const endPoint = entry.value.url;
			// Load the end point.
			this._numEndPointsLoading += 1;
			const promise = this.getEntity().getScene().getEngine().getDownloader().download(endPoint + '/configuration.json', false).then((download) => {
				if (download.status === 'failed') {
					throw new Error('Failed to download ' + endPoint + '/configuration.json');
				}
				if (download.status === 'completed' && typeof download.content === 'string') {
					const configuration = /** @type {CMTSConfiguration} */(JSON.parse(download.content));
					entry.value.configuration = configuration;
					if (entry.key === 'color') {
						this._colorTileSize = configuration.tile_size;
					}
					this._numEndPointsLoading -= 1;
				}
			});
			promises.push(promise);
		}

		// Return promise that resolves when all end points have been loaded.
		return Promise.all(promises);
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		for (let face = 0; face < 6; face++) {
			if (this._rootTiles[face] !== null) {
				this._rootTiles[face].destroy();
			}
		}
		this._rootTiles = [null, null, null, null, null, null];
	}

	/**
	 * Gets the number of loads currently happening.
	 * @returns {number}
	 * @internal
	 */
	__getNumCurrentLoads() {
		return this._numCurrentLoads;
	}

	/**
	 * Increments the number of loads currently happening. Used by CMTSTile.
	 * @internal
	 */
	__incNumCurrentLoads() {
		this._numCurrentLoads += 1;
	}

	/**
	 * Decrements the number of loads currently happening. Used by CMTSTile.
	 * @internal
	 */
	__decNumCurrentLoads() {
		this._numCurrentLoads -= 1;
	}

	/**
	 * Gets the maximum number of loads that can happen. Used by CMTSTile.
	 * @internal
	 */
	__getMaxCurrentLoads() {
		return this._maxCurrentLoads;
	}

	/**
	 * Gets the end points.
	 * @returns {FastMap<string, { url: string, configuration: CMTSConfiguration }>}
	 * @internal
	 */
	__getEndPoints() {
		return this._endPoints;
	}

	/**
	 * Returns true if thare are no end points loading.
	 * @returns {boolean}
	 * @internal
	 */
	__endPointsAreLoaded() {
		return this._numEndPointsLoading === 0;
	}

	/**
	 * Gets the tileOffsets. Used by CMTSTile.
	 * @returns {Array<{offset: Vector3, face: number, level: number, min: Vector2, max: Vector2}>}
	 * @internal
	 */
	__getTileOffsets() {
		return this._tileOffsets;
	}

	/**
	 * Gets the texture cache. Used by CMTSTile.
	 * @returns {Cache<Promise<THREE.Texture>>}
	 * @internal
	 */
	__getTextureCache() {
		return this._textureCache;
	}

	/**
	 * Gets the camera positions. Used by CMTSTile.
	 * @returns {Vector3[]}
	 * @internal
	 */
	__getCameraPositions() {
		return this._cameraPositions;
	}

	/**
	 * Gets the camera fields of view. Used by CMTSTile.
	 * @returns {number[]}
	 * @internal
	 */
	__getCameraFieldsOfView() {
		return this._cameraFieldsOfView;
	}

	/**
	 * Gets the Three.js scene. Used by CMTSTile.
	 * @returns {THREE.Scene}
	 * @internal
	 */
	__getThreeJsScene() {
		return this._threeJsScene;
	}

	/**
	 * Gets the split/join threshold factor.
	 * @returns {number}
	 * @internal
	 */
	__getSplitJoinThresholdFactor() {
		return this._splitJoinThresholdFactor;
	}

	/**
	 * Gets the tile size of the color configuration.
	 * @returns {number}
	 * @internal
	 */
	__getColorTileSize() {
		return this._colorTileSize;
	}

	/*
	 * Gets the spheroid component this is using. Used by Tile.
	 * @returns {SpheroidComponent}
	 * @package
	 */
	__getSpheroidComponent() {
		return this._spheroidComponentRef.get();
	}

	/**
	 * Callback called when the spheroid reference is found or lost.
	 * @param {SpheroidComponent} oldRef
	 * @param {SpheroidComponent} newRef
	 * @private
	 */
	_spheroidRefChangedCallback(oldRef, newRef) {
		if (oldRef !== null) {
			oldRef.removeChangedCallback(this._spheroidChangedCallback);
		}
		if (newRef !== null) {
			newRef.addChangedCallback(this._spheroidChangedCallback);
		}
		this._spheroidChangedCallback();
	}

	/**
	 * Callback to be called when the spheroid component changed.
	 * @private
	 */
	_spheroidChangedCallback() {
		// Set the radii uniforms.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			this.__setRadius(Math.max(spheroidComponent.getEquatorialRadius(), spheroidComponent.getPolarRadius()));
		}
		else {
			this.__setRadius(0);
		}
		this.resetResources();
	}
}

/**
 * A single tile with mesh, material, and bounds.
 * @extends Tile<CMTSTile>
 * @private
 */
class CMTSTile extends _internal__WEBPACK_IMPORTED_MODULE_0__.Tile {
	/**
	 * Constructor.
	 * @param {CMTSComponent} component
	 * @param {CMTSTile} parent
	 * @param {number} face
	 * @param {number} level
	 * @param {Vector2} tile
	 */
	constructor(component, parent, face, level, tile) {
		super(parent);

		/**
		 * The CMTS component.
		 * @type {CMTSComponent}
		 * @private
		 */
		this._component = component;

		/**
		 * The face.
		 * @type {number}
		 * @private
		 */
		this._face = face;

		/**
		 * The level.
		 * @type {number}
		 * @private
		 */
		this._level = level;

		/**
		 * The level exponential factor.
		 * @type {number}
		 * @private
		 */
		this._levelPow = Math.pow(2, -Math.max(0, level));

		/**
		 * The tile coordinates.
		 * @type {Vector2}
		 * @private
		 */
		this._tile = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		this._tile.copy(tile);

		/**
		 * True if this can't be split any more.
		 * @type {boolean}
		 * @private
		 */
		this._isLeaf = true;

		/**
		 * The center of the tile's surface, for distance checking.
		 * @type {Vector3}
		 * @private
		 */
		this._center = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * The "radius", the distance from the center to one of the corners, for distance checking.
		 * @type {number}
		 * @private
		 */
		this._radius = 0;

		/**
		 * The material used by the tile.
		 * @type {THREE.ShaderMaterial}
		 * @private
		 */
		this._threeJsMaterial = null;

		/**
		 * Gets the level to which the texture belongs for the given texture name.
		 * @type {FastMap<string, number>}
		 * @private
		 */
		this._textureLevels = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * Gets the texture promises that are aquired from the texture cache.
		 * @type {FastMap<string, Promise<THREE.Texture>>}
		 * @private
		 */
		this._texturePromises = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * A flag that says whether or not one of the non-positive textures is loading.
		 * @type {boolean}
		 * @private
		 */
		this._nonPositiveTextureLoading = false;

		/**
		 * The Three.js object of the tile.
		 * @type {THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial | THREE.ShaderMaterial[]>}
		 * @private
		 */
		this._threeJsObject = null;

		/**
		 * The height data if it exists.
		 * @type {ImageData}
		 * @private
		 */
		this._heightData = null;

		/**
		 * The tile offset. The vertices will use this as their origin.
		 * @type {Vector3}
		 * @private
		 */
		this._tileOffset = this._getTileOffset();

		// Check if this tile is a leaf.
		for (let y = 0; y < 2; y++) {
			for (let x = 0; x < 2; x++) {
				for (let i = 0; i < this._component.__getEndPoints().size; i++) {
					const configuration = this._component.__getEndPoints().getAt(i).value.configuration;
					this._isLeaf = this._isLeaf && !CMTSTile._isInABoundary(configuration, this._face, this._level + 1, new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(this._tile.x * 2 + x, this._tile.y * 2 + y));
				}
			}
		}

		// Get the spheroid component.
		const spheroidComponent = component.__getSpheroidComponent();

		// Calculate the center.
		CMTSTile.cmtsCoordToPosition(this._center, this._face, this._levelPow, this._tile.x + 0.5, this._tile.y + 0.5, spheroidComponent);

		// Calculate the radius by getting the distance between the center and the origin point.
		const origin1 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const origin2 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const origin3 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const origin4 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		CMTSTile.cmtsCoordToPosition(origin1, this._face, this._levelPow, this._tile.x, this._tile.y, spheroidComponent);
		CMTSTile.cmtsCoordToPosition(origin2, this._face, this._levelPow, this._tile.x + 1, this._tile.y, spheroidComponent);
		CMTSTile.cmtsCoordToPosition(origin3, this._face, this._levelPow, this._tile.x + 1, this._tile.y + 1, spheroidComponent);
		CMTSTile.cmtsCoordToPosition(origin4, this._face, this._levelPow, this._tile.x, this._tile.y + 1, spheroidComponent);
		origin1.sub(this._center, origin1);
		origin2.sub(this._center, origin2);
		origin3.sub(this._center, origin3);
		origin4.sub(this._center, origin4);
		this._radius = Math.max(origin1.magnitude(), origin2.magnitude(), origin3.magnitude(), origin4.magnitude());

		// Figure out which texture levels this uses. It may use a texture from a higher level if a texture doesn't exist at this level.
		const endPoints = this._component.__getEndPoints();
		for (let i = 0; i < endPoints.size; i++) {
			const textureName = endPoints.getAt(i).key;
			const endPoint = endPoints.getAt(i).value;

			// If we're at level 0, check for non-positive levels.
			const nonPositiveLevel = this._level === 0 ? this._getNonPositiveLevel(textureName) : 0;

			if (CMTSTile._isInABoundary(endPoint.configuration, this._face, this._level, this._tile)) {
				const textureLevel = this._level === 0 ? nonPositiveLevel : this._level;
				// Set the material's level for the texture name to this level.
				this._textureLevels.set(textureName, textureLevel);
			}
			else {
				let ancestor = this.getParent();
				while (ancestor !== null && ancestor._level !== ancestor._textureLevels.getAt(i).value) {
					ancestor = ancestor.getParent();
				}
				if (ancestor !== null) { // It found an ancestor, so use that texture for this tile.
					this._textureLevels.set(textureName, ancestor._textureLevels.getAt(i).value);
				}
				else { // There's no coverage for this tile all the way up to the top, so just set it to 0.
					this._textureLevels.set(textureName, 0);
				}
			}
		}
	}

	/**
	 * Gets the level.
	 * @returns {number}
	 */
	getLevel() {
		return this._level;
	}

	/**
	 * Gets the tile coords.
	 * @returns {Vector2}
	 */
	getTileCoord() {
		return this._tile;
	}

	/**
	 * Gets the height data, if any.
	 * @returns {ImageData | null}
	 */
	getHeightData() {
		return this._heightData;
	}

	/**
	 * @param {CMTSTile} parent
	 * @param {number} row - 0 or 1
	 * @param {number} col - 0 or 1
	 * @returns {CMTSTile}
	 * @override
	 */
	createNewTile(parent, row, col) {
		const level = this._level + 1;
		const tile = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(parent._tile.x * 2 + col, parent._tile.y * 2 + row);
		return new CMTSTile(parent._component, this, this._face, level, tile);
	}

	/**
	 * Returns true if this tile should be split.
	 * @returns {boolean}
	 * @override
	 */
	checkSplit() {
		// Don't split if we're a leaf or at the maximum level of detail.
		if (this._isLeaf || this._level >= this._component.getMaxLevel()) {
			return false;
		}
		if (this._component.__getNumCurrentLoads() >= this._component.__getMaxCurrentLoads()) {
			return false;
		}
		// Always split if we're below the minimum level of detail.
		if (this._level < this._component.getMinLevel()) {
			return true;
		}
		// Get the pixel size, used to determine how much we should split.
		const tilePixelSize = this._component.__getColorTileSize();
		// Split if the nearest camera distance is less than the threshold.
		return this._getNearestDistance() < this._component.__getSplitJoinThresholdFactor() * this._radius / tilePixelSize;
	}

	/**
	 * Returns true if this tile should join its children.
	 * @returns {boolean}
	 * @override
	 */
	checkJoin() {
		// Always join is we're above the maximum level of detail.
		if (this._level >= this._component.getMaxLevel()) {
			return true;
		}
		if (this._component.__getNumCurrentLoads() >= this._component.__getMaxCurrentLoads()) {
			return false;
		}
		// Never join if we're at or below the minimum level of detail.
		if (this._level < this._component.getMinLevel()) {
			return false;
		}
		// Get the pixel size, used to determine how much we should split.
		const tilePixelSize = this._component.__getColorTileSize();
		// Check if the nearest camera distance is greater than the threshold.
		return this._getNearestDistance() > this._component.__getSplitJoinThresholdFactor() * this._radius / tilePixelSize * 4;
	}

	/**
	 * Asynchronously loads the tile so that it may be used.
	 * @returns {Promise<void | void[]>}
	 * @override
	 */
	async load() {
		// Increment the number of loads so we don't have too many concurrent loads.
		this._component.__incNumCurrentLoads();

		if (this._threeJsMaterial !== null) {
			this._component.__decNumCurrentLoads();
			throw new Error('Tile already has material.');
		}

		// Get a material from the component's materials cache.
		this._threeJsMaterial = _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.get();
		this._component.getThreeJsMaterials().push(this._threeJsMaterial);
		this._threeJsMaterial.defines['shadowEntities'] = (this._component.getNumShadowEntities() > 0);
		// this._threeJsMaterial.wireframe = true;
		// this._threeJsMaterial.defines['baseColor'] = true;
		// this._threeJsMaterial.uniforms['color'].value.setRGB(0.25 + 0.75 * Math.random(), 0.25 + 0.75 * Math.random(), 0.25 + 0.75 * Math.random());

		const endPoints = this._component.__getEndPoints();
		// A list of promises that will be returned by load.
		const loadPromises = [];
		for (let i = 0; i < endPoints.size; i++) {
			const textureName = endPoints.getAt(i).key;
			const endPoint = endPoints.getAt(i).value;
			let texturePromise = /** @type {Promise<THREE.Texture>} */(null);
			const textureLevel = this._textureLevels.get(textureName);
			const tileX = this._tile.x >> (this._level - textureLevel);
			const tileY = this._tile.y >> (this._level - textureLevel);
			// Form the URL from the end point and the tile params.
			const textureUrl = endPoint.url + '/' + this._face + '/' + textureLevel + '/' + tileX + '/' + tileY + '.' + endPoint.configuration.extension;
			// Do the loading of the texture.
			texturePromise = this._component.__getTextureCache().get(textureUrl);
			this._texturePromises.set(textureName, texturePromise);
			loadPromises.push(texturePromise.then((texture) => {
				this._setTexture(textureName, texture);
			}).catch(async () => { // There was an error, so just set it to pink.
				this._component.__getTextureCache().release(texturePromise);
				texturePromise = this._component.__getTextureCache().get('pink');
				const texture = await texturePromise;
				this._setTexture(textureName, texture);
			}));
		}
		return Promise.all(loadPromises).finally(() => {
			this._component.__decNumCurrentLoads();
		});
	}

	/**
	 * Asynchronously unloads the tile.
	 * @returns {Promise<void>}
	 * @override
	 */
	async unload() {
		if (this._threeJsMaterial === null) {
			throw new Error('Tile has no material to unload.');
		}
		// Remove up the material from the materials list.
		const materials = this._component.getThreeJsMaterials();
		for (let i = 0, l = materials.length; i < l; i++) {
			if (materials[i] === this._threeJsMaterial) {
				materials.splice(i, 1);
				break;
			}
		}
		// Dispose of the material.
		this._threeJsMaterial.dispose();
		this._threeJsMaterial = null;
		// Clean up the texture.
		for (let i = 0; i < this._texturePromises.size; i++) {
			this._component.__getTextureCache().release(this._texturePromises.getAt(i).value);
		}
	}

	/**
	 * Asynchronously activates the tile.
	 * @returns {Promise<void>}
	 * @override
	 */
	async activate() {
		if (this._threeJsObject !== null || this._threeJsMaterial === null) {
			throw new Error('NULL');
		}
		// Setup the attributes, depending on the types of data and textures available.
		const attributes = [
			{ name: 'position', dimensions: 3 },
			{ name: 'normal', dimensions: 3 },
			{ name: 'uv', dimensions: 2 }
		];
		const hasNormalTexture = this._textureLevels.has('normal');
		if (hasNormalTexture) {
			attributes.push({ name: 'tangent', dimensions: 3 });
			attributes.push({ name: 'bitangent', dimensions: 3 });
		}
		for (let i = 0; i < this._textureLevels.size; i++) {
			const textureName = this._textureLevels.getAt(i).key;
			if (textureName !== 'color' && textureName !== 'height') {
				attributes.push({ name: textureName + 'UV', dimensions: 2 });
			}
		}
		// Create the Three.js object.
		this._threeJsObject = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this._component, this._threeJsMaterial, attributes, false);
		this._component.getThreeJsObjects().push(this._threeJsObject);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.useInDynEnvMap(this._threeJsObject, true);

		this._setupMesh();
	}

	/**
	 * Asynchronously deactivates the tile.
	 * @returns {Promise<void>}
	 * @override
	 */
	async deactivate() {
		// Remove the object from the objects list.
		const objects = this._component.getThreeJsObjects();
		for (let i = 0, l = objects.length; i < l; i++) {
			if (objects[i] === this._threeJsObject) {
				objects.splice(i, 1);
				break;
			}
		}
		// Destroy the object and its geometry.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyObject(this._threeJsObject);
		this._threeJsObject = null;
	}

	/**
	 * Updates the tiles recursively. Returns true if the tile or any descendant is transitioning.
	 * @returns {boolean}
	 */
	update() {
		if (!this._component.__endPointsAreLoaded()) {
			return false;
		}
		let transitioning = this.check();
		for (let i = 0, l = this.children.length; i < l; i++) {
			transitioning = this.children[i].update() || transitioning;
		}

		// If we're at the root level and it's loaded, see if we need to change to a negative level texture.
		if (!transitioning && !this._nonPositiveTextureLoading && this._level === 0 && this.children.length === 0) {
			const endPoints = this._component.__getEndPoints();
			for (let i = 0; i < endPoints.size; i++) {
				const textureName = endPoints.getAt(i).key;
				const endPoint = endPoints.getAt(i).value;
				const textureLevel = this._getNonPositiveLevel(textureName);
				if (textureLevel !== this._textureLevels.get(textureName)) {
					this._nonPositiveTextureLoading = true;
					this._textureLevels.set(textureName, textureLevel);
					transitioning = true;
					// Form the URL from the end point and the tile params.
					const textureUrl = endPoint.url + '/' + this._face + '/' + textureLevel + '/0/0.' + endPoint.configuration.extension;
					// Save the previous texture promise.
					const prevTexturePromise = this._texturePromises.get(textureName);
					// Do the loading of the texture.
					let texturePromise = this._component.__getTextureCache().get(textureUrl);
					this._texturePromises.set(textureName, texturePromise);
					texturePromise.then((texture) => {
						this._setTexture(textureName, texture);
						this._setupMesh();
						this._nonPositiveTextureLoading = false;
					}).catch(async () => { // There was an error, so just set it to pink.
						this._component.__getTextureCache().release(texturePromise);
						texturePromise = this._component.__getTextureCache().get('pink');
						const texture = await texturePromise;
						this._setTexture(textureName, texture);
						this._nonPositiveTextureLoading = false;
					}).finally(() => {
						// Now that the new texture is loaded, release the previous texture.
						if (textureName !== 'height') {
							this._component.__getTextureCache().release(prevTexturePromise);
						}
					});
				}
			}
		}
		transitioning = this._nonPositiveTextureLoading || transitioning;

		return transitioning;
	}

	_setupMesh() {
		// Get the pixel tab, used to make mesh tabs.
		const tilePixelSize = this._component.__getColorTileSize();

		// Since there is one set of UVs per texture name, we have to set them up here.
		/** @type {FastMap<string, Float32Array>} */
		const meshUVs = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();
		/** @type {FastMap<string, Vector2>} */
		const uvOffsets = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();
		/** @type {FastMap<string, Vector2>} */
		const uvScales = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();
		for (let i = 0; i < this._textureLevels.size; i++) {
			const textureName = this._textureLevels.getAt(i).key;
			// Calculate the uv bounds, since it may be using a material from a different level.
			const levelFactor = 1 << (this._level - Math.max(0, this._textureLevels.get(textureName)));
			uvOffsets.set(textureName, new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(
				(this._tile.x - Math.floor(this._tile.x / levelFactor) * levelFactor) / levelFactor,
				(this._tile.y - Math.floor(this._tile.y / levelFactor) * levelFactor) / levelFactor));
			uvScales.set(textureName, new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(1 / levelFactor, 1 / levelFactor));
		}
		const hasNormalTexture = this._textureLevels.has('normal');

		// Create the vertices, normals, uvs, and indices arrays.
		const numUVerts = this._heightData ? _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(Math.ceil(this._heightData.width * uvScales.get('height').x) - 2, 5, 129) : (5 << _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(2 - this._level / 2, 0, 2));
		const numVVerts = this._heightData ? _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(Math.ceil(this._heightData.height * uvScales.get('height').y) - 2, 5, 129) : (5 << _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(2 - this._level / 2, 0, 2));
		const numVerts = numUVerts * numVVerts;
		const meshPositions = new Float32Array(numVerts * 3);
		const meshNormals = new Float32Array(numVerts * 3);
		let meshTangents = null;
		let meshBitangents = null;
		if (hasNormalTexture) {
			meshTangents = new Float32Array(numVerts * 3);
			meshBitangents = new Float32Array(numVerts * 3);
		}
		const meshIndices = new Uint16Array((numUVerts - 1) * (numVVerts - 1) * 6);
		for (let i = 0; i < this._textureLevels.size; i++) {
			const textureName = this._textureLevels.getAt(i).key;
			// Create the uv array.
			meshUVs.set(textureName, new Float32Array(numVerts * 2));
		}

		// Get the height offset and scale, if it has a height map.
		let heightOffset = 0;
		let heightScale = 0;
		if (this._textureLevels.has('height')) {
			const configuration = this._component.__getEndPoints().get('height').configuration;
			heightOffset = configuration['height_range'].min * this._component.getHeightScale();
			heightScale = (configuration['height_range'].max - configuration['height_range'].min) * this._component.getHeightScale();
		}

		// Set the vertices, normals, uvs, and indices arrays.
		const tile = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const pos = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const heightDir = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const up = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const tangent = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const bitangent = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const lla = new _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt();
		const spheroid = this._component.__getSpheroidComponent();
		for (let y = 0; y < numVVerts; y++) {
			for (let x = 0; x < numUVerts; x++) {
				const vertexI = y * numUVerts + x;
				// Get the tile coordinate of this place within the tile.
				tile.set(this._tile.x + (x - 1) / (numUVerts - 3), this._tile.y + (y - 1) / (numVVerts - 3));

				// Convert it to an XYZ.
				CMTSTile.cmtsCoordToPosition(pos, this._face, this._levelPow, tile.x, tile.y, spheroid);
				if (hasNormalTexture) {
					CMTSTile.cmtsCoordToTangent(tangent, this._face, this._levelPow, tile.x, tile.y, spheroid);
					CMTSTile.cmtsCoordToBitangent(bitangent, this._face, this._levelPow, tile.x, tile.y, spheroid);
				}

				// Convert it to an LLA and get up.
				spheroid.llaFromXYZ(lla, pos);
				spheroid.upFromLLA(up, lla);

				// Get the height direction. It is not the same as up if it is planetocentric.
				if (spheroid.isPlanetographic()) {
					heightDir.copy(up);
				}
				else {
					heightDir.normalize(pos);
				}

				if (this._heightData) { // If there's a height map, get the heightmap value and apply it to the position.
					const data = this._heightData.data;
					const uvOffset = uvOffsets.get('height');
					const uvScale = uvScales.get('height');
					const heightTileSize = this._heightData.width - 4;

					// Get the height position.
					CMTSTile.getHeightPos(pos, heightDir, x, y, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
					// Calculate the normal if there isn't a normal map.
					if (!this._textureLevels.has('normal')) {
						const posX1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const posX2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const posY1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const posY2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const posX1Y1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const posX2Y2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const temp1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						const temp2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						CMTSTile.cmtsCoordToPosition(posX1, this._face, this._levelPow, tile.x - 1 / (numUVerts - 3), tile.y, spheroid);
						CMTSTile.getHeightPos(posX1, heightDir, x - 1, y, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
						CMTSTile.cmtsCoordToPosition(posX2, this._face, this._levelPow, tile.x + 1 / (numUVerts - 3), tile.y, spheroid);
						CMTSTile.getHeightPos(posX2, heightDir, x + 1, y, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
						CMTSTile.cmtsCoordToPosition(posY1, this._face, this._levelPow, tile.x, tile.y - 1 / (numVVerts - 3), spheroid);
						CMTSTile.getHeightPos(posY1, heightDir, x, y - 1, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
						CMTSTile.cmtsCoordToPosition(posY2, this._face, this._levelPow, tile.x, tile.y + 1 / (numVVerts - 3), spheroid);
						CMTSTile.getHeightPos(posY2, heightDir, x, y + 1, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
						CMTSTile.cmtsCoordToPosition(posX1Y1, this._face, this._levelPow, tile.x - 1 / (numUVerts - 3), tile.y - 1 / (numVVerts - 3), spheroid);
						CMTSTile.getHeightPos(posX1Y1, heightDir, x - 1, y - 1, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
						CMTSTile.cmtsCoordToPosition(posX2Y2, this._face, this._levelPow, tile.x + 1 / (numUVerts - 3), tile.y + 1 / (numVVerts - 3), spheroid);
						CMTSTile.getHeightPos(posX2Y2, heightDir, x + 1, y + 1, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale);
						posX1.sub(posX2, posX1);
						posY1.sub(posY2, posY1);
						heightDir.cross(posX1, posY1);
						heightDir.normalize(heightDir);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posX1);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posX2);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posY1);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posY2);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posX1Y1);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posX2Y2);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(temp1);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(temp2);
					}
				}
				if (x === 0 || y === 0 || x === numUVerts - 1 || y === numVVerts - 1) {
					if (this._textureLevels.has('height')) {
						pos.setMagnitude(pos, pos.magnitude() - 2.0 * heightScale * this._levelPow);
					}
					else {
						pos.mult(pos, 0.9);
					}
				}

				pos.sub(pos, this._tileOffset);

				meshPositions[vertexI * 3 + 0] = pos.x;
				meshPositions[vertexI * 3 + 1] = pos.y;
				meshPositions[vertexI * 3 + 2] = pos.z;

				meshNormals[vertexI * 3 + 0] = heightDir.x;
				meshNormals[vertexI * 3 + 1] = heightDir.y;
				meshNormals[vertexI * 3 + 2] = heightDir.z;

				if (hasNormalTexture) {
					meshTangents[vertexI * 3 + 0] = tangent.x;
					meshTangents[vertexI * 3 + 1] = tangent.y;
					meshTangents[vertexI * 3 + 2] = tangent.z;

					meshBitangents[vertexI * 3 + 0] = bitangent.x;
					meshBitangents[vertexI * 3 + 1] = bitangent.y;
					meshBitangents[vertexI * 3 + 2] = bitangent.z;
				}

				for (let i = 0; i < this._textureLevels.size; i++) {
					const textureName = this._textureLevels.getAt(i).key;
					const uvOffset = uvOffsets.get(textureName);
					const uvScale = uvScales.get(textureName);
					const uvs = meshUVs.get(textureName);
					uvs[vertexI * 2 + 0] = ((uvOffset.x + (x - 1) / (numUVerts - 3) * uvScale.x)) * tilePixelSize / (tilePixelSize + 4) + 2.0 / (tilePixelSize + 4);
					uvs[vertexI * 2 + 1] = 1 - (((uvOffset.y + (y - 1) / (numVVerts - 3) * uvScale.y)) * tilePixelSize / (tilePixelSize + 4) + 2.0 / (tilePixelSize + 4));
				}

				if (x < numUVerts - 1 && y < numVVerts - 1) {
					const triangleI = y * (numUVerts - 1) + x;
					meshIndices[triangleI * 6 + 0] = numUVerts * (y + 0) + (x + 0);
					meshIndices[triangleI * 6 + 1] = numUVerts * (y + 0) + (x + 1);
					meshIndices[triangleI * 6 + 2] = numUVerts * (y + 1) + (x + 1);
					meshIndices[triangleI * 6 + 3] = numUVerts * (y + 0) + (x + 0);
					meshIndices[triangleI * 6 + 4] = numUVerts * (y + 1) + (x + 1);
					meshIndices[triangleI * 6 + 5] = numUVerts * (y + 1) + (x + 0);
				}
			}
		}

		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'position', meshPositions);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'normal', meshNormals);
		if (hasNormalTexture) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'tangent', meshTangents);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'bitangent', meshBitangents);
		}
		for (let i = 0; i < this._textureLevels.size; i++) {
			const textureName = this._textureLevels.getAt(i).key;
			const uvs = meshUVs.get(textureName);
			if (textureName === 'height') {
				continue;
			}
			if (textureName === 'color') {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'uv', uvs);
			}
			else {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, textureName + 'UV', uvs);
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(this._threeJsObject.geometry, meshIndices);
	}

	/**
	 * Gets the non-positive level for root tiles.
	 * @param {string} textureName
	 * @returns {number}
	 * @private
	 */
	_getNonPositiveLevel(textureName) {
		const nearestDistance = this._getNearestDistance();
		const endPoint = this._component.__getEndPoints().get(textureName);
		const tilePixelSize = endPoint.configuration.tile_size;
		return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(4 - Math.floor(Math.log2(nearestDistance / this._radius / this._component.__getSplitJoinThresholdFactor() * tilePixelSize * 4)), endPoint.configuration.first_level, 0);
	}

	/**
	 * Gets the nearest distance of all cameras to see if we need to split or join this node.
	 * @private
	 */
	_getNearestDistance() {
		let nearestDistance = Number.POSITIVE_INFINITY;
		const cameraPositions = this._component.__getCameraPositions();
		const cameraFieldsOfView = this._component.__getCameraFieldsOfView();
		for (let i = 0, l = cameraPositions.length; i < l; i++) {
			const position = cameraPositions[i];
			const fieldOfView = cameraFieldsOfView[i];
			CMTSTile._pos.sub(position, this._center);
			const distance = Math.max(0, CMTSTile._pos.magnitude() - this._radius) * Math.tan(fieldOfView / 2);
			if (nearestDistance > distance) {
				nearestDistance = distance;
			}
		}
		return nearestDistance;
	}

	/**
	 * Converts this to a string.
	 * @returns {string}
	 * @override
	 */
	toString() {
		return this._face + '/' + this._level + '/' + this._tile.x + '/' + this._tile.y;
	}

	/**
	 * Prepares the tile for rendering.
	 * @param {CameraComponent} camera
	 */
	prepareForRender(camera) {
		// Check if the tile should be hidden.
		const entity = this._component.getEntity();
		if (this._threeJsObject !== null) {
			const cameraSpacePosition = entity.getCameraSpacePosition(camera);
			const centerInJ2000 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			centerInJ2000.rotate(entity.getOrientation(), this._center);
			const angleBetweenCenterAndCamera = Math.acos(centerInJ2000.dot(cameraSpacePosition)
				/ centerInJ2000.magnitude() / cameraSpacePosition.magnitude());
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(centerInJ2000);
			if (angleBetweenCenterAndCamera < Math.PI / 2 - (Math.PI / 4) * this._levelPow) {
				this._threeJsObject.visible = false;
				return;
			}
		}

		// Set the Three.js object position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this._threeJsObject, this._component.getEntity(), camera, this._tileOffset, true);

		// Prepare the children for rendering.
		for (let i = 0, l = this.children.length; i < l; i++) {
			this.children[i].prepareForRender(camera);
		}
	}

	/**
	 * Sets the texture.
	 * @param {string} textureName
	 * @param {THREE.Texture} texture
	 * @private
	 */
	_setTexture(textureName, texture) {
		if (this._component.getLoadState() !== 'loaded') {
			return;
		}
		if (textureName === 'height') {
			const canvas = document.createElement('canvas');
			canvas.width = texture.image.width;
			canvas.height = texture.image.height;
			const context = canvas.getContext('2d', { desynchronized: true, alpha: false });
			context.drawImage(texture.image, 0, 0);
			texture.dispose();
			this._heightData = context.getImageData(0, 0, texture.image.width, texture.image.height);
			// Release the used height texture.
			this._component.__getTextureCache().release(this._texturePromises.get('height'));
			this._texturePromises.delete('height');
			// Recalculate the center using the height data.
			const spheroid = this._component.__getSpheroidComponent();
			CMTSTile.cmtsCoordToPosition(this._center, this._face, this._levelPow, this._tile.x + 0.5, this._tile.y + 0.5, spheroid);
			const up = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
			spheroid.llaFromXYZ(lla, this._center);
			spheroid.upFromLLA(up, lla);
			const height = CMTSTile.getLinearInterpolatedHeightPixel(this._heightData.width / 2, this._heightData.height / 2, this._heightData.data, this._heightData.width);
			const configuration = this._component.__getEndPoints().get('height').configuration;
			const heightOffset = configuration['height_range'].min * this._component.getHeightScale();
			const heightScale = (configuration['height_range'].max - configuration['height_range'].min) * this._component.getHeightScale();
			this._center.addMult(this._center, up, heightOffset + height * heightScale);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(up);
			_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		}
		else {
			this._threeJsMaterial.uniforms[textureName + 'Texture'].value = texture;
			if (textureName === 'normal') {
				this._threeJsMaterial.defines['normalMap'] = true;
				this._threeJsMaterial.defines['normalUVs'] = true;
				this._threeJsMaterial.defines['hasBitangents'] = true;
				this._threeJsMaterial.uniforms['normalScale'].value.set(this._component.getHeightScale(), this._component.getHeightScale());
				this._threeJsMaterial.uniforms['specularIntensity'].value = 0;
				this._threeJsMaterial.uniforms['specularHardness'].value = 100;
			}
			else if (textureName === 'specular') {
				this._threeJsMaterial.defines['specularMap'] = true;
				this._threeJsMaterial.defines['specularUVs'] = true;
			}
			else if (textureName === 'night') {
				this._threeJsMaterial.defines['nightMap'] = true;
				this._threeJsMaterial.defines['nightUVs'] = true;
			}
			else if (textureName === 'decal') {
				this._threeJsMaterial.defines['decalMap'] = true;
				this._threeJsMaterial.defines['decalUVs'] = true;
			}
		}
	}

	/**
	 * Gets the greatest level available for the given tile.
	 * @param {CMTSConfiguration} configuration
	 * @param {number} face
	 * @param {number} level
	 * @param {Vector2} tile
	 * @returns {number}
	 */
	static _getGreatestLevel(configuration, face, level, tile) {
		let greatestLevel = Number.NEGATIVE_INFINITY;
		for (let i = 0, l = configuration.boundaries.length; i < l; i++) {
			const boundary = configuration.boundaries[i];
			if (boundary.face !== face) { // Different face.
				continue;
			}
			const levelDifference = boundary['last_level'] - level;
			if (boundary.min[0] <= (tile.x >> levelDifference) && (tile.x >> levelDifference) <= boundary.max[0]
				&& boundary.min[1] <= (tile.y >> levelDifference) && (tile.y >> levelDifference) <= boundary.max[1]
				&& greatestLevel < boundary['last_level']) {
				greatestLevel = boundary['last_level'];
			}
		}
		return greatestLevel;
	}

	/**
	 * Returns true if the tile coordinates are within a boundary.
	 * @param {CMTSConfiguration} configuration
	 * @param {number} face
	 * @param {number} level
	 * @param {Vector2} tile
	 * @returns {boolean}
	 */
	static _isInABoundary(configuration, face, level, tile) {
		let foundValidBoundary = false;
		for (let i = 0, l = configuration.boundaries.length; i < l; i++) {
			const boundary = configuration.boundaries[i];
			if (boundary.face !== face) { // Different face.
				continue;
			}
			if (boundary['last_level'] < level) { // Not a deep enough level to cover the child tile.
				continue;
			}
			const levelFactor = 1 << (boundary['last_level'] - level);
			if (tile.x < Math.floor(boundary.min[0] / levelFactor) || Math.floor(boundary.max[0] / levelFactor) < tile.x) {
				continue;
			}
			if (tile.y < Math.floor(boundary.min[1] / levelFactor) || Math.floor(boundary.max[1] / levelFactor) < tile.y) {
				continue;
			}
			foundValidBoundary = true;
		}
		return foundValidBoundary;
	}

	/**
	 * Updates the position based on the tileOffsets.
	 * @returns {Vector3}
	 * @private
	 */
	_getTileOffset() {
		const tileOffsets = this._component.__getTileOffsets();
		for (let i = 0, l = tileOffsets.length; i < l; i++) {
			const tileOffset = tileOffsets[i];
			if (tileOffset.face !== this._face || tileOffset.level > this._level) {
				continue;
			}
			const levelMult = 1 << (this._level - tileOffset.level);
			if (tileOffset.min.x * levelMult <= this._tile.x && this._tile.x < (tileOffset.max.x + 1) * levelMult && tileOffset.min.y * levelMult <= this._tile.y && this._tile.y < (tileOffset.max.y + 1) * levelMult) {
				return tileOffset.offset;
			}
		}
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero;
	}

	/**
	 * Adjust the position given the height on a tile.
	 * @param {Vector3} pos
	 * @param {Vector3} heightDir
	 * @param {number} x
	 * @param {number} y
	 * @param {Uint8ClampedArray} data
	 * @param {Vector2} uvOffset
	 * @param {number} numUVerts
	 * @param {number} numVVerts
	 * @param {Vector2} uvScale
	 * @param {number} heightTileSize
	 * @param {number} heightOffset
	 * @param {number} heightScale
	 */
	static getHeightPos(pos, heightDir, x, y, data, uvOffset, numUVerts, numVVerts, uvScale, heightTileSize, heightOffset, heightScale) {
		const u = ((uvOffset.x + (x - 1) / (numUVerts - 3) * uvScale.x)) * heightTileSize / (heightTileSize + 4) + 2.0 / (heightTileSize + 4);
		const v = 1 - (((uvOffset.y + (y - 1) / (numVVerts - 3) * uvScale.y)) * heightTileSize / (heightTileSize + 4) + 2.0 / (heightTileSize + 4));
		const pixelX = u * (heightTileSize + 4);
		const pixelY = v * (heightTileSize + 4);
		const height = this.getLinearInterpolatedHeightPixel(pixelX, pixelY, data, heightTileSize + 4);
		pos.addMult(pos, heightDir, heightOffset + height * heightScale);
	}

	/** Gets the linearly interpolated height from a pixel.
	 * @param {number} pixelX
	 * @param {number} pixelY
	 * @param {Uint8ClampedArray} data
	 * @param {number} size
	 * @returns {number} */
	static getLinearInterpolatedHeightPixel(pixelX, pixelY, data, size) {
		const pixelXInt = Math.floor(pixelX);
		const pixelYInt = Math.floor(pixelY);
		const pixelXFrac = pixelX - pixelXInt;
		const pixelYFrac = pixelY - pixelYInt;
		const u = Math.abs(pixelXFrac - 0.5);
		const v = Math.abs(pixelYFrac - 0.5);
		let height = this.getHeightFromPixel(pixelXInt, pixelYInt, data, size) * ((1 - u) * (1 - v));
		if (pixelXFrac >= 0.5) {
			height += this.getHeightFromPixel(pixelXInt + 1, pixelYInt, data, size) * (u * (1 - v));
			if (pixelYFrac < 0.5) {
				height += this.getHeightFromPixel(pixelXInt + 1, pixelYInt - 1, data, size) * (u * v);
			}
			else if (pixelYFrac >= 0.5) {
				height += this.getHeightFromPixel(pixelXInt + 1, pixelYInt + 1, data, size) * (u * v);
			}
		}
		else if (pixelXFrac < 0.5) {
			height += this.getHeightFromPixel(pixelXInt - 1, pixelYInt, data, size) * (u * (1 - v));
			if (pixelYFrac < 0.5) {
				height += this.getHeightFromPixel(pixelXInt - 1, pixelYInt - 1, data, size) * (u * v);
			}
			else if (pixelYFrac >= 0.5) {
				height += this.getHeightFromPixel(pixelXInt - 1, pixelYInt + 1, data, size) * (u * v);
			}
		}
		if (pixelYFrac >= 0.5) {
			height += this.getHeightFromPixel(pixelXInt, pixelYInt + 1, data, size) * ((1 - u) * v);
		}
		else if (pixelYFrac < 0.5) {
			height += this.getHeightFromPixel(pixelXInt, pixelYInt - 1, data, size) * ((1 - u) * v);
		}
		return height;
	}

	/** Gets the height from a pixel.
	 * @param {number} pixelX
	 * @param {number} pixelY
	 * @param {Uint8ClampedArray} data
	 * @param {number} size
	 * @returns {number} */
	static getHeightFromPixel(pixelX, pixelY, data, size) {
		pixelX = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(pixelX, 0, size - 1);
		pixelY = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(pixelY, 0, size - 1);
		const pixelIndex = (pixelY * size + pixelX) * 4; // 4 for the rgba channels.
		// We parse the color, combining it into a single 24-bit value.
		// Eventually a proposal will allow more efficient types of height data. https://github.com/WICG/canvas-color-space/blob/master/CanvasColorSpaceProposal.md
		return data[pixelIndex + 0] / 256 + data[pixelIndex + 1] / 65536 + data[pixelIndex + 2] / 16777216;
	}

	/**
	 * Converts a CMTS coordinate to an XYZ coordinate in the frame of the spheroid.
	 * @param {Vector3} out
	 * @param {number} face
	 * @param {number} levelPow
	 * @param {number} x
	 * @param {number} y
	 * @param {SpheroidComponent} spheroid
	 */
	static cmtsCoordToPosition(out, face, levelPow, x, y, spheroid) {
		let u = x * levelPow;
		let v = y * levelPow;

		// If the uv are out of bounds, get the correct uv and face.
		while (u < 0 || u > 1 || v < 0 || v > 1) {
			if (0 <= face && face <= 3) { // One of the horizontal faces
				if (u > 1) {
					u -= 1;
					face = (face + 1) % 4;
				}
				else if (u < 0) {
					u += 1;
					face = (face + 3) % 4; // same as - 1
				}
				else if (face === 0) {
					if (v < 0) {
						v += 1;
						face = 5;
					}
					else if (v > 1) {
						v -= 1;
						face = 4;
					}
				}
				else if (face === 1) {
					if (v < 0) {
						const t = u;
						u = v + 1;
						v = 1 - t;
						face = 5;
					}
					else if (v > 1) {
						const t = u;
						u = 2 - v;
						v = t;
						face = 4;
					}
				}
				else if (face === 2) {
					if (v < 0) {
						u = 1 - u;
						v = 0 - v;
						face = 5;
					}
					else if (v > 1) {
						u = 1 - u;
						v = 2 - v;
						face = 4;
					}
				}
				else if (face === 3) {
					if (v < 0) {
						const t = u;
						u = 0 - v;
						v = t;
						face = 5;
					}
					else if (v > 1) {
						const t = u;
						u = v - 1;
						v = 1 - t;
						face = 4;
					}
				}
			}
			else if (face === 4) {
				if (u < 0) {
					const t = u;
					u = 1 - v;
					v = t + 1;
					face = 3;
				}
				else if (u > 1) {
					const t = u;
					u = v;
					v = 2 - t;
					face = 1;
				}
				else if (v < 0) {
					v += 1;
					face = 0;
				}
				else if (v > 1) {
					u = 1 - u;
					v = 2 - v;
					face = 2;
				}
			}
			else if (face === 5) {
				if (u < 0) {
					const t = u;
					u = v;
					v = 0 - t;
					face = 3;
				}
				else if (u > 1) {
					const t = u;
					u = 1 - v;
					v = t - 1;
					face = 1;
				}
				else if (v < 0) {
					u = 1 - u;
					v = 0 - v;
					face = 2;
				}
				else if (v > 1) {
					v -= 1;
					face = 0;
				}
			}
		}

		const uT = 2 * u - 1;
		const vT = 2 * v - 1;

		const basis = this._basis[face];

		// Convert to XYZ vector as if it were a sphere.
		out.set(
			basis[0].x * uT + basis[1].x * vT + basis[2].x,
			basis[0].y * uT + basis[1].y * vT + basis[2].y,
			basis[0].z * uT + basis[1].z * vT + basis[2].z);
		out.normalize(out);

		// Get it as an LLA.
		_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLLAFromXYZOnSphere(this._lla, out, 0);
		this._lla.alt = 0;

		// Convert to a proper XYZ.
		spheroid.xyzFromLLA(out, this._lla);
	};

	/**
	 * Converts a CMTS coordinate to a tangent XYZ coordinate in the frame of the spheroid.
	 * @param {Vector3} out
	 * @param {number} face
	 * @param {number} levelPow
	 * @param {number} x
	 * @param {number} y
	 * @param {SpheroidComponent} spheroid
	 */
	static cmtsCoordToTangent(out, face, levelPow, x, y, spheroid) {
		this.cmtsCoordToPosition(out, face, levelPow, x, y, spheroid);
		const basis = this._basis[face];
		out.setNormalTo(out, basis[0]);
	};

	/**
	 * Converts a CMTS coordinate to a bitangent XYZ coordinate in the frame of the spheroid.
	 * @param {Vector3} out
	 * @param {number} face
	 * @param {number} levelPow
	 * @param {number} x
	 * @param {number} y
	 * @param {SpheroidComponent} spheroid
	 */
	static cmtsCoordToBitangent(out, face, levelPow, x, y, spheroid) {
		this.cmtsCoordToPosition(out, face, levelPow, x, y, spheroid);
		const basis = this._basis[face];
		out.setNormalTo(out, basis[1]);
	};
}

/**
 * The basis vectors for every face. The first corresponds to the U direction, then the V direction, and then out of the face.
 */
CMTSTile._basis = [
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxisNeg]
];

/**
 * A temporary lat/lon/alt.
 */
CMTSTile._lla = new _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt();

/**
 * A temporary vector3
 */
CMTSTile._pos = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

/**
 * @typedef CMTSBoundary
 * @property {number} face
 * @property {number} last_level
 * @property {{ 0: number, 1: number }} min
 * @property {{ 0: number, 1: number }} max
 */

/**
 * @typedef CMTSRange {
 * @property {number} min
 * @property {number} max
 */

/**
 * @typedef CMTSConfiguration
 * @property {CMTSBoundary[]} boundaries
 * @property {number} first_level
 * @property {number} tile_size
 * @property {string} extension
 * @property {CMTSRange} height_range
 */


/***/ }),

/***/ "../pioneer/engine/src/scene/components/comet_tail_component.js":
/*!**********************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/comet_tail_component.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CometTailComponent": function() { return /* binding */ CometTailComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A comet coma and tail.
 */
class CometTailComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The light source.
		 * @type {EntityRef}
		 * @private
		 */
		this._lightSource = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The length of the particle stream.
		 * @type {number}
		 * @private
		 */
		this._timeLength = 6e5;

		/**
		 * The number of particles.
		 * @type {number}
		 * @private
		 */
		this._numberOfParticles = 200;

		/**
		 * The color of the particles.
		 * @type {Color}
		 * @private
		 */
		this._color = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color();
		this._color.freeze();

		/**
		 * The force multiplier of the star.
		 * @type {number}
		 * @private
		 */
		this._starAccelerationMultiplier = 1.0;

		/**
		 * The time of particle 0. All values in originTimeArray are relative to this.
		 * @type {number}
		 * @private
		 */
		this._timeOfParticle0 = 0;
	}

	/**
	 * Returns the light source's name.
	 * @return {string}
	 */
	getLightSource() {
		return this._lightSource.getName();
	}

	/**
	 * Sets the light source's name.
	 * @param {string} lightSource
	 */
	setLightSource(lightSource) {
		this._lightSource.setName(lightSource);
	}

	/**
	 * Gets the length in seconds of the particle stream.
	 * @returns {number}
	 */
	getTimeLength() {
		return this._timeLength;
	}

	/**
	 * Sets the length of the particle stream. Defaults to 6e5.
	 * @param {number} length
	 */
	setTimeLength(length) {
		this._timeLength = length;
		this.resetResources();
	}

	/**
	 * Gets the acceleration multiplier of the star.
	 * @returns {number}
	 */
	getStarAccelerationMultiplier() {
		return this._starAccelerationMultiplier;
	}

	/**
	 * Sets the acceleration multiplier of the star. Defaults to 1.
	 * @param {number} starAccelerationMultiplier
	 */
	setStarAccelerationMultiplier(starAccelerationMultiplier) {
		this._starAccelerationMultiplier = starAccelerationMultiplier;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'starAccelerationMultiplier', this._starAccelerationMultiplier);
	}

	/**
	 * Gets the number of particles.
	 * @returns {number}
	 */
	getNumberOfParticles() {
		return this._numberOfParticles;
	}

	/**
	 * Sets the number of particles. Defaults to 100.
	 * @param {number} numberOfParticles
	 */
	setNumberOfParticles(numberOfParticles) {
		this._numberOfParticles = numberOfParticles;
		this.resetResources();
	}

	/**
	 * Gets the color of the particles.
	 * @returns {Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the particles. Defaults to white.
	 * @param {Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color);
	}

	/**
	 * Updates the particles.
	 * @override
	 */
	__update() {
		// Update the radius given the time length.
		this.__setRadius(Math.max(this.getEntity().getExtentsRadius(), this._timeLength * this.getEntity().getVelocity().magnitude()));

		// If not loaded, do nothing.
		if (this.getLoadState() !== 'loaded') {
			return;
		}

		// Check if any particles have gone outside the time bounds and recreate them if so.
		const time = this.getEntity().getScene().getEngine().getTime();
		const originTimeAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['originTime'];
		const originTimeArray = /** @type {Float32Array} */(originTimeAttribute.array);
		for (let i = 0, l = this._numberOfParticles; i < l; i++) {
			const particleTime = originTimeArray[i] + this._timeOfParticle0;
			if (particleTime < time - this._timeLength || particleTime > time) {
				this._newParticle(i, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(particleTime, time - this._timeLength, time));
			}
		}

		// Update the uniform with the time. If there is a single particle, it's a coma, so don't update the time.
		if (this._numberOfParticles > 1) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'time', time - this._timeOfParticle0);
		}
		else {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'time', 0);
		}

		// Get the light source for the updates below.
		const lightSource = this._lightSource.get();
		if (lightSource !== null) {
			// Update the star absolute magnitude.
			const lightSourceComponent = /** @type {LightSourceComponent} */(lightSource.getComponentByType('lightSource'));
			if (lightSourceComponent !== null) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'starAbsoluteMagnitude', lightSourceComponent.getAbsoluteMagnitude());
			}

			// Update the position entity uniform.
			const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			this.getEntity().getPositionRelativeToEntity(position, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, lightSource);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'positionOfEntity', position);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		}
	}

	/**
	 * Prepares the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// Set the position of the ThreeJs object.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), camera);

		// Set the position-in-camera as well.
		const cameraSpacePosition = this.getEntity().getCameraSpacePosition(camera);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'positionInCamera', cameraSpacePosition);

		if (cameraSpacePosition.magnitude() < 4e4) {
			this.getThreeJsObjects()[0].visible = false;
		}
		else {
			const u = (cameraSpacePosition.magnitude() - 4e4) / 4e5;
			this.getThreeJsMaterials()[0].uniforms['color'].value.w = this._color.a * _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(u);
			this.getThreeJsObjects()[0].visible = true;
		}
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Setup the Three.js material.
		const threeJsMaterial = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial({
			uniforms: {
				time: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				timeLength: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				positionInCamera: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),
				starAbsoluteMagnitude: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				starAccelerationMultiplier: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				positionOfEntity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),
				color: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4()),

				..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
			},
			vertexShader: CometTailComponent.vertexShader,
			fragmentShader: CometTailComponent.fragmentShader,
			transparent: true,
			depthWrite: false,
			blending: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AdditiveBlending,
			side: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide
		});
		_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderFix.fix(threeJsMaterial);
		this.getThreeJsMaterials().push(threeJsMaterial);

		// Setup the attribute arrays.
		const positionArray = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0]);
		const indexArray = new Uint16Array([0, 1, 2, 2, 3, 0]);
		const originTimeArray = new Float32Array(1 * this._numberOfParticles);
		const originPositionArray = new Float32Array(3 * this._numberOfParticles);
		const accelerationMultiplier = new Float32Array(1 * this._numberOfParticles);

		// Setup the Three.js geometry.
		const threeJsGeometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferGeometry();
		threeJsGeometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(positionArray, 3));
		threeJsGeometry.setAttribute('originTime', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(originTimeArray, 1));
		threeJsGeometry.setAttribute('originPosition', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(originPositionArray, 3));
		threeJsGeometry.setAttribute('accelerationMultiplier', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(accelerationMultiplier, 1));
		threeJsGeometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(indexArray, 1));
		threeJsGeometry.instanceCount = this._numberOfParticles;

		// Setup the Three.js object.
		const threeJsObject = /** @type {THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>} */ (_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObjectGivenGeometry(this, threeJsMaterial, threeJsGeometry));
		this.getThreeJsObjects().push(threeJsObject);

		// Setup the arrays.
		const time = this.getEntity().getScene().getEngine().getTime();
		for (let i = 0, l = this._numberOfParticles; i < l; i++) {
			this._newParticle(i, time - (i / l) * this._timeLength);
		}

		// Set the uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'timeLength', this._timeLength);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'starAccelerationMultiplier', this._starAccelerationMultiplier);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color);
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Sets up a new particle at the comet.
	 * @param {number} i - the particle number
	 * @param {number} time - the time to instantiate
	 * @private
	 */
	_newParticle(i, time) {
		// Set the origin time.
		const originTime = time;
		const originTimeAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['originTime'];
		const originTimeArray = /** @type {Float32Array} */(originTimeAttribute.array);
		if (i > 0) {
			originTimeArray[i] = originTime - this._timeOfParticle0;
		}
		else {
			// Adjust the rest of the particle times to be relative to the new particle 0.
			for (let j = 1, l = this._numberOfParticles; j < l; j++) {
				originTimeArray[j] += this._timeOfParticle0 - originTime;
			}
			this._timeOfParticle0 = originTime;
			originTimeArray[0] = 0;
		}
		originTimeAttribute.needsUpdate = true;

		// Set the origin position.
		const originPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const lightSource = this._lightSource.get();
		if (lightSource !== null) {
			this.getEntity().getPositionRelativeToEntity(originPosition, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, lightSource, originTime);
		}
		const originPositionAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['originPosition'];
		const originPositionArray = /** @type {Float32Array} */(originPositionAttribute.array);
		originPositionArray[i * 3 + 0] = originPosition.x;
		originPositionArray[i * 3 + 1] = originPosition.y;
		originPositionArray[i * 3 + 2] = originPosition.z;
		originPositionAttribute.needsUpdate = true;
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(originPosition);

		// Set the acceleration factor.
		const accelerationMultiplierAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['accelerationMultiplier'];
		const accelerationMultiplierArray = /** @type {Float32Array} */(accelerationMultiplierAttribute.array);
		accelerationMultiplierArray[i] = 0 + 1 * Math.random();
		accelerationMultiplierAttribute.needsUpdate = true;
	}
}

CometTailComponent.vertexShader = `
	attribute vec3 position;
	attribute float originTime;
	attribute vec3 originPosition;
	attribute vec3 originStarPosition;
	attribute vec3 originExternalAcceleration;
	attribute float accelerationMultiplier;

	uniform float time;
	uniform float timeLength;
	uniform vec3 positionInCamera;
	uniform float starAbsoluteMagnitude;
	uniform float starAccelerationMultiplier;
	uniform vec3 positionOfEntity;
	uniform mat4 viewMatrix;
	uniform mat4 modelViewMatrix;
	uniform mat4 projectionMatrix;

	varying vec2 vPosition;
	varying float vAlpha;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

	void main() {
		// Get the position of the center point of the quad in model space.
		float deltaTime = time - originTime;
		vec3 externalAcceleration = starAccelerationMultiplier * accelerationMultiplier * normalize(originPosition) * 5.0e7 * pow(2.51188643151, 20.0 - starAbsoluteMagnitude) / dot(originPosition, originPosition);
		vec3 modelPosition = externalAcceleration * pow(deltaTime, 1.5);

		// Get a general expansion scale in all directions.
		float expansion = 0.2 * max(1.0e5, length(modelPosition));

		// Get the stretch direction in view space.
		vec3 modelStretch = modelPosition;
		vec3 cameraDirection = normalize(positionInCamera);
		modelStretch = modelStretch - dot(cameraDirection, modelStretch) * cameraDirection;
		vec4 viewStretch = viewMatrix * vec4(modelStretch, 1.0);

		// Get the stretch amounts in the x and y directions.
		vec2 stretch2d = vec2(max(expansion, 2.0 * length(viewStretch.xz)), expansion);

		// Do the stretch calculation on the vertex position in view space.
		// It translates it, rotates it, stretches it, and unrotates it.
		vec2 translate = 0.5 * normalize(vec2(viewStretch.xz));
		float angle = length(viewStretch.xz) > 0.0 ? atan(viewStretch.z, viewStretch.x) : 0.0;
		float cosAngle = cos(angle);
		float sinAngle = sin(angle);
		float stretchedX = (stretch2d.x * cosAngle * cosAngle + stretch2d.y * sinAngle * sinAngle) * 0.5 * (position.x + translate.x) + (stretch2d.x - stretch2d.y) * sinAngle * cosAngle * 0.5 * (position.y + translate.y);
		float stretchedY = (stretch2d.x - stretch2d.y) * sinAngle * cosAngle * 0.5 * (position.x + translate.x) + (stretch2d.x * sinAngle * sinAngle + stretch2d.y * cosAngle * cosAngle) * 0.5 * (position.y + translate.y);

		// Get the position in view space and then in normalized space.
		vec4 viewPosition = vec4(stretchedX, 0.0, stretchedY, 0.0) + modelViewMatrix * vec4(modelPosition, 1.0);
		gl_Position = projectionMatrix * viewPosition;
		gl_Position.w = viewPosition.y;

		// Set the varying variables for adjusting te
		vPosition = vec2(cosAngle * position.x + sinAngle * position.y, -sinAngle * position.x + cosAngle * position.y);
		vAlpha = sqrt(1.0 - sqrt(deltaTime / timeLength));

		// Make the gas fade far from the star.
		vAlpha *= min(1.0, 1.0 - length(originPosition) / 7.0e8);

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
	}`;

CometTailComponent.fragmentShader = `
	precision highp float;

	uniform vec4 color;

	varying vec2 vPosition;
	varying float vAlpha;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

	void main(void) {
		// Set the color to be a circle tinted by the color.
		gl_FragColor = vec4(color.rgb, 0.5 * color.a) * max(0.0, 1.0 - dot(vPosition, vPosition)) * vAlpha;

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
	}`;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/connected_sprite_component.js":
/*!****************************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/connected_sprite_component.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectedSpriteComponent": function() { return /* binding */ ConnectedSpriteComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A 2D sprite in the X-Y plane relative to an entity.
 */
class ConnectedSpriteComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The entity 1 to connect to.
		 * @type {EntityRef}
		 * @private
		 */
		this._entity1 = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The offset of entity 1 in entity 1's frame.
		 * @type {Vector3}
		 * @private
		 */
		this._entity1Offset = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._entity1Offset.freeze();

		/**
		 * The entity 2 to connect to.
		 * @type {EntityRef}
		 * @private
		 */
		this._entity2 = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The offset of entity 2 in entity 2's frame.
		 * @type {Vector3}
		 * @private
		 */
		this._entity2Offset = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._entity2Offset.freeze();

		/**
		 * The width of the sprite along the axis perpendicular to the line between the two entities at entity 1.
		 * @type {number}
		 * @private
		 */
		this._width1 = 1.0;

		/**
		 * The width of the sprite along the axis perpendicular to the line between the two entities at entity 2.
		 * @type {number}
		 * @private
		 */
		this._width2 = 1.0;

		/**
		 * The units of the width. It can be 'px' or 'km'.
		 * @type {string}
		 * @private
		 */
		this._widthUnits = 'km';

		/**
		 * The url for the texture.
		 * @type {string}
		 * @private
		 */
		this._textureUrl = '';

		/**
		 * The aspect ratio of the texture.
		 * @type {number}
		 * @private
		 */
		this._textureAspectRatio = 1;

		/**
		 * The flag for whether to repeat or stretch the texture.
		 * @type {boolean}
		 * @private
		 */
		this._textureRepeat = true;

		/**
		 * The stretch factor for textures.
		 * @type {number}
		 * @private
		 */
		this._textureStretch = 1;

		/**
		 * The y offset from 0 to 1 of the texture.
		 * @type {number}
		 * @private
		 */
		this._textureYOffset = 0;

		/**
		 * The u offset from 0 to 1 of the start of the line. 0 is at Entity1, 1 is at Entity2.
		 * @type {number}
		 * @private
		 */
		this._uOffsetStart = 0;

		/**
		 * The u offset from 0 to 1 of the end of the line. 0 is at Entity1, 1 is at Entity2.
		 * @type {number}
		 * @private
		 */
		this._uOffsetEnd = 1;

		/**
		 * Each pixel in the texture is multiplied by this value.
		 * @type {Color}
		 * @private
		 */
		this._colorMultiplier = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._colorMultiplier.freeze();

		/**
		 * A flag that determines if the sprite has blending mode.
		 * @type {string}
		 * @private
		 */
		this._blending = 'normal';
	}

	/**
	 * Gets the entity 1 to connect to.
	 * @returns {string}
	 */
	getEntity1() {
		return this._entity1.getName();
	}

	/**
	 * Sets the entity 1 to connect to. It defaults to null.
	 * @param {string} entityName
	 */
	setEntity1(entityName) {
		this._entity1.setName(entityName);
	}

	/**
	 * Gets the offset of entity 1 in entity 1's frame.
	 * @returns {Vector3}
	 */
	getEntity1Offset() {
		return this._entity1Offset;
	}

	/**
	 * Sets the offset of entity 1 in entity 1's frame. It defaults to zero.
	 * @param {Vector3} offset
	 */
	setEntity1Offset(offset) {
		this._entity1Offset.thaw();
		this._entity1Offset.copy(offset);
		this._entity1Offset.freeze();
	}

	/**
	 * Gets the entity 2 to connect to.
	 * @returns {string}
	 */
	getEntity2() {
		return this._entity2.getName();
	}

	/**
	 * Sets the entity 2 to connect to. It defaults to null.
	 * @param {string} entityName
	 */
	setEntity2(entityName) {
		this._entity2.setName(entityName);
	}

	/**
	 * Gets the offset of entity 2 in entity 2's frame.
	 * @returns {Vector3}
	 */
	getEntity2Offset() {
		return this._entity2Offset;
	}

	/**
	 * Sets the offset of entity 2 in entity 2's frame. It defaults to zero.
	 * @param {Vector3} offset
	 */
	setEntity2Offset(offset) {
		this._entity2Offset.thaw();
		this._entity2Offset.copy(offset);
		this._entity2Offset.freeze();
	}

	/**
	 * Gets the width of the sprite along the axis perpendicular to the line between the two entities at entity 1.
	 * @return {number}
	 */
	getWidth1() {
		return this._width1;
	}

	/**
	 * Gets the width of the sprite along the axis perpendicular to the line between the two entities at entity 2.
	 * @return {number}
	 */
	getWidth2() {
		return this._width2;
	}

	/**
	 * Sets the widths of the sprite along the axis perpendicular to the line between the two entities. It defaults to 1 for both.
	 * @param {number} width1 - The width near entity1.
	 * @param {number} width2 - The width near entity2.
	 */
	setWidths(width1, width2) {
		this._width1 = width1;
		this._width2 = width2;
	}

	/**
	 * Gets the units of the width. It can be 'px' or 'km'.
	 * @returns {string}
	 */
	getWidthUnits() {
		return this._widthUnits;
	}

	/**
	 * Sets the units of the width. It can be 'px' or 'km'. Defaults to 'km'.
	 * @param {string} widthUnits
	 */
	setWidthUnits(widthUnits) {
		this._widthUnits = widthUnits;
		if (this.getLoadState() === 'loaded') {
			const material = this.getThreeJsMaterials()[0];
			material.defines['PIXEL_BASED'] = (widthUnits === 'px');
			material.needsUpdate = true;
		}
	}

	/**
	 * Gets the url of the texture.
	 * @returns {string}
	 */
	getTextureUrl() {
		return this._textureUrl;
	}

	/**
	 * Sets the url of the texture. It defaults '', meaning no texture.
	 * @param {string} url
	 */
	setTextureUrl(url) {
		this._textureUrl = url;
		this.resetResources();
	}

	/**
	 * Gets the flag for whether to repeat or stretch the texture.
	 * @returns {boolean}
	 */
	getTextureRepeat() {
		return this._textureRepeat;
	}

	/**
	 * Sets the flag for whether to repeat or stretch the texture. Defaults to true.
	 * @param {boolean} repeat
	 */
	setTextureRepeat(repeat) {
		this._textureRepeat = repeat;
	}

	/**
	 * Gets the stretch factor for textures.
	 * @returns {number}
	 */
	getTextureStretch() {
		return this._textureStretch;
	}

	/**
	 * Sets the stretch factor for textures. Defaults to 1.
	 * @param {number} stretch
	 */
	setTextureStretch(stretch) {
		this._textureStretch = stretch;
	}

	/**
	 * Gets the y offset from 0 to 1 of the texture.
	 * @returns {number}
	 */
	getTextureYOffset() {
		return this._textureYOffset;
	}

	/**
	 * Sets the y offset from 0 to 1 of the texture. Defaults to 0.
	 * @param {number} offset
	 */
	setTextureYOffset(offset) {
		this._textureYOffset = offset;
	}

	/**
	 * Gets the u offset from 0 to 1 of the start of the line. 0 is at Entity1, 1 is at Entity2.
	 * @returns {number}
	 */
	getUOffsetStart() {
		return this._uOffsetStart;
	}

	/**
	 * Sets the u offset from 0 to 1 of the start of the line. 0 is at Entity1, 1 is at Entity2. Defaults to 0.
	 * @param {number} uOffsetStart
	 */
	setUOffsetStart(uOffsetStart) {
		this._uOffsetStart = uOffsetStart;
	}

	/**
	 * Gets the u offset from 0 to 1 of the end of the line. 0 is at Entity1, 1 is at Entity2.
	 * @returns {number}
	 */
	getUOffsetEnd() {
		return this._uOffsetEnd;
	}

	/**
	 * Sets the u offset from 0 to 1 of the end of the line. 0 is at Entity1, 1 is at Entity2. Defaults to 1.
	 * @param {number} uOffsetEnd
	 */
	setUOffsetEnd(uOffsetEnd) {
		this._uOffsetEnd = uOffsetEnd;
	}

	/**
	 * Gets the color multiplier of the sprite. Each pixel in the texture is multiplied by this color.
	 * @returns {Color}
	 */
	getColorMultiplier() {
		return this._colorMultiplier;
	}

	/**
	 * Sets the color multiplier of the sprite. Each pixel in the texture is multiplied by this color. It defaults to (1, 1, 1, 1).
	 * @param {Color} colorMultiplier
	 */
	setColorMultiplier(colorMultiplier) {
		this._colorMultiplier.thaw();
		this._colorMultiplier.copy(colorMultiplier);
		this._colorMultiplier.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._colorMultiplier, 1.0);
	}

	/**
	 * Sets blending mode. It defaults to 'normal'.
	 * @param {string} blending - one of 'normal', 'additive', 'subtractive', 'multliply', 'custom', or 'none'
	 */
	setBlending(blending) {
		this._blending = blending;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setBlending(this.getThreeJsMaterials()[0], blending);
	}

	/**
	 * Updates the camera-independent parts of the component.
	 * @override
	 * @internal
	 */
	__update() {
		const entity1 = this._entity1.get();
		const entity2 = this._entity2.get();
		if (entity1 === null || entity2 === null) {
			return;
		}

		// Update the radius of the component.
		const offset = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		entity1.getPositionRelativeToEntity(offset, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, entity2);
		this.__setRadius(offset.magnitude() + entity1.getExtentsRadius() + entity2.getExtentsRadius());
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(offset);
	}

	/**
	 * Prepares the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// If either entity is not there, don't show the line.
		const entity1 = this._entity1.get();
		const entity2 = this._entity2.get();
		if (entity1 === null || entity2 === null) {
			this.getThreeJsObjects()[0].visible = false;
			return;
		}

		// Get the two positions in camera space.
		const cameraSpacePosition1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const cameraSpacePosition2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const cameraSpacePosition1Temp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		cameraSpacePosition1.rotate(entity1.getOrientation(), this._entity1Offset);
		cameraSpacePosition1.add(entity1.getCameraSpacePosition(camera), cameraSpacePosition1);
		cameraSpacePosition2.rotate(entity2.getOrientation(), this._entity2Offset);
		cameraSpacePosition2.add(entity2.getCameraSpacePosition(camera), cameraSpacePosition2);
		cameraSpacePosition1Temp.copy(cameraSpacePosition1);
		cameraSpacePosition1.lerp(cameraSpacePosition1, cameraSpacePosition2, this._uOffsetStart);
		cameraSpacePosition2.lerp(cameraSpacePosition1Temp, cameraSpacePosition2, this._uOffsetEnd);

		// Make entity1 always the closer of the two. Indicate if they were flipped.
		let entity1DistanceToCamera = cameraSpacePosition1.magnitude();
		let entity2DistanceToCamera = cameraSpacePosition2.magnitude();
		let entitiesFlipped = false;
		if (entity1DistanceToCamera > entity2DistanceToCamera) {
			cameraSpacePosition1Temp.copy(cameraSpacePosition1);
			cameraSpacePosition1.copy(cameraSpacePosition2);
			cameraSpacePosition2.copy(cameraSpacePosition1Temp);
			entity1DistanceToCamera = cameraSpacePosition1.magnitude();
			entity2DistanceToCamera = cameraSpacePosition2.magnitude();
			entitiesFlipped = true;
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraSpacePosition1Temp);

		// If we're in pixel mode, make sure the camera-space positions don't get too far from the normal clipping box or
		// visual bugs can appear. This clips their x and y to the normal-space bounds.
		const normalSpacePosition1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const normalSpacePosition2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		camera.getNormalSpacePositionFromCameraSpacePosition(normalSpacePosition1, cameraSpacePosition1);
		camera.getNormalSpacePositionFromCameraSpacePosition(normalSpacePosition2, cameraSpacePosition2);

		// Get the vertical and horizontal axes. The vertical is the one connecting the entities.
		const vAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const hAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		vAxis.sub(cameraSpacePosition2, cameraSpacePosition1);
		hAxis.copy(cameraSpacePosition1);
		hAxis.cross(vAxis, hAxis);
		hAxis.normalize(hAxis);

		// Make the vAxis shorter so that we don't have such large numbers.
		vAxis.setMagnitude(vAxis, Math.min(vAxis.magnitude(), entity1DistanceToCamera * 10));
		cameraSpacePosition2.add(cameraSpacePosition1, vAxis);
		camera.getNormalSpacePositionFromCameraSpacePosition(normalSpacePosition2, cameraSpacePosition2);
		entity2DistanceToCamera = cameraSpacePosition2.magnitude();

		// Get the widths at each entity and the 'midpoint' value.
		let width1 = entitiesFlipped ? this._width2 : this._width1;
		let width2 = entitiesFlipped ? this._width1 : this._width2;

		// If we're in pixel mode, the widths need to be adjusted from pixel-space to camera-space.
		if (this._widthUnits === 'px') {
			const forward = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			camera.getEntity().getOrientation().getAxis(forward, 1);
			width1 = camera.getViewport().getNormalSpaceRadiusFromPixelSpaceRadius(width1);
			width2 = camera.getViewport().getNormalSpaceRadiusFromPixelSpaceRadius(width2);
			width1 = camera.getRadiusFromNormalSpaceRadius(width1, cameraSpacePosition1.dot(forward));
			width2 = camera.getRadiusFromNormalSpaceRadius(width2, cameraSpacePosition2.dot(forward));
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(forward);
		}

		// Get the amount to repeat the texture.
		let repeatAmount = 1 / this._textureStretch;
		if (this._widthUnits === 'px') {
			if (this._textureRepeat) {
				const pixelSpacePosition1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
				const pixelSpacePosition2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
				camera.getViewport().getPixelSpacePositionFromNormalSpacePosition(pixelSpacePosition1, normalSpacePosition1);
				camera.getViewport().getPixelSpacePositionFromNormalSpacePosition(pixelSpacePosition2, normalSpacePosition2);
				const pixelDiff = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
				pixelDiff.sub(pixelSpacePosition1, pixelSpacePosition2);
				if (pixelDiff.isNaN()) {
					const bounds = camera.getViewport().getBounds();
					pixelDiff.x = bounds.size.x * (normalSpacePosition2.x - normalSpacePosition1.x) / 2.0;
					pixelDiff.y = bounds.size.y * (normalSpacePosition2.y - normalSpacePosition1.y) / 2.0;
				}
				repeatAmount *= pixelDiff.magnitude() / Math.max(this._width1, this._width2) * this._textureAspectRatio;

				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelDiff);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelSpacePosition1);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelSpacePosition2);
			}
		}
		else {
			if (this._textureRepeat) {
				repeatAmount *= vAxis.magnitude() / Math.max(this._width1, this._width2) * this._textureAspectRatio;
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(normalSpacePosition1);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(normalSpacePosition2);

		// Set the camera position of the Three.js object.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPosition(this.getThreeJsObjects(), cameraSpacePosition1);

		// Update the uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'vAxis', vAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'width1', width1);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'width2', width2);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'textureYOffset', this._textureYOffset * (entitiesFlipped ? -1 : 1));
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'repeatAmount', repeatAmount);

		// Release the temporaries.
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraSpacePosition1);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraSpacePosition2);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(vAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(hAxis);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Load the texture.
		const texture = await _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTexture(this, this._textureUrl, true, false);
		texture.wrapT = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RepeatWrapping;
		this._textureAspectRatio = texture.image.width / texture.image.height;

		// Check if the component has since stopped loading.
		if (this.getLoadState() !== 'loading') {
			texture.dispose();
			return;
		}

		// Create the material.
		const threeJsMaterial = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('connected_sprite');
		this.getThreeJsMaterials().push(threeJsMaterial);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setBlending(this.getThreeJsMaterials()[0], this._blending);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(threeJsMaterial, 'PIXEL_BASED', (this._widthUnits === 'px'));
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(threeJsMaterial, 'color', this._colorMultiplier, 1.0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformTexture(threeJsMaterial, 'colorTexture', texture);

		// Create the object.
		const threeJsObject = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, threeJsMaterial, [
			{ name: 'position', dimensions: 2 }], false);
		this.getThreeJsObjects().push(threeJsObject);

		// Setup the vertices and indices.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(threeJsObject.geometry, 'position', new Float32Array([-1, 0, 1, 0, -1, 1, 1, 1]));
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(threeJsObject.geometry, new Uint16Array([0, 2, 3, 3, 1, 0]));
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/div_component.js":
/*!***************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/div_component.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DivComponent": function() { return /* binding */ DivComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Div component. Creates an HTML div element located at position of the entity, using absolute positioning.
*/
class DivComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The camera in which the div is active.
		 * @type {CameraComponent}
		 * @private
		*/
		this._activeCamera = null;

		/**
		 * The flag that determines whether or not the div ignores the distance to the camera when determining visibility.
		 * @type {boolean}
		 * @private
		 */
		this._fadeWhenCloseToCamera = true;

		/**
		 * The entity that, if defined, when the div gets close to, fades away. If set to '', it defaults to the parent.
		 * @type {EntityRef}
		 * @private
		 */
		this._fadeWhenCloseToEntity = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The HTML div element. It will be contained in the labels container div, which will be after the canvas element.
		 * @type {HTMLDivElement}
		 * @private
		 */
		this._div = document.createElement('div');
		this._div.style.position = 'absolute';
		this._div.style.left = '0';
		this._div.style.top = '0';
		this._div.style.transform = 'translate(0%, 0%);';

		/**
		 * The alignment of the text.
		 * @type {Vector2}
		 * @private
		 */
		this._alignment = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.0, 0.5);
		this._alignment.freeze();

		/**
		 * The size of the div in px. Used instead of offsetWidth/offsetHeight every frame so as not to trigger reflow.
		 * @type {Vector2}
		 * @private
		 */
		this._sizeInPx = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);

		/**
		 * The current html, used to see if the sizeInPx needs to be updated.
		 * @type {string}
		 * @private
		 */
		this._currentHTML = '';

		// Set the radius to infinity, since it will always be visible.
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Gets the div.
	 * @returns {HTMLDivElement}
	 */
	getDiv() {
		return this._div;
	}

	/**
	 * Gets the camera in which the div is active.
	 * @returns {CameraComponent}
	 */
	getActiveCamera() {
		return this._activeCamera;
	}

	/**
	 * Sets the camea in which the div is active. Defaults to the first viewport when created.
	 * @param {CameraComponent} activeCamera
	 */
	setActiveCamera(activeCamera) {
		this._activeCamera = activeCamera;
		this.resetResources();
	}

	/**
	 * Gets the flag that determines whether or not the div ignores the distance to the camera when determining visibility.
	 * @returns {boolean}
	 */
	getFadeWhenCloseToCamera() {
		return this._fadeWhenCloseToCamera;
	}

	/**
	 * Sets the flag that determines whether or not the div ignores the distance to the camera when determining visibility. Defaults to true.
	 * @param {boolean} enable
	 */
	setFadeWhenCloseToCamera(enable) {
		this._fadeWhenCloseToCamera = enable;
	}

	/**
	 * Gets the entity name that, if defined, when the div gets close to, fades away.
	 * @returns {string}
	 */
	getFadeWhenCloseToEntity() {
		return this._fadeWhenCloseToEntity.getName();
	}

	/**
	 * Sets the entity name that, if defined, when the div gets close to, fades away. If set to '', it defaults to the parent. Defaults to ''.
	 * @param {string} entityName
	 */
	setFadeWhenCloseToEntity(entityName) {
		this._fadeWhenCloseToEntity.setName(entityName);
	}

	/**
	 * Gets the div alignment. Defaults to the left aligned to the entity and vertically centered.
	 * @returns {Vector2}
	 */
	getAlignment() {
		return this._alignment;
	}

	/**
	 * Sets the alignment. Defaults to Vector2(0.0, 0.5).
	 * @param {Vector2} alignment - the alignment to set
	 */
	setAlignment(alignment) {
		this._alignment.thaw();
		this._alignment.copy(alignment);
		this._alignment.freeze();
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		// Detach the div from its parent.
		if (this._div.parentNode !== null) {
			this._div.parentNode.removeChild(this._div);
		}
	}

	/**
	 * Prepares the component for render.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// If there's no active camera, set the first viewport as the default one.
		if (this._activeCamera === null) {
			const firstViewport = this.getEntity().getScene().getEngine().getViewport(0);
			if (firstViewport !== null) {
				this._activeCamera = firstViewport.getCamera();
			}
		}
		// Check to see that there's a camera and viewport set up.
		if (this._activeCamera !== camera || this._activeCamera === null || this._activeCamera.getViewport() === null) {
			return;
		}
		// Attach the div to the viewport's div, if it isn't already done.
		if (this._activeCamera.getViewport().getDiv() !== this._div.parentNode) {
			this._activeCamera.getViewport().getDiv().appendChild(this._div);
		}

		let alphaMultiplier = 1;

		// Fade the label when too close to the object.
		if (alphaMultiplier > 0 && this._fadeWhenCloseToCamera) {
			const normalizedSizeOfEntity = this.getEntity().getNormalSpaceExtentsRadius(camera);
			alphaMultiplier *= _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((0.02 - normalizedSizeOfEntity) / 0.02);
		}

		// Fade the div when the entity div is visually close to the closest parent div.
		const cameraSpacePosition = this.getEntity().getCameraSpacePosition(camera);
		if (alphaMultiplier > 0) {
			let closeToEntity = /** @type {Entity} */(null);
			if (this._fadeWhenCloseToEntity.getName() === '') {
				closeToEntity = this.getEntity().getParent();
			}
			else {
				closeToEntity = this._fadeWhenCloseToEntity.get();
			}
			if (closeToEntity !== null) {
				const normalSpaceDifferenceFromParent = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				normalSpaceDifferenceFromParent.sub(this.getEntity().getNormalSpacePosition(camera), closeToEntity.getNormalSpacePosition(camera));
				const normalizedEntityDistanceFromParent = normalSpaceDifferenceFromParent.magnitude();
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(normalSpaceDifferenceFromParent);
				const normalizedParentRadius = closeToEntity.getNormalSpaceExtentsRadius(camera);
				if (normalizedParentRadius < 0.02) {
					alphaMultiplier *= _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((normalizedEntityDistanceFromParent - 0.02) / 0.02);
				}
			}
		}

		// If it is occluded, hide the div. Check parent always, too.
		if (alphaMultiplier > 0) {
			if (this.getEntity().getParent() !== null && this.getEntity().getParent().isOccludingPosition(camera, cameraSpacePosition)) {
				alphaMultiplier = 0;
			}
			else if (camera.isPositionOccluded(cameraSpacePosition)) {
				alphaMultiplier = 0;
			}
		}

		// If the div is behind the camera, make it invisible.
		if (alphaMultiplier > 0) {
			const cameraForward = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			camera.getEntity().getOrientation().getAxis(cameraForward, 1);
			if (cameraForward.dot(this.getEntity().getCameraSpacePosition(camera)) <= 0) {
				alphaMultiplier = 0;
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraForward);
		}

		// Set the opacity and pointerEvents from the above conditions.
		if (this._div.style.opacity !== '' + alphaMultiplier) {
			this._div.style.opacity = '' + alphaMultiplier;
			if (alphaMultiplier === 0) {
				this._div.style.pointerEvents = 'none';
			}
			else {
				this._div.style.pointerEvents = '';
			}
		}

		if (alphaMultiplier > 0) {
			// Update the pixel size if needed.
			if (this._currentHTML !== this._div.innerHTML) {
				this._sizeInPx.set(this._div.offsetWidth, this._div.offsetHeight);
				this._currentHTML = this._div.innerHTML;
			}

			// Set the position of the div.
			const renderBounds = camera.getViewport().getBounds();
			const pixelSpacePosition = this.getEntity().getPixelSpacePosition(camera);
			const left = pixelSpacePosition.x - this._sizeInPx.x * this._alignment.x - renderBounds.origin.x + (renderBounds.size.x % 2 === 0 ? -0.5 : 0);
			const top = pixelSpacePosition.y - this._sizeInPx.y * this._alignment.y - renderBounds.origin.y + (renderBounds.size.y % 2 === 0 ? -0.5 : 0);
			this._div.style.transform = `translate(${left}px, ${top}px)`;
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/dynamic_environment_map_component.js":
/*!***********************************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/dynamic_environment_map_component.js ***!
  \***********************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DynamicEnvironmentMapComponent": function() { return /* binding */ DynamicEnvironmentMapComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Environmental map component. The entity should also have a camera component.
 */
class DynamicEnvironmentMapComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The face width of the highest resolution render. Must be power of two.
		 * @type {number}
		 * @private
		 */
		this._faceSize = 64;

		/**
		 * The color of the invalid area. Used for finding meshes with bad normals or faces.
		 * @type {Color}
		 * @private
		 */
		this._invalidColor = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 1);
		this._invalidColor.freeze();

		// STUFF FOR RENDERING FACES

		/**
		 * The Three.js renderer.
		 * @type {THREE.WebGLRenderer}
		 * @private
		 */
		this._threeJsRenderer = this.getEntity().getScene().getEngine().__getThreeJsRenderer();

		/**
		 * The three js cameras.
		 * @type {THREE.PerspectiveCamera[]}
		 * @private
		 */
		this._threeJsFaceCameras = [];

		/**
		 * This render targets.
		 * @type {THREE.WebGLRenderTarget[]}
		 * @private
		 */
		this._threeJsFaceRenderTargets = [];

		// STUFF FOR RENDERING FINAL TEXTURE

		/**
		 * The ThreeJS quad.
		 * @type {THREE.Mesh<THREE.BufferGeometry, THREE.RawShaderMaterial>}
		 * @private
		 */
		this._threeJsQuad = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh();

		/**
		 * The ThreeJS scene.
		 * @type {THREE.Scene}
		 * @private
		 */
		this._threeJsScene = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Scene();

		/**
		 * The ThreeJS cube camera.
		 * @type {THREE.OrthographicCamera}
		 * @private
		 */
		this._threeJsCubeCamera = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.OrthographicCamera(-1, 1, -1, 1, -1, 1);

		/**
		 * This render target is the texture that will be used as the environment map.
		 * @private
		 */
		this._envMapTexture = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(this._faceSize * 4, this._faceSize * 4, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, wrapS: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ClampToEdgeWrapping, wrapT: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ClampToEdgeWrapping });

		// Setup the cameras.
		this._setupFaceCameras();

		// Setup the quad for the final render.
		this._setupQuad();
	}

	/**
	 * Gets the face size.
	 * @return {number}
	 */
	getFaceSize() {
		return this._faceSize;
	}

	/**
	 * Sets the face size. Defaults to 64.
	 * @param {number} faceSize
	 */
	setFaceSize(faceSize) {
		this._faceSize = faceSize;
		if (this._envMapTexture.width !== this._faceSize * 4) {
			this._envMapTexture.setSize(this._faceSize * 4, this._faceSize * 4);
			this._threeJsQuad.material.uniforms['faceSize'].value = this._faceSize;
		}
		for (let face = 0; face < 6; face++) {
			this._threeJsFaceRenderTargets[face].setSize(this._faceSize, this._faceSize);
		}
	}

	/**
	 * Gets the color of the invalid area. Used for finding meshes with bad normals or faces.
	 * @returns {Color}
	 */
	getInvalidColor() {
		return this._invalidColor;
	}

	/**
	 * Sets the color of the invalid area. Used for finding meshes with bad normals or faces.
	 * @param {Color} invalidColor
	 */
	setInvalidColor(invalidColor) {
		this._invalidColor.thaw();
		this._invalidColor.copy(invalidColor);
		this._invalidColor.freeze();
		if (this._threeJsQuad !== null) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGB(this._threeJsQuad.material, 'invalidColor', this._invalidColor);
		}
	}

	/**
	 * Gets the environment map texture.
	 * @returns {THREE.Texture}
	 */
	getTexture() {
		return this._envMapTexture.texture;
	}

	// INTERNALS

	/**
	 * Cleans up the component.
	 * @override
	 * @internal
	 */
	__destroy() {
		this._threeJsQuad.geometry.dispose();
		this._threeJsQuad.material.dispose();
		this._envMapTexture.dispose();
		for (let i = 0; i < this._threeJsFaceRenderTargets.length; i++) {
			this._threeJsFaceRenderTargets[i].dispose();
		}
		super.__destroy();
	}

	/**
	 * Renders the camera. Called by Viewport.
	 * @internal
	 */
	__render() {
		// Update the projection matrix.
		this._updateProjectionMatrix();

		// Set the camera's orientation for each of the face cameras.
		const sqrt2 = 0.7071067811865476;
		_tempThreeJsQuaternion.set(0, 0, -sqrt2, sqrt2);
		this._threeJsFaceCameras[0].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(0, 0, 0, 1);
		this._threeJsFaceCameras[1].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(0, 0, sqrt2, sqrt2);
		this._threeJsFaceCameras[2].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(0, 0, 1, 0);
		this._threeJsFaceCameras[3].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(0.5, -0.5, -0.5, 0.5);
		this._threeJsFaceCameras[4].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(-0.5, 0.5, -0.5, 0.5);
		this._threeJsFaceCameras[5].setRotationFromQuaternion(_tempThreeJsQuaternion);

		// Render each of the face cameras to the render targets.
		for (let face = 0; face < 6; face++) {
			this._threeJsRenderer.setRenderTarget(this._threeJsFaceRenderTargets[face]);
			this._threeJsRenderer.render(this.getEntity().getScene().getThreeJsScene(), this._threeJsFaceCameras[face]);
		}

		// Render to the environment map texture using the render targets.
		this._threeJsRenderer.setRenderTarget(this._envMapTexture);
		// this._threeJsRenderer.setRenderTarget(null);
		this._threeJsRenderer.render(this._threeJsScene, this._threeJsCubeCamera);
	}

	/**
	 * Sets up the cameras.
	 * @private
	 */
	_setupFaceCameras() {
		for (let face = 0; face < 6; face++) {
			this._threeJsFaceCameras.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.PerspectiveCamera(90.0, 1.0, 0.1, 1000));
			const projectionMatrix = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix4();
			projectionMatrix.set(
				1, 0, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1,
				0, 1, 0, 0);
			this._threeJsFaceCameras[face].projectionMatrix = projectionMatrix;
			const projectionMatrixInverse = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix4();
			projectionMatrixInverse.set(
				1, 0, 0, 0,
				0, 0, 0, 1,
				0, 1, 0, 0,
				0, 0, 1, 0);
			this._threeJsFaceCameras[face].projectionMatrixInverse = projectionMatrixInverse;
			this._threeJsFaceCameras[face].layers.set(1);

			const renderTarget = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(this._faceSize, this._faceSize, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter });
			this._threeJsFaceRenderTargets.push(renderTarget);
		}
	}

	/**
	 * Updates the projection.
	 * @private
	 */
	_updateProjectionMatrix() {
		const cameraComponent = /** @type {CameraComponent} */(this.getEntity().get('camera'));
		if (cameraComponent === null) {
			return;
		}
		const f1 = 1.0 - Number.EPSILON;
		const f2 = -cameraComponent.getAutoNearDistance() * (2.0 - Number.EPSILON);
		for (let face = 0; face < 6; face++) {
			this._threeJsFaceCameras[face].projectionMatrix.elements[6] = f1;
			this._threeJsFaceCameras[face].projectionMatrix.elements[14] = f2;
			this._threeJsFaceCameras[face].projectionMatrixInverse.elements[11] = 1 / f2;
			this._threeJsFaceCameras[face].projectionMatrixInverse.elements[15] = -f1 / f2;
		}
	}

	/**
	 * Sets the quad meshes up.
	 */
	_setupQuad() {
		// Setup geometry.
		const geometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferGeometry();
		const meshPositions = new Float32Array([-1, -1, 0, 1, -1, 0, 1, 1, 0, -1, 1, 0]);
		const meshIndices = new Uint16Array([0, 1, 2, 0, 2, 3]);
		geometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(meshPositions, 3));
		geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(meshIndices, 1));

		// Setup material uniforms.
		const uniforms = {
			textures: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([]),
			faceSize: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._faceSize),
			invalidColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(this._invalidColor.r, this._invalidColor.g, this._invalidColor.b))
		};
		for (let face = 0; face < 6; face++) {
			uniforms['textures'].value.push(this._threeJsFaceRenderTargets[face].texture);
		}

		// Setup material.
		const material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial({
			uniforms: uniforms,
			vertexShader: `
				attribute vec3 position;
				varying vec2 xy;
				void main() {
					gl_Position = vec4(position, 1.0);
					xy = position.xy;
				}`,
			fragmentShader: `
				precision highp float;

				uniform sampler2D textures[6];
				uniform float faceSize;
				uniform vec3 invalidColor;

				varying vec2 xy;

				void adjustTextureCoordsForBorders(inout int textureIndex, inout vec2 xyInTexture, in float pixelSize) {
					// Get the pixells in pixel-space.
					vec2 xyInPixels = xyInTexture * pixelSize;

					// Flip the x since this code is for surface cubes, but we're inside out.
					xyInPixels.x = pixelSize - xyInPixels.x;

					// If it's a border, adjust the pixel it's reading the next pixel in one face over.
					// This allows for nice linear filtering to happen on the material side of things.
					if (xyInPixels.x < 0.6 || xyInPixels.x > pixelSize - 0.6 || xyInPixels.y < 0.6 || xyInPixels.y > pixelSize - 0.6) {
						if (0 <= textureIndex && textureIndex <= 3) { // One of the horizontal faces
							if (xyInPixels.x > pixelSize - 0.6) {
								xyInPixels.x = 1.5;
								textureIndex = (textureIndex + 1);
								if (textureIndex == 4) {
									textureIndex = 0;
								}
							}
							else if (xyInPixels.x < 0.6) {
								xyInPixels.x = pixelSize - 1.5;
								textureIndex = textureIndex - 1;
								if (textureIndex == -1) {
									textureIndex = 3;
								}
							}
						}
						if (textureIndex == 0) {
							if (xyInPixels.y < 0.6) {
								xyInPixels.y = pixelSize - 1.5;
								textureIndex = 5;
							}
							else if (xyInPixels.y > pixelSize - 0.6) {
								xyInPixels.y = 1.5;
								textureIndex = 4;
							}
						}
						if (textureIndex == 1) {
							if (xyInPixels.y < 0.6) {
								xyInPixels.y = pixelSize - xyInPixels.x;
								xyInPixels.x = pixelSize - 1.5;
								textureIndex = 5;
							}
							else if (xyInPixels.y > pixelSize - 0.6) {
								xyInPixels.y = xyInPixels.x;
								xyInPixels.x = pixelSize - 1.5;
								textureIndex = 4;
							}
						}
						if (textureIndex == 2) {
							if (xyInPixels.y < 0.6) {
								xyInPixels.x = pixelSize - xyInPixels.x;
								xyInPixels.y = 1.5;
								textureIndex = 5;
							}
							else if (xyInPixels.y > pixelSize - 0.6) {
								xyInPixels.x = pixelSize - xyInPixels.x;
								xyInPixels.y = pixelSize - 1.5;
								textureIndex = 4;
							}
						}
						if (textureIndex == 3) {
							if (xyInPixels.y < 0.6) {
								xyInPixels.y = xyInPixels.x;
								xyInPixels.x = 1.5;
								textureIndex = 5;
							}
							else if (xyInPixels.y > pixelSize - 0.6) {
								xyInPixels.y = pixelSize - xyInPixels.x;
								xyInPixels.x = 1.5;
								textureIndex = 4;
							}
						}
						if (textureIndex == 4) {
							if (xyInPixels.x < 0.6) {
								xyInPixels.x = pixelSize - xyInPixels.y;
								xyInPixels.y = pixelSize - 1.5;
								textureIndex = 3;
							}
							else if (xyInPixels.x > pixelSize - 0.6) {
								xyInPixels.x = xyInPixels.y;
								xyInPixels.y = pixelSize - 1.5;
								textureIndex = 1;
							}
							if (xyInPixels.y < 0.6) {
								xyInPixels.y = pixelSize - 1.5;
								textureIndex = 0;
							}
							else if (xyInPixels.y > pixelSize - 0.6) {
								xyInPixels.x = pixelSize - xyInPixels.x;
								xyInPixels.y = pixelSize - 1.5;
								textureIndex = 2;
							}
						}
						if (textureIndex == 5) {
							if (xyInPixels.x < 0.6) {
								xyInPixels.x = xyInPixels.y;
								xyInPixels.y = 1.5;
								textureIndex = 3;
							}
							else if (xyInPixels.x > pixelSize - 0.6) {
								xyInPixels.x = pixelSize - xyInPixels.y;
								xyInPixels.y = 1.5;
								textureIndex = 1;
							}
							if (xyInPixels.y < 0.6) {
								xyInPixels.x = pixelSize - xyInPixels.x;
								xyInPixels.y = 1.5;
								textureIndex = 2;
							}
							else if (xyInPixels.y > pixelSize - 0.6) {
								xyInPixels.y = 1.5;
								textureIndex = 0;
							}
						}
					}

					// Shrink all pixels so that they fit within the border.
					// The border pixels have already been modified so that they work with this equation.
					xyInPixels.x = ((pixelSize - 1.0) * xyInPixels.x - pixelSize) / (pixelSize - 3.0);
					xyInPixels.y = ((pixelSize - 1.0) * xyInPixels.y - pixelSize) / (pixelSize - 3.0);

					// Flip the x back.
					xyInPixels.x = pixelSize - xyInPixels.x;

					// Go back into unit-space.
					xyInTexture = xyInPixels / pixelSize;
				}

				void main() {
					// Make it pink everywhere else for easy debugging.
					vec3 color = invalidColor;
					// Get the mip level, size, and offset.
					float level = floor(1.0 - log2(1.0 - xy.y)); // 0 is base, then 1, etc.
					float mipSizeX = pow(2.0, -level); // 1, .5, .25, .125, etc.
					float mipOffsetY = 1.0 - pow(2.0, -level); // 0, .5, .75, .875, etc.
					// Get the xy within the mip level. Note the x value is * 3 for less computing further on.
					vec2 xyInMip;
					xyInMip.x = 0.5 * (xy.x + 1.0) / mipSizeX * 4.0;
					xyInMip.y = (xy.y + 1.0 - 2.0 * mipOffsetY) / mipSizeX;
					if (xyInMip.x <= 3.0) {
						int textureIndex = int(floor(xyInMip.y * 2.0) * 3.0 + floor(xyInMip.x));
						// Get the xy within the face/texture.
						vec2 xyInTexture;
						xyInTexture.x = 1.0 - xyInMip.x + floor(xyInMip.x);
						xyInTexture.y = 2.0 * (xyInMip.y - floor(xyInMip.y * 2.0) / 2.0);
						// Adjust the coordinates and face to account for borders.
						adjustTextureCoordsForBorders(textureIndex, xyInTexture, faceSize * mipSizeX);
						// Set the color based on the face (textureIndex) and the coords.
						if (textureIndex == 0) {
							color = texture2D(textures[0], xyInTexture).rgb;
						}
						else if (textureIndex == 1) {
							color = texture2D(textures[1], xyInTexture).rgb;
						}
						else if (textureIndex == 2) {
							color = texture2D(textures[2], xyInTexture).rgb;
						}
						else if (textureIndex == 3) {
							color = texture2D(textures[3], xyInTexture).rgb;
						}
						else if (textureIndex == 4) {
							color = texture2D(textures[4], xyInTexture).rgb;
						}
						else if (textureIndex == 5) {
							color = texture2D(textures[5], xyInTexture).rgb;
						}
					}
					gl_FragColor = vec4(color, 1.0);
				}`,
			depthTest: false,
			depthWrite: false
		});

		// Setup object.
		this._threeJsQuad = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh(geometry, material);
		this._threeJsQuad.frustumCulled = false;
		this._threeJsScene.add(this._threeJsQuad);
	}
}

/**
 * A temporary ThreeJs Quaternion.
 * @type {THREE.Quaternion}
 * @private
 */
const _tempThreeJsQuaternion = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Quaternion();


/***/ }),

/***/ "../pioneer/engine/src/scene/components/gizmo_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/gizmo_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GizmoComponent": function() { return /* binding */ GizmoComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Red, green, blue axes to help in understanding the orientation of an object.
 */
class GizmoComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The size of the gizmo lines. If not set, defaults to two times the radius of the entity.
		 * @type {number | undefined}
		 * @private
		 */
		this._size = undefined;

		/**
		 * Whether or not the gizmo lines are relative to the orientation of the entity.
		 * @type {boolean}
		 * @private
		 */
		this._relativeToEntity = true;

		/**
		 * The joint for the model to show the gizmo. If empty, the entity itself is used.
		 * @type {string}
		 * @private
		 */
		this._joint = '';

		/**
		 * The joint's ThreeJs object.
		 * @type {THREE.Object3D}
		 * @private
		 */
		this._jointObject = null;

		/**
		 * The model for the joint.
		 * @type {ModelComponent}
		 * @private
		 */
		this._model = null;

		/**
		 * The line mesh.
		 * @type {LineMesh}
		 * @private
		 */
		this._lineMesh = null;

		// Set the radius to twice the entity's radius.
		this.__setRadius(entity.getExtentsRadius() * 2.0);

		// It uses the entity's orientation.
		this.__setUsesEntityOrientation(this._relativeToEntity);
	}

	/**
	 * Gets the size of the gizmo lines. If not set, defaults to two times the extents radius of the entity.
	 * @returns {number}
	 */
	getSize() {
		if (this._size !== undefined) {
			return this._size;
		}
		else {
			return Math.max(0.0001, this.getEntity().getExtentsRadius() * 2.0);
		}
	}

	/**
	 * Sets the size of the gizmo lines. If not set, defaults to two times the extents radius of the entity.
	 * @param {number} [size]
	 */
	setSize(size) {
		this._size = size;
		this.__setRadius(this.getSize());
	}

	/**
	 * Gets whether or not the gizmo lines are relative to the orientation of the entity. Defaults to true.
	 * @returns {boolean}
	 */
	isRelativeToEntity() {
		return this._relativeToEntity;
	}

	/**
	 * Sets whether or not the gizmo lines are relative to the orientation of the entity.
	 * @param {boolean} relativeToEntity
	 */
	setRelativeToEntity(relativeToEntity) {
		this._relativeToEntity = relativeToEntity;
		this.__setUsesEntityOrientation(this._relativeToEntity);
	}

	/**
	 * Sets the gizmo to be at the joint on the specified model. If no model is given, the first model in the entity is used.
	 * @param {string} joint
	 * @param {ModelComponent} [model]
	 */
	setJoint(joint, model) {
		this._joint = joint;
		if (!model) {
			const modelFromEntity = /** @type {ModelComponent} */(this.getEntity().get('model'));
			if (modelFromEntity !== null) {
				this._model = modelFromEntity;
			}
		}
		else {
			this._model = model;
		}
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// If a joint is specified, setup the joint's ThreeJs object.
		if (this._joint !== '' && (this._jointObject === null || this._jointObject.name !== this._joint) && this._model !== null) {
			this._jointObject = this._model.getThreeJsObjectByName(this._joint);
		}
		// If the joint object is valid,
		if (this._jointObject !== null) {
			// Get the position of the joint within the entity by adding up the ancestor positions.
			const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			let jointAncestor = this._jointObject;
			GizmoComponent._tempThreeJsVector3.copy(jointAncestor.position);
			GizmoComponent._tempThreeJsQuaternion.copy(jointAncestor.quaternion);
			while (jointAncestor.parent !== null && jointAncestor.parent !== this._model.getThreeJsObjects()[0]) {
				jointAncestor = jointAncestor.parent;
				GizmoComponent._tempThreeJsVector3.add(jointAncestor.position);
				GizmoComponent._tempThreeJsQuaternion.multiplyQuaternions(jointAncestor.quaternion, GizmoComponent._tempThreeJsQuaternion);
			}
			position.copyFromThreeJs(GizmoComponent._tempThreeJsVector3);
			position.mult(position, 0.001); // Get it into the proper km scale.
			position.rotate(this._model.getRotation(), position); // Rotate it to be in the model component's frame.

			// Set the Three.js object position the entity's camera-space position.
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera, position, true);

			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);

			const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			orientation.copyFromThreeJs(GizmoComponent._tempThreeJsQuaternion);
			orientation.mult(this._model.getRotation(), orientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity(), orientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
		}
		else {
			if (this._relativeToEntity) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());
			}
			else {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
			}

			// Set the Three.js object position the entity's camera-space position.
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(this.getThreeJsObjects()[0], this.getSize());

		this._lineMesh.prepareForRender(camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		this._lineMesh = new _internal__WEBPACK_IMPORTED_MODULE_0__.LineMesh(this);
		const positions = [];
		positions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));
		positions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0));
		positions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));
		positions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0));
		positions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0));
		positions.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1));
		this._lineMesh.setPositions(positions);
		const colors = [];
		colors.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0));
		colors.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 0, 0));
		colors.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0));
		colors.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 1, 0));
		colors.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1));
		colors.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 1));
		this._lineMesh.setColors(colors);
		const widths = [];
		widths.push(2);
		widths.push(2);
		widths.push(2);
		widths.push(2);
		widths.push(2);
		widths.push(2);
		this._lineMesh.setWidths(widths);

		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}
}

/**
 * A temporary ThreeJs Vector3.
 * @type {THREE.Vector3}
 */
GizmoComponent._tempThreeJsVector3 = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3();


/***/ }),

/***/ "../pioneer/engine/src/scene/components/label_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/label_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LabelComponent": function() { return /* binding */ LabelComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Label component.
 */
class LabelComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The text to be displayed.
		 * @type {string}
		 * @private
		 */
		this._text = '<PLACEHOLDER>';

		/**
		 * The font face.
		 * @type {string}
		 * @private
		 */
		this._fontFamily = 'Arial';

		/**
		 * The font size in pixels.
		 * @type {number}
		 * @private
		 */
		this._fontSize = 16;

		/**
		 * The color of the text.
		 * @type {Color}
		 * @private
		 */
		this._color = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color();
		this._color.freeze();

		/**
		 * A flag the determines whether or not the label ignores the distance when determining visibility.
		 * @type {boolean}
		 * @private
		 */
		this._ignoreDistance = false;

		/**
		 * The alignment of the text.
		 * @type {Vector2}
		 * @private
		 */
		this._alignment = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.0, 0.5);
		this._alignment.freeze();

		/**
		 * The pixel offset of the text.
		 * @type {Vector2}
		 * @private
		 */
		this._pixelOffset = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(0, 0);
		this._pixelOffset.freeze();

		/**
		 * The pixel-space size of the text.
		 * @type {Vector2}
		 * @private
		 */
		this._pixelSize = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();

		/**
		 * The pixel device ratio. Saved here when text is created.
		 * @type {number}
		 * @private
		 */
		this._devicePixelRatio = 1;

		/**
		 * The canvas to draw text on.
		 * @type {HTMLCanvasElement}
		 * @private
		 */
		this._canvas = null;

		/**
		 * The normal-space bounds.
		 * @type {Map<CameraComponent, Rect>}
		 * @private
		 */
		this._normalSpaceBounds = new Map();

		// Set the font family and font size from the config, if it exists.
		const fontFamily = entity.getScene().getEngine().getConfig().getValue('fontFamily');
		if (typeof fontFamily === 'string') {
			this._fontFamily = fontFamily;
		}
		const fontSize = entity.getScene().getEngine().getConfig().getValue('fontSize');
		if (typeof fontSize === 'number') {
			this._fontSize = fontSize;
		}

		// Set the radius to infinity, since it will always show, regardless of distance.
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Returns the text.
	 * @returns {string}
	 */
	getText() {
		return this._text;
	}

	/**
	 * Sets the text. Defaults to ''.
	 * @param {string} text
	 */
	setText(text) {
		this._text = text;
		this._updateText();
	}

	/**
	 * Gets the font face.
	 * @returns {string}
	 */
	getFontFamily() {
		return this._fontFamily;
	}

	/**
	 * Sets the font face. Defaults to Arial.
	 * @param {string} fontFamily
	 */
	setFontFamily(fontFamily) {
		this._fontFamily = fontFamily;
		this._updateText();
	}

	/**
	 * Gets the font size in pixels.
	 * @returns {number}
	 */
	getFontSize() {
		return this._fontSize;
	}

	/**
	 * Sets the font size in pixels. Defaults to 16.
	 * @param {number} fontSize
	 */
	setFontSize(fontSize) {
		this._fontSize = fontSize;
		this._updateText();
	}

	/**
	 * Gets the text color.
	 * @returns {Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the text color. Defaults to white.
	 * @param {Color} color - the color to set
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
	}

	/**
	 * Ignores the distance when determining whether it should show the label or not. Defaults to false.
	 * @param {boolean} enable
	 */
	setIgnoreDistance(enable) {
		this._ignoreDistance = enable;
	}

	/**
	 * Gets the label alignment.
	 * @returns {Vector2}
	 */
	getAlignment() {
		return this._alignment;
	}

	/**
	 * Sets the alignment. Defaults to the left aligned to the entity and vertically centered (0, .5). Each component should only be between 0 and 1.
	 * @param {Vector2} alignment - the alignment to set
	 */
	setAlignment(alignment) {
		this._alignment.thaw();
		this._alignment.copy(alignment);
		this._alignment.freeze();
		this._updateText();
	}

	/**
	 * Gets the pixel offset.
	 * @returns {Vector2}
	 */
	getPixelOffset() {
		return this._pixelOffset;
	}

	/**
	 * Sets the pixel offset.
	 * @param {Vector2} pixelOffset
	 */
	setPixelOffset(pixelOffset) {
		this._pixelOffset.thaw();
		this._pixelOffset.copy(pixelOffset);
		this._pixelOffset.freeze();
	}

	/**
	 * Gets the normal-space bounds of the label for the given camera. Used by the selection controller for selecting labels.
	 * @param {CameraComponent} camera
	 * @returns {Rect}
	 */
	getNormalSpaceBounds(camera) {
		return this._normalSpaceBounds.get(camera);
	}

	/**
	 * Prepares the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		const cameraSpacePosition = this.getEntity().getCameraSpacePosition(camera);

		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);

		// If the camera is a Spout camera, use Spout for the render size.
		const renderSize = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
		if (camera.getType() === 'spout') {
			const spoutComponent = /** @type {SpoutComponent} */(camera);
			renderSize.set(spoutComponent.getForGlobe() ? -spoutComponent.getRenderWidth() : spoutComponent.getRenderWidth(), spoutComponent.getRenderWidth());
			renderSize.div(renderSize, 4);
		}
		// Otherwise use the viewport size.
		else {
			renderSize.copy(camera.getViewport().getBounds().size);
		}

		// Set the uniforms.
		const pixelOffset = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
		const pixelSize = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
		const renderUp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const renderRight = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		pixelOffset.set(
			(this._pixelOffset.x - this._alignment.x * this._canvas.width),
			(this._pixelOffset.y - this._alignment.y * this._canvas.height));
		pixelSize.set(this._canvas.width, this._canvas.height);
		camera.getEntity().getOrientation().getAxis(renderUp, 2);
		camera.getEntity().getOrientation().getAxis(renderRight, 0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], 'pixelOffset', pixelOffset);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], 'pixelSize', pixelSize);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], 'renderSize', renderSize);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'renderUp', renderUp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'renderRight', renderRight);

		// Update the normal-space bounds.
		if (camera.getType() !== 'spout') {
			// Get the normalized bounds.
			if (!this._normalSpaceBounds.has(camera)) {
				this._normalSpaceBounds.set(camera, new _internal__WEBPACK_IMPORTED_MODULE_0__.Rect());
			}

			const normalSpaceBounds = this._normalSpaceBounds.get(camera);
			normalSpaceBounds.thaw();
			const normalSpacePosition = this.getEntity().getNormalSpacePosition(camera);
			normalSpaceBounds.origin.x = normalSpacePosition.x + 2.0 * (this._pixelOffset.x - this._alignment.x * this._pixelSize.x) / renderSize.x;
			normalSpaceBounds.origin.y = normalSpacePosition.y + 2.0 * (this._pixelOffset.y - this._alignment.y * this._pixelSize.y) / renderSize.y;
			normalSpaceBounds.size.x = 2.0 * this._pixelSize.x / renderSize.x;
			normalSpaceBounds.size.y = 2.0 * this._pixelSize.y / renderSize.y;
			normalSpaceBounds.freeze();
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelSize);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelOffset);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(renderUp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(renderRight);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(renderSize);

		// Fade the label when the camera is close.
		let alphaMultiplier = 1.0;
		const normalizedRadiusOfEntity = this.getEntity().getNormalSpaceExtentsRadius(camera);
		if (!this._ignoreDistance) {
			alphaMultiplier *= _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((0.02 - normalizedRadiusOfEntity) / 0.02);
		}

		// Fade the label when the entity is visually close to its parent and its parent also has a label.
		if (this.getEntity().getParent() !== null) {
			const normalizedEntityDistanceFromParent = camera.getNormalSpaceRadiusFromRadius(this.getEntity().getPosition().magnitude(), cameraSpacePosition.magnitude());
			const normalizedParentRadius = this.getEntity().getParent().getNormalSpaceExtentsRadius(camera);
			if (!this._ignoreDistance && normalizedParentRadius < 0.02) {
				alphaMultiplier *= _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((normalizedEntityDistanceFromParent - 0.02) / 0.02);
			}
		}

		// If it is occluded, hide label. Check parent always, too.
		if (this.getEntity().getParent() !== null && this.getEntity().getParent().isOccludingPosition(camera, cameraSpacePosition)) {
			alphaMultiplier = 0;
		}
		else if (camera.isPositionOccluded(cameraSpacePosition)) {
			alphaMultiplier = 0;
		}

		// Set the color of the sprite and include the alpha multiplier.
		const color = _internal__WEBPACK_IMPORTED_MODULE_0__.Color.pool.get();
		color.copy(this._color);
		color.a *= alphaMultiplier;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'colorMultiplier', color);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Color.pool.release(color);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Create the Three.js object.
		if (LabelComponent._useCount === 0) {
			// Create the shared geometry as a square 0, 0 to 1, 1.
			LabelComponent._threeJsGeometry = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createGeometry([{ name: 'position', dimensions: 2 }, { name: 'uv', dimensions: 2 }], false);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(LabelComponent._threeJsGeometry, 'position', new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]));
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(LabelComponent._threeJsGeometry, 'uv', new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]));
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(LabelComponent._threeJsGeometry, new Uint16Array([0, 1, 2, 2, 3, 0]));

			// Create the shared material.
			LabelComponent._threeJsMaterial = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ShaderMaterial({
				uniforms: {
					colorMultiplier: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4(1.0, 1.0, 1.0, 1.0)),
					colorTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					pixelOffset: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2(0, 0)),
					pixelSize: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2(1, 1)),
					renderSize: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2(1, 1)),
					renderUp: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 1, 0)),
					renderRight: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0)),

					..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
				},
				vertexShader: `
					uniform vec2 pixelOffset;
					uniform vec2 pixelSize;
					uniform vec2 renderSize;
					uniform vec3 renderUp;
					uniform vec3 renderRight;
					varying vec2 fUV;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

					void main() {
						// Get a frame for the label to be on the x-y axis.
						vec3 forward = (modelMatrix * vec4(0, 0, 0, 1.)).xyz;
						float distance = length(forward);
						forward = normalize(forward);
						vec3 up = normalize(renderUp);
						vec3 right = normalize(cross(forward, up));

						// Setup the up and right vectors.
						up *= (position.y * pixelSize.y + pixelOffset.y) / renderSize.y * distance;
						right *= (position.x * pixelSize.x + pixelOffset.x) / renderSize.x * distance * projectionMatrix[1][3];

						// Do the transforms.
						vec4 viewPosition = modelViewMatrix * vec4(up + right, 1.);
						gl_Position = projectionMatrix * viewPosition;

						fUV = uv;

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
					}`,
				fragmentShader: `
					precision highp float;

					uniform vec4 colorMultiplier;
					uniform sampler2D colorTexture;
					varying vec2 fUV;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

					void main(void) {
						gl_FragColor = texture2D(colorTexture, fUV);
						gl_FragColor *= colorMultiplier;

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
					}`,
				side: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide
			});
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupLogDepthBuffering(LabelComponent._threeJsMaterial);
		}
		LabelComponent._useCount += 1;

		// Create the material.
		const material = LabelComponent._threeJsMaterial.clone();
		this.getThreeJsMaterials().push(material);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setTransparent(material, true);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOverlay(material, true);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(material, 'colorMultiplier', this._color);

		// Create the object.
		const object = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObjectGivenGeometry(this, material, LabelComponent._threeJsGeometry);
		this.getThreeJsObjects().push(object);

		// Create the canvas.
		this._canvas = document.createElement('canvas');
		this._canvas.width = 1;
		this._canvas.height = 1;

		// Update the text.
		this._updateText();
	}

	/**
	 * Unloads the resources.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		LabelComponent._useCount -= 1;
		if (LabelComponent._useCount === 0) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyGeometry(LabelComponent._threeJsGeometry);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyMaterial(LabelComponent._threeJsMaterial);
		}
		const object = this.getThreeJsObjects()[0];
		if (object.parent !== null) {
			object.parent.remove(object);
		}
		this.getThreeJsMaterials()[0].dispose();
		this._canvas = null;
	}

	_updateText() {
		if (this._canvas === null) {
			return;
		}

		const context = this._canvas.getContext('2d');
		this._devicePixelRatio = window.devicePixelRatio;

		// Get the dimensions of the text.
		context.font = this._fontSize + 'px ' + this._fontFamily;
		const metrics = context.measureText(this._text);
		this._pixelSize.set(metrics.width * this._devicePixelRatio, this._fontSize * this._devicePixelRatio);

		// Get the texture size. It needs to be a power of 2.
		const textureWidth = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.ceilPow2(this._pixelSize.x);
		const textureHeight = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.ceilPow2(this._pixelSize.y);

		if (textureWidth !== this._canvas.width || textureHeight !== this._canvas.height) {
			this._canvas.width = textureWidth;
			this._canvas.height = textureHeight;
		}

		context.clearRect(0, 0, this._canvas.width, this._canvas.height);
		this._canvas.style.width = (textureWidth / this._devicePixelRatio) + 'px';
		this._canvas.style.height = (textureHeight / this._devicePixelRatio) + 'px';
		context.font = this._pixelSize.y + 'px ' + this._fontFamily; // need to do this again due to browser bug
		context.fillStyle = 'rgba(255, 255, 255, 255)';
		context.fillText(this._text, (this._canvas.width - this._pixelSize.x) * _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(this._alignment.x), (this._canvas.height - this._pixelSize.y * 0.1875) - (this._canvas.height - this._pixelSize.y) * _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(this._alignment.y));

		const material = this.getThreeJsMaterials()[0];
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformTexture(material, 'colorTexture', _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTextureFromCanvas(this._canvas));
	}
}

/**
 * A global shared material, copied by labels.
 * @type {THREE.ShaderMaterial}
 */
LabelComponent._threeJsMaterial = null;

/**
 * A global shared geometry unit square with a corner at (0, 0), copied by labels.
 * @type {THREE.BufferGeometry}
 */
LabelComponent._threeJsGeometry = null;

/**
 * The count for the number of labels used.
 * @type {number}
 */
LabelComponent._useCount = 0;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/light_source_component.js":
/*!************************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/light_source_component.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LightSourceComponent": function() { return /* binding */ LightSourceComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A light source. Does not produce any actual light per se, but is used by other shaders when referenced. Shaders can use the 'lightSourceColor' and 'lightSourcePos' uniforms, and call setUniforms() to use the light source.
 */
class LightSourceComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The color of the light. Alpha is not used.
		 * @type {Color}
		 * @private
		 */
		this._color = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1);
		this._color.freeze();

		/**
		 * The absolute magnitude of the light.
		 * @type {number}
		 * @private
		 */
		this._absoluteMagnitude = 1;

		// Make the light source work everywhere.
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Gets the color. Defaults to white.
	 * @returns {Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color.
	 * @param {Color} color - the color to set
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
	}

	/**
	 * Gets the absolute magnitude. Defaults to 1.
	 * @returns {number}
	 */
	getAbsoluteMagnitude() {
		return this._absoluteMagnitude;
	}

	/**
	 * Sets the absolute magnitude.
	 * @param {number} absoluteMagnitude
	 */
	setAbsoluteMagnitude(absoluteMagnitude) {
		this._absoluteMagnitude = absoluteMagnitude;
	}

	/**
	 * Loads the light source, adding it to the scene.
	 * @returns {Promise<void | void[]>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		this.getEntity().getScene().__addLightSource(this.getEntity().getName(), this.getTypeIndex());
		return Promise.resolve();
	}

	/**
	 * Unloads the light source, removing it from the scene.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		this.getEntity().getScene().__removeLightSource(this.getEntity().getName(), this.getTypeIndex());
	}

	/**
	 * Sets the type index. Overriden to ensure that the scene has the correct type index.
	 * @param {number} typeIndex
	 * @override
	 * @internal
	 */
	__setTypeIndex(typeIndex) {
		if (this.getLoadState() === 'loaded') {
			this.getEntity().getScene().__removeLightSource(this.getEntity().getName(), this.getTypeIndex());
		}
		super.__setTypeIndex(typeIndex);
		if (this.getLoadState() === 'loaded') {
			this.getEntity().getScene().__addLightSource(this.getEntity().getName(), this.getTypeIndex());
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/model_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/model_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModelComponent": function() { return /* binding */ ModelComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A model, usually imported from a GLTF file.
 */
class ModelComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The url of the model.
		 * @type {string}
		 * @private
		 */
		this._url = '';

		/**
		 * The entities uses for shadows. Derived from the shadow entity names.
		 * @type {EntityRef[]}
		 * @private
		 */
		this._shadowEntities = [];

		/**
		 * The translation to apply to the model when rendering it.
		 * @type {Vector3}
		 * @private
		 */
		this._translation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._translation.freeze();

		/**
		 * The rotation to apply to the model when rendering it.
		 * @type {Quaternion}
		 * @private
		 */
		this._rotation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this._rotation.freeze();

		/**
		 * The mapping of file names to urls when loading GLTF references.
		 * @type {Map<string, string>}
		 * @private
		 */
		this._urlReferenceMap = new Map();

		/**
		 * The Three.js animation clips, keyed by name.
		 * @type {Map<string, THREE.AnimationClip>}
		 * @private
		 */
		this._threeJsAnimationClips = new Map();

		/**
		 * A mapping of names to objects of objects that should be hidden.
		 * @type {FastMap<string, THREE.Object3D>}
		 * @private
		 */
		this._hiddenObjects = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The scale to apply to the model.
		 * @type {Vector3}
		 * @private
		 */
		this._scale = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.001, 0.001, 0.001);
		this._scale.freeze();

		/**
		 * The size of the actual model without any scaling. Defaults to NaN since it doesn't
		 * know the actual model radius until the model is loaded.
		 * @type {number}
		 * @private
		 */
		this._modelRadius = NaN;

		/**
		 * The url for the environment cube map.
		 * @type {string}
		 * @private
		 */
		this._environmentCubemapUrl = '';

		/**
		 * The url for the cylindrical cube map.
		 * @type {string}
		 * @private
		 */
		this._environmentCylindricalUrl = '';

		/**
		 * The environment cube map.
		 * @type {THREE.Texture}
		 * @private
		 */
		this._environmentCubemap = null;

		/**
		 * The intensity of the environment.
		 * @type {number}
		 * @private
		 */
		this._environmentIntensity = 0.5;

		/**
		 * The dynamic environment map texture, if used.
		 * @type {DynamicEnvironmentMapComponent}
		 * @private
		 */
		this._dynamicEnvironmentMapComponent = null;

		/**
		 * The pixel radius interval over which the model is visible. It will fade to nothing for 50% outside of these bounds.
		 * @type {Interval | undefined}
		 */
		this._pixelRadiusVisibleInterval = undefined;

		/**
		 * The flag that if true, uses compressed textures.
		 * @type {boolean}
		 * @private
		 */
		this._useCompressedTextures = false;

		/**
		 * A bound function for use in callbacks.
		 * @type {function():void}
		 * @private
		 */
		this._onConfigChanged = this._onConfigChanged.bind(this);

		this.__setRadius(this.getEntity().getExtentsRadius());
	}

	/**
	 * Returns the url of the model file.
	 * @returns {string}
	 */
	getUrl() {
		return this._url;
	}

	/**
	 * Sets the url of the model file.
	 * @param {string} url
	 */
	setUrl(url) {
		if (this._url !== '') {
			this.getEntity().getScene().getEngine().getDownloader().cancel(this._url);
		}
		this.resetResources();
		this._modelRadius = NaN;
		this._loading = false;
		this._url = url;
	}

	/**
	 * Sets an object to be hidden on the model.
	 * @param {string} name - The object name
	 * @param {boolean} hidden - Whether or not it should be hidden
	 */
	setHiddenObject(name, hidden) {
		if (hidden && !this._hiddenObjects.has(name)) {
			this._hiddenObjects.set(name, null);
		}
		else if (!hidden && this._hiddenObjects.has(name)) {
			this._hiddenObjects.delete(name);
		}
	}

	/**
	 * Gets the translation of the model.
	 * @returns {Vector3} translation
	 */
	getTranslation() {
		return this._translation;
	}

	/**
	 * Sets the translation of the model. It defaults to the zero vector.
	 * @param {Vector3} translation
	 */
	setTranslation(translation) {
		this._translation.thaw();
		this._translation = translation;
		this._translation.freeze();
	}

	/**
	 * Gets the scale of the model.
	 * @returns {Vector3} scale
	 */
	getScale() {
		return this._scale;
	}

	/**
	 * Sets the scale of the model. It defaults to 0.001, since most models are in meters, not kilometers.
	 * @param {Vector3 | number} scale
	 */
	setScale(scale) {
		this._scale.thaw();
		if (typeof scale === 'number') {
			this._scale.set(scale, scale, scale);
		}
		else {
			this._scale.copy(scale);
		}
		this._scale.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(this.getThreeJsObjects()[0], this._scale);
		if (!isNaN(this._modelRadius)) {
			this.__setRadius(Math.max(this._scale.x, this._scale.y, this._scale.z) * this._modelRadius);
		}
		else {
			this.__setRadius(this.getEntity().getExtentsRadius());
		}
	}

	/**
	 * Gets the rotation applied to the model. Defaults to the identity rotation.
	 * @returns {Quaternion}
	 */
	getRotation() {
		return this._rotation;
	}

	/**
	 * Sets the rotation applied to the modeol.
	 * @param {Quaternion} rotation
	 */
	setRotation(rotation) {
		this._rotation.thaw();
		this._rotation.copy(rotation);
		this._rotation.freeze();
	}

	/**
	 * Gets the url of the environment cubemap applied to the model during loading
	 * @returns {string}
	 */
	getEnvironmentCubemapUrl() {
		return this._environmentCubemapUrl;
	}

	/**
	 * Sets the url of the environment cubemap applied to the model during loading
	 * @param {string} url - the url is used by TextureLoader.loadCubeTexture and follows its rules for the $FACE variable.
	 */
	setEnvironmentCubemapUrl(url) {
		this._environmentCubemapUrl = url;
	}

	/**
	 * Gets the intensity multiplier applied to environment lighting
	 * @returns {number}
	 */
	getEnvironmentIntensity() {
		return this._environmentIntensity;
	}

	/**
	 * Sets the intensity multiplier applied to environment lighting
	 * @param {number} environmentIntensity
	 */
	setEnvironmentIntensity(environmentIntensity) {
		this._environmentIntensity = environmentIntensity;
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[i], 'environmentIntensity', this._environmentIntensity);
		}
	}

	/**
	 * Gets the url of the cylindrical cubemap applied to the model during loading
	 * @returns {string}
	 */
	getEnvironmentCylindricalUrl() {
		return this._environmentCylindricalUrl;
	}

	/**
	 * Sets the url of the cylindrical cubemap applied to the model during loading
	 * @param {string} url - url of the image to use
	 */
	setEnvironmentCylindricalUrl(url) {
		this._environmentCylindricalUrl = url;
	}

	/**
	 * Sets the pixel radius interval over which the model is visible.
	 * It will fade to nothing for 5% outside of these bounds.
	 * The material must already have transparency enabled for it to work.
	 * Defaults to [0, +infinity].
	 * @param {Interval | undefined} interval
	 */
	setPixelRadiusVisibleInterval(interval) {
		if (interval !== undefined) {
			if (this._pixelRadiusVisibleInterval === undefined) {
				this._pixelRadiusVisibleInterval = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(interval.min, interval.max);
			}
			else {
				this._pixelRadiusVisibleInterval.copy(interval);
			}
		}
		else {
			this._pixelRadiusVisibleInterval = undefined;
			for (const material of this.getThreeJsMaterials()) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'alphaMultiplier', 1);
			}
			this.getThreeJsObjects()[0].visible = true;
		}
	}

	/**
	 * Sets whether or not the dynamic environment map is enabled.
	 * @param {DynamicEnvironmentMapComponent} dynamicEnvironmentMapComponent
	 */
	setDynamicEnvironmentMapComponent(dynamicEnvironmentMapComponent) {
		this._dynamicEnvironmentMapComponent = dynamicEnvironmentMapComponent;
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			const material = this.getThreeJsMaterials()[i];
			if (material.uniforms['dynEnvTexture'] !== undefined) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(material, 'dynEnvMap', true);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformTexture(material, 'dynEnvTexture', this._dynamicEnvironmentMapComponent.getTexture());
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'dynEnvFaceSize', dynamicEnvironmentMapComponent.getFaceSize());
			}
		}
		// Disable the static environment cube map.
		if (this._environmentCubemap !== null) {
			this._environmentCubemap.dispose();
			this._environmentCubemap = null;
		}
	}

	/**
	 * Gets the flag that if true, uses compressed textures.
	 * @returns {boolean}
	 */
	getUseCompressedTextures() {
		return this._useCompressedTextures;
	}

	/**
	 * Sets the flag that if true, uses compressed textures.
	 * @param {boolean} useCompressedTextures
	 */
	setUseCompressedTextures(useCompressedTextures) {
		this._useCompressedTextures = useCompressedTextures;
	}

	/**
	 * Sets the mapping of file names to urls when loading GLTF references.
	 * @param {Map<string, string>} urlReferenceMap;
	 */
	setURLReferenceMap(urlReferenceMap) {
		this._urlReferenceMap.clear();
		for (const entry of urlReferenceMap) {
			this._urlReferenceMap.set(entry[0], entry[1]);
		}
	}

	/**
	 * Gets the Three.js animation clip of the given name. Returns null if the clip doesn't exist.
	 * @param {string} name
	 * @returns {THREE.AnimationClip}
	 */
	getAnimationClip(name) {
		return this._threeJsAnimationClips.get(name) || null;
	}

	/**
	 * Gets a material by name.
	 * @param {string} name
	 * @returns {THREE.ShaderMaterial | null}
	 */
	getMaterial(name) {
		const materials = this.getThreeJsMaterials();
		for (let i = 0, l = materials.length; i < l; i++) {
			if (materials[i].name === name) {
				return materials[i];
			}
		}
		return null;
	}

	/**
	 * Replaces a material with a new material.
	 * @param {string} name
	 * @param {THREE.ShaderMaterial} newMaterial
	 */
	updateMaterial(name, newMaterial) {
		// Find the material by name and replace it in the materials list.
		const materials = this.getThreeJsMaterials();
		let foundMaterial;
		for (let i = 0; i < materials.length; i++) {
			const material = materials[i];
			if (material.name === name) {
				foundMaterial = material;
				materials.splice(i, 1);
				materials.push(newMaterial);
				break;
			}
		}
		if (!foundMaterial) {
			throw new Error(`No material with the name ${name} was found in ${this}.`);
		}
		// Replace the material in every object that has it.
		for (let i = 0, l = this.getThreeJsObjects().length; i < l; i++) {
			const object = this.getThreeJsObjects()[i];
			if (object instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh) {
				if (object.material === foundMaterial) {
					object.material = newMaterial;
					object.material.name = name;
				}
			}
		}
	}

	/**
	 * Gets the number of shadow entities. Can be used to enumerate the shadow entities.
	 * @returns {number}
	 */
	getNumShadowEntities() {
		return this._shadowEntities.length;
	}

	/**
	 * Returns the shadow entity or its name at the index.
	 * @param {number} index
	 * @returns {string | undefined}
	 */
	getShadowEntity(index) {
		return this._shadowEntities[index]?.getName();
	}

	/**
	 * Sets the shadow entities. Each element can be either the name of an entity or an entity itself.
	 * @param {string[]} shadowEntities
	 */
	setShadowEntities(shadowEntities) {
		this._shadowEntities = [];
		for (const shadowEntity of shadowEntities) {
			this._shadowEntities.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), shadowEntity));
		}
		const shadowEntitiesEnabled = (shadowEntities.length > 0);
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[i], 'shadowEntities', shadowEntitiesEnabled);
		}
	}

	/**
	 * Updates the camera-dependent parts of the component.
	 * @param {CameraComponent} camera
	 * @override
	 */
	__prepareForRender(camera) {
		// Make any objects hidden that should be hidden.
		for (let i = 0, l = this._hiddenObjects.size; i < l; i++) {
			const entry = this._hiddenObjects.getAt(i);
			if (entry.value === null) {
				entry.value = this.getThreeJsObjectByName(entry.key);
			}
			if (entry.value !== null) {
				entry.value.visible = false;
			}
		}

		// Set the alpha multiplier based on conditions.
		if (this._pixelRadiusVisibleInterval !== undefined) {
			const pixelRadius = this.getEntity().getPixelSpaceExtentsRadius(camera);
			const alphaMultiplier = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(Math.min(
				1 + 2 * (pixelRadius - this._pixelRadiusVisibleInterval.min) / this._pixelRadiusVisibleInterval.min,
				isFinite(this._pixelRadiusVisibleInterval.max) ? (1 - 2 * (pixelRadius - this._pixelRadiusVisibleInterval.max) / this._pixelRadiusVisibleInterval.max) : 1));
			for (const material of this.getThreeJsMaterials()) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'alphaMultiplier', alphaMultiplier);
			}
			if (alphaMultiplier === 0) {
				this.getThreeJsObjects()[0].visible = false;
			}
		}

		// Apply the position to the ThreeJS object.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera, this._translation, true);

		// Apply the rotation and orientation to the ThreeJS object.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity(), this._rotation);

		// Setup the regular uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setUniforms(this.getThreeJsMaterials(), camera, this.getEntity(), this._shadowEntities, null, false);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		const engine = this.getEntity().getScene().getEngine();

		const binary = this._url.startsWith('blob:') || this._url.endsWith('.glb');
		try {
			const download = await engine.getDownloader().download(this._url, binary);

			// If we're no longer loading or the download was canceled, do nothing.
			if (this.getLoadState() !== 'loading' || download.status === 'cancelled') {
				return;
			}
			// If the download failed, error.
			else if (download.status === 'failed') {
				throw new Error('Failed to load model component file "' + download.url + '": ' + download.errorMessage);
			}
			// If the download isn't the right format, error.
			else if (!download.actualUrl.endsWith('.gltf') && !download.actualUrl.endsWith('.glb') && !download.actualUrl.startsWith('blob:')) {
				throw new Error('Unknown model format.');
			}

			// Create and setup the Three.js loading manager needed by the ThreeJsGLTFLoader.
			const manager = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LoadingManager();
			// Use the standard texture loaders only if there are no replacement URLs for the references.
			if (this._urlReferenceMap.size === 0) {
				manager.addHandler(/.$/, this._useCompressedTextures ? engine.getTextureLoaderCompressed() : engine.getTextureLoader());
			}
			// If there is a reference map, replace every reference in the GLTF with the mapped URL.
			manager.setURLModifier((url) => {
				const urlFileName = url.substring(url.lastIndexOf('/') + 1);
				if (this._urlReferenceMap.has(urlFileName)) {
					return this._urlReferenceMap.get(urlFileName);
				}
				return url;
			});

			// Load and parse the rest of the model.
			const loader = new _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsGLTFLoader(manager);
			await new Promise((resolve, reject) => {
				loader.parse(download.content, _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LoaderUtils.extractUrlBase(download.actualUrl), async (gltf) => {
					// Save the root for use below.
					const root = gltf.scene;

					// Populate the Three.js objects and materials lists. Even if we're no longer loading, this makes it easier to clean.
					this._populateThreeJsObjectsAndMaterials(gltf.scene);

					// If we're no longer loading clean up and return.
					if (this.getLoadState() !== 'loading') {
						_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
					}

					// Cleans up some of the extra objects.
					this._clean();

					// Set the initial properties of the root object.
					_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupObject(this, root);

					// Set the scale of the model.
					_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(root, this._scale);

					// Set the radius based on the bounding box.
					const boundingBox = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Box3().setFromObject(root);
					this._modelRadius = Math.max(boundingBox.min.length(), boundingBox.max.length());
					this.__setRadius(Math.max(this._scale.x, this._scale.y, this._scale.z) * this._modelRadius);

					// Save the animation clips.
					for (let i = 0; i < gltf.animations.length; i++) {
						this._threeJsAnimationClips.set(gltf.animations[i].name, gltf.animations[i]);
					}

					// Load the environment map if it does have a standard material. Dynamic has priority over static.
					if (this._dynamicEnvironmentMapComponent === null && this._environmentCubemap === null) {
						// Cubemap has priority over cylindrical
						if (this._environmentCubemapUrl !== '') {
							await engine.getTextureLoader().loadCubeTexture(this._environmentCubemapUrl, true).then((cubeTexture) => {
								this._environmentCubemap = engine.getTextureLoader().generateEnvMap(cubeTexture);
							});
						}
						else if (this._environmentCylindricalUrl !== '') {
							await engine.getTextureLoader().loadTexture(this._environmentCylindricalUrl, true).then((texture) => {
								this._environmentCubemap = engine.getTextureLoader().generateEnvMap(texture);
							});
						}
					}

					// Update the materials to be the Pioneer compatible materials.
					this._updateMaterials();

					// If the config's gamma value changes, set the callback to update the model.
					this.getEntity().getScene().getEngine().getConfig().addEventListener('gammaCorrection', this._onConfigChanged);

					resolve();
				}, (error) => {
					reject(new Error(`Error loading gltf: ${error}`));
				});
			});
		}
		catch (error) {
			if (error instanceof Error) {
				error.message = `While loading model "${this._url}": ${error.message}`;
			}
			throw error;
		}
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		// Clear the hidden object references.
		for (let i = 0, l = this._hiddenObjects.size; i < l; i++) {
			this._hiddenObjects.getAt(i).value = null;
		}
		// Remove the gamma correction event listener.
		this.getEntity().getScene().getEngine().getConfig().removeEventListener('gammaCorrection', this._onConfigChanged);
		// Clear the objects and materials.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}

	/**
	 * Populates the Three.js object list with all objects, including the children.
	 * @param {THREE.Object3D} object
	 * @private
	 */
	_populateThreeJsObjectsAndMaterials(object) {
		// Add the object to the list.
		this.getThreeJsObjects().push(object);
		// If the object's materials haven't already been added to the list, add them.
		if (object instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh) {
			/** @type {THREE.ShaderMaterial | THREE.ShaderMaterial[]} */
			let materials = object.material;
			if (!Array.isArray(materials)) {
				materials = [materials];
			}
			for (const material of materials) {
				let alreadyAdded = false;
				for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
					if (this.getThreeJsMaterials()[i] === material) {
						alreadyAdded = true;
						break;
					}
				}
				if (!alreadyAdded) {
					this.getThreeJsMaterials().push(material);
				}
			}
		}
		// Go through the children.
		for (let i = 0; i < object.children.length; i++) {
			this._populateThreeJsObjectsAndMaterials(object.children[i]);
		}
	}

	/**
	 * Clean up a number of objects that aren't needed.
	 * @private
	 */
	_clean() {
		// Remove lamps and hemis.
		const removeRegex = /_(lamp|hemi)/i;
		for (let i = 0; i < this.getThreeJsObjects().length; i++) {
			const object = this.getThreeJsObjects()[i];
			if (object.name.match(removeRegex)) {
				if (object.parent) {
					object.parent.remove(object);
				}
				this.getThreeJsObjects().splice(i, 1);
				i--;
			}
		}

		// Make invisible any object with a name starting with '_root' or having a material named 'transparent'.
		// Only remove its attributes so that it doesn't break things too much.
		for (let i = 0, l = this.getThreeJsObjects().length; i < l; i++) {
			let shouldMakeInvisible = false;
			const object = this.getThreeJsObjects()[i];
			if (object instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh && object.geometry instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferGeometry) {
				if (object.name.startsWith('_root')) {
					shouldMakeInvisible = true;
				}
				if (object instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh && object.material instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Material && object.material.name === 'transparent') {
					shouldMakeInvisible = true;
				}
				if (shouldMakeInvisible) {
					object.geometry.deleteAttribute('position');
					object.geometry.deleteAttribute('normal');
				}
			}
		}
	}

	/**
	 * Manage pioneer config changes
	 * @private
	 */
	_onConfigChanged() {
		this._updateMaterials();
	}

	/**
	 * Updates the existing object materials to be ones compatible with Pioneer. Creates tangents if necessary.
	 * @private
	 */
	_updateMaterials() {
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			const oldMaterial = this.getThreeJsMaterials()[i];
			if (!(oldMaterial instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.MeshStandardMaterial)) {
				continue;
			}
			const newMaterial = this._getNewPioneerMaterial(oldMaterial);
			this.getThreeJsMaterials()[i] = newMaterial;

			// Check if the new material requires a tangent attribute.
			let needsTangents = false;
			if (newMaterial.defines['normalMap']) {
				needsTangents = true;
			}

			// Go through each object and replace the materials, computing the tangents if necessary.
			for (const object of this.getThreeJsObjects()) {
				if (object instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh) {
					let hasOldMaterial = false;
					if (Array.isArray(object.material)) {
						for (let j = 0, k = object.material.length; j < k; j++) {
							if (object.material[j] === oldMaterial) {
								object.material[j] = newMaterial;
								hasOldMaterial = true;
							}
						}
					}
					else if (object.material === oldMaterial) {
						object.material = newMaterial;
						hasOldMaterial = true;
					}

					// If the object's geometry doesn't have a tangent attribute defined, create it manually from the positions and uvs.
					if (hasOldMaterial && needsTangents && object.geometry instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferGeometry && object.geometry.getAttribute('tangent') === undefined) {
						_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.computeTangents(object.geometry);
					}
				}
			}
			oldMaterial.dispose();
		}
	}

	/**
	 * Use the Three.JS material as a basis to create a new Pioneer-compatible material.
	 * @param {THREE.MeshStandardMaterial} material
	 * @returns {THREE.ShaderMaterial}
	 * @private
	 */
	_getNewPioneerMaterial(material) {
		const newMaterial = _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.getPBR();
		newMaterial.name = material.name;
		newMaterial.transparent = material.transparent;
		newMaterial.depthWrite = material.depthWrite;
		newMaterial.side = material.side;

		if (material.map !== null) {
			// Retrieve KTX compressed format from if available
			// @ts-ignore
			const ktxFormat = material.map.ktxFormat;
			if (ktxFormat !== undefined) {
				material.map.format = ktxFormat;
			}
			newMaterial.uniforms['colorTexture'].value = material.map;
			newMaterial.defines['colorMap'] = true;
		}

		if (material.roughnessMap) {
			newMaterial.uniforms['roughnessTexture'].value = material.roughnessMap;
			newMaterial.defines['roughnessMap'] = true;
		}

		if (material.metalnessMap) {
			newMaterial.uniforms['metalnessTexture'].value = material.metalnessMap;
			newMaterial.defines['metalnessMap'] = true;
		}

		if (material.normalMap !== null) {
			newMaterial.uniforms['normalTexture'].value = material.normalMap;
			newMaterial.uniforms['normalScale'].value = material.normalScale;
			newMaterial.defines['normalMap'] = true;
		}

		// Update the emissivity.
		newMaterial.uniforms['emissiveColor'].value.copy(material.emissive);
		newMaterial.uniforms['emissiveColor'].value.multiplyScalar(material.emissiveIntensity);
		if (material.emissiveMap !== null) {
			newMaterial.uniforms['emissiveTexture'].value = material.emissiveMap;
			newMaterial.defines['emissiveMap'] = true;
		}

		newMaterial.uniforms['color'].value = material.color;
		newMaterial.uniforms['roughness'].value = material.roughness;
		newMaterial.uniforms['metalness'].value = material.metalness;

		// Apply environment map
		let textureSideLength = 0;
		if (this._dynamicEnvironmentMapComponent !== null) {
			newMaterial.defines['dynEnvMap'] = true;
			newMaterial.uniforms['dynEnvTexture'].value = this._dynamicEnvironmentMapComponent.getTexture();
			newMaterial.uniforms['dynEnvFaceSize'].value = this._dynamicEnvironmentMapComponent.getFaceSize();
		}
		else if (this._environmentCubemap !== null) {
			newMaterial.defines['envMap'] = true;
			newMaterial.defines['envIsCubeUV'] = true;

			newMaterial.uniforms['envTexture'].value = this._environmentCubemap;
			textureSideLength = this._environmentCubemap.image.height;
			newMaterial.uniforms['maxMipLevel'].value = Math.log(textureSideLength) * Math.LOG2E;
		}
		newMaterial.uniforms['environmentIntensity'].value = this._environmentIntensity;

		// Apply gamma correction.
		newMaterial.uniforms['gammaCorrectionFactor'].value = this.getEntity().getScene().getEngine().getConfig().getValue('gammaCorrection');

		// Apply shadow entity define.
		if (this._shadowEntities.length > 0) {
			newMaterial.defines['shadowEntities'] = true;
		}

		// Trigger the update in Three.js.
		newMaterial.needsUpdate = true;

		return newMaterial;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/orbital_particles_component.js":
/*!*****************************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/orbital_particles_component.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitalParticlesComponent": function() { return /* binding */ OrbitalParticlesComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * @typedef LoadFunctionReturnValue
 * @property {OrbitalElements[]} orbitalElements
 * @property {Color[]} colors
 * @property {number[]} scales
 */

/**
 * @callback LoadFunction
 * @returns {LoadFunctionReturnValue}
 */

/**
 * A particle cloud with orbital parameters.
 */
class OrbitalParticlesComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The size of each particle.
		 * @type {number}
		 * @private
		 */
		this._scaleOfParticles = 1.0;

		/**
		 * The function that loads the particle arrays.
		 * @type {LoadFunction}
		 * @private
		 */
		this._loadFunction = null;

		/**
		 * The orbital elements of each particle.
		 * @type {OrbitalElements[]}
		 * @private
		 */
		this._orbitalElementsList = [];

		/**
		 * The positions of the particles as an array.
		 * @type {Float32Array}
		 * @private
		 */
		this._offsetArray = new Float32Array(0);

		/**
		 * The sprite particles object.
		 * @type {SpriteParticles}
		 * @private
		 */
		this._spriteParticles = null;

		// Set the radius of the component to zero. It will be set to the furthest out particle.
		this.__setRadius(this.getEntity().getExtentsRadius() * 100);
	}

	/**
	 * Gets the scale of the particles flowing out.
	 * @returns {number}
	 */
	getScaleOfParticles() {
		return this._scaleOfParticles;
	}

	/**
	 * Sets the scale of the particles flowing out. Defaults to 1.0.
	 * @param {number} scaleOfParticles
	 */
	setScaleOfParticles(scaleOfParticles) {
		this._scaleOfParticles = scaleOfParticles;
		this.resetResources();
	}

	/**
	 * Sets the function that loads the particle arrays. It should return a { orbitalElements: OrbitalElements[], colors: Color[], scales: number[] } object.
	 * @param {LoadFunction} loadFunction
	 */
	setLoadFunction(loadFunction) {
		this._loadFunction = loadFunction;
		this.resetResources();
	}

	/**
	 * Updates the component.
	 * @override
	 * @internal
	 */
	__update() {
		// Do nothing if there's no particles.
		if (this._spriteParticles === null) {
			return;
		}
		// Update the particle positions from the orbital elements.
		const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const velocity = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const time = this.getEntity().getScene().getEngine().getTime();
		for (let i = 0, l = this._orbitalElementsList.length; i < l; i++) {
			this._orbitalElementsList[i].project(position, velocity, time);
			this._offsetArray[i * 3 + 0] = position.x;
			this._offsetArray[i * 3 + 1] = position.y;
			this._offsetArray[i * 3 + 2] = position.z;
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(velocity);
		this._spriteParticles.setParticleOffsets(this._offsetArray);
	}

	/**
	 * Prepares the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		this._spriteParticles.prepareForRender(camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Create the sprite particles.
		this._spriteParticles = new _internal__WEBPACK_IMPORTED_MODULE_0__.SpriteParticles(this);
		// Push the object and material to the list.
		this.getThreeJsMaterials().push(this._spriteParticles.getThreeJsMaterial());
		this.getThreeJsObjects().push(this._spriteParticles.getThreeJsObject());
		// Initialize the particles.
		await this._initializeParticles();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._spriteParticles = null;
	}

	/**
	 * Initializes the particles. Resets them if they were already initialized.
	 * @private
	 */
	async _initializeParticles() {
		if (this._loadFunction === null) {
			return;
		}
		// Load the orbital elements.
		const returnValue = await this._loadFunction();
		const numParticles = returnValue.orbitalElements.length;
		// Set the orbital elements.
		this._orbitalElementsList = [];
		let maxParticleDistance = 0;
		for (let i = 0, l = numParticles; i < l; i++) {
			// Copy them over so they can't be changed outside of the class.
			const orbitalElements = new _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements();
			orbitalElements.copy(returnValue.orbitalElements[i]);
			this._orbitalElementsList.push(orbitalElements);
			// Set the orbit apoapsis as the furthest distance the particle will go.
			const apoapsis = orbitalElements.semiMajorAxis * (1 + orbitalElements.eccentricity);
			maxParticleDistance = Math.max(maxParticleDistance, apoapsis);
		}
		// Set the radius.
		this.__setRadius(maxParticleDistance);
		// Initialize the offset array. It will be dynamic over time.
		this._offsetArray = new Float32Array(numParticles * 3);
		// Create and set the color and scale arrays, since they are static over time.
		const colorArray = new Float32Array(numParticles * 4);
		const scaleArray = new Float32Array(numParticles * 1);
		for (let i = 0, l = numParticles; i < l; i++) {
			colorArray[i * 4 + 0] = returnValue.colors[i].r;
			colorArray[i * 4 + 1] = returnValue.colors[i].g;
			colorArray[i * 4 + 2] = returnValue.colors[i].b;
			colorArray[i * 4 + 3] = returnValue.colors[i].a;
			scaleArray[i * 1 + 0] = returnValue.scales[i] * this._scaleOfParticles;
		}
		this._spriteParticles.setParticleColors(colorArray);
		this._spriteParticles.setParticleScales(scaleArray);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/particle_spray_component.js":
/*!**************************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/particle_spray_component.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ParticleSprayComponent": function() { return /* binding */ ParticleSprayComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A bunch of sprite particles in a stream.
 */
class ParticleSprayComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The length of the particle stream.
		 * @type {number}
		 * @private
		 */
		this._length = 1;

		/**
		 * The spread in degrees of the particle stream.
		 * @type {number}
		 * @private
		 */
		this._spread = 30;

		/**
		 * The number of particles.
		 * @type {number}
		 * @private
		 */
		this._numberOfParticles = 0;

		/**
		 * The speed in units/sec of the particles flowing out.
		 * @type {number}
		 * @private
		 */
		this._speedOfParticles = 0.1;

		/**
		 * The size of each particle.
		 * @type {number}
		 * @private
		 */
		this._sizeOfParticles = 0.1;

		/**
		 * The flag that says whether the spacing between particles is random. If not, the particles are evenly spaced. Certain affects look better with even spacing.
		 * @type {boolean}
		 * @private
		 */
		this._particleSpacingRandom = true;

		/**
		 * The color of the particles.
		 * @type {Color}
		 * @private
		 */
		this._colorOfParticles = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color();
		this._colorOfParticles.freeze();

		/**
		 * The offset of the particle origin. If relativeToEntityOrientation is true, this is also relative to the entity orientation.
		 * @type {Vector3}
		 */
		this._originOffset = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._originOffset.freeze();

		/**
		 * The direction of the particle stream. If relativeToEntityOrientation is true, this is also relative to the entity orientation.
		 * @type {Vector3}
		 * @private
		 */
		this._direction = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._direction.freeze();

		/**
		 * The flag that says whether or not the offset origin and direction are relative to the entity orientation.
		 * @type {boolean}
		 * @private
		 */
		this._relativeToEntityOrientation = true;

		// Set the radius of the component.
		this.__setRadius(this._length);
	}

	/**
	 * Gets the length of the particle stream.
	 * @returns {number}
	 */
	getLength() {
		return this._length;
	}

	/**
	 * Sets the length of the particle stream. Defaults to 1.
	 * @param {number} length
	 */
	setLength(length) {
		this._length = length;
		this.__setRadius(this._length);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'length', this._length);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'totalTime', this._length / this._speedOfParticles);
	}

	/**
	 * Gets the spread in degrees of the particle stream.
	 * @returns {number}
	 */
	getSpread() {
		return this._spread;
	}

	/**
	 * Sets the spread in degrees of the particle stream. Defaults to 30.
	 * @param {number} spread
	 */
	setSpread(spread) {
		this._spread = spread;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'spread', _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(this._spread));
	}

	/**
	 * Gets the number of particles.
	 * @returns {number}
	 */
	getNumberOfParticles() {
		return this._numberOfParticles;
	}

	/**
	 * Sets the number of particles. Defaults to 0.
	 * @param {number} numberOfParticles
	 */
	setNumberOfParticles(numberOfParticles) {
		this._numberOfParticles = numberOfParticles;
		this.resetResources();
	}

	/**
	 * Gets the speed in units/sec of the particles flowing out.
	 * @returns {number}
	 */
	getSpeedOfParticles() {
		return this._speedOfParticles;
	}

	/**
	 * Sets the speed in km/sec of the particles flowing out. Defaults to 0.1.
	 * @param {number} speedOfParticles
	 */
	setSpeedOfParticles(speedOfParticles) {
		this._speedOfParticles = speedOfParticles;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'totalTime', this._length / this._speedOfParticles);
	}

	/**
	 * Gets the size in km of the particles flowing out.
	 * @returns {number}
	 */
	getSizeOfParticles() {
		return this._sizeOfParticles;
	}

	/**
	 * Sets the size in km of the particles flowing out. Defaults to 1.0.
	 * @param {number} sizeOfParticles
	 */
	setSizeOfParticles(sizeOfParticles) {
		this._sizeOfParticles = sizeOfParticles;
		this.resetResources();
	}

	/**
	 * Gets the flag that says whether the spacing between particles is random. If not, the particles are evenly spaced. Certain affects look better with even spacing.
	 * @returns {boolean}
	 */
	getParticleSpacingRandom() {
		return this._particleSpacingRandom;
	}

	/**
	 * Sets the flag that says whether the spacing between particles is random. If not, the particles are evenly spaced. Certain affects look better with even spacing. Defaults to true.
	 * @param {boolean} particleSpacingRandom
	 */
	setParticleSpacingRandom(particleSpacingRandom) {
		this._particleSpacingRandom = particleSpacingRandom;
		this.resetResources();
	}

	/**
	 * Gets the color of the particles.
	 * @return {Color}
	 */
	getColorOfParticles() {
		return this._colorOfParticles;
	}

	/**
	 * Sets the color of the particles. Defaults to white.
	 * @param {Color} color
	 */
	setColorOfParticles(color) {
		this._colorOfParticles.thaw();
		this._colorOfParticles.copy(color);
		this._colorOfParticles.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'globalColor', this._colorOfParticles);
	}

	/**
	 * Gets the offset of the particle origin. If relativeToEntityOrientation is true, this is also relative to the entity orientation.
	 * @returns {Vector3}
	 */
	getOriginOffset() {
		return this._originOffset;
	}

	/**
	 * Sets the offset of the particle origin. If relativeToEntityOrientation is true, this is also relative to the entity orientation. Defaults to zero.
	 * @param {Vector3} originOffset
	 */
	setOriginOffset(originOffset) {
		this._originOffset.thaw();
		this._originOffset.copy(originOffset);
		this._originOffset.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'originOffset', this._originOffset);
	}

	/**
	 * Gets the direction of the particle stream. If relativeToEntityOrientation is true, this is also relative to the entity orientation.
	 * @returns {Vector3}
	 */
	getDirection() {
		return this._direction;
	}

	/**
	 * Sets the direction of the particle stream. If relativeToEntityOrientation is true, this is also relative to the entity orientation. Defaults to the x-axis.
	 * @param {Vector3} direction
	 */
	setDirection(direction) {
		this._direction.thaw();
		this._direction.normalize(direction);
		this._direction.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'direction', this._direction);

		// Get the perpendicular direction for orienting the particles.
		const directionPerp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		directionPerp.cross(this._direction, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis);
		if (directionPerp.isZero()) {
			directionPerp.cross(this._direction, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis);
		}
		directionPerp.normalize(directionPerp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'directionPerp', directionPerp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(directionPerp);
	}

	/**
	 * Gets the flag that says whether or not the offset origin and direction are relative to the entity orientation.
	 * @returns {boolean}
	 */
	getRelativeToEntityOrientation() {
		return this._relativeToEntityOrientation;
	}

	/**
	 * Sets the flag that says whether or not the offset origin and direction are relative to the entity orientation. Defaults to true.
	 * @param {boolean} relativeToEntityOrientation
	 */
	setRelativeToEntityOrientation(relativeToEntityOrientation) {
		this._relativeToEntityOrientation = relativeToEntityOrientation;
	}

	/**
	 * Prepares the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		const time = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(this.getEntity().getScene().getEngine().getTime(), 0, this._length / this._speedOfParticles);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'time', time);

		if (this._relativeToEntityOrientation) {
			const originOffset = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const direction = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			originOffset.rotate(this.getEntity().getOrientation(), this._originOffset);
			direction.rotate(this.getEntity().getOrientation(), this._direction);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'originOffset', originOffset);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'direction', direction);

			// Get the perpendicular direction for orienting the particles.
			const directionPerp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			directionPerp.cross(direction, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis);
			if (directionPerp.isZero()) {
				directionPerp.cross(direction, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis);
			}
			directionPerp.normalize(directionPerp);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'directionPerp', directionPerp);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(directionPerp);

			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(originOffset);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(direction);
		}

		// Set the Three.js object position the entity's camera-space position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Setup the Three.js material.
		const threeJsMaterial = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial({
			uniforms: {
				spread: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				originOffset: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),
				direction: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),
				directionPerp: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),
				length: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				time: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				totalTime: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				globalColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4(1, 1, 1, 1)),

				..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
			},
			vertexShader: ParticleSprayComponent.vertexShader,
			fragmentShader: ParticleSprayComponent.fragmentShader,
			transparent: true,
			depthWrite: false,
			blending: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AdditiveBlending,
			side: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide
		});
		_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderFix.fix(threeJsMaterial);
		this.getThreeJsMaterials().push(threeJsMaterial);

		// Setup the attribute arrays.
		const positionArray = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
		const paramsArray = new Float32Array(3 * this._numberOfParticles);
		const colorArray = new Float32Array(4 * this._numberOfParticles);
		const sizeArray = new Float32Array(1 * this._numberOfParticles);
		const indexArray = new Uint16Array([0, 1, 2, 2, 3, 0]);

		// Setup the Three.js geometry.
		const threeJsGeometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferGeometry();
		threeJsGeometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(positionArray, 2));
		threeJsGeometry.setAttribute('params', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(paramsArray, 3));
		threeJsGeometry.setAttribute('color', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(colorArray, 4));
		threeJsGeometry.setAttribute('size', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(sizeArray, 1));
		threeJsGeometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(indexArray, 1));
		threeJsGeometry.instanceCount = this._numberOfParticles;

		// Setup the Three.js object.
		const threeJsObject = /** @type {THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>} */ (_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObjectGivenGeometry(this, threeJsMaterial, threeJsGeometry));
		this.getThreeJsObjects().push(threeJsObject);

		// Set its orientation to the identity. The origin offset and direction vectors will be rotated if they are relative ot the entity.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);

		// Initialize the particles.
		this._initializeParticles();

		// Setup uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'length', this._length);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'spread', _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(this._spread));
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'totalTime', this._length / this._speedOfParticles);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'originOffset', this._originOffset);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'direction', this._direction);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'globalColor', this._colorOfParticles);

		// Get the perpendicular direction for orienting the particles.
		const directionPerp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		directionPerp.cross(this._direction, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis);
		if (directionPerp.isZero()) {
			directionPerp.cross(this._direction, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis);
		}
		directionPerp.normalize(directionPerp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector3(this.getThreeJsMaterials()[0], 'directionPerp', directionPerp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(directionPerp);
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Initializes the particles. Resets them if they were already initialized.
	 * @private
	 */
	_initializeParticles() {
		// Get the attributes and arrays.
		const paramsAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['params'];
		const colorAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['color'];
		const sizeAttribute = /** @type THREE.Mesh */(this.getThreeJsObjects()[0]).geometry.attributes['size'];
		const paramsArray = /** @type {Float32Array} */(paramsAttribute.array);
		const colorArray = /** @type {Float32Array} */(colorAttribute.array);
		const sizeArray = /** @type {Float32Array} */(sizeAttribute.array);

		// Setup the particles.
		for (let i = 0, l = this._numberOfParticles; i < l; i++) {
			paramsArray[i * 3 + 0] = Math.random() * 2 - 1;
			paramsArray[i * 3 + 1] = Math.random() * 2 - 1;
			if (this._particleSpacingRandom) {
				paramsArray[i * 3 + 2] = Math.random();
			}
			else {
				paramsArray[i * 3 + 2] = i / this._numberOfParticles;
			}
			colorArray[i * 4 + 0] = 1;
			colorArray[i * 4 + 1] = 1;
			colorArray[i * 4 + 2] = 1;
			colorArray[i * 4 + 3] = 1;
			sizeArray[i * 1 + 0] = this._sizeOfParticles;
		}

		// Flag to update the attributes.
		paramsAttribute.needsUpdate = true;
		colorAttribute.needsUpdate = true;
		sizeAttribute.needsUpdate = true;
	}
}

ParticleSprayComponent.vertexShader = `
	attribute vec2 position;
	attribute vec3 params; // x, y are in plane made by direction if z were 1, z is 0 to 1 where the particle is in the total length at time = 0
	attribute vec4 color;
	attribute float size;

	uniform float spread;
	uniform vec3 originOffset; // in model-space
	uniform vec3 direction; // in model-space
	uniform vec3 directionPerp; // in model-space
	uniform float length;
	uniform float time;
	uniform float totalTime;

	uniform mat4 modelViewMatrix;
	uniform mat4 projectionMatrix;

	varying vec2 vPosition;
	varying vec4 vColor;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

	void main() {
		float u = mod(params.z + time / totalTime, 1.0);
		float sinSpread = sin(spread);
		float uSpread = sinSpread > 0.0 ? u : (1.0 - u);
		float sizeAtU = size * max(0.1, uSpread);
		vec3 directionPerp2 = cross(direction, directionPerp);
		vec3 modelPosition = originOffset + (directionPerp * params.x * sinSpread * uSpread + directionPerp2 * params.y * sinSpread * uSpread + direction * u) * length;
		vec4 viewPosition = vec4(position.x * sizeAtU, 0, position.y * sizeAtU, 1) + modelViewMatrix * vec4(modelPosition, 1.0);
		gl_Position = projectionMatrix * viewPosition;
		gl_Position.w = viewPosition.y;

		// Set the varying variables.
		vPosition = position;
		vColor = color * (1.0 - u);

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
	}`;

ParticleSprayComponent.fragmentShader = `
	precision highp float;

	uniform vec4 globalColor;

	varying vec2 vPosition;
	varying vec4 vColor;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

	void main(void) {
		// Set the color to be a circle tinted by the color and globalColor.
		gl_FragColor = globalColor * vColor * max(0.0, 1.0 - dot(vPosition, vPosition));

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
	}`;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/rings_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/rings_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RingsComponent": function() { return /* binding */ RingsComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Rings, such as for Saturn.
 */
class RingsComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The url for the top texture.
		 * @type {string}
		 * @private
		 */
		this._topTextureUrl = '';

		/**
		 * The url for the bottom texture.
		 * @type {string}
		 * @private
		 */
		this._bottomTextureUrl = '';

		/**
		 * The inner radius.
		 * @type {number}
		 * @private
		 */
		this._innerRadius = 0;

		/**
		 * The outer radius.
		 * @type {number}
		 * @private
		 */
		this._outerRadius = 0;

		/**
		 * The distance at which the ring begins to fade (50% less than this number and it is completely gone).
		 * @type {number}
		 * @private
		 */
		this._fadeDistance = 0;

		/**
		 * The entities uses for shadows. Derived from the shadow entity names.
		 * @type {EntityRef[]}
		 * @private
		 */
		this._shadowEntities = [];

		/**
		 * A reference to the spheroid component.
		 * @type {ComponentRef<SpheroidComponent>}
		 * @private
		 */
		this._spheroidComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid');
		this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this));

		// Bind the callbacks to this.
		this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this);

		// Lets the base component to check for valid orientation when determining whether this is visible.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the top texture url.
	 * @returns {string}
	 */
	getTopTextureUrl() {
		return this._topTextureUrl;
	}

	/**
	 * Sets the top texture url.
	 * @param {string} url
	 */
	setTopTextureUrl(url) {
		this._topTextureUrl = url;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTextureIntoUniform(this, this.getThreeJsMaterials()[0], 'topTexture', this._topTextureUrl, true, false);
	}

	/**
	 * Gets the bottom texture url.
	 * @returns {string}
	 */
	getBottomTextureUrl() {
		return this._bottomTextureUrl;
	}

	/**
	 * Sets the bottom texture url.
	 * @param {string} url
	 */
	setBottomTextureUrl(url) {
		this._bottomTextureUrl = url;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTextureIntoUniform(this, this.getThreeJsMaterials()[0], 'bottomTexture', this._bottomTextureUrl, true, false);
	}

	/**
	 * Gets the inner radius.
	 * @returns {number}
	 */
	getInnerRadius() {
		return this._innerRadius;
	}

	/**
	 * Sets the inner radius.
	 * @param {number} radius
	 */
	setInnerRadius(radius) {
		this._innerRadius = radius;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'innerRadius', this._innerRadius);
	}

	/**
	 * Gets the outer radius.
	 * @returns {number}
	 */
	getOuterRadius() {
		return this._outerRadius;
	}

	/**
	 * Sets the outer radius.
	 * @param {number} radius
	 */
	setOuterRadius(radius) {
		this._outerRadius = radius;
		this.__setRadius(this._outerRadius);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'outerRadius', this._outerRadius);
	}

	/**
	 * Gets the top texture used for the rings. The alpha channel is used by the main material for shadows.
	 * @returns {THREE.Texture}
	 */
	getTopTexture() {
		const material = this.getThreeJsMaterials()[0];
		if (material !== undefined) {
			return material.uniforms['topTexture'].value;
		}
		return null;
	}

	/**
	 * Gets the distance at which the ring begins to fade (50% less than this number and it is completely gone).
	 * @returns {number}
	 */
	getFadeDistance() {
		return this._fadeDistance;
	}

	/**
	 * Sets the distance at which the ring begins to fade (50% less than this number and it is completely gone). Defaults to 0.
	 * @param {number} fadeDistance
	 */
	setFadeDistance(fadeDistance) {
		this._fadeDistance = fadeDistance;
	}

	/**
	 * Returns the shadow entity or its name at the index.
	 * @param {number} index
	 * @returns {string | undefined}
	 */
	getShadowEntity(index) {
		return this._shadowEntities[index]?.getName();
	}

	/**
	 * Sets the shadow entities. Each element can be either the name of an entity or an entity itself.
	 * @param {string[]} shadowEntities
	 */
	setShadowEntities(shadowEntities) {
		this._shadowEntities = [];
		for (const shadowEntity of shadowEntities) {
			this._shadowEntities.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), shadowEntity));
		}
		const shadowEntitiesEnabled = (shadowEntities.length > 0);
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[i], 'shadowEntities', shadowEntitiesEnabled);
		}
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @package
	 */
	__destroy() {
		// Remove the spheroid changed callback.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			spheroidComponent.removeChangedCallback(this._spheroidChangedCallback);
		}

		super.__destroy();
	}

	/**
	 * Updates the camera-non-specific parts of the component.
	 * @override
	 * @package
	 */
	__update() {
		// Update the spheroid component reference.
		this._spheroidComponentRef.update();
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// Set the alpha fade distance multiplier.
		if (this._fadeDistance > 0) {
			const posInSpriteFrame = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			const threeJsOrientation = this.getThreeJsObjects()[0].quaternion;
			orientation.copyFromThreeJs(threeJsOrientation);
			posInSpriteFrame.rotateInverse(this.getEntity().getOrientation(), this.getEntity().getCameraSpacePosition(camera));
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'alphaFadeMultiplier',
				_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(0, 1, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(2 * (Math.abs(posInSpriteFrame.z) / this._fadeDistance - 1) + 1)));
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posInSpriteFrame);
		}

		// Set the lightPosition and lightColor uniform.
		_internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setLightSourceUniforms(this.getThreeJsMaterials(), this.getEntity(), camera);

		// Setup the regular uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setUniforms(this.getThreeJsMaterials(), camera, this.getEntity(), this._shadowEntities, null, false);

		// Set the orientation to the entity's orientation.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());

		// Set the Three.js object position the entity's camera-space position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Load the textures.
		const topPromise = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTexture(this, this._topTextureUrl, true, false);
		const bottomPromise = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTexture(this, this._bottomTextureUrl, true, false);

		const [topTexture, bottomTexture] = await Promise.all([topPromise, bottomPromise]);

		// Check if the component has since been destroyed.
		if (this.isDestroyed()) {
			topTexture.dispose();
			bottomTexture.dispose();
			return;
		}

		// Create the material.
		const material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ShaderMaterial({
			uniforms: {
				ambientLightColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color()),
				lightPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0)]),
				lightColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)]),
				lightRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
				numLights: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

				entityPos: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),
				innerRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._innerRadius),
				outerRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(this._outerRadius),
				topTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(topTexture),
				bottomTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(bottomTexture),
				alphaFadeMultiplier: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1),
				spheroidEquatorialRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				spheroidPolarRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

				// Shadow Entities
				numShadowEntities: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
				shadowEntityPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()]),
				shadowEntityRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
				shadowEntitySunsetIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
				shadowEntitySunsetColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()]),

				..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
			},
			vertexShader: RingsComponent.vertexShader,
			fragmentShader: RingsComponent.fragmentShader,
			transparent: true,
			depthWrite: false,
			blending: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NormalBlending,
			side: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide
		});
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupLogDepthBuffering(material);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(material, 'shadowEntities', this._shadowEntities.length > 0);
		this.getThreeJsMaterials().push(material);

		const object = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [
			{ name: 'position', dimensions: 3 },
			{ name: 'normal', dimensions: 3 }], false);

		const numSegments = 10;
		const positions = new Float32Array(3 * numSegments * numSegments);
		const normals = new Float32Array(3 * numSegments * numSegments);
		const indices = new Uint16Array(6 * (numSegments - 1) * (numSegments - 1));
		for (let j = 0; j < numSegments; j++) {
			for (let i = 0; i < numSegments; i++) {
				const vertexIndex = i + j * numSegments;
				positions[vertexIndex * 3 + 0] = (i / (numSegments - 1)) * 2.0 - 1.0;
				positions[vertexIndex * 3 + 1] = (j / (numSegments - 1)) * 2.0 - 1.0;
				positions[vertexIndex * 3 + 2] = 0.0;
				normals[vertexIndex * 3 + 0] = 0.0;
				normals[vertexIndex * 3 + 1] = 0.0;
				normals[vertexIndex * 3 + 2] = 1.0;
				if (i + 1 < numSegments && j + 1 < numSegments) {
					indices[(i + j * (numSegments - 1)) * 6 + 0] = (i + 0) + (j + 0) * numSegments;
					indices[(i + j * (numSegments - 1)) * 6 + 1] = (i + 0) + (j + 1) * numSegments;
					indices[(i + j * (numSegments - 1)) * 6 + 2] = (i + 1) + (j + 0) * numSegments;
					indices[(i + j * (numSegments - 1)) * 6 + 3] = (i + 1) + (j + 0) * numSegments;
					indices[(i + j * (numSegments - 1)) * 6 + 4] = (i + 0) + (j + 1) * numSegments;
					indices[(i + j * (numSegments - 1)) * 6 + 5] = (i + 1) + (j + 1) * numSegments;
				}
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(object.geometry, 'position', positions);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(object.geometry, 'normal', normals);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(object.geometry, indices);
		object.material = material;
		this.getThreeJsObjects().push(object);

		// Update from the spheroid properties.
		this._spheroidChangedCallback();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Callback called when the spheroid reference is found or lost.
	 * @param {SpheroidComponent} oldRef
	 * @param {SpheroidComponent} newRef
	 * @private
	 */
	_spheroidRefChangedCallback(oldRef, newRef) {
		if (oldRef !== null) {
			oldRef.removeChangedCallback(this._spheroidChangedCallback);
		}
		if (newRef !== null) {
			newRef.addChangedCallback(this._spheroidChangedCallback);
		}
		this._spheroidChangedCallback();
	}

	/**
	 * Callback to be called when the spheroid component changed.
	 * @private
	 */
	_spheroidChangedCallback() {
		// Set the radii uniforms.
		const material = this.getThreeJsMaterials()[0];
		if (material !== null) {
			const spheroidComponent = this._spheroidComponentRef.get();
			if (spheroidComponent !== null) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'spheroidEquatorialRadius', spheroidComponent.getEquatorialRadius());
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'spheroidPolarRadius', spheroidComponent.getPolarRadius());
			}
			else {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'spheroidEquatorialRadius', 0);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'spheroidPolarRadius', 0);
			}
		}
	}
}

RingsComponent.vertexShader = `
	uniform float outerRadius;

	varying vec3 localPosition;
	varying vec3 cameraSpacePosition;
	varying vec3 modelNormal;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

	void main() {
		localPosition = position * outerRadius;
		cameraSpacePosition = (modelMatrix * vec4(localPosition, 1.)).xyz;
		modelNormal = (modelMatrix * vec4(normal, 0.)).xyz;
		vec4 viewPosition = viewMatrix * vec4(cameraSpacePosition, 1.);
		gl_Position = projectionMatrix * viewPosition;

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
	}`;

RingsComponent.fragmentShader = `
	precision highp float;

	#ifndef saturate
		#define saturate(a) clamp(a, 0.0, 1.0)
	#endif

	// Lights
	uniform vec3 ambientLightColor;
	uniform vec3 lightPositions[5];
	uniform vec3 lightColors[5];
	uniform float lightRadii[5];
	uniform int numLights;

	uniform float innerRadius;
	uniform float outerRadius;
	uniform sampler2D topTexture;
	uniform sampler2D bottomTexture;
	uniform float alphaFadeMultiplier;
	uniform float spheroidEquatorialRadius;
	uniform float spheroidPolarRadius;
	uniform vec3 entityPos;

	// Shadow Entities.
	#ifdef shadowEntities
		uniform int numShadowEntities;
		uniform vec3 shadowEntityPositions[5];
		uniform float shadowEntityRadii[5];
		uniform float shadowEntitySunsetIntensity[5];
		uniform vec3 shadowEntitySunsetColors[5];
	#endif

	// The varying attributes.
	varying vec3 localPosition;
	varying vec3 cameraSpacePosition;
	varying vec3 modelNormal;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

	float spheroidShadow(vec3 lightDir, float lightCosAngle, float spheroidScaling, vec3 normal, vec3 ringPos) {
		vec3 sunDirScaled = normalize(lightDir - (spheroidScaling - 1.0) * lightCosAngle * normal);
		float pDotLScaled = dot(ringPos, sunDirScaled);
		if(dot(ringPos, ringPos) - pDotLScaled * pDotLScaled < spheroidEquatorialRadius * spheroidEquatorialRadius && pDotLScaled > 0.0) {
			return 0.0;
		}
		else {
			return 1.0;
		}
	}

	#ifdef shadowEntities
		vec3 applyRayleighScattering(vec3 color, float amount) {
			float value = (color.r + color.g + color.b);
			if (value > 0.0) {
				float rFactor = 1.0; // 6.3^-4 / 6.3^-4
				float gFactor = 1.602; // 5.6^-4 / 6.3^-4
				float bFactor = 3.228; // 4.7^-4 / 6.3^-4
				color.r *= pow(rFactor, -amount);
				color.g *= pow(gFactor, -amount);
				color.b *= pow(bFactor, -amount);
				color = value * color / (color.r + color.g + color.b);
			}
			return color;
		}

		vec3 getLightColorFromShadowEntities(vec3 lightColor, vec3 lightDir, vec3 lightPosition, float lightRadius, vec3 normal) {
			vec3 color = lightColor;
			for (int i = 0; i < 5; i++) {
				if (i >= numShadowEntities) {
					break;
				}
				vec3 origin = cameraSpacePosition - shadowEntityPositions[i];
				vec3 axis = normalize(shadowEntityPositions[i] - lightPosition);
				float sd = dot(origin, axis);
				if (sd > 0.0) {
					float e = length(origin - sd * axis);
					float ld = dot(cameraSpacePosition - lightPosition, axis);
					float lr = lightRadius;
					float sr = shadowEntityRadii[i];
					float e0 = (ld * sr - sd * lr) / (ld - sd);
					float e1 = (ld * sr + sd * lr) / (ld - sd);
					float lightLevel = 0.0;
					if (e1 < 0.0 || sd < 0.0) { // light in front of shadow entity
						lightLevel = 1.0;
					}
					else if (e0 < e1) {
						e0 /= max(1.0, shadowEntitySunsetIntensity[i] * 2.0);
						lightLevel = (e - e0) / (e1 - e0);
					}
					else {
						lightLevel = e < e0 ? 0.0 : 1.0; // 0 radius light.
					}
					color = saturate(lightLevel) * applyRayleighScattering(color, saturate(1.5 - lightLevel) * saturate(shadowEntitySunsetIntensity[i]));
				}
}
			return color;
		}
	#endif

	void main(void) {
		float spheroidScaling = spheroidEquatorialRadius / spheroidPolarRadius;
		vec3 positionDir = normalize(cameraSpacePosition);
		vec3 ringPos = cameraSpacePosition - entityPos;
		vec3 normal = normalize(modelNormal);
		float cameraCosAngle = -dot(positionDir, normal);

		// Calculate the UVs.
		vec2 uv;
		uv.x = (length(localPosition) - innerRadius) / (outerRadius - innerRadius);
		if (uv.x < 0.0 || uv.x > 1.0) {
			gl_FragColor = vec4(0, 0, 0, 0);
			return;
		}
		uv.y = 0.0;

		// Get the pixels at those uvs.
		vec4 topPixel = texture2D(topTexture, uv);
		vec4 bottomPixel = texture2D(bottomTexture, uv);

		// Get the initial diffuse light.
		vec3 diffuseLight = ambientLightColor;
		
		// For each light,
		for (int i = 0; i < 5; i++) {
			if (i >= numLights) {
				break;
			}

			vec3 lightDir = normalize(cameraSpacePosition - lightPositions[i]);
			float lightCosAngle = -dot(lightDir, normal);

			vec3 incomingLight = lightColors[i];

			#ifdef shadowEntities
				incomingLight = getLightColorFromShadowEntities(incomingLight, lightDir, lightPositions[i], lightRadii[i], normal);
			#endif

			float cameraDirDotLight = dot(positionDir, lightDir);
			float bottomTopRatio = (1.0 + 0.2 * cameraDirDotLight) * sign(cameraCosAngle) * lightCosAngle;
			float shadow = spheroidShadow(lightDir, lightCosAngle, spheroidScaling, normal, ringPos);
			vec3 bottomColor = saturate(incomingLight * (1.0 - bottomTopRatio) * shadow);
			vec3 topColor = 2.0 * saturate(incomingLight * bottomTopRatio * shadow);

			vec3 color = mix(bottomPixel.rgb * bottomColor, topPixel.rgb * topColor, bottomTopRatio);
			gl_FragColor.rgb += color;
		}

		gl_FragColor.a = topPixel.a;
		gl_FragColor.a *= alphaFadeMultiplier;

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
	}`;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/skybox_component.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/skybox_component.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SkyboxComponent": function() { return /* binding */ SkyboxComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** The skybox component. */
class SkyboxComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The number of latitudinal lines. The longitudinal lines will be double it.
		 * @type {number}
		 * @private
		 */
		this._numLatVerts = 20;

		/**
		 * The texture URL.
		 * @type {string}
		 * @private
		 */
		this._textureUrl = '';

		// Set the radius to the whole universe.
		this.__setRadius(1e24);

		// It uses the orientatin of the entity.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the texture url.
	 * @returns {string}
	 */
	getTextureUrl() {
		return this._textureUrl;
	}

	/**
	 * Sets the texture url.
	 * @param {string} url
	 */
	setTextureUrl(url) {
		this._textureUrl = url;
		this.resetResources();
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// Set the orientation to the entity's orientation.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());

		// Set the Three.js object position the entity's camera-space position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Load the texture.
		const texture = await _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTexture(this, this._textureUrl, false, false);

		// Check if the component has since stopped loading.
		if (this.getLoadState() !== 'loading') {
			texture.dispose();
			return;
		}

		// Create Three.js material.
		const material = _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.get();
		this.getThreeJsMaterials().push(material);
		material.defines['colorMapEmmissive'] = true;
		material.needsUpdate = true;
		material.uniforms['colorTexture'].value = texture;

		// Create the Three.js object.
		const object = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [{ name: 'position', dimensions: 3 }, { name: 'uv', dimensions: 2 }], false);
		this.getThreeJsObjects().push(object);

		// Make it used in the dynamic environment map.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.useInDynEnvMap(object, true);

		// Setup the geometry.
		const latStep = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi / (this._numLatVerts - 1);
		const lonStep = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi / this._numLatVerts;
		const numVerts = (this._numLatVerts * 2 + 1) * this._numLatVerts;

		const meshPositions = new Float32Array(numVerts * 3);
		const meshUVs = new Float32Array(numVerts * 2);
		const meshIndices = new Uint16Array(this._numLatVerts * (this._numLatVerts - 1) * 12);

		const xyz = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		for (let latI = 0; latI < this._numLatVerts; latI++) {
			for (let lonI = 0; lonI < this._numLatVerts * 2 + 1; lonI++) {
				// Calculate the lla.
				lla.lat = latI * latStep - _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi;
				lla.lon = lonI * lonStep - _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi;
				lla.alt = 0;

				// Calculate the xyz from the lla.
				xyz.x = 5e23 * Math.cos(lla.lat) * Math.cos(lla.lon);
				xyz.y = 5e23 * Math.cos(lla.lat) * Math.sin(lla.lon);
				xyz.z = 5e23 * Math.sin(lla.lat);

				const vertexI = latI * (this._numLatVerts * 2 + 1) + lonI;
				meshPositions[vertexI * 3 + 0] = xyz.x;
				meshPositions[vertexI * 3 + 1] = xyz.y;
				meshPositions[vertexI * 3 + 2] = xyz.z;
				meshUVs[vertexI * 2 + 0] = 0.5 - lla.lon / _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
				meshUVs[vertexI * 2 + 1] = 0.5 - lla.lat / _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi;

				const triangleI = latI * this._numLatVerts * 2 + lonI;
				if (latI < this._numLatVerts - 1 && lonI < this._numLatVerts * 2) {
					meshIndices[triangleI * 6 + 0] = (this._numLatVerts * 2 + 1) * (latI + 0) + (lonI + 0);
					meshIndices[triangleI * 6 + 1] = (this._numLatVerts * 2 + 1) * (latI + 1) + (lonI + 0);
					meshIndices[triangleI * 6 + 2] = (this._numLatVerts * 2 + 1) * (latI + 1) + (lonI + 1);
					meshIndices[triangleI * 6 + 3] = (this._numLatVerts * 2 + 1) * (latI + 0) + (lonI + 0);
					meshIndices[triangleI * 6 + 4] = (this._numLatVerts * 2 + 1) * (latI + 1) + (lonI + 1);
					meshIndices[triangleI * 6 + 5] = (this._numLatVerts * 2 + 1) * (latI + 0) + (lonI + 1);
				}
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(xyz);
		const geometry = /** @type {THREE.Mesh} */(this.getThreeJsObjects()[0]).geometry;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(geometry, 'position', meshPositions);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(geometry, 'uv', meshUVs);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(geometry, meshIndices);
	}

	/**
	 * Unloads the resources.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/spheroid_component.js":
/*!********************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/spheroid_component.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpheroidComponent": function() { return /* binding */ SpheroidComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The spheroid component.
 */
class SpheroidComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The equatorial radius.
		 * @type {number}
		 * @private
		 */
		this._equatorialRadius = 1;

		/**
		  * The polar radius.
		  * @type {number}
		  * @private
		  */
		this._polarRadius = 1;

		/**
		 * The flag that if true is planetographic, otherwise is planetocentric.
		 * @type {boolean}
		 * @private
		 */
		this._planetographic = false;

		/**
		 * The flag that determines if the changedCallbacks need to be called on the next update.
		 * @type {boolean}
		 * @private
		 */
		this._changed = true;

		/**
		 * A set of callbacks to call when the spheroid properties change.
		 * @type {FastSet<() => any>}
		 * @private
		 */
		this._changedCallbacks = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastSet();
	}

	/**
	 * Gets the equatorial radius.
	 * @returns {number}
	 */
	getEquatorialRadius() {
		return this._equatorialRadius;
	}

	/**
	 * Sets the equatorial radius.
	 * @param {number} equatorialRadius
	 */
	setEquatorialRadius(equatorialRadius) {
		this._equatorialRadius = equatorialRadius;
		this._changed = true;
	}

	/**
	 * Gets the polar radius.
	 * @returns {number}
	 */
	getPolarRadius() {
		return this._polarRadius;
	}

	/**
	 * Sets the polar radius.
	 * @param {number} polarRadius
	 */
	setPolarRadius(polarRadius) {
		this._polarRadius = polarRadius;
		this._changed = true;
	}

	/**
	 * Gets the flag that if true is planetographic, otherwise is planetocentric.
	 * @returns {boolean}
	 */
	isPlanetographic() {
		return this._planetographic;
	}

	/**
	 * Sets flag that if true is planetographic, otherwise is planetocentric. Defaults to true.
	 * @param {boolean} planetographic
	 */
	setPlanetographic(planetographic) {
		this._planetographic = planetographic;
		this._changed = true;
	}

	/**
	 * Adds a callback to be called when this changes.
	 * @param {() => any} changedCallback
	 */
	addChangedCallback(changedCallback) {
		this._changedCallbacks.add(changedCallback);
	}

	/**
	 * Removes a callback to be called when this changes.
	 * @param {() => any} changedCallback
	 */
	removeChangedCallback(changedCallback) {
		this._changedCallbacks.delete(changedCallback);
	}

	/**
	 * Updates the component.
	 * @override
	 * @package
	 */
	__update() {
		// If one of the properties have changed, call the callbacks to notify other components or controllers.
		if (this._changed) {
			for (let i = 0, l = this._changedCallbacks.size; i < l; i++) {
				this._changedCallbacks.getAt(i)();
			}
			this._changed = false;
		}
	}

	/**
	 * Takes an LLA and sets out to the equivalent XYZ.
	 * @param {Vector3} out - the XYZ vector to be set
	 * @param {LatLonAlt} lla - the LLA vector to convert
	 */
	xyzFromLLA(out, lla) {
		const cosLat = Math.cos(lla.lat);
		const sinLat = Math.sin(lla.lat);
		if (this._planetographic) {
			const eSq = 1.0 - (this._polarRadius * this._polarRadius) / (this._equatorialRadius * this._equatorialRadius);
			const radiusOfCurvature = this._equatorialRadius / Math.sqrt(1.0 - eSq * sinLat * sinLat);
			out.x = (radiusOfCurvature + lla.alt) * cosLat * Math.cos(lla.lon);
			out.y = (radiusOfCurvature + lla.alt) * cosLat * Math.sin(lla.lon);
			out.z = ((1.0 - eSq) * radiusOfCurvature + lla.alt) * sinLat;
		}
		else {
			const a = this._equatorialRadius;
			const b = this._polarRadius;
			const radius = a * b / Math.sqrt(b * b * cosLat * cosLat + a * a * sinLat * sinLat);
			out.x = (radius + lla.alt) * cosLat * Math.cos(lla.lon);
			out.y = (radius + lla.alt) * cosLat * Math.sin(lla.lon);
			out.z = (radius + lla.alt) * sinLat;
		}
	}

	/**
	 * Gets the radius at the given XYZ.
	 * @param {Vector3} xyz - the xyz vector to use
	 * @param {number} [numIterations] - the number of iterations to use. Defaults to 5.
	 * @returns {number}
	 */
	radiusFromXYZ(xyz, numIterations = 5) {
		if (this._planetographic) {
			// Using http://mathforum.org/library/drmath/view/51834.html as a reference. The standard algorithm from the Astronomical Almanac.
			const r = xyz.magnitudeXY();
			const eSq = 1.0 - (this._polarRadius * this._polarRadius) / (this._equatorialRadius * this._equatorialRadius);
			let lat = Math.atan(xyz.z / ((1.0 - eSq) * r));
			let radius = 0;
			for (let i = 0; i < numIterations; i++) {
				const sinLat = Math.sin(lat);
				radius = this._equatorialRadius / Math.sqrt(1.0 - eSq * sinLat * sinLat);
				lat = Math.atan((xyz.z + radius * eSq * sinLat) / r);
			}
			return radius;
		}
		else {
			const f = (xyz.z * xyz.z) / (xyz.x * xyz.x + xyz.y * xyz.y);
			const cosLatSq = 1 / (1 + f);
			const sinLatSq = f * cosLatSq;
			const a = this._equatorialRadius;
			const b = this._polarRadius;
			return a * b / Math.sqrt(b * b * cosLatSq + a * a * sinLatSq);
		}
	}

	/**
	 * Takes an XYZ and sets out to the equivalent LLA.
	 * @param {LatLonAlt} out - the LLA vector to be set
	 * @param {Vector3} xyz - the XYZ vector to convert
	 * @param {number} [numIterations] - the number of iterations to use. Defaults to 5.
	 */
	llaFromXYZ(out, xyz, numIterations = 5) {
		if (this._planetographic) {
			out.lon = Math.atan2(xyz.y, xyz.x);

			// Using http://mathforum.org/library/drmath/view/51834.html as a reference. The standard algorithm from the Astronomical Almanac.
			const r = xyz.magnitudeXY();
			const eSq = 1.0 - (this._polarRadius * this._polarRadius) / (this._equatorialRadius * this._equatorialRadius);
			out.lat = Math.atan(xyz.z / ((1.0 - eSq) * r));
			let C = 0;
			for (let i = 0; i < numIterations; i++) {
				const sinLat = Math.sin(out.lat);
				C = 1.0 / Math.sqrt(1.0 - eSq * sinLat * sinLat);
				out.lat = Math.atan((xyz.z + this._equatorialRadius * C * eSq * sinLat) / r);
			}
			out.alt = r / Math.cos(out.lat) - this._equatorialRadius * C;
		}
		else {
			const xyLength = xyz.magnitudeXY();
			out.lon = Math.atan2(xyz.y, xyz.x);
			out.lat = Math.atan(xyz.z / xyLength);
			const cosLat = Math.cos(out.lat);
			const sinLat = Math.sin(out.lat);
			const a = this._equatorialRadius;
			const b = this._polarRadius;
			const radius = a * b / Math.sqrt(b * b * cosLat * cosLat + a * a * sinLat * sinLat);
			out.alt = xyz.magnitude() - radius;
		}
	}

	/**
	 * Sets out to lla but with the planetographic flag toggled, adjusting the latitude and altiude so that they represent the same location.
	 * @param {LatLonAlt} out - the LLA vector to be set
	 * @param {LatLonAlt} lla
	 */
	llaToggleGraphicCentric(out, lla) {
		const xyz = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.xyzFromLLA(xyz, lla);
		this._planetographic = !this._planetographic;
		this.llaFromXYZ(out, xyz);
		this._planetographic = !this._planetographic;
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(xyz);
	}

	/**
	 * Returns the up vector from the LLA.
	 * @param {Vector3} out - the up vector to be set
	 * @param {LatLonAlt} lla - the LLA to use
	 */
	upFromLLA(out, lla) {
		const llaPlanetographic = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		if (this._planetographic) {
			llaPlanetographic.copy(lla);
		}
		else {
			this.llaToggleGraphicCentric(llaPlanetographic, lla);
		}
		out.x = Math.cos(llaPlanetographic.lat) * Math.cos(llaPlanetographic.lon);
		out.y = Math.cos(llaPlanetographic.lat) * Math.sin(llaPlanetographic.lon);
		out.z = Math.sin(llaPlanetographic.lat);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(llaPlanetographic);
	}

	/**
	 * Returns the east vector from the LLA.
	 * @param {Vector3} out - the east vector to be set
	 * @param {LatLonAlt} lla - the LLA to use
	 */
	eastFromLLA(out, lla) {
		out.x = -Math.sin(lla.lon);
		out.y = Math.cos(lla.lon);
		out.z = 0;
	}

	/**
	 * Returns the north vector from the LLA.
	 * @param {Vector3} out - the north vector to be set
	 * @param {LatLonAlt} lla - the LLA to use
	 */
	northFromLLA(out, lla) {
		const llaPlanetographic = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		if (this._planetographic) {
			llaPlanetographic.copy(lla);
		}
		else {
			this.llaToggleGraphicCentric(llaPlanetographic, lla);
		}
		out.x = -Math.sin(llaPlanetographic.lat) * Math.cos(llaPlanetographic.lon);
		out.y = -Math.sin(llaPlanetographic.lat) * Math.sin(llaPlanetographic.lon);
		out.z = Math.cos(llaPlanetographic.lat);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(llaPlanetographic);
	}

	/**
	 * Returns an orientation representing +x as east, +y as north, and +z as up from a LLA.
	 * @param {Quaternion} out - the orientation to be set
	 * @param {LatLonAlt} lla - the LLA to use
	 */
	orientationFromLLA(out, lla) {
		const llaPlanetographic = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		if (this._planetographic) {
			llaPlanetographic.copy(lla);
		}
		else {
			this.llaToggleGraphicCentric(llaPlanetographic, lla);
		}
		const sLat = Math.sin(llaPlanetographic.lat);
		const sLon = Math.sin(llaPlanetographic.lon);
		const cLon = Math.cos(llaPlanetographic.lon);
		out.w = 0.5 * Math.sqrt((1.0 + sLat) * (1.0 - sLon));
		out.x = 0.5 * Math.sqrt((1.0 - sLat) * (1.0 - sLon));
		out.y = 0.5 * Math.sqrt((1.0 - sLat) * (1.0 + sLon)) * Math.sign(cLon);
		out.z = 0.5 * Math.sqrt((1.0 + sLat) * (1.0 + sLon)) * Math.sign(cLon);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(llaPlanetographic);
	}

	/**
	 * Sets out to the AER of an XYZ from the viewpoint of an observer at a LLA.
	 * @param {AER} out - the AER vector to be set
	 * @param {Vector3} xyz - the XYZ point to observe
	 * @param {LatLonAlt} lla - the LLA from which to observe
	 */
	aerFromXYZRelToLLA(out, xyz, lla) {
		// get the relative xyz at lla, as v
		const v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.xyzFromLLA(v, lla);
		const llaPlanetographic = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		if (!this._planetographic) {
			this.llaFromXYZ(llaPlanetographic, v);
		}
		else {
			llaPlanetographic.copy(lla);
		}
		v.sub(xyz, v);
		out.range = v.magnitude(); // the range

		// normalize it
		v.mult(v, 1.0 / out.range);

		// get the angle between horizon and v, using up. this is the elevation
		const up = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.upFromLLA(up, llaPlanetographic);
		const vDotUp = v.dot(up);
		out.elevation = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi - Math.acos(vDotUp); // get angle from horizontal

		// make v be just the tangent part
		v.addMult(v, up, -vDotUp);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(up);

		// get the azimuth using the north/east directions
		const north = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.northFromLLA(north, llaPlanetographic);
		const east = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.eastFromLLA(east, llaPlanetographic);
		out.azimuth = Math.atan2(v.dot(east), v.dot(north));
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(north);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(east);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(llaPlanetographic);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(v);
	}

	/**
	 * Gets the location at the point of intersection of the ray and the spheroid. Origin and direction are in frame space.
	 * @param {Vector3} outPosition
	 * @param {Vector3} origin
	 * @param {Vector3} direction
	 */
	getRayIntersection(outPosition, origin, direction) {
		const spheroidRatio = this._equatorialRadius / this._polarRadius;
		const originAsSphere = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const directionAsSphere = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		originAsSphere.set(origin.x, origin.y, origin.z * spheroidRatio);
		directionAsSphere.set(direction.x, direction.y, direction.z * spheroidRatio);
		const intersectionDistance = _internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLineSphereIntersectionWithSphereAtOrigin(originAsSphere, directionAsSphere, this._equatorialRadius);
		outPosition.addMult(originAsSphere, directionAsSphere, intersectionDistance);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(originAsSphere);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(directionAsSphere);
		outPosition.z /= spheroidRatio;
	}

	/**
	 * Gets the frame-space position and up on the surface at the given frame-space position.
	 * Note that the height direction is not up with planetocentric coordinates.
	 * @param {Vector3} outPosition
	 * @param {Vector3} outHeightDir
	 * @param {Vector3} position
	 */
	getGroundPosition(outPosition, outHeightDir, position) {
		// Get the position on the surface of the spheroid.
		const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		this.llaFromXYZ(lla, position);
		lla.alt = 0;
		this.xyzFromLLA(outPosition, lla);
		const up = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.upFromLLA(outHeightDir, lla);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(up);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/components/spheroid_lod_component.js":
/*!************************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/spheroid_lod_component.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpheroidLODComponent": function() { return /* binding */ SpheroidLODComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The spheroid LOD component.
 */
class SpheroidLODComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * Texture URLs for the various textures.
		 * @type {FastMap<string, string>}
		 * @private
		 */
		this._textureUrls = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The LOD objects (one per face and one per texture type) that determines the texture.
		 * @type {FastMap<string, TextureLOD[]>}
		 * @private
		 */
		this._textureLODs = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The pixel sizes used for the LOD textures.
		 * @type {FastMap<string, number[]>}
		 * @private
		 */
		this._textureSizes = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The mapping used for the mesh and textures.
		 * @type {string}
		 * @private
		 */
		this._mapping = 'cylinder';

		/**
		 * The longitudinal rotation in radians of the spheroid.
		 * @type {number}
		 * @private
		 */
		this._longitudinalRotation = 0;

		/**
		 * The number of faces, determined by the mapping.
		 * @type {number}
		 * @private
		 */
		this._numFaces = 1;

		/**
		 * The lower left coordinate of the bounds.
		 * @type {LatLonAlt}
		 * @private
		 */
		this._lowerLeftBounds = new _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt(-_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi, -_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi, 0);

		/**
		 * The upper right coordinate of the bounds.
		 * @type {LatLonAlt}
		 * @private
		 */
		this._upperRightBounds = new _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt(+_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi, 0);

		/**
		 * The layout used for the cubemap mapping.
		 * @type {Vector3[][]}
		 */
		this._cubeMapFaceFrames = _internal__WEBPACK_IMPORTED_MODULE_0__.CubeMap._defaultCubeMapFaceFrames;

		/**
		 * The entities uses for shadows. Derived from the shadow entity names.
		 * @type {EntityRef[]}
		 * @private
		 */
		this._shadowEntities = [];

		/**
		 * The features that are enabled.
		 * @type {Set<string>}
		 * @private
		 */
		this._features = new Set();

		/**
		 * The flag that if true, uses compressed textures.
		 * @type {boolean}
		 * @private
		 */
		this._useCompression = false;

		/**
		 * A reference to the atmosphere component.
		 * @type {ComponentRef<AtmosphereComponent>}
		 * @private
		 */
		this._atmosphereComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._atmosphereComponentRef.setByType(this.getEntity().getName(), 'atmosphere');

		/**
		 * A reference to the spheroid component.
		 * @type {ComponentRef<SpheroidComponent>}
		 * @private
		 */
		this._spheroidComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid');
		this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this));

		// Bind the callbacks to this.
		this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this);

		// Lets the base component to check for valid orientation when determining whether this is visible.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the list of texture names as a new array.
	 * @returns {string[]}
	 */
	getTextureNames() {
		/** @type {string[]} */
		const names = [];
		for (let i = 0; i < this._textureUrls.size; i++) {
			names.push(this._textureUrls.getAt(i).key);
		}
		return names;
	}

	/**
	 * Gets the texture URL for the given name. Returns undefined if it doesn't exist.
	 * @param {string} name
	 * @returns {string}
	 */
	getTextureUrl(name) {
		return this._textureUrls.get(name);
	}

	/**
	 * Gets the level-of-detail sizes of the named texture. Defaults to [16, 512, 4096].
	 * @param {string} name
	 * @returns {number[]}
	 */
	getTextureSizes(name) {
		return this._textureSizes.get(name);
	}

	/**
	 * Sets the texture URL for the given name.
	 * @param {string} name
	 * @param {string} url
	 * @param {number[]} [sizes=[4, 512, 4096]]
	 */
	setTexture(name, url, sizes = [4, 512, 4096]) {
		// Activate feature
		if (SpheroidLODComponent._textureToFeature.has(name)) {
			this.setFeature(SpheroidLODComponent._textureToFeature.get(name), url !== '');
		}

		this._textureUrls.set(name, url);
		this._textureSizes.set(name, [...sizes]);
		let textureLODs = this._textureLODs.get(name);
		// If there is no texture LOD yet, add it.
		if (textureLODs === undefined) {
			textureLODs = [];
			const materials = this.getThreeJsMaterials();
			for (let i = 0, l = this._numFaces; i < l; i++) {
				const textureLOD = new _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLOD(this);
				if (materials.length > 0) {
					const uniform = materials[i].uniforms[name + 'Texture'];
					if (uniform !== undefined) {
						textureLOD.setUniform(uniform);
					}
				}
				textureLODs.push(textureLOD);
			}
			this._textureLODs.set(name, textureLODs);
		}
		for (let i = 0, l = this._numFaces; i < l; i++) {
			textureLODs[i].setUrl(url.replace('$FACE', i.toString()));
			textureLODs[i].setSizes(sizes);
		}
	}

	/**
	 * Forces the texture to be at the texture size. If size is undefined, it does normal LOD levels.
	 * @param {string} name
	 * @param {number} size
	 */
	forceTextureSize(name, size) {
		const textureLODs = this._textureLODs.get(name);
		if (textureLODs === undefined) {
			throw new Error('No texture named "' + name + '" has been defined.');
		}
		for (let i = 0; i < textureLODs.length; i++) {
			textureLODs[i].setForcedSize(size);
		}
	}

	/**
	 * Removes the texture from the material.
	 * @param {string} name
	 */
	unsetTexture(name) {
		// Deactivate feature
		if (SpheroidLODComponent._textureToFeature.has(name)) {
			this.setFeature(SpheroidLODComponent._textureToFeature.get(name), false);
		}

		this._textureUrls.delete(name);
		this._textureLODs.delete(name);
		this._textureSizes.delete(name);
		const materials = this.getThreeJsMaterials();
		for (let i = 0, l = materials.length; i < l; i++) {
			const uniform = materials[i].uniforms[name + 'Texture'];
			if (uniform !== undefined) {
				uniform.value.dispose();
				uniform.value = null;
			}
		}
	}

	/**
	 * Gets the texture level-of-detail's current size.
	 * @param {string} name
	 * @param {number} face
	 * @returns {number}
	 */
	getTextureCurrentSize(name, face) {
		const textureLODs = this._textureLODs.get(name);
		if (textureLODs !== undefined && textureLODs[face] !== undefined) {
			return textureLODs[face].getCurrentSize();
		}
		return undefined;
	}

	/**
	 * Returns true if the feature is enabled. All features disabled by default.
	 * @param {string} feature
	 * @returns {boolean}
	 */
	isFeatureEnabled(feature) {
		return this._features.has(feature);
	}

	/**
	 * Enables or disables a feature, one of 'normalMap', 'nightMap', 'decalMap', 'specularMap', 'shadowRings', 'shadowEntities', 'noShading'.
	 * @param {string} feature - the feature to enable or disable
	 * @param {boolean} enable - turn on or off the feature in the shader
	 */
	setFeature(feature, enable) {
		const materials = this.getThreeJsMaterials();
		if (enable && !this._features.has(feature)) {
			this._features.add(feature);
			for (let i = 0, l = materials.length; i < l; i++) {
				const material = materials[i];
				material.defines[feature] = true;
				material.needsUpdate = true;
			}
			if (feature === 'normalMap') {
				this._updateMeshes();
			}
		}
		else if (!enable && this._features.has(feature)) {
			this._features.delete(feature);
			for (let i = 0, l = materials.length; i < l; i++) {
				const material = materials[i];
				delete material.defines[feature];
				material.needsUpdate = true;
			}
			if (feature === 'normalMap') {
				this._updateMeshes();
			}
		}
	}

	/**
	 * Gets the mapping used. Defaults to 'cylinder'.
	 * @returns {string}
	 */
	getMapping() {
		return this._mapping;
	}

	/**
	 * Sets the mapping used. It can be 'cylinder' or 'cube'.
	 * @param {string} mapping - the mapping to use
	 */
	setMapping(mapping) {
		// Determine the number of faces.
		const oldNumFaces = this._numFaces;
		if (mapping === 'cylinder') {
			this._numFaces = 1;
		}
		else if (mapping === 'cube') {
			this._numFaces = 6;
		}
		else {
			throw new Error('Invalid mapping type.');
		}

		// If there are a different number of faces, redo the texture LODs.
		if (this._numFaces !== oldNumFaces) {
			for (let i = 0; i < this._textureLODs.size; i++) {
				const name = this._textureLODs.getAt(i).key;
				const textureLODs = [];
				for (let face = 0, l = this._numFaces; face < l; face++) {
					const textureLOD = new _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLOD(this);
					textureLOD.setUrl(this._textureUrls.get(name).replace('$FACE', face.toString()));
					textureLOD.setSizes(this._textureSizes.get(name));
					textureLODs.push(textureLOD);
				}
				this._textureLODs.set(name, textureLODs);
			}
		}

		// Set the mapping.
		this._mapping = mapping;

		// Reset the resources, since the mapping changed.
		this.resetResources();
	}

	/**
	 * Sets the lower left and upper right coordinates of the bounds.
	 * @param {LatLonAlt} lowerLeft
	 * @param {LatLonAlt} upperRight
	 */
	setBounds(lowerLeft, upperRight) {
		this._lowerLeftBounds.copy(lowerLeft);
		this._upperRightBounds.copy(upperRight);

		// Reset the resources, since the bounds changed.
		this.resetResources();
	}

	/**
	 * Sets how the 6 cubemaps will be laid out. It takes an 6-array of a 3-array of strings, like [['+x', '-y', '+z'], ['-x', '+y', '-z'], ...].
	 * The first component is u, the second component is v, and the third component is outward.
	 * @param {string[][]} layout
	 */
	setCubeMapLayout(layout) {
		// Set the vectors up correctly.
		this._cubeMapFaceFrames = [];
		for (let i = 0; i < 6; i++) {
			this._cubeMapFaceFrames.push([]);
			for (let j = 0; j < 3; j++) {
				let v = null;
				switch (layout[i][j]) {
					case '+x':
						v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis; break;
					case '-x':
						v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg; break;
					case '+y':
						v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis; break;
					case '-y':
						v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg; break;
					case '+z':
						v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis; break;
					case '-z':
						v = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxisNeg; break;
					default:
						throw new Error('Invalid cubemap layout component.');
				}
				this._cubeMapFaceFrames[i][j] = v;
			}
		}
		// Reset the resources, since the layout changed.
		this.resetResources();
	}

	/**
	 * Gets the number of shadow entities. Can be used to enumerate the shadow entities.
	 * @returns {number}
	 */
	getNumShadowEntities() {
		return this._shadowEntities.length;
	}

	/**
	 * Returns the shadow entity or its name at the index.
	 * @param {number} index
	 * @returns {string | undefined}
	 */
	getShadowEntity(index) {
		return this._shadowEntities[index]?.getName();
	}

	/**
	 * Sets the shadow entities. Each element can be either the name of an entity or an entity itself.
	 * @param {string[]} shadowEntities
	 */
	setShadowEntities(shadowEntities) {
		this._shadowEntities = [];
		for (const shadowEntity of shadowEntities) {
			this._shadowEntities.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), shadowEntity));
		}
		const shadowEntitiesEnabled = (shadowEntities.length > 0);
		for (let i = 0, l = this.getThreeJsMaterials().length; i < l; i++) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setDefine(this.getThreeJsMaterials()[i], 'shadowEntities', shadowEntitiesEnabled);
		}
	}

	/**
	 * Gets the flag that if true, uses compressed textures.
	 * @returns {boolean}
	 */
	getUseCompression() {
		return this._useCompression;
	}

	/**
	 * Sets the flag that if true, uses compressed textures.
	 * @param {boolean} useCompression
	 */
	setUseCompression(useCompression) {
		this._useCompression = useCompression;
	}

	/**
	 * Gets the longitudinal rotation in radians of the spheroid.
	 * @returns {number}
	 */
	getLongitudeRotation() {
		return this._longitudinalRotation;
	}

	/**
	 * Sets the longitudinal rotation in radians of the spheroid.
	 * @param {number} rotation
	 */
	setLongitudeRotation(rotation) {
		this._longitudinalRotation = rotation;
	}

	/**
	 * Gets a new promise that resolves when the component is loaded.
	 * @returns {Promise<void>}
	 * @override
	 */
	getLoadedPromise() {
		const promises = [super.getLoadedPromise()];
		for (let i = 0; i < this._textureLODs.size; i++) {
			const textureLODs = this._textureLODs.getAt(i).value;
			for (let i = 0, l = textureLODs.length; i < l; i++) {
				promises.push(textureLODs[i].getLoadedPromise());
			}
		}
		return Promise.all(promises).then();
	}

	/**
	 * Gets the color of the named texture at the given position in frame-space. If the position is higher up, it reduces the lat/lon of the position to find the color.
	 * @param {Color} outColor
	 * @param {Vector3} position
	 * @param {string} textureName
	 */
	getColorAtPosition(outColor, position, textureName) {
		const uvFace = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		if (this._mapping === 'cube') {
			_internal__WEBPACK_IMPORTED_MODULE_0__.CubeMap.xyzToUVFace(uvFace, position, this._cubeMapFaceFrames);
		}
		else if (this._mapping === 'cylinder') {
			const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
			const spheroidComponent = this._spheroidComponentRef.get();
			if (spheroidComponent === null) {
				outColor.set(0, 0, 0);
				return;
			}
			uvFace.set(lla.lon / _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi + 0.5, lla.lat / Math.PI + 0.5, 0);
			_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		}
		// Get the texture LOD corresponding to the face.
		const textureLODs = this._textureLODs.get(textureName);
		if (textureLODs === undefined) {
			throw new Error('Invalid texture name.');
		}
		// Get the texture.
		/** @type {THREE.Texture} */
		const texture = textureLODs[uvFace.z].getUniform().value;
		// Since we can't read from a loaded texture, we load it to a canvas.
		const canvas = document.createElement('canvas');
		canvas.width = texture.image.width;
		canvas.height = texture.image.height;
		const context = canvas.getContext('2d');
		context.drawImage(texture.image, 0, 0);
		const imageData = context.getImageData(0, 0, texture.image.width, texture.image.height);
		// Get the pixel from the image data.
		const numbersPerPixel = texture.format === _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RGBAFormat ? 4 : 3;
		const pixelIndex = (Math.floor((1 - uvFace.y) * imageData.height) * imageData.width + Math.floor(uvFace.x * imageData.width)) * numbersPerPixel;
		outColor.set(imageData.data[pixelIndex + 0], imageData.data[pixelIndex + 1], imageData.data[pixelIndex + 2], numbersPerPixel === 4 ? imageData.data[pixelIndex + 3] : 1.0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(uvFace);
	}

	/**
	 * Sets the reference to use for the spheroid component, by name or the type index.
	 * @param {string | number} nameOrTypeIndex
	 */
	setSpheroidReference(nameOrTypeIndex) {
		if (typeof nameOrTypeIndex === 'string') {
			this._spheroidComponentRef.setByName(this.getEntity().getName(), nameOrTypeIndex);
		}
		else {
			this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid', nameOrTypeIndex);
		}
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @package
	 */
	__destroy() {
		// Remove the spheroid changed callback.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			spheroidComponent.removeChangedCallback(this._spheroidChangedCallback);
		}

		super.__destroy();
	}

	/**
	 * Updates the camera-non-specific parts of the component.
	 * @override
	 * @package
	 */
	__update() {
		// Set the texture LOD target size.
		for (let i = 0; i < this._textureLODs.size; i++) {
			const textureLODs = this._textureLODs.getAt(i).value;
			for (let i = 0, l = textureLODs.length; i < l; i++) {
				textureLODs[i].update();
			}
		}

		// Update the spheroid component reference.
		this._spheroidComponentRef.update();
	}

	/**
	 * Prepares the component for render.
	 * @param {CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		// Set the orientation and position to the entity's orientation and camera-space position.
		const objects = this.getThreeJsObjects();
		const longitudinalRotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		longitudinalRotation.setFromAxisAngle(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, this._longitudinalRotation);
		for (let i = 0; i < objects.length; i++) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(objects[i], this.getEntity(), longitudinalRotation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(objects[i], this.getEntity(), camera);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(longitudinalRotation);

		// Get the atmosphere.
		const atmosphere = this._atmosphereComponentRef.get();

		// Setup the regular uniforms.
		_internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setUniforms(this.getThreeJsMaterials(), camera, this.getEntity(), this._shadowEntities, atmosphere, true);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		const textureLODPromises = [];
		for (let i = 0; i < this._numFaces; i++) {
			// Create the material.
			const material = _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.get();
			this.getThreeJsMaterials().push(material);
			for (const feature of this._features) {
				material.defines[feature] = true;
				material.needsUpdate = true;
			}

			// Create the object.
			const object = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [
				{ name: 'position', dimensions: 3 },
				{ name: 'normal', dimensions: 3 },
				{ name: 'uv', dimensions: 2 }], false);
			this.getThreeJsObjects().push(object);

			// Make it used in the dynamic environment map.
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.useInDynEnvMap(object, true);

			// Set the texture LODs uniforms.
			for (let j = 0; j < this._textureLODs.size; j++) {
				const name = this._textureLODs.getAt(j).key;
				const uniform = material.uniforms[name + 'Texture'];
				if (uniform !== undefined) {
					const textureLOD = this._textureLODs.get(name)[i];
					textureLOD.setUniform(uniform);
					textureLOD.update();
					textureLODPromises.push(textureLOD.getLoadedPromise());
				}
			}
		}

		return Promise.all(textureLODPromises).then(() => {
			this._updateMeshes();
		});
	}

	/**
	 * Destroys the triangle meshes and LOD objects.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		// Destroy al of the objects and materials and textures.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);

		// Set the texture LODs uniforms to null.
		for (let i = 0; i < this._textureLODs.size; i++) {
			const name = this._textureLODs.getAt(i).key;
			for (let face = 0; face < this._numFaces; face++) {
				this._textureLODs.get(name)[face].setUniform(null);
			}
		}
	}

	/**
	 * Updates the ThreeJS mesh with the latest parameters.
	 * @private
	 */
	_updateMeshes() {
		// No triangle meshes or spheroid, so do nothing.
		if (this.getThreeJsObjects().length === 0) {
			return;
		}
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent === null) {
			return;
		}

		if (this._mapping === 'cylinder') {
			const latDistance = this._upperRightBounds.lat - this._lowerLeftBounds.lat;
			const lonDistance = this._upperRightBounds.lon - this._lowerLeftBounds.lon;
			const numLatVerts = Math.max(Math.ceil(100 * latDistance / _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi), 4);
			const numLonVerts = Math.max(Math.ceil(200 * lonDistance / _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi), 4);
			const latStep = latDistance / (numLatVerts - 1);
			const lonStep = lonDistance / (numLonVerts - 1);
			const numVerts = numLonVerts * numLatVerts;

			const meshPositions = new Float32Array(numVerts * 3);
			const meshNormals = new Float32Array(numVerts * 3);
			const meshUVs = new Float32Array(numVerts * 2);
			const meshIndices = new Uint16Array((numLonVerts - 1) * (numLatVerts - 1) * 6);

			const xyz = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
			for (let latI = 0; latI < numLatVerts; latI++) {
				for (let lonI = 0; lonI < numLonVerts; lonI++) {
					lla.lat = this._lowerLeftBounds.lat + latI * latStep;
					lla.lon = this._lowerLeftBounds.lon + lonI * lonStep;
					lla.alt = 0;

					const vertexI = latI * numLonVerts + lonI;
					spheroidComponent.xyzFromLLA(xyz, lla);
					meshPositions[vertexI * 3 + 0] = xyz.x;
					meshPositions[vertexI * 3 + 1] = xyz.y;
					meshPositions[vertexI * 3 + 2] = xyz.z;
					spheroidComponent.upFromLLA(xyz, lla);
					meshNormals[vertexI * 3 + 0] = xyz.x;
					meshNormals[vertexI * 3 + 1] = xyz.y;
					meshNormals[vertexI * 3 + 2] = xyz.z;
					meshUVs[vertexI * 2 + 0] = lonI / (numLonVerts - 1);
					meshUVs[vertexI * 2 + 1] = 1.0 - latI / (numLatVerts - 1);

					if (latI + 1 < numLatVerts && lonI + 1 < numLonVerts) {
						const triangleI = latI * (numLonVerts - 1) + lonI;
						meshIndices[triangleI * 6 + 0] = numLonVerts * (latI + 0) + (lonI + 0);
						meshIndices[triangleI * 6 + 1] = numLonVerts * (latI + 1) + (lonI + 1);
						meshIndices[triangleI * 6 + 2] = numLonVerts * (latI + 1) + (lonI + 0);
						meshIndices[triangleI * 6 + 3] = numLonVerts * (latI + 0) + (lonI + 0);
						meshIndices[triangleI * 6 + 4] = numLonVerts * (latI + 0) + (lonI + 1);
						meshIndices[triangleI * 6 + 5] = numLonVerts * (latI + 1) + (lonI + 1);
					}
				}
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(xyz);

			const mesh = /** @type {THREE.Mesh<THREE.BufferGeometry>} */ (this.getThreeJsObjects()[0]);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(mesh.geometry, 'position', meshPositions);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(mesh.geometry, 'normal', meshNormals);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(mesh.geometry, 'uv', meshUVs);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(mesh.geometry, meshIndices);
			if (this._features.has('normalMap')) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.computeTangents(mesh.geometry);
			}
		}
		else if (this._mapping === 'cube') {
			const numGridLines = 50;

			const xyz = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
			for (let i = 0; i < 6; i++) {
				const meshPositions = new Float32Array(numGridLines * numGridLines * 3);
				const meshNormals = new Float32Array(numGridLines * numGridLines * 3);
				const meshUVs = new Float32Array(numGridLines * numGridLines * 2);
				const meshIndices = new Uint16Array((numGridLines - 1) * (numGridLines - 1) * 6);

				// Check the handed-ness of the cubemap vectors.
				let flipped = false;
				const zVector = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				zVector.cross(this._cubeMapFaceFrames[i][0], this._cubeMapFaceFrames[i][1]);
				if (zVector.x !== this._cubeMapFaceFrames[i][2].x || zVector.y !== this._cubeMapFaceFrames[i][2].y || zVector.z !== this._cubeMapFaceFrames[i][2].z) {
					flipped = true;
				}
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(zVector);

				// Create the vertices, normals, and uvs.
				let vertexI = 0;
				let triangleI = 0;
				for (let k = 0; k < numGridLines; k++) {
					for (let j = 0; j < numGridLines; j++) {
						xyz.mult(this._cubeMapFaceFrames[i][0], (2 * j) / (numGridLines - 1) - 1);
						xyz.addMult(xyz, this._cubeMapFaceFrames[i][1], (2 * k) / (numGridLines - 1) - 1);
						xyz.addMult(xyz, this._cubeMapFaceFrames[i][2], 1.0);
						xyz.normalize(xyz);

						// Convert to lla as if xyz was on a sphere, then using it as a geodetic lla.
						_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLLAFromXYZOnSphere(lla, xyz, 0);
						lla.alt = 0;

						// Set the position.
						spheroidComponent.xyzFromLLA(xyz, lla);
						meshPositions[vertexI * 3 + 0] = xyz.x;
						meshPositions[vertexI * 3 + 1] = xyz.y;
						meshPositions[vertexI * 3 + 2] = xyz.z;

						// Set the normals.
						spheroidComponent.upFromLLA(xyz, lla);
						meshNormals[vertexI * 3 + 0] = xyz.x;
						meshNormals[vertexI * 3 + 1] = xyz.y;
						meshNormals[vertexI * 3 + 2] = xyz.z;

						// Set the UVs.
						meshUVs[vertexI * 2 + 0] = j / (numGridLines - 1);
						meshUVs[vertexI * 2 + 1] = 1.0 - k / (numGridLines - 1);

						// Set the indices.
						if (j < numGridLines - 1 && k < numGridLines - 1) {
							meshIndices[triangleI * 6 + 0] = (k + 0) * numGridLines + (j + 0);
							meshIndices[triangleI * 6 + 3] = (k + 1) * numGridLines + (j + 1);
							if (!flipped) {
								meshIndices[triangleI * 6 + 1] = (k + 0) * numGridLines + (j + 1);
								meshIndices[triangleI * 6 + 2] = (k + 1) * numGridLines + (j + 1);
								meshIndices[triangleI * 6 + 4] = (k + 1) * numGridLines + (j + 0);
								meshIndices[triangleI * 6 + 5] = (k + 0) * numGridLines + (j + 0);
							}
							else {
								meshIndices[triangleI * 6 + 1] = (k + 1) * numGridLines + (j + 1);
								meshIndices[triangleI * 6 + 2] = (k + 0) * numGridLines + (j + 1);
								meshIndices[triangleI * 6 + 4] = (k + 0) * numGridLines + (j + 0);
								meshIndices[triangleI * 6 + 5] = (k + 1) * numGridLines + (j + 0);
							}
							triangleI += 1;
						}

						vertexI += 1;
					}
				}

				const mesh = /** @type {THREE.Mesh<THREE.BufferGeometry>} */ (this.getThreeJsObjects()[i]);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(mesh.geometry, 'position', meshPositions);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(mesh.geometry, 'normal', meshNormals);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(mesh.geometry, 'uv', meshUVs);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(mesh.geometry, meshIndices);
				if (this._features.has('normalMap')) {
					_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.computeTangents(mesh.geometry);
				}
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(xyz);
		}
	}

	/**
	 * Callback called when the spheroid reference is found or lost.
	 * @param {SpheroidComponent} oldRef
	 * @param {SpheroidComponent} newRef
	 * @private
	 */
	_spheroidRefChangedCallback(oldRef, newRef) {
		if (oldRef !== null) {
			oldRef.removeChangedCallback(this._spheroidChangedCallback);
		}
		if (newRef !== null) {
			newRef.addChangedCallback(this._spheroidChangedCallback);
		}
		this._spheroidChangedCallback();
	}

	/**
	 * Callback to be called when the spheroid component changed.
	 * @private
	 */
	_spheroidChangedCallback() {
		// Set the radii uniforms.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			this.__setRadius(Math.max(spheroidComponent.getEquatorialRadius(), spheroidComponent.getPolarRadius()));
		}
		else {
			this.__setRadius(0);
		}
		this.resetResources();
	}
}

/**
 * Maps texture names to features to activate/deactivate automatically.
 * @type {Map<string, string>}
 */
SpheroidLODComponent._textureToFeature = new Map([
	['normal', 'normalMap'],
	['night', 'nightMap'],
	['decal', 'decalMap'],
	['specular', 'specularMap']
]);


/***/ }),

/***/ "../pioneer/engine/src/scene/components/spout_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/spout_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpoutComponent": function() { return /* binding */ SpoutComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Spout component. The entity should also have a camera component.
 */
class SpoutComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.CameraComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The render width.
		 * @type {number}
		 * @private
		 */
		this._renderWidth = 2048;

		/**
		 * The distance to which the globe cameras should render.
		 * @private
		 */
		this._globeDistance = 1;

		// STUFF FOR RENDERING FACES

		/**
		 * The three js cameras.
		 * @type {THREE.PerspectiveCamera[]}
		 * @private
		 */
		this._threeJsFaceCameras = [];

		/**
		 * This render targets.
		 * @type {THREE.WebGLRenderTarget[]}
		 * @private
		 */
		this._threeJsFaceRenderTargets = [];

		// STUFF FOR RENDERING FINAL TEXTURE

		/**
		 * The ThreeJS quad.
		 * @type {THREE.Mesh}
		 * @private
		 */
		this._threeJsQuad = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh();

		/**
		 * The ThreeJS scene.
		 * @type {THREE.Scene}
		 * @private
		 */
		this._threeJsSpoutScene = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Scene();

		/**
		 * The ThreeJS cube camera.
		 * @type {THREE.OrthographicCamera}
		 * @private
		 */
		this._threeJsCubeCamera = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.OrthographicCamera(-1, 1, -1, 1, -1, 1);

		/**
		 * This render target is used to mark the start of the shared texture render block.
		 * @private
		 */
		this._tagStart = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(2, 3, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NearestFilter });

		/**
		 * This render target is used to mark the end of the shared texture render block.
		 * @private
		 */
		this._tagEnd = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(3, 2, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NearestFilter });

		/**
		 * This render target is used to signal that all the shared textures are rendered and can be sent to Spout.
		 * @private
		 */
		this._tagSend = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(3, 3, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NearestFilter });

		/**
		 * This render target is the texture that will be read by Spout.
		 * @private
		 */
		this._spoutTexture = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(this._renderWidth, this._renderWidth / 2, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NearestFilter });

		// Setup the cameras.
		this._setupFaceCameras();

		// Setup the quad for the final render.
		this._setupQuad();
	}

	/**
	 * Gets the render width.
	 * @returns {number}
	 */
	getRenderWidth() {
		return this._renderWidth;
	}

	/**
	 * Sets the render width.
	 * @param {number} renderWidth
	 */
	setRenderWidth(renderWidth) {
		this._renderWidth = renderWidth;
		if (this._spoutTexture.width !== this._renderWidth) {
			this._spoutTexture.setSize(this._renderWidth, this._renderWidth / 2);
		}
		for (let face = 0; face < 6; face++) {
			this._threeJsFaceRenderTargets[face].setSize(this._renderWidth / 4, this._renderWidth / 4);
		}
	}

	/**
	 * Gets if this is for a globe projection.
	 * @return {boolean}
	 */
	getForGlobe() {
		return this.getInvertDepth() === 1;
	}

	/**
	 * Sets if this is for a globe projection.
	 * @param {boolean} forGlobe
	 * @param {number} globeDistance - The distance to which the camera should render.
	 */
	setForGlobe(forGlobe, globeDistance) {
		this.setInvertDepth(forGlobe ? 1 : 0);
		this._globeDistance = globeDistance;
	}

	// INTERNALS

	/**
	 * Renders the camera. Called by Viewport.
	 * @override
	 * @internal
	 */
	__render() {
		// Set the near and mid distances manually to work with the globe.
		if (this.getForGlobe()) {
			this.setNearDistance(Math.max(0.1, this.getEntity().getParent().getOcclusionRadius() * 0.5));
			this.setMidDistance(this.getAutoNearDistance());
		}

		// Update the projection matrix.
		this._updateProjectionMatrices();

		// Set the camera's orientation for each of the face cameras.
		const sqrt2 = 0.7071067811865476;
		const ori = this.getEntity().getOrientation();
		_tempThreeJsQuaternion.set(ori.x, ori.y, ori.z, ori.w);
		this._threeJsFaceCameras[0].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(sqrt2 * (ori.x - ori.y), sqrt2 * (ori.x + ori.y), sqrt2 * (-ori.w + ori.z), sqrt2 * (ori.w + ori.z));
		this._threeJsFaceCameras[1].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(ori.y, -ori.x, ori.w, -ori.z);
		this._threeJsFaceCameras[2].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(sqrt2 * (ori.x + ori.y), sqrt2 * (-ori.x + ori.y), sqrt2 * (ori.w + ori.z), sqrt2 * (ori.w - ori.z));
		this._threeJsFaceCameras[3].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(sqrt2 * (ori.w + ori.x), sqrt2 * (ori.y + ori.z), sqrt2 * (-ori.y + ori.z), sqrt2 * (ori.w - ori.x));
		this._threeJsFaceCameras[4].setRotationFromQuaternion(_tempThreeJsQuaternion);
		_tempThreeJsQuaternion.set(sqrt2 * (-ori.w + ori.x), sqrt2 * (ori.y - ori.z), sqrt2 * (ori.y + ori.z), sqrt2 * (ori.w + ori.x));
		this._threeJsFaceCameras[5].setRotationFromQuaternion(_tempThreeJsQuaternion);

		// If we're using the globe, flip all of the face culling, since depth is inverted.
		if (this.getForGlobe()) {
			this._threeJsRenderer.state.setCullFace(_internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CullFaceFront);
		}

		// Render each of the face cameras to the render targets.
		for (let face = 0; face < 6; face++) {
			this._threeJsRenderer.setRenderTarget(this._threeJsFaceRenderTargets[face]);
			this._threeJsRenderer.render(this.getEntity().getScene().getThreeJsScene(), this._threeJsFaceCameras[face]);
		}

		// If we're using the globe, revert all of the face culling.
		if (this.getForGlobe()) {
			this._threeJsRenderer.state.setCullFace(_internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CullFaceBack);
		}

		// All of the render targets cleared between 'tagStart' and 'tagEnd', will be recorded as Spout textures.
		this._threeJsRenderer.setRenderTarget(this._tagStart);
		this._threeJsRenderer.clearColor();
		this._threeJsRenderer.setRenderTarget(this._spoutTexture);
		this._threeJsRenderer.clearColor();
		this._threeJsRenderer.setRenderTarget(this._tagEnd);
		this._threeJsRenderer.clearColor();

		// Render to the Spout texture using the render targets.
		this._threeJsRenderer.setRenderTarget(this._spoutTexture);
		// this._threeJsRenderer.setRenderTarget(null); // Uncomment this to make it render to the viewport for debugging.
		this._threeJsRenderer.render(this._threeJsSpoutScene, this._threeJsCubeCamera);

		// Signal that all of the recorded textures have been rendered and can be sent to Spout.
		this._threeJsRenderer.setRenderTarget(this._tagSend);
		this._threeJsRenderer.clearColor();

		// Make the render target back to default.
		this._threeJsRenderer.setRenderTarget(null);
	}

	/**
	 * Sets up the cameras.
	 * @private
	 */
	_setupFaceCameras() {
		for (let face = 0; face < 6; face++) {
			this._threeJsFaceCameras.push(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.PerspectiveCamera(90.0, 1.0, 0.1, 1000));
			const projectionMatrix = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Matrix4();
			projectionMatrix.set(
				1, 0, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1,
				0, 1, 0, 0);
			this._threeJsFaceCameras[face].projectionMatrix = projectionMatrix;
			this._threeJsFaceCameras[face].projectionMatrixInverse.copy(projectionMatrix).invert();

			// Setup the render target for the camera.
			const renderTarget = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLRenderTarget(this._renderWidth / 4, this._renderWidth / 4, { minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter, magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter });
			this._threeJsFaceRenderTargets.push(renderTarget);
		}
	}

	/**
	 * Updates the projection.
	 * @private
	 */
	_updateProjectionMatrices() {
		const n = this.getAutoNearDistance();
		let f1 = Number.EPSILON - 1.0;
		let f2 = n * (2.0 - Number.EPSILON);
		if (this.getInvertDepth() === 1) {
			const f = this._globeDistance;
			f1 = (n + f) * (1 - Number.EPSILON) / (n - f);
			f2 = -2 * n * f * (1 - Number.EPSILON) / (n - f);
		}
		for (let face = 0; face < 6; face++) {
			this._threeJsFaceCameras[face].projectionMatrix.elements[6] = f1;
			this._threeJsFaceCameras[face].projectionMatrix.elements[14] = f2;
		}
	}

	/**
	 * Sets the quad meshes up.
	 */
	_setupQuad() {
		// Setup geometry.
		const geometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferGeometry();
		const meshPositions = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]);
		const meshIndices = new Uint16Array([0, 1, 2, 0, 2, 3]);
		geometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(meshPositions, 2));
		geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(meshIndices, 1));

		// Setup material uniforms.
		const uniforms = {
			textures: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([])
		};
		for (let face = 0; face < 6; face++) {
			uniforms['textures'].value.push(this._threeJsFaceRenderTargets[face].texture);
		}

		// Setup material.
		const material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial({
			uniforms: uniforms,
			vertexShader: `
				attribute vec2 position;
				varying vec2 xy;
				void main() {
					gl_Position = vec4(position.x, position.y, 0.0, 1.0);
					xy = position;
				}`,
			fragmentShader: `
				precision highp float;

				uniform sampler2D textures[6];

				varying vec2 xy;
				const float PI = 3.1415926535897932384626433832795;

				vec3 xyToUvFace(vec2 xy) {
					vec3 xyz = vec3(
						cos(xy.y * PI / 2.0) * cos(xy.x * PI),
						cos(xy.y * PI / 2.0) * sin(xy.x * PI),
						sin(-xy.y * PI / 2.0));

					vec3 basis[3];
					float face;
					if (xyz.x * xyz.x >= xyz.y * xyz.y && xyz.x * xyz.x >= xyz.z * xyz.z) {
						if (xyz.x >= 0.0) {
							basis[0] = vec3(0, 1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(1, 0, 0);
							face = 0.0;
						}
						else {
							basis[0] = vec3(0, -1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(-1, 0, 0);
							face = 2.0;
						}
					}
					else if (xyz.y * xyz.y >= xyz.x * xyz.x && xyz.y * xyz.y >= xyz.z * xyz.z) {
						if (xyz.y >= 0.0) {
							basis[0] = vec3(-1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, 1, 0);
							face = 1.0;
						}
						else {
							basis[0] = vec3(1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, -1, 0);
							face = 3.0;
						}
					}
					else {
						if (xyz.z >= 0.0) {
							basis[0] = vec3(0, 1, 0); basis[1] = vec3(-1, 0, 0); basis[2] = vec3(0, 0, 1);
							face = 4.0;
						}
						else {
							basis[0] = vec3(0, 1, 0); basis[1] = vec3(1, 0, 0); basis[2] = vec3(0, 0, -1);
							face = 5.0;
						}
					}

					vec3 uv = vec3(
						basis[0].x * xyz.x + basis[0].y * xyz.y + basis[0].z * xyz.z,
						basis[1].x * xyz.x + basis[1].y * xyz.y + basis[1].z * xyz.z,
						basis[2].x * xyz.x + basis[2].y * xyz.y + basis[2].z * xyz.z);
					uv.x /= uv.z;
					uv.y /= uv.z;

					return vec3(0.5 * (uv.x + 1.0), 0.5 * (uv.y + 1.0), face);
				}

				void main() {
					vec3 uvFace = xyToUvFace(xy);

					vec4 pixel;
					int face = int(uvFace.z);

					if (face == 0) {
						pixel = texture2D(textures[0], vec2(uvFace.x, uvFace.y));
					}
					else if (face == 1) {
						pixel = texture2D(textures[1], vec2(uvFace.x, uvFace.y));
					}
					else if (face == 2) {
						pixel = texture2D(textures[2], vec2(uvFace.x, uvFace.y));
					}
					else if (face == 3) {
						pixel = texture2D(textures[3], vec2(uvFace.x, uvFace.y));
					}
					else if (face == 4) {
						pixel = texture2D(textures[4], vec2(uvFace.x, uvFace.y));
					}
					else if (face == 5) {
						pixel = texture2D(textures[5], vec2(uvFace.x, uvFace.y));
					}

					gl_FragColor = pixel;
				}`,
			depthTest: false,
			depthWrite: false,
			side: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide
		});

		// Setup object.
		this._threeJsQuad = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh(geometry, material);
		this._threeJsQuad.frustumCulled = false;
		this._threeJsSpoutScene.add(this._threeJsQuad);
	}
}

/**
 * A temporary ThreeJs Quaternion.
 * @type {THREE.Quaternion}
 * @private
 */
const _tempThreeJsQuaternion = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Quaternion();


/***/ }),

/***/ "../pioneer/engine/src/scene/components/sprite_component.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/sprite_component.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteComponent": function() { return /* binding */ SpriteComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A 2D sprite in the X-Y plane relative to an entity.
 */
class SpriteComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The url for the texture.
		 * @type {string}
		 * @private
		 */
		this._textureUrl = '';

		/**
		 * The size of the sprite. If a component is NaN, it uses the aspect ratio of the texture to determine that component's size.
		 * @type {Vector2}
		 * @private
		 */
		this._size = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(1, Number.NaN);
		this._size.freeze();

		/**
		 * The units of the size. It can be 'pixels' or 'km'.
		 * @type {string}
		 * @private
		 */
		this._sizeUnits = 'km';

		/**
		 * Each pixel in the texture is multiplied by this value.
		 * @type {Color}
		 * @private
		 */
		this._colorMultiplier = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._colorMultiplier.freeze();

		/**
		 * The alignment of the sprite along the x-y plane.
		 * @type {Vector2}
		 * @private
		 */
		this._alignment = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.5, 0.5);
		this._alignment.freeze();

		/**
		 * The distance at which the sprite begins to fade (50% less than this number and it is completely gone).
		 * @type {number}
		 * @private
		 */
		this._fadeDistance = 0;

		/**
		 * A flag that determines if the sprite has transparent pixels.
		 * @type {boolean}
		 * @private
		 */
		this._transparent = false;

		/**
		 * A flag that determines if the sprite has blending mode.
		 * @type {string}
		 * @private
		 */
		this._blending = 'normal';

		/**
		 * A flag that determines if the sprite is a billboard (always facing the camera).
		 * @type {boolean}
		 * @private
		 */
		this._billboard = false;

		/**
		 * The render ordering of the sprite. Lesser numbers are rendered behind greater numbers.
		 * @type {number}
		 * @private
		 */
		this._renderOrder = 0;
	}

	/**
	 * Gets the url of the texture.
	 * @returns {string}
	 */
	getTextureUrl() {
		return this._textureUrl;
	}

	/**
	 * Sets the url of the texture.
	 * @param {string} url
	 */
	setTextureUrl(url) {
		this._textureUrl = url;
		this.resetResources();
	}

	/**
	 * Gets the size of the sprite.
	 * @return {Vector2}
	 */
	getSize() {
		return this._size;
	}

	/**
	 * Sets the size of the sprite. If a component is NaN, it uses the aspect ratio of the texture to determine that component's size.
	 * @param {Vector2} size
	 */
	setSize(size) {
		this._size.thaw();
		this._size.copy(size);
		this._size.freeze();
		this._updateSizeUniform();
	}

	/**
	 * Gets the units of the size. It can be 'pixels' or 'km'. Defaults to 'km'.
	 * @returns {string}
	 */
	getSizeUnits() {
		return this._sizeUnits;
	}

	/**
	 * Sets the units of the size. It can be 'pixels' or 'km'.
	 * @param {string} sizeUnits
	 */
	setSizeUnits(sizeUnits) {
		this._sizeUnits = sizeUnits;
		this._updateSizeUniform();
	}

	/**
	 * Gets the color multiplier of the sprite. Each pixel in the texture is multiplied by this color.
	 * @returns {Color}
	 */
	getColorMultiplier() {
		return this._colorMultiplier;
	}

	/**
	 * Sets the color multiplier of the sprite. Each pixel in the texture is multiplied by this color.
	 * @param {Color} colorMultiplier
	 */
	setColorMultiplier(colorMultiplier) {
		this._colorMultiplier.thaw();
		this._colorMultiplier.copy(colorMultiplier);
		this._colorMultiplier.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'colorMultiplier', colorMultiplier);
	}

	/**
	 * Gets the sprite alignment on the X-Y plane. Defaults to being center aligned on both axes.
	 * @returns {Vector2}
	 */
	getAlignment() {
		return this._alignment;
	}

	/**
	 * Sets the alignment.
	 * @param {Vector2} alignment - the alignment to set
	 */
	setAlignment(alignment) {
		this._alignment.thaw();
		this._alignment.copy(alignment);
		this._alignment.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], 'origin', this._alignment);
	}

	/**
	 * Gets the distance at which the sprite begins to fade (50% less than this number and it is completely gone).
	 * @returns {number}
	 */
	getFadeDistance() {
		return this._fadeDistance;
	}

	/**
	 * Sets the distance at which the sprite begins to fade (50% less than this number and it is completely gone). Defaults to 0.
	 * @param {number} fadeDistance
	 */
	setFadeDistance(fadeDistance) {
		this._fadeDistance = fadeDistance;
	}

	/**
	 * Returns true if the sprite is a billboard (always facing the camera). Defaults to false.
	 * @returns {boolean}
	 */
	isBillboard() {
		return this._billboard;
	}

	/**
	 * Sets whether the sprite is a billboard (always facing the camera).
	 * @param {boolean} billboard
	 */
	setBillboard(billboard) {
		this._billboard = billboard;
	}

	/**
	 * Gets the transparency of the sprite. Determines whether or not the sprite has alpha values other than 0 or 1.
	 * @returns {boolean}
	 */
	getTransparent() {
		return this._transparent;
	}

	/**
	 * Sets whether or not the sprite has alpha values other than 0 or 1. Defaults to false.
	 * @param {boolean} transparent
	 */
	setTransparent(transparent) {
		this._transparent = transparent;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setTransparent(this.getThreeJsMaterials()[0], this._transparent);
	}

	/**
	 * Sets blending mode. Mode is one of 'normal', 'additive', 'subtractive', 'multliply', 'custom', or 'none'. Defaults to 'normal'.
	 * @param {string} blending
	 */
	setBlending(blending) {
		this._blending = blending;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setBlending(this.getThreeJsMaterials()[0], this._blending);
	}

	/**
	 * Gets the render ordering of the sprite. Lesser numbers are rendered behind greater numbers.
	 * @returns {number}
	 */
	getRenderOrder() {
		return this._renderOrder;
	}

	/**
	 * Sets the render ordering of the sprite. Lesser numbers are rendered behind greater numbers. Defaults to 0.
	 * @param {number} renderOrder
	 */
	setRenderOrder(renderOrder) {
		this._renderOrder = renderOrder;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setRenderOrder(this.getThreeJsObjects()[0], this._renderOrder);
	}

	/**
	 * Updates the camera-dependent parts of the component.
	 * @param {CameraComponent} camera - the camera being used in the render
	 * @override
	 */
	__prepareForRender(camera) {
		// If the size units are in pixels, adjust the size accordingly.
		if (this._sizeUnits === 'pixels') {
			const size = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
			const sizeMultiplier = this.getEntity().getExtentsRadius() / this.getEntity().getPixelSpaceExtentsRadius(camera);
			size.mult(this._size, sizeMultiplier);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], 'size', size);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(size);
		}

		// If it is a billboard, set the orientation to always face the camera.
		if (this.getThreeJsObjects().length > 0) {
			if (this._billboard) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToBillboard(this.getThreeJsObjects()[0], this.getEntity(), camera);
			}
			else {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());
			}
		}

		// Set the alpha fade distance multiplier.
		if (this._fadeDistance > 0) {
			const posInSpriteFrame = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			const threeJsOrientation = this.getThreeJsObjects()[0].quaternion;
			orientation.copyFromThreeJs(threeJsOrientation);
			posInSpriteFrame.rotateInverse(this.getEntity().getOrientation(), this.getEntity().getCameraSpacePosition(camera));
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'alphaFadeMultiplier',
				_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(0, 1, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(2 * (Math.abs(posInSpriteFrame.z) / this._fadeDistance - 1) + 1)));
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(posInSpriteFrame);
		}

		// Set the Three.js object position the entity's camera-space position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Load the texture.
		const texture = await _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTexture(this, this._textureUrl, false, false);

		// Check if the component has since stopped loading.
		if (this.getLoadState() !== 'loading') {
			texture.dispose();
			return;
		}

		// Create the Three.js object.
		if (SpriteComponent._useCount === 0) {
			// Create the shared geometry as a square 0, 0 to 1, 1.
			SpriteComponent._threeJsGeometry = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createGeometry([{ name: 'position', dimensions: 3 }, { name: 'uv', dimensions: 2 }], false);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(SpriteComponent._threeJsGeometry, 'position', new Float32Array([0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0]));
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(SpriteComponent._threeJsGeometry, 'uv', new Float32Array([0, 1, 1, 1, 1, 0, 0, 0]));
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(SpriteComponent._threeJsGeometry, new Uint16Array([0, 1, 2, 2, 3, 0]));

			// Create the shared material.
			SpriteComponent._threeJsMaterial = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ShaderMaterial({
				uniforms: {
					colorMultiplier: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4(1.0, 1.0, 1.0, 1.0)),
					alphaFadeMultiplier: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1),
					size: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2(1.0, 1.0)),
					colorTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					origin: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2(0, 0)),

					..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
				},
				vertexShader: `
					uniform vec2 size;
					uniform vec2 origin;
					varying vec2 fUV;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

					void main() {
						vec4 viewPosition = modelViewMatrix * vec4((position.x - origin.x) * size.x, (position.y - origin.y) * size.y, 0.0, 1.0);
						gl_Position = projectionMatrix * viewPosition;
						fUV = uv;

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
					}`,
				fragmentShader: `
					precision highp float;

					uniform vec4 colorMultiplier;
					uniform float alphaFadeMultiplier;
					uniform sampler2D colorTexture;
					varying vec2 fUV;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

					void main(void) {
						gl_FragColor = texture2D(colorTexture, fUV);
						gl_FragColor *= colorMultiplier;
						gl_FragColor.a *= alphaFadeMultiplier;

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
					}`,
				side: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DoubleSide
			});
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupLogDepthBuffering(SpriteComponent._threeJsMaterial);
		}
		SpriteComponent._useCount += 1;

		// Create the material.
		const material = SpriteComponent._threeJsMaterial.clone();
		this.getThreeJsMaterials().push(material);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setTransparent(material, this._transparent);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setBlending(material, this._blending);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(material, 'colorMultiplier', this._colorMultiplier);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'alphaFadeMultiplier', 1);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(material, 'origin', this._alignment);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformTexture(material, 'colorTexture', texture);

		// Create the object.
		const object = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObjectGivenGeometry(this, material, SpriteComponent._threeJsGeometry);
		this.getThreeJsObjects().push(object);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setRenderOrder(object, this._renderOrder);

		this._updateSizeUniform();
	}

	/**
	 * Unloads the resources.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		// Destroy the material.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyMaterial(this.getThreeJsMaterials()[0]);
		// Remove the object from the scene.
		const object = this.getThreeJsObjects()[0];
		if (object.parent !== undefined) {
			object.parent.remove(object);
		}
		// If there are no more sprites, destroy the geometry and material.
		SpriteComponent._useCount -= 1;
		if (SpriteComponent._useCount === 0) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyGeometry(SpriteComponent._threeJsGeometry);
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyMaterial(SpriteComponent._threeJsMaterial);
		}
	}

	/**
	 * Updates the size of the sprite given the size of this component and the texture size.
	 * @private
	 */
	_updateSizeUniform() {
		if (this.getThreeJsMaterials().length > 0) {
			/** @type {THREE.Texture} */
			const texture = this.getThreeJsMaterials()[0].uniforms['colorTexture'].value;
			if (texture !== null) {
				const textureAspectRatio = texture.image.width / texture.image.height;
				const size = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
				if (Number.isNaN(this._size.x)) {
					size.set(this._size.y * textureAspectRatio, this._size.y);
				}
				else if (Number.isNaN(this._size.y)) {
					size.set(this._size.x, this._size.x / textureAspectRatio);
				}
				else {
					size.set(this._size.x, this._size.y);
				}
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this.getThreeJsMaterials()[0], 'size', size);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(size);

				if (this._sizeUnits === 'km') {
					this.__setRadius(Math.max(size.x, size.y));
				}
				else { // pixels
					this.__setRadius(Number.POSITIVE_INFINITY);
				}
			}
		}
		else {
			if (this._sizeUnits === 'km') {
				if (Number.isNaN(this._size.x)) {
					this.__setRadius(this._size.y);
				}
				else if (Number.isNaN(this._size.y)) {
					this.__setRadius(this._size.y);
				}
				else {
					this.__setRadius(Math.max(this._size.x, this._size.y));
				}
			}
			else {
				this.__setRadius(Number.POSITIVE_INFINITY);
			}
		}
	}
}

/**
 * A global shared material, copied by sprites.
 * @type {THREE.ShaderMaterial}
 */
SpriteComponent._threeJsMaterial = null;

/**
 * A global shared geometry unit square with a corner at (0, 0), copied by sprites.
 * @type {THREE.BufferGeometry}
 */
SpriteComponent._threeJsGeometry = null;

/**
 * The count for the number of sprites used.
 * @type {number}
 */
SpriteComponent._useCount = 0;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/starfield_component.js":
/*!*********************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/starfield_component.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "StarfieldComponent": function() { return /* binding */ StarfieldComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


const eclipJ2000ToJ200Rotation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion(0.9791532214288992, 0.2031230389823101, 0, 0);

// Star used in the Starfield component.
class Star {
	constructor() {
		this.mag = 0;
		this.absMag = 0;
		this.color = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color();
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this.particle = null;
	}
}

/**
 * The starfield component. Loads a star file.
 * @todo Document the star file format.
 */
class StarfieldComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The database URL.
		 * @type {string}
		 * @private
		 */
		this._url = '';

		// Set the radius to the whole universe.
		this.__setRadius(1e24);
	}

	/**
	 * Gets the url of the star database.
	 * @returns {string}
	 */
	getUrl() {
		return this._url;
	}

	/**
	 * Sets the url.
	 * @param {string} url - the url to set
	 */
	setUrl(url) {
		this._url = url;
		this.resetResources();
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// If the camera is a Spout camera, use Spout for the render size.
		const renderSize = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
		if (camera.getType() === 'spout') {
			const spoutComponent = /** @type {SpoutComponent} */(camera);
			renderSize.set(spoutComponent.getRenderWidth(), spoutComponent.getRenderWidth() * 0.5);
		}
		// Otherwise use the viewport size.
		else {
			renderSize.copy(camera.getViewport().getBounds().size);
		}

		const resolutionFactor = Math.sqrt(Math.max(renderSize.x, renderSize.y) * window.devicePixelRatio) / 60;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'resolutionFactor', resolutionFactor);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(renderSize);

		// Set the Three.js object position the entity's camera-space position.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		// Load the stars from the database.
		const stars = await this._loadStars();

		// Check if the component has since been destroyed.
		if (this.isDestroyed()) {
			return;
		}

		// Setup the Three.js material.
		const material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ShaderMaterial({
			vertexShader: StarfieldComponent.vertexShader,
			fragmentShader: StarfieldComponent.fragmentShader,
			transparent: true,
			blending: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AdditiveBlending,
			depthWrite: false,
			uniforms: {
				resolutionFactor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1.0),

				..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
			}
		});
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupLogDepthBuffering(material);
		this.getThreeJsMaterials().push(material);

		// Setup the Three.js geometry.
		const threeJsGeometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferGeometry();
		threeJsGeometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Float32Array(0), 3));
		threeJsGeometry.setAttribute('color', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Float32Array(0), 4));
		threeJsGeometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Uint16Array(0), 1));

		// Setup the Three.js object.
		const threeJsObject = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Points(threeJsGeometry, material);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupObject(this, threeJsObject);
		threeJsObject.renderOrder = -2; // Make it render before other transparent objects.
		this.getThreeJsObjects().push(threeJsObject);

		// Update the particle geometry from the star database.
		const meshPositions = new Float32Array(stars.length * 3);
		const meshColors = new Float32Array(stars.length * 4);
		const meshIndices = new Uint16Array(stars.length);
		for (let i = 0; i < stars.length; i++) {
			const star = stars[i];
			meshPositions[i * 3 + 0] = star.position.x;
			meshPositions[i * 3 + 1] = star.position.y;
			meshPositions[i * 3 + 2] = star.position.z;
			meshColors[i * 4 + 0] = star.color.r;
			meshColors[i * 4 + 1] = star.color.g;
			meshColors[i * 4 + 2] = star.color.b;
			meshColors[i * 4 + 3] = star.absMag; // The alpha channel is for the absolute magnitude, used in the shader.
			meshIndices[i] = i;
		}

		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(threeJsGeometry, 'position', meshPositions);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(threeJsGeometry, 'color', meshColors);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(threeJsGeometry, meshIndices);
	}

	/**
	 * Unloads the resources.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Loads the star database.
	 * @returns {Promise<Star[]>}
	 * @private
	 */
	_loadStars() {
		// The promise that is used to tell when the animdef is loaded.
		return this.getEntity().getScene().getEngine().getDownloader().download(this._url, true).then((download) => {
			if (download.status === 'cancelled') {
				return Promise.resolve([]);
			}
			else if (download.status === 'failed') {
				return Promise.reject(new Error('Failed to load starfield component file "' + download.url + '": ' + download.errorMessage));
			}
			if (!(download.content instanceof ArrayBuffer)) {
				return Promise.reject(new Error('Failed to load starfield component file "' + download.url + '": Not a binary file.'));
			}
			const reader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);
			const numStars = reader.readInt32();
			/** @type {Star[]} */
			const stars = [];
			for (let i = 0; i < numStars; i++) {
				const star = new Star();
				star.mag = reader.readFloat32();
				star.absMag = reader.readFloat32();
				star.color.r = reader.readByte() / 255;
				star.color.g = reader.readByte() / 255;
				star.color.b = reader.readByte() / 255;
				star.color.div(star.color, star.color.max());
				star.position.y = -reader.readFloat32();
				star.position.z = reader.readFloat32();
				star.position.x = reader.readFloat32();
				star.position.rotate(eclipJ2000ToJ200Rotation, star.position);
				stars.push(star);
			}

			return stars;
		});
	}
}

StarfieldComponent.vertexShader = `
	#define PI 3.1415926538

	attribute vec4 color;
	varying vec4 fColor;

	uniform float resolutionFactor;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

	// Returns the watts per km^2.
	float absoluteMagnitudeToFlux(float absoluteMagnitude, float distance) {
		float luminosityInWatts = 3.0128e28 * pow(10.0, absoluteMagnitude / -2.5);
		return luminosityInWatts / (4.0 * PI * distance * distance);
	}

	void main() {
		vec4 viewPosition = modelViewMatrix * vec4(position, 1.0);
		gl_Position = projectionMatrix * viewPosition;
		gl_Position.w = viewPosition.y;
		fColor = color;

		// Get the flux and brightness of the star at the camera's point.
		float absMag = color.a;
		float distance = length(viewPosition);
		float flux = absoluteMagnitudeToFlux(absMag, distance);
		float brightness = 2.0 * log(1.0 + flux * 1e4);

		// Adjust the color and size so that it is visually pleasing.
		fColor.a = clamp(brightness * resolutionFactor, 0.05, 1.0);
		gl_PointSize = clamp(brightness * 4.0 * resolutionFactor, 5.0, 24.0);

		// If it is too close, fade the star.
		fColor.a = mix(0.0, fColor.a, clamp((distance - 1.0e12) / 9.0e12, 0.0, 1.0));

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
	}`;

StarfieldComponent.fragmentShader = `
	precision highp float;

	varying vec4 fColor;

	${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

	void main(void) {
		float distanceFromEdge = clamp(1.0 - 2.0 * length(gl_PointCoord - vec2(0.5, 0.5)), 0.0, 1.0);
		float a = pow(distanceFromEdge, 5.0);
		gl_FragColor.rgb = fColor.rgb;
		gl_FragColor.a = fColor.a * a;

		${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
	}`;


/***/ }),

/***/ "../pioneer/engine/src/scene/components/trail_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/components/trail_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrailComponent": function() { return /* binding */ TrailComponent; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * Point used in Trail component.
 * @private
 */
class Point {
	/**
	 * Constructor.
	 */
	constructor() {
		/**
		 * The time of the point.
		 * @type {number}
		 */
		this.time = 0;

		/**
		 * The position of the entity at this time.
		 * @type {Vector3}
		 */
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * The velocity of the entity at this time.
		 * @type {Vector3}
		 */
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}
}

/**
 * The trail component.
 */
class TrailComponent extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The color of the trail.
		 * @type {Color}
		 * @private
		 */
		this._color = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The alpha value to which the trail fades (_points[0] is this value)
		 * @type {number}
		 * @private
		 */
		this._alphaFade = 0;

		/**
		 * The minimum width for the trail.
		 * @type {number}
		 * @private
		 */
		this._widthMin = 0;

		/**
		 * The maximum width for the trail.
		 * @type {number}
		 * @private
		 */
		this._widthMax = 2;

		/**
		 * A flag the determines whether or not the trail ignores the distance when determining visibility.
		 * @type {boolean}
		 * @private
		 */
		this._ignoreDistance = false;

		/**
		 * The start time. May be absolute or relative.
		 * @type {number | undefined}
		 * @private
		 */
		this._startTime = undefined;

		/**
		 * The end time. May be absolute or relative.
		 * @type {number|undefined}
		 * @private
		 */
		this._endTime = 0;

		/**
		 * Whether the start time is absolute or relative.
		 * @type {boolean}
		 * @private
		 */
		this._relativeStartTime = true;

		/**
		 * Whether the end time is absolute or relative.
		 * @type {boolean}
		 * @private
		 */
		this._relativeEndTime = true;

		/**
		 * The multiplier of the start time to use. Only valid when startTime is relative.
		 * @type {number}
		 * @private
		 */
		this._startTimeMultiplier = 1;

		/**
		 * The multiplier of the end time to use. Only valid when endTime is relative.
		 * @type {number}
		 * @private
		 */
		this._endTimeMultiplier = 1;

		/**
		 * The entity that the trail is relative to. Defaults to entity's parent if null.
		 * @type {EntityRef}
		 * @private
		 */
		this._relativeToEntity = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * Flag if the trail is relative to the parent entity's orientation.
		 * @type {boolean}
		 * @private
		 */
		this._relativeToEntityOrientation = false;

		/**
		 * The maximum angle in radians allowed between segments before they are split.
		 * @type {number}
		 * @private
		 */
		this._angleCurveThreshold = 0.05235987755; // 3 degrees

		/**
		 * The initial time step for following the trail. Undefined means the trail length / the angular curve threshold.
		 * @type {number | undefined}
		 * @private
		 */
		this._initialTimeStep = undefined;

		/**
		 * The circular buffer of points.
		 * @type {Array<Point>}
		 * @private
		 */
		this._points = [];

		/**
		 * The start index for the points array.
		 * @type {number}
		 * @private
		 */
		this._pointsStart = 0;

		/**
		 * The number of items in the points array.
		 * @type {number}
		 * @private
		 */
		this._pointsCount = 0;

		/**
		 * The entity that the trail is relative-to.
		 * @type {EntityRef}
		 * @private
		 */
		this._currentRelativeToEntity = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The dash length for dashed lines.
		 * @type {number}
		 * @private
		 */
		this._dashLength = 1;

		/**
		 * The dash gap length for dashed lines.
		 * @type {number}
		 * @private
		 */
		this._dashGapLength = 0;

		/**
		 * The glow width for the lines.
		 * @type {number}
		 * @private
		 */
		this._glowWidth = 0;

		/**
		 * An offset time for the dash offset.
		 * @type {number}
		 * @private
		 */
		this._dashOffsetTime = 0;

		// Make the radius infinite since this should always show.
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Gets the color of the trail.
	 * @returns {Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the trail. Defaults to white.
	 * @param {Color} color - The color to set
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color);
	}

	/**
	 * Gets the value to which the trail alpha fades, between 0 and 1. Defaults to 0.
	 * @returns {number}
	 */
	getAlphaFade() {
		return this._alphaFade;
	}

	/**
	 * Sets the min and max widths for the trail.
	 * @param {number} min
	 * @param {number} max
	 */
	setWidths(min, max) {
		this._widthMin = min;
		this._widthMax = max;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'widthMin', min);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'widthMax', max);
	}

	/**
	 * Sets the value to which trail alpha fades, between 0 and 1. Defaults to 0.
	 * @param {number} alphaFade - the value to set
	 */
	setAlphaFade(alphaFade) {
		this._alphaFade = alphaFade;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'alphaFade', alphaFade);
	}

	/**
	 * Sets the line dash and gap length.
	 * @param {number} dashLength
	 * @param {number} dashGapLength
	 */
	setDashLength(dashLength, dashGapLength) {
		this._dashLength = dashLength;
		this._dashGapLength = dashGapLength;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'dashLength', dashLength);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'dashGapLength', dashGapLength);
	}

	/**
	 * Sets the glow for the lines.
	 * @param {number} glowWidth
	 */
	setGlowWidth(glowWidth) {
		this._glowWidth = glowWidth;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'glowWidth', this._glowWidth);
	}

	/**
	 * Gets the start time of the trail. If relative start time is true, this is a positive offset time. Otherwise it is absolute. If it is undefined and relative time is true, it is a dynamic length. Defaults to undefined.
	 * @returns {number | undefined}
	 */
	getStartTime() {
		return this._startTime;
	}

	/**
	 * Sets the start time of the trail. If relative start time is true, this is a positive offset time. Otherwise it is absolute.
	 * If it is undefined and relative start time is true, the length is dynamic. Default is undefined.
	 * @param {number | undefined} value - The value to set
	 */
	setStartTime(value) {
		this._startTime = value;
	}

	/**
	 * Gets the end time of the trail. If relative time is true, this is a positive offset time. Otherwise it is absolute. If it is undefined and relative time is true, it is a dynamic length. Defaults to 0.
	 * @returns {number | undefined}
	 */
	getEndTime() {
		return this._endTime;
	}

	/**
	 * Sets the end time of the trail. If relative end time is true, this is a positive offset time. Otherwise it is absolute.
	 * If it is undefined and relative time is true, the length is dynamic.
	 * @param {number | undefined} value - The value to set
	 */
	setEndTime(value) {
		this._endTime = value;
	}

	/**
	 * Returns true if the trail start time is relative to the current time. Defaults to true.
	 * @returns {boolean}
	 */
	isRelativeStartTime() {
		return this._relativeStartTime;
	}

	/**
	 * Sets if the trail start time is relative to the current time.
	 * @param {boolean} value - The value to set
	 */
	setRelativeStartTime(value) {
		this._relativeStartTime = value;
		this.resetPoints();
	}

	/**
	 * Returns true if the trail end time is relative to the current time. Defaults to true.
	 * @returns {boolean}
	 */
	isRelativeEndTime() {
		return this._relativeEndTime;
	}

	/**
	 * Sets if the trail end time is relative to the current time.
	 * @param {boolean} value - The value to set
	 */
	setRelativeEndTime(value) {
		this._relativeEndTime = value;
		this.resetPoints();
	}

	/**
	 * Gets the multiplier of the start time to use. Only valid when startTime is relative. Defaults to 1.
	 * @returns {number}
	 */
	getStartTimeMultiplier() {
		return this._startTimeMultiplier;
	}

	/**
	 * Sets the multiplier of the start time to use. Only valid when startTime is relative. Defaults to 1.
	 * @param {number} startTimeMultiplier
	 */
	setStartTimeMultiplier(startTimeMultiplier) {
		this._startTimeMultiplier = startTimeMultiplier;
	}

	/**
	 * Gets the multiplier of the end time to use. Only valid when endTime is relative. Defaults to 1.
	 * @returns {number}
	 */
	getEndTimeMultiplier() {
		return this._endTimeMultiplier;
	}

	/**
	 * Sets the multiplier of the end time to use. Only valid when endTime is relative. Defaults to 1.
	 * @param {number} endTimeMultiplier
	 */
	setEndTimeMultiplier(endTimeMultiplier) {
		this._endTimeMultiplier = endTimeMultiplier;
	}

	/**
	 * Gets the entity name that the trail is relative to.
	 * @returns {string}
	 */
	getRelativeToEntity() {
		return this._relativeToEntity.getName();
	}

	/**
	 * Sets the entity name that the trail is relative to. Defaults to the parent if ''.
	 * @param {string} entityName
	 */
	setRelativeToEntity(entityName) {
		this._relativeToEntity.setName(entityName);
		this._currentRelativeToEntity.setName(entityName);
		this.resetPoints();
	}

	/**
	 * Returns true if the trail is relative to the parent entity's orientation. Defaults to false.
	 * @returns {boolean}
	 */
	isRelativeToEntityOrientation() {
		return this._relativeToEntityOrientation;
	}

	/**
	 * Sets if the trail is relative to the parent entity's orientation. Used for landers and ground objects.
	 * @param {boolean} enable
	 */
	setRelativeToEntityOrientation(enable) {
		this._relativeToEntityOrientation = enable;
		if (!enable) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		this.resetPoints();
	}

	/**
	 * Gets the maximum angle in radians allowed between segments before they are split.
	 * @returns {number}
	 */
	getAngleCurveThreshold() {
		return this._angleCurveThreshold;
	}

	/**
	 * Sets the maximum angle in radians allowed between segments before they are split. Defaults to 3 degrees.
	 * @param {number} angleCurveThreshold
	 */
	setAngleCurveThreshold(angleCurveThreshold) {
		this._angleCurveThreshold = angleCurveThreshold;
		this.resetPoints();
	}

	/**
	 * Gets the initial time step for following the trail. Undefined means the trail length / the angular curve threshold.
	 * @returns {number | undefined}
	 */
	getInitialTimeStep() {
		return this._initialTimeStep;
	}

	/**
	 * Sets the initial time step for following the trail. Undefined means the trail length / the angular curve threshold. Defaults to undefined.
	 * @param {number | undefined} initialTimeStep
	 */
	setInitialTimeStep(initialTimeStep) {
		this._initialTimeStep = initialTimeStep;
		this.resetPoints();
	}

	/**
	 * Ignores the distance when determining whether it should show the trail or not. Defaults to false.
	 * @param {boolean} enable
	 */
	setIgnoreDistance(enable) {
		this._ignoreDistance = enable;
	}

	/**
	 * Resets the points on the trail, so that they will be newly added. Useful for when the entity's controllers have bee modified and the whole trail needs to be updated.
	 */
	resetPoints() {
		this._points = [];
		this._pointsCount = 0;
		this._pointsStart = 0;

		if (this.getThreeJsObjects().length > 0) {
			const geometry = (/** @type {THREE.Mesh} */(this.getThreeJsObjects()[0])).geometry;
			const newArray = new Float32Array(0);
			const buffer = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBuffer(newArray, TrailComponent.VERTEX_SIZE);
			geometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 0, false));
			geometry.setAttribute('positionPrev', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 3, false));
			geometry.setAttribute('positionNext', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 6, false));
			geometry.setAttribute('side', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 9, false));
			geometry.setAttribute('index', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 10, false));
			geometry.setAttribute('dashOffset', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 11, false));

			// Setup the index buffer.
			geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Uint16Array(0), 1));
		}
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		// Create the material.
		const material = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('trail');
		this.getThreeJsMaterials().push(material);
		material.uniforms['dashLength'].value = this._dashLength;
		material.uniforms['dashGapLength'].value = this._dashGapLength;
		material.uniforms['indexStart'].value = 0;
		material.uniforms['indexCount'].value = 0;
		material.uniforms['indexLength'].value = 0;
		material.uniforms['color'].value.set(this._color.r, this._color.g, this._color.b, this._color.a);
		material.uniforms['widthMin'].value = this._widthMin;
		material.uniforms['widthMax'].value = this._widthMax;
		material.uniforms['glowWidth'].value = this._glowWidth;
		material.uniforms['alphaFade'].value = this._alphaFade;

		// Create the object.
		const threeJsObject = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [
			{ name: 'position', dimensions: 3 },
			{ name: 'positionPrev', dimensions: 3 },
			{ name: 'positionNext', dimensions: 3 },
			{ name: 'side', dimensions: 1 },
			{ name: 'index', dimensions: 1 },
			{ name: 'dashOffset', dimensions: 1 }
		], true);
		this.getThreeJsObjects().push(threeJsObject);

		// Return the resolved promise.
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		this.getEntity().getScene().getEngine().getMaterialManager().release(this.getThreeJsMaterials()[0]);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._points = [];
		this._pointsCount = 0;
		this._pointsStart = 0;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// If the parent has changed, we need to reset the points so that they work with the new parent.
		if (this._relativeToEntity.getName() === '' && this.getEntity().getParent() !== null && this._currentRelativeToEntity.get() !== this.getEntity().getParent()) {
			this._currentRelativeToEntity.setName(this.getEntity().getParent().getName());
			this.resetPoints();
		}
		if (this._currentRelativeToEntity === null) {
			return;
		}

		// Update the points and set the calculated positions and colors.
		this._updatePoints();

		// Set the index start, count, and length uniforms.
		const material = this.getThreeJsMaterials()[0];
		material.uniforms['indexStart'].value = this._pointsStart;
		material.uniforms['indexCount'].value = this._pointsCount;
		material.uniforms['indexLength'].value = this._points.length;

		// Set the alpha multiplier based on conditions.
		let alphaMultiplier = 1.0;
		if (!this._ignoreDistance) {
			// Set the alpha multiplier based on the camera distance to the entity.
			const normalizedSizeOfEntity = this.getEntity().getNormalSpaceExtentsRadius(camera);
			alphaMultiplier *= (0.02 - normalizedSizeOfEntity) / 0.02;

			// When the position is too far, there's imprecision "wiggle" in the shader. This fades the trail before the wiggle occurs.
			const camDistOverPosDist = this.getEntity().getCameraSpacePosition(camera).magnitude() / this.getEntity().getPosition().magnitude();
			alphaMultiplier *= _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(camDistOverPosDist * 1000);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(material, 'alphaMultiplier', alphaMultiplier);

		// Set the pixel size.
		// If the camera is a Spout camera, make the lines thicker and use Spout for the render size.
		const pixelSize = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
		if (camera instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.SpoutComponent) {
			pixelSize.set(camera.getRenderWidth() * 0.1, camera.getRenderWidth() * 0.5 * 0.1);
		}
		// Otherwise use the viewport size.
		else {
			pixelSize.copy(camera.getViewport().getBounds().size);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(material, 'pixelSize', pixelSize);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelSize);

		// Set the position and orientation of the Three.js objects.
		const currentRelativeToEntity = this._currentRelativeToEntity.get();
		if (currentRelativeToEntity !== null) {
			// Set the Three.js object position the relative-to-entity's camera-space position.
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPosition(this.getThreeJsObjects(), currentRelativeToEntity.getCameraSpacePosition(camera));

			// If relativeToEntityOrientation is set, set the orientation to that entity.
			if (this._relativeToEntityOrientation) {
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), currentRelativeToEntity.getOrientation());
			}
		}
	}

	/**
	 * Updates the points array.
	 * @private
	 */
	_updatePoints() {
		const intervalForUpdate = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();

		// Determine the interval that will be updated.
		this._getIntervalForUpdate(intervalForUpdate);

		// If one of the values is NaN, don't update the trail.
		if (isNaN(intervalForUpdate.min) || isNaN(intervalForUpdate.max)) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(intervalForUpdate);
			return;
		}

		// Determine the step for the vertices to be added.
		// For a circular trail, 360 degrees total / 3 degrees each = 120 steps.
		const initialTimeStep = this._initialTimeStep ?? (intervalForUpdate.length() * this._angleCurveThreshold / (2 * Math.PI));

		// Get the start and end index ranges.
		const updateRange = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
		updateRange.set(Number.POSITIVE_INFINITY, 0);

		// FRONT POINTS

		// Pop off one end point.
		if (this._relativeStartTime && this._pointsCount > 0 && this._points[this._pointsStart].time !== intervalForUpdate.min) {
			this._popFrontPoint(updateRange);
		}

		// Clear off any excess end points.
		while (this._pointsCount > 0 && this._points[this._pointsStart].time < intervalForUpdate.min) {
			this._popFrontPoint(updateRange);
		}

		// Add on any new end points.
		const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		while (this._pointsCount === 0 || this._points[this._pointsStart].time > intervalForUpdate.min) {
			// If we have a ton of points and we're in relative mode, don't add any more.
			if (this._pointsCount >= 16000 && this._relativeStartTime) {
				break;
			}

			// Create new point.
			this._pushFrontPoint(updateRange);
			const nextPoint = this._points[this._pointsStart];

			// Get a starting step.
			let minStep = 1;
			let maxStep = Number.POSITIVE_INFINITY;
			let step = initialTimeStep;
			if (this._pointsCount > 2) {
				step = this._points[(this._pointsStart + 2) % this._points.length].time
					- this._points[(this._pointsStart + 1) % this._points.length].time;
			}

			// Get the next time, taking into account curvature.
			let curvatureCheckCount = 0;
			while (curvatureCheckCount < 20) {
				let nextTime = intervalForUpdate.max;
				if (this._pointsCount > 1) {
					nextTime = this._points[(this._pointsStart + 1) % this._points.length].time - step;
				}
				if (nextTime < intervalForUpdate.min) {
					nextTime = intervalForUpdate.min;
				}

				// Get the next position and/or orientation states.
				nextPoint.time = nextTime;
				this._getPositionAndVelocity(nextPoint.position, nextPoint.velocity, nextPoint.time);

				// Invalid position and/or orientation states, so we can't draw any more trail.
				if (nextPoint.position.isNaN() || (this._relativeToEntityOrientation && orientation.isNaN())) {
					break;
				}

				// Get angle for curvature checking.
				let angle = 0;
				if (this._pointsCount >= 2) {
					angle = this._points[(this._pointsStart + 1) % this._points.length].velocity.angle(nextPoint.velocity);
				}

				// Grow or shrink the step depending on the angle.
				if (angle > this._angleCurveThreshold) { // too big of an angle, so shrink the step.
					maxStep = step;
					step = (minStep + step) / 2.0;
				}
				else if (this._pointsCount > 1 && step < initialTimeStep * 10 && (isNaN(angle) || angle < this._angleCurveThreshold / 3) && nextTime !== intervalForUpdate.min) { // too small of an angle, so grow the step.
					minStep = step;
					if (maxStep === Number.POSITIVE_INFINITY) {
						step *= 2;
					}
					else {
						step = (step + maxStep) / 2.0;
					}
				}
				else {
					break;
				}
				curvatureCheckCount++;
			}
			if (nextPoint.position.isNaN() || (this._relativeToEntityOrientation && orientation.isNaN())) {
				this._popFrontPoint(updateRange);
				break;
			}
		}

		// BACK POINTS

		// Pop off one end point.
		if (this._relativeEndTime && this._pointsCount > 0 && this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length].time !== intervalForUpdate.max) {
			this._popBackPoint(updateRange);
		}

		// Clear off any excess end points.
		while (this._pointsCount > 0 && this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length].time > intervalForUpdate.max) {
			this._popBackPoint(updateRange);
		}

		// Add on any new end points.
		while (this._pointsCount === 0 || this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length].time < intervalForUpdate.max) {
			// If we have a ton of points and we're in relative mode, don't add any more.
			if (this._pointsCount >= 16000 && this._relativeEndTime) {
				break;
			}

			// Create new point.
			this._pushBackPoint(updateRange);
			const nextPoint = this._points[(this._pointsStart + this._pointsCount - 1) % this._points.length];

			// Get a starting step.
			let minStep = 1;
			let maxStep = Number.POSITIVE_INFINITY;
			let step = initialTimeStep;
			if (this._pointsCount > 2) {
				step = this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].time
					- this._points[(this._pointsStart + this._pointsCount - 3) % this._points.length].time;
			}

			// Get the next time, taking into account curvature.
			let curvatureCheckCount = 0;
			while (curvatureCheckCount < 20) {
				let nextTime = intervalForUpdate.min;
				if (this._pointsCount > 1) {
					nextTime = this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].time + step;
				}
				if (nextTime > intervalForUpdate.max) {
					nextTime = intervalForUpdate.max;
				}

				// Get the next position and/or orientation states.
				nextPoint.time = nextTime;
				this._getPositionAndVelocity(nextPoint.position, nextPoint.velocity, nextPoint.time);

				// Invalid position and/or orientation states, so we can't draw any more trail.
				if (nextPoint.position.isNaN() || (this._relativeToEntityOrientation && orientation.isNaN())) {
					break;
				}

				// Get angle for curvature checking.
				let angle = 0;
				if (this._pointsCount >= 2) {
					angle = this._points[(this._pointsStart + this._pointsCount - 2) % this._points.length].velocity.angle(nextPoint.velocity);
				}

				// Grow or shrink the step depending on the angle.
				if (angle > this._angleCurveThreshold) { // too big of an angle, so shrink the step.
					maxStep = step;
					step = (minStep + step) / 2.0;
				}
				else if (this._pointsCount > 1 && step < initialTimeStep * 10 && (isNaN(angle) || angle < this._angleCurveThreshold / 3) && nextTime !== intervalForUpdate.max) { // too small of an angle, so grow the step.
					minStep = step;
					if (maxStep === Number.POSITIVE_INFINITY) {
						step *= 2;
					}
					else {
						step = (step + maxStep) / 2.0;
					}
				}
				else {
					break;
				}
				curvatureCheckCount++;
			}
			if (nextPoint.position.isNaN() || (this._relativeToEntityOrientation && orientation.isNaN())) {
				this._popBackPoint(updateRange);
				break;
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(intervalForUpdate);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);

		// UPDATE THE VERTEX ARRAY

		const geometry = (/** @type {THREE.Mesh} */(this.getThreeJsObjects()[0])).geometry;
		const buffer = /** @type {THREE.InterleavedBufferAttribute} */(geometry.attributes['positionCurr']).data;
		const array = /** @type {Float32Array} */(buffer.array);
		for (let i = updateRange.min, max = Math.min(this._points.length - 1, updateRange.max); i <= max; i++) {
			const thisPosition = this._points[i].position;
			const prevPosition = !isNaN(this._points[(i + this._points.length - 1) % this._points.length].position.x)
				? this._points[(i + this._points.length - 1) % this._points.length].position
				: thisPosition;
			const nextPosition = !isNaN(this._points[(i + 1) % this._points.length].position.x)
				? this._points[(i + 1) % this._points.length].position
				: thisPosition;

			array[i * 2 * TrailComponent.VERTEX_SIZE + 0] = thisPosition.x;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 1] = thisPosition.y;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 2] = thisPosition.z;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 0] = thisPosition.x;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 1] = thisPosition.y;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 2] = thisPosition.z;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 3] = prevPosition.x;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 4] = prevPosition.y;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 5] = prevPosition.z;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 3] = prevPosition.x;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 4] = prevPosition.y;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 5] = prevPosition.z;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 6] = nextPosition.x;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 7] = nextPosition.y;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 8] = nextPosition.z;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 6] = nextPosition.x;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 7] = nextPosition.y;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 8] = nextPosition.z;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 9] = +1;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 9] = -1;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 10] = i;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 10] = i;
			array[i * 2 * TrailComponent.VERTEX_SIZE + 11] = this._points[i].time - this._dashOffsetTime;
			array[(i * 2 + 1) * TrailComponent.VERTEX_SIZE + 11] = this._points[i].time - this._dashOffsetTime;
		}
		buffer.needsUpdate = true;
		buffer.updateRange.offset = updateRange.max < updateRange.min ? 0 : updateRange.min * 2 * TrailComponent.VERTEX_SIZE;
		buffer.updateRange.count = updateRange.max < updateRange.min ? -1 : (updateRange.length() + 1) * 2 * TrailComponent.VERTEX_SIZE;

		_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(updateRange);
	}

	/**
	 * Gets the interval for updating the points.
	 * @param {Interval} intervalForUpdate
	 * @private
	 */
	_getIntervalForUpdate(intervalForUpdate) {
		const currentTime = (this._relativeStartTime || this._relativeEndTime)
			? this.getEntity().getScene().getEngine().getTime()
			: undefined;
		// Set the interval min from the start time.
		if (this._relativeStartTime) {
			if (this._startTime !== undefined) {
				intervalForUpdate.min = currentTime - this._startTimeMultiplier * this._startTime;
			}
			else { // We're using a dynamic length, dependent on the orbital parameters.
				intervalForUpdate.min = currentTime - this._startTimeMultiplier * this._getAutoLength(currentTime);
			}
		}
		else {
			intervalForUpdate.min = this._startTime;
		}
		// Set the interval max from the end time.
		if (this._relativeEndTime) {
			if (this._endTime !== undefined) {
				intervalForUpdate.max = currentTime + this._endTimeMultiplier * this._endTime;
			}
			else { // We're using a dynamic length, dependent on the position, speed, and orbital parameters.
				intervalForUpdate.max = currentTime + this._endTimeMultiplier * this._getAutoLength(currentTime);
			}
		}
		else {
			intervalForUpdate.max = this._endTime;
		}
		intervalForUpdate.intersection(intervalForUpdate, this.getEntity().getPositionCoverage());
	}

	/**
	 * Pops the front of the positions array.
	 * @param {Interval} updateRange
	 * @private
	 */
	_popFrontPoint(updateRange) {
		if (this._pointsCount > 0) {
			this._resize(this._pointsCount - 1, updateRange);
			updateRange.expandTo(this._pointsStart);
			if (this._pointsCount > 1) {
				updateRange.expandTo((this._pointsStart + 1) % this._points.length);
			}
			this._points[this._pointsStart].position.x = NaN;
			this._pointsStart = (this._pointsStart + 1) % this._points.length;
			this._pointsCount -= 1;
		}
	}

	/**
	 * Pops the back of the positions array.
	 * @param {Interval} updateRange
	 * @private
	 */
	_popBackPoint(updateRange) {
		if (this._pointsCount > 0) {
			this._resize(this._pointsCount - 1, updateRange);
			this._pointsCount -= 1;
			updateRange.expandTo((this._pointsStart + this._pointsCount) % this._points.length);
			if (this._pointsCount > 0) {
				updateRange.expandTo((this._pointsStart + this._pointsCount - 1) % this._points.length);
			}
			this._points[(this._pointsStart + this._pointsCount) % this._points.length].position.x = NaN;
		}
	}

	/**
	 * Pushes a value to the front of the positions array.
	 * @param {Interval} updateRange
	 * @private
	 */
	_pushFrontPoint(updateRange) {
		this._resize(this._pointsCount + 1, updateRange);
		this._pointsStart = (this._pointsStart + this._points.length - 1) % this._points.length;
		updateRange.expandTo(this._pointsStart);
		if (this._pointsCount > 0) {
			updateRange.expandTo((this._pointsStart + 1) % this._points.length);
		}
		this._pointsCount += 1;
	}

	/**
	 * Pushes a value to the back of the positions array.
	 * @param {Interval} updateRange
	 * @private
	 */
	_pushBackPoint(updateRange) {
		this._resize(this._pointsCount + 1, updateRange);
		this._pointsCount += 1;
		updateRange.expandTo((this._pointsStart + this._pointsCount - 1) % this._points.length);
		if (this._pointsCount > 1) {
			updateRange.expandTo((this._pointsStart + this._pointsCount - 2) % this._points.length);
		}
	}

	/**
	 * Pops the front of the positions array.
	 * @param {number} newCount
	 * @param {Interval} updateRange
	 * @private
	 */
	_resize(newCount, updateRange) {
		let resizing = false;
		let newSize = this._points.length;
		if (newCount + 1 > this._points.length
			|| (newCount <= this._points.length / 4 && newCount >= 8)) {
			resizing = true;
		}
		if (resizing) {
			newSize = Math.max(8, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.ceilPow2(newCount + 1));
			const points = /** @type {Point[]} */([]);
			// Copy over the original array of points, moving everything to start at 0.
			for (let i = 0, l = this._pointsCount; i < l; i++) {
				points.push(this._points[(this._pointsStart + i) % this._points.length]);
			}
			this._pointsStart = 0;
			// Double the size of the array of points.
			for (let i = this._pointsCount, l = newSize; i < l; i++) {
				const point = new Point();
				point.position.x = Number.NaN;
				points.push(point);
			}
			this._points = points;

			// Update the vertex buffer.
			const geometry = (/** @type {THREE.Mesh} */(this.getThreeJsObjects()[0])).geometry;
			const newArray = new Float32Array(this._points.length * 2 * TrailComponent.VERTEX_SIZE);
			const buffer = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBuffer(newArray, TrailComponent.VERTEX_SIZE);
			geometry.setAttribute('positionCurr', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 0, false));
			geometry.setAttribute('positionPrev', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 3, false));
			geometry.setAttribute('positionNext', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 6, false));
			geometry.setAttribute('side', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 9, false));
			geometry.setAttribute('index', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 10, false));
			geometry.setAttribute('dashOffset', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 11, false));

			// Setup the index buffer.
			const indices = new Uint16Array(this._points.length * 6);
			for (let i = 0; i < this._points.length; i++) {
				indices[i * 6 + 0] = (i * 2 + 0) % (this._points.length * 2);
				indices[i * 6 + 1] = (i * 2 + 2) % (this._points.length * 2);
				indices[i * 6 + 2] = (i * 2 + 3) % (this._points.length * 2);
				indices[i * 6 + 3] = (i * 2 + 3) % (this._points.length * 2);
				indices[i * 6 + 4] = (i * 2 + 1) % (this._points.length * 2);
				indices[i * 6 + 5] = (i * 2 + 0) % (this._points.length * 2);
			}
			geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(indices, 1));

			// Set the dash offset time, since every vertex will be updated anyway.
			this._dashOffsetTime = this._points[this._pointsStart].time;

			updateRange.min = 0;
			updateRange.max = newSize;
		}
	}

	/**
	 * Gets the auto-length of a trail, if the start or end time is undefined.
	 * @param {number} time
	 * @returns {number}
	 * @private
	 */
	_getAutoLength(time) {
		// Find the last dynamo that contains the time.
		let dynamoController = null;
		for (let i = 0; ; i++) {
			const aDynamoController = this.getEntity().getControllerByClass(_internal__WEBPACK_IMPORTED_MODULE_0__.DynamoController, i);
			if (aDynamoController === null) {
				break;
			}
			if (aDynamoController.getPointType() === 'orb' && aDynamoController.getCoverage().contains(time)) {
				dynamoController = aDynamoController;
			}
		}
		// Get the specific angular momentum and velocity for the calcs.
		const specificAngularMomentum = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const velocityAtTime = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.getEntity().getPositionAtTime(specificAngularMomentum, time);
		this.getEntity().getVelocityAtTime(velocityAtTime, time);
		specificAngularMomentum.cross(specificAngularMomentum, velocityAtTime);
		let period = 0;
		if (dynamoController !== null) {
			// Get the dynamo params for the calcs.
			const eccentricity = dynamoController.getEccentricity(time);
			const gravParameter = dynamoController.getHeaderValue('gravitationalParameter1') + dynamoController.getHeaderValue('gravitationalParameter2');
			const specificOrbitalEnergy = -0.5 * (gravParameter * gravParameter / specificAngularMomentum.magnitudeSqr()) * (1 - eccentricity * eccentricity);
			period = 2 * Math.PI * gravParameter / Math.sqrt(8.0 * Math.abs(Math.min(1.0, specificOrbitalEnergy * specificOrbitalEnergy * specificOrbitalEnergy)));
		}
		else {
			period = 2 * Math.PI * specificAngularMomentum.magnitude() / velocityAtTime.magnitudeSqr();
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(specificAngularMomentum);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(velocityAtTime);
		return period;
	}

	/**
	 * Gets the position and the velocity relative to the relative-to entity at the given time.
	 * @param {Vector3} position
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @private
	 */
	_getPositionAndVelocity(position, velocity, time) {
		const relativeToEntity = this._relativeToEntity.getName() !== '' ? this._relativeToEntity.get() : this.getEntity().getParent();
		if (this._relativeToEntity.getName() === '') { // The relative to entity is the parent at the given time.
			this.getEntity().getPositionAtTime(position, time);
			this.getEntity().getVelocityAtTime(velocity, time);
			const parentOfPositionName = this.getEntity().getParentAtTime(time);
			const currentRelativeToEntity = this._currentRelativeToEntity.get();
			if (currentRelativeToEntity !== null && parentOfPositionName !== '' && parentOfPositionName !== currentRelativeToEntity.getName()) {
				const parentOfPosition = this.getEntity().getScene().getEntity(parentOfPositionName);
				if (parentOfPosition !== null) {
					parentOfPosition.getPositionRelativeToEntity(position, position, currentRelativeToEntity, time);
					parentOfPosition.getVelocityRelativeToEntity(velocity, velocity, currentRelativeToEntity, time);
				}
				else {
					position.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
					velocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
				}
			}
		}
		else if (relativeToEntity !== null) {
			this.getEntity().getPositionRelativeToEntity(position, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, relativeToEntity, time);
			this.getEntity().getVelocityRelativeToEntity(velocity, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, relativeToEntity, time);
		}
		else {
			position.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			velocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
		}
		if (this._relativeToEntityOrientation && relativeToEntity !== null) {
			const relativeToEntityOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			relativeToEntity.getOrientationAtTime(relativeToEntityOrientation, time);
			position.rotateInverse(relativeToEntityOrientation, position);
			velocity.rotateInverse(relativeToEntityOrientation, velocity);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(relativeToEntityOrientation);
		}
	}
}

TrailComponent.VERTEX_SIZE = 12;


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/align_controller.js":
/*!*******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/align_controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AlignController": function() { return /* binding */ AlignController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that aligns an entity with another entity on arbitrary axes.
 */
class AlignController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The align type for primary alignment. It can be 'none', 'align', 'velocity', 'point', or 'position'.
		 * @type {string}
		 * @private
		 */
		this._primaryAlignType = 'none';

		/**
		 * The axis of this entity that will be used for primary alignment.
		 * @type {Vector3}
		 * @private
		 */
		this._primaryAxis = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);
		this._primaryAxis.freeze();

		/**
		 * The target entity for primary alignment.
		 * @type {EntityRef}
		 * @private
		 */
		this._primaryTargetEntity = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());
		this._primaryTargetEntity.setRefChangedCallback((oldRef, newRef) => {
			this._removeDependentStates(oldRef, this._primaryAlignType);
			this._addDependentStates(newRef, this._primaryAlignType);
		});

		/**
		 * The axis of the target entity with which this entity will align or point for primary alignment.
		 * @type {Vector3}
		 * @private
		 */
		this._primaryTargetAxis = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);
		this._primaryTargetAxis.freeze();

		/**
		 * The align type for secondary alignment. It can be 'none', 'align', 'velocity', 'point', or 'position'.
		 * @type {string}
		 * @private
		 */
		this._secondaryAlignType = 'none';

		/**
		 * The axis of this entity that will align with the target entity's axis for secondary alignment.
		 * @type {Vector3}
		 * @private
		 */
		this._secondaryAxis = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
		this._secondaryAxis.freeze();

		/**
		 * The target entity for secondary alignment.
		 * @type {EntityRef}
		 * @private
		 */
		this._secondaryTargetEntity = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());
		this._secondaryTargetEntity.setRefChangedCallback((oldRef, newRef) => {
			this._removeDependentStates(oldRef, this._secondaryAlignType);
			this._addDependentStates(newRef, this._secondaryAlignType);
		});

		/**
		 * The axis of the target entity with which this entity will align for secondary alignment.
		 * @type {Vector3}
		 * @private
		 */
		this._secondaryTargetAxis = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
		this._secondaryTargetAxis.freeze();

		/**
		 * The joint for the model to align. If empty, the entity itself is used.
		 * @type {string}
		 * @private
		 */
		this._joint = '';

		/**
		 * The joint's ThreeJs object.
		 * @type {THREE.Object3D}
		 * @private
		 */
		this._jointObject = null;

		/**
		 * The model for the joint.
		 * @type {ModelComponent}
		 * @private
		 */
		this._model = null;

		/**
		 * The id of the root of the model. Used to tell if the model's Three.js object has been destroyed and reloaded.
		 * @type {number}
		 * @private
		 */
		this._modelRootId = 0;

		// Let the base controller know that this changes the orientation.
		this.addModifiedState('orientation');
	}

	/**
	 * Gets the align type for the primary alignment.
	 * @returns {string}
	 */
	getPrimaryAlignType() {
		return this._primaryAlignType;
	}

	/**
	 * Sets the align type for the primary alignment. It can be 'none', 'align', 'velocity', or 'point'.
	 * 'none' means no alignment
	 * 'align' aligns the entity with the target entity's axis
	 * 'velocity' aligns the entity with the target entity's velocity
	 * 'point' points the entity at the target entity.
	 * 'position' aligns the entity with the target entity's local position
	 * @param {string} alignType
	 */
	setPrimaryAlignType(alignType) {
		if (this._primaryAlignType === alignType) {
			return;
		}
		this._removeDependentStates(this._primaryTargetEntity.get(), this._primaryAlignType);
		this._primaryAlignType = alignType;
		this._addDependentStates(this._primaryTargetEntity.get(), this._primaryAlignType);
	}

	/**
	 * Gets the axis of this entity that will align with the target entity's axis for the primary alignment
	 * @returns {Vector3}
	 */
	getPrimaryAxis() {
		return this._primaryAxis;
	}

	/**
	 * Sets the axis of this entity that will be used in the primary alignment. The axis must be normalized.
	 * @param {Vector3} axis
	 */
	setPrimaryAxis(axis) {
		this._primaryAxis.thaw();
		this._primaryAxis.copy(axis);
		this._primaryAxis.freeze();
	}

	/**
	 * Gets the target entity name with which this entity will align or point for primary alignment.
	 * @returns {string}
	 */
	getPrimaryTargetEntity() {
		return this._primaryTargetEntity.getName();
	}

	/**
	 * Sets the target entity name with which this entity will align or point for primary alignment.
	 * @param {string} targetEntityName
	 */
	setPrimaryTargetEntity(targetEntityName) {
		this._primaryTargetEntity.setName(targetEntityName);
	}

	/**
	 * Gets the axis of the target entity with which this entity will align for primary alignment. The axis is in the target entity's oriented frame.
	 * @returns {Vector3}
	 */
	getPrimaryTargetAxis() {
		return this._primaryTargetAxis;
	}

	/**
	 * Sets the axis of the target entity with which this entity will align for primary alignment. The axis is in the target entity's oriented frame. The axis must be normalized.
	 * @param {Vector3} targetAxis
	 */
	setPrimaryTargetAxis(targetAxis) {
		this._primaryTargetAxis.thaw();
		this._primaryTargetAxis.copy(targetAxis);
		this._primaryTargetAxis.freeze();
	}

	/**
	 * Gets the align type for the secondary alignment.
	 * @returns {string}
	 */
	getSecondaryAlignType() {
		return this._secondaryAlignType;
	}

	/**
	 * Sets the align type for the secondary alignment. It can be 'none', 'align', 'velocity', 'point', or 'position'.
	 * 'none' means no alignment
	 * 'align' aligns the entity with the target entity's axis
	 * 'velocity' aligns the entity with the target entity's velocity
	 * 'point' points the entity at the target entity
	 * 'position' aligns the entity with the target entity's local position
	 * @param {string} alignType
	 */
	setSecondaryAlignType(alignType) {
		if (this._secondaryAlignType === alignType) {
			return;
		}
		this._removeDependentStates(this._secondaryTargetEntity.get(), this._secondaryAlignType);
		this._secondaryAlignType = alignType;
		this._addDependentStates(this._secondaryTargetEntity.get(), this._secondaryAlignType);
	}

	/**
	 * Gets the axis of this entity that will align with the target entity's axis for the secondary alignment
	 * @returns {Vector3}
	 */
	getSecondaryAxis() {
		return this._secondaryAxis;
	}

	/**
	 * Sets the axis of this entity that will be used in the secondary alignment. The axis must be normalized.
	 * @param {Vector3} axis
	 */
	setSecondaryAxis(axis) {
		this._secondaryAxis.thaw();
		this._secondaryAxis.copy(axis);
		this._secondaryAxis.freeze();
	}

	/**
	 * Gets the target entity name with which this entity will align or point for secondary alignment.
	 * @returns {string}
	 */
	getSecondaryTargetEntity() {
		return this._secondaryTargetEntity.getName();
	}

	/**
	 * Sets the target entity name with which this entity will align or point for secondary alignment.
	 * @param {string} targetEntityName
	 */
	setSecondaryTargetEntity(targetEntityName) {
		this._secondaryTargetEntity.setName(targetEntityName);
	}

	/**
	 * Gets the axis of the target entity with which this entity will align for secondary alignment. The axis is in the target entity's oriented frame.
	 * @returns {Vector3}
	 */
	getSecondaryTargetAxis() {
		return this._secondaryTargetAxis;
	}

	/**
	 * Sets the axis of the target entity with which this entity will align for secondary alignment. The axis is in the target entity's oriented frame. The axis must be normalized.
	 * @param {Vector3} targetAxis
	 */
	setSecondaryTargetAxis(targetAxis) {
		this._secondaryTargetAxis.thaw();
		this._secondaryTargetAxis.copy(targetAxis);
		this._secondaryTargetAxis.freeze();
	}

	/**
	 * Sets the alignment to be at the joint on the specified model. If no model is given, the first model in the entity is used.
	 * @param {string} joint
	 * @param {ModelComponent} [model]
	 */
	setJoint(joint, model) {
		this._joint = joint;
		if (!model) {
			const modelFromEntity = /** @type {ModelComponent} */(this.getEntity().get('model'));
			if (modelFromEntity !== null) {
				this._model = modelFromEntity;
			}
		}
		else {
			this._model = model;
		}
		if (this._joint !== '') {
			this.addDependentState(this.getEntity().getName(), 'orientation');
			this.removeModifiedState('orientation');
		}
		else {
			this.removeDependentState(this.getEntity().getName(), 'orientation');
			this.addModifiedState('orientation');
		}
	}

	/**
	 * Sets the orientation at the given time.
	 * @param {Quaternion} orientation
	 * @param {number} [time]
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, time) {
		if (this._joint !== '') {
			return;
		}
		this._getOrientation(orientation, time);
	}

	/**
	 * Updates the orientation.
	 * @override
	 * @internal
	 */
	__update() {
		const newOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		if (this._jointObject !== null) {
			newOrientation.copy(this.getEntity().getOrientation());
		}
		else {
			newOrientation.copy(this.getEntity().getOrientation());
		}
		this._getOrientation(newOrientation);

		// Set the orientation.
		if (this._jointObject !== null) {
			// Get the orientation back into the ThreeJS object coordinates.
			this._jointObject.quaternion.set(newOrientation.x, newOrientation.y, newOrientation.z, newOrientation.w);
		}
		else {
			this.getEntity().setOrientation(newOrientation);
		}

		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);
	}

	/**
	 * Gets the orientation of the entity or joint at the given time.
	 * The orientation should be initialized to the existing orientation of the entity.
	 * @param {Quaternion} orientation
	 * @param {number} [time]
	 * @private
	 */
	_getOrientation(orientation, time) {
		// If a joint is specified, setup the joint's ThreeJs object.
		if (this._joint !== '' && this._model !== null) {
			const root = this._model.getThreeJsObjects()[0];
			if (root !== undefined && (this._jointObject === null || this._jointObject.name !== this._joint || root.id !== this._modelRootId)) {
				const subObject = this._model.getThreeJsObjectByName(this._joint);
				if (subObject !== null) {
					this._jointObject = subObject;
					this._modelRootId = root.id;
				}
			}
			// No joint object yet when there should be, so do nothing.
			if (this._jointObject === null) {
				return;
			}
		}

		// Get the temporaries.
		const targetAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();

		// Get the primary axis from local to world coordinates.
		const primaryAxisGlobal = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const primaryRotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const localToWorld = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		if (this._jointObject !== null) {
			let jointAncestor = this._jointObject;
			AlignController._tempThreeJsQuaternion.set(0, 0, 0, 1);
			while (jointAncestor.parent !== null && jointAncestor.parent !== this._model.getThreeJsObjects()[0]) {
				jointAncestor = jointAncestor.parent;
				AlignController._tempThreeJsQuaternion.multiplyQuaternions(jointAncestor.quaternion, AlignController._tempThreeJsQuaternion);
			}
			localToWorld.copyFromThreeJs(AlignController._tempThreeJsQuaternion);
			localToWorld.mult(this._model.getRotation(), localToWorld);
			localToWorld.mult(orientation, localToWorld);
		}
		else {
			localToWorld.copy(orientation);
		}
		if (localToWorld.isNaN()) {
			localToWorld.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		primaryAxisGlobal.rotate(localToWorld, this._primaryAxis);

		// Get the primary axis.
		this._getAxis(targetAxis, this._primaryAlignType, this._primaryTargetEntity, this._primaryTargetAxis, primaryAxisGlobal, time);

		if (targetAxis.isNaN()) {
			targetAxis.set(1, 0, 0);
		}

		// Get the rotation needed to align it, and apply it to the new orientation.
		primaryRotation.setFromVectorFromTo(primaryAxisGlobal, targetAxis);
		orientation.mult(primaryRotation, localToWorld);
		if (orientation.isNaN()) {
			orientation.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(primaryAxisGlobal);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(primaryRotation);

		// Nothing to do if there is no secondary target entity.
		if (this._secondaryAlignType !== 'none' && this._secondaryTargetEntity !== null) {
			// Get the secondary axis.
			this._getAxis(targetAxis, this._secondaryAlignType, this._secondaryTargetEntity, this._secondaryTargetAxis, primaryAxisGlobal, time);

			// Get the rotation required to align this entity. The rotation is around the primary target axis.
			if (!targetAxis.isNaN()) {
				const secondaryRotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				const primaryAxisOriented = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				const secondaryAxisOriented = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				primaryAxisOriented.rotate(orientation, this._primaryAxis);
				secondaryAxisOriented.rotate(orientation, this._secondaryAxis);
				const angle = secondaryAxisOriented.angleAroundAxis(targetAxis, primaryAxisOriented);
				secondaryRotation.setFromAxisAngle(primaryAxisOriented, angle);
				orientation.mult(secondaryRotation, orientation);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(secondaryRotation);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(primaryAxisOriented);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(secondaryAxisOriented);
			}
		}

		// Set the orientation.
		orientation.normalize(orientation);
		if (this._jointObject !== null) {
			// Get the orientation back into the ThreeJS object coordinates.
			orientation.multInverseL(localToWorld, orientation);
		}

		// Release the temporaries.
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(localToWorld);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(targetAxis);
	}

	/**
	 * Gets the axis to aligning.
	 * @param {Vector3} outAxis
	 * @param {string} alignType
	 * @param {EntityRef} targetEntityRef
	 * @param {Vector3} targetAxis
	 * @param {Vector3} axisGlobal
	 * @param {number} time
	*/
	_getAxis(outAxis, alignType, targetEntityRef, targetAxis, axisGlobal, time) {
		const targetEntity = targetEntityRef.get();
		if (alignType === 'align' && targetEntity !== null) {
			// Get the primary target entity axis in the global frame.
			const primaryOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			targetEntity.getOrientationAtTime(primaryOrientation, time);
			outAxis.rotate(primaryOrientation, targetAxis);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(primaryOrientation);
		}
		else if (alignType === 'velocity' && targetEntity !== null) {
			// Get the primary target entity velocity.
			targetEntity.getVelocityAtTime(outAxis, time);
			outAxis.normalize(outAxis);
		}
		else if (alignType === 'point' && targetEntity !== null) {
			// Get the position of the primary target entity in this entity's frame.
			targetEntity.getPositionRelativeToEntity(outAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity(), time);
			outAxis.normalize(outAxis);
		}
		else if (alignType === 'position' && targetEntity !== null) {
			// Get the position of the primary target entity in this entity's frame.
			outAxis.normalize(targetEntity.getPosition());
		}
		else {
			outAxis.copy(axisGlobal);
		}
	}

	/**
	 * Removes the dependent states based on the align entities.
	 * @param {Entity} entity
	 * @param {string} alignType
	 */
	_removeDependentStates(entity, alignType) {
		if (entity !== null) {
			if (alignType === 'align') {
				this.removeDependentState(entity.getName(), 'orientation');
			}
			else if (alignType === 'velocity') {
				this.removeDependentState(entity.getName(), 'velocity');
			}
			else if (alignType === 'point') {
				this.removeDependentState(this.getEntity().getName(), 'position');
				this.removeDependentState(entity.getName(), 'position');
			}
			else if (alignType === 'position') {
				this.removeDependentState(entity.getName(), 'position');
			}
		}
	}

	/**
	 * Adds the dependent states based on the align entities.
	 * @param {Entity} entity
	 * @param {string} alignType
	 */
	_addDependentStates(entity, alignType) {
		if (entity !== null) {
			if (alignType === 'align') {
				this.addDependentState(entity.getName(), 'orientation');
			}
			else if (alignType === 'velocity') {
				this.addDependentState(entity.getName(), 'velocity');
			}
			else if (alignType === 'point') {
				this.addDependentState(this.getEntity().getName(), 'position');
				this.addDependentState(entity.getName(), 'position');
			}
			else if (alignType === 'position') {
				this.addDependentState(entity.getName(), 'position');
			}
		}
	}
}

/**
 * A temporary ThreeJs Quaternion.
 * @type {THREE.Quaternion}
 */
AlignController._tempThreeJsQuaternion = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Quaternion();


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/animdata_controller.js":
/*!**********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/animdata_controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnimdataController": function() { return /* binding */ AnimdataController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


const eclipJ2000ToJ200Rotation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion(0.9791532214288992, 0.2031230389823101, 0, 0);

class State {
	/**
	 * Takes a Reader and populates the values.
	 * @param {Reader} _reader
	 */
	read(_reader) {
	}

	/**
	 * Sets this to an interpolated state between state a and state b with an applied offset.
	 * @param {State} _state0 - the state at the beginning of the interval
	 * @param {State} _state1 - the state at the end of the interval
	 * @param {number} _intervalLength - the length of the interval
	 * @param {number} _u - the factor between 0 and 1
	 */
	interpolate(_state0, _state1, _intervalLength, _u) {
	}
}

/** A state that represents a position and velocity. Used by {@link Animdata}.
 * @private */
class PosState extends State {
	/**
	 * Constructor
	 */
	constructor() {
		super();

		/**
		 * Position in km at the start of this interval.
		 * @type {Vector3}
		 */
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * Velocity in km/s at the start of this interval.
		 * @type {Vector3}
		 */
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Takes a Reader and populates the values.
	 * @param {Reader} reader
	 * @override
	 */
	read(reader) {
		this.position.y = -reader.readFloat64();
		this.position.z = reader.readFloat64();
		this.position.x = reader.readFloat64();
		this.velocity.y = -reader.readFloat64();
		this.velocity.z = reader.readFloat64();
		this.velocity.x = reader.readFloat64();
		this.position.rotate(eclipJ2000ToJ200Rotation, this.position);
		this.velocity.rotate(eclipJ2000ToJ200Rotation, this.velocity);
	}

	/**
	 * Sets this to an interpolated state between state a and state b with an applied offset.
	 * @param {PosState} state0 - the state at the beginning of the interval
	 * @param {PosState} state1 - the state at the end of the interval
	 * @param {number} intervalLength - the length of the interval
	 * @param {number} u - the factor between 0 and 1
	 * @override
	 */
	interpolate(state0, state1, intervalLength, u) {
		const oneMinusU = 1.0 - u;
		const oneMinusUQuantitySquared = oneMinusU * oneMinusU;
		const uSquared = u * u;
		const a = (1.0 + 2.0 * u) * oneMinusUQuantitySquared;
		const b = u * oneMinusUQuantitySquared;
		const c = uSquared * (3.0 - 2.0 * u);
		const d = uSquared * -oneMinusU;
		this.position.mult(state0.position, a);
		this.position.addMult(this.position, state0.velocity, intervalLength * b);
		this.position.addMult(this.position, state1.position, c);
		this.position.addMult(this.position, state1.velocity, intervalLength * d);
		const sixUSquaredMinusU = 6.0 * (uSquared - u);
		const aV = sixUSquaredMinusU;
		const bV = 3.0 * uSquared - 4.0 * u + 1.0;
		const cV = -sixUSquaredMinusU;
		const dV = 3.0 * uSquared - 2.0 * u;
		this.velocity.mult(state0.position, aV / intervalLength);
		this.velocity.addMult(this.velocity, state0.velocity, bV);
		this.velocity.addMult(this.velocity, state1.position, cV / intervalLength);
		this.velocity.addMult(this.velocity, state1.velocity, dV);
	}
}

/** A state that represents an orientation. Used by {@link Animdata}.
 * @private */
class OriState extends State {
	/**
	 * Constructor
	 */
	constructor() {
		super();

		/**
		 * Orientation in radians at the start of this interval.
		 * @type {Quaternion}
		 */
		this.orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
	}

	/**
	 * Takes a Reader and populates the values.
	 * @param {Reader} reader
	 * @override
	 */
	read(reader) {
		this.orientation.y = reader.readFloat32();
		this.orientation.z = -reader.readFloat32();
		this.orientation.x = -reader.readFloat32();
		this.orientation.w = reader.readFloat32();
		this.orientation.mult(eclipJ2000ToJ200Rotation, this.orientation);
	}

	/**
	 * Sets this to an interpolated state between state a and state b with an applied offset.
	 * @param {OriState} state0 - the state at the beginning of the interval
	 * @param {OriState} state1 - the state at the end of the interval
	 * @param {number} _intervalLength - the length of the interval (not used)
	 * @param {number} u - the factor between 0 and 1
	 * @override
	 */
	interpolate(state0, state1, _intervalLength, u) {
		this.orientation.slerp(state0.orientation, state1.orientation, u);
	}
}

/** Data for a point in time. Used by {@link Animdata}.
 * @private */
class DataPoint {
	/**
	 * Constructor
	 * @param {AnimdataController} controller - The controller.
	 */
	constructor(controller) {
		/**
		 * Interval for this data point. Really only start is used.
		 * @type {Interval}
		 */
		this.interval = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();

		/**
		 * The state at the start of the data point.
		 * @type {State}
		 */
		this.state = controller.__getNewState();
	}

	/**
	 * Read binary data into the data point.
	 * @param {Reader} reader - The reader to read data
	 */
	read(reader) {
		this.interval.min = reader.readFloat64();
		this.interval.max = reader.readFloat64();
		this.state.read(reader);
	}
}

/** The animdata file. Contains list of intervals and states. Used by {@link Animdata}.
 * @private */
class AnimdataFile {
	/**
	 * Constructor. Starts loading the data.
	 * @param {AnimdataController} controller - The controller
	 * @param {number} coverageIndex - The coverage index
	 * @param {number} animdataIndex - The animdata index
	 */
	constructor(controller, coverageIndex, animdataIndex) {
		/**
		 * The interval covered by this animdata. It goes from the beginning of the first data point to the beginning of the last data point.
		 * @type {Interval}
		 */
		this.interval = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();

		/**
		 * The list of data points contained in this animdata.
		 * @type {DataPoint[]}
		 */
		this.dataPoints = [];

		const url = controller.getUrl() + '/' + controller.getStateType() + '_data/' + ('00' + coverageIndex).slice(-3) + '.' + ('000' + (animdataIndex + 1)).slice(-4) + '.animdata';
		/**
		 * The promise that is used to tell when the animdata is loaded.
		 * @type {Promise<void>}
		 */
		this.promise = controller.getEntity().getScene().getEngine().getDownloader().download(url, true).then(async (download) => {
			if (download.status === 'cancelled') {
				return Promise.resolve();
			}
			else if (download.status === 'failed') {
				return Promise.reject(new Error('Failed to load animdata controller file "' + download.url + '": ' + download.errorMessage));
			}
			if (!(download.content instanceof ArrayBuffer)) {
				return Promise.reject(new Error('Failed to load animdata controller file "' + download.url + '": Not a binary file.'));
			}
			const reader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);
			this.interval.min = reader.readFloat64();
			this.interval.max = reader.readFloat64();
			const numDataPoints = reader.readInt32();
			for (let dataPointIndex = 0; dataPointIndex < numDataPoints; dataPointIndex++) {
				const dataPoint = new DataPoint(controller);
				dataPoint.read(reader);
				this.dataPoints.push(dataPoint);
			}
		});
	}
}

/** A single animdata file index and the interval it covers. Used by {@link Animdata}.
 * @private */
class FileOverlap {
	/**
	 * Constructor
	 */
	constructor() {
		/**
		 * The file index of this animdata file.
		 * @type {number}
		 */
		this.fileIndex = 0;

		/**
		 * The coverage of this animdata file.
		 * @type {Interval}
		 */
		this.interval = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();
	}
}

/** A list of data point locations in the bucket. Used by {@link Animdata}.
 * @private */
class BucketOverlap {
	/**
	 * Constructor
	 */
	constructor() {
		/**
		 * The animdata file index for this bucket overlap.
		 * @type {number}
		 */
		this.fileIndex = 0;

		/**
		 * Data point indices in this file in this bucket.
		 * @type {number[]}
		 */
		this.dataPointIndices = [];
	}
}

/** A list of bucket overlaps in the animinfo file. Used by {@link Animdata}.
 * @private */
class Bucket {
	/**
	 * Constructor
	 */
	constructor() {
		/**
		 * List of animdata file indices and data point indices for this bucket.
		 * @type {BucketOverlap[]}
		 */
		this.bucketOverlaps = [];
	}
}

/** The animinfo file, containing file overlaps and bucket overlaps. Used by {@link Animdata}.
 * @private */
class AniminfoFile {
	/**
	 * Constructor. Starts loading the data.
	 * @param {AnimdataController} controller - The controller
	 * @param {number} coverageIndex - The coverage index
	 * @param {number} animinfoIndex - The animinfo index
	 */
	constructor(controller, coverageIndex, animinfoIndex) {
		/**
		 * List of files & intervals to which the buckets refer, hashed by fileIndex.
		 * @type {Map.<number,FileOverlap>}
		 */
		this.fileOverlaps = new Map();

		/**
		 * List of buckets in animinfo file.
		 * @type {Bucket[]}
		 */
		this.buckets = [];

		const url = controller.getUrl() + '/' + controller.getStateType() + '_info/' + ('00' + coverageIndex).slice(-3) + '.' + ('000' + animinfoIndex).slice(-4) + '.animinfo';
		/**
		 * The promise that is used to tell when the animinfo is loaded.
		 * @type {Promise<void>}
		 */
		this.promise = controller.getEntity().getScene().getEngine().getDownloader().download(url, true).then(async (download) => {
			if (download.status === 'cancelled') {
				return Promise.resolve();
			}
			else if (download.status === 'failed') {
				return Promise.reject(new Error('Failed to load animdata controller file "' + download.url + '": ' + download.errorMessage));
			}
			if (!(download.content instanceof ArrayBuffer)) {
				return Promise.reject(new Error('Failed to load animdata controller file "' + download.url + '": Not a binary file.'));
			}
			const reader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);
			const numFileOverlaps = reader.readInt16();
			for (let fileOverlapIndex = 0; fileOverlapIndex < numFileOverlaps; fileOverlapIndex++) {
				const fileOverlap = new FileOverlap();
				fileOverlap.fileIndex = reader.readInt16();
				fileOverlap.interval.min = reader.readFloat64();
				fileOverlap.interval.max = reader.readFloat64();
				this.fileOverlaps.set(fileOverlap.fileIndex, fileOverlap);
			}
			const numBuckets = reader.readInt16();
			for (let bucketIndex = 0; bucketIndex < numBuckets; bucketIndex++) {
				const bucket = new Bucket();
				const numBucketOverlaps = reader.readInt16();
				for (let bucketOverlapIndex = 0; bucketOverlapIndex < numBucketOverlaps; bucketOverlapIndex++) {
					const bucketOverlap = new BucketOverlap();
					bucketOverlap.fileIndex = reader.readInt16();
					const numDataPointIndices = reader.readInt16();
					for (let dataPointIndex = 0; dataPointIndex < numDataPointIndices; dataPointIndex++) {
						bucketOverlap.dataPointIndices.push(reader.readInt16());
					}
					bucket.bucketOverlaps.push(bucketOverlap);
				}
				this.buckets.push(bucket);
			}
		});
	}
}

/** The bookkeeping information for a given coverage defined in the animdef file. Used by {@link Animdata}.
 * @private */
class Coverage {
	/**
	 * Constructor
	 */
	constructor() {
		/**
		 * The interval that this coverage covers.
		 * @type {Interval}
		 */
		this.interval = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();

		/**
		 * The number of data files.
		 * @type {number}
		 */
		this.numDataFiles = 0;

		/**
		 * The number of buckets.
		 * @type {number}
		 */
		this.numBuckets = 0;

		/**
		 * The size in seconds of each bucket.
		 * @type {number}
		 */
		this.bucketStepSize = 0;

		/**
		 * The number of buckets contained in each animinfo file.
		 * @type {number}
		 */
		this.numBucketsPerAniminfoFile = 0;

		/**
		 * Currently loaded or downloading animinfo files, keyed by index.
		 * @type {Map.<number,AniminfoFile>}
		 */
		this.animinfos = new Map();

		/**
		 * Currently loaded or downloading animdata files, keyed by index.
		 * @type {Map.<number,AnimdataFile>}
		 */
		this.animdatas = new Map();
	}
}

/** The animdef file, containing all of the coverages. Used by {@link Animdata}.
 * @private */
class AnimdefFile {
	/**
	 * Constructor. Starts loading the data.
	 * @param {AnimdataController} controller - The controller
	 */
	constructor(controller) {
		/**
		 * List of coverages defined in animdef file.
		 * @type {Coverage[]}
		 */
		this.coverages = [];

		const url = controller.getUrl() + '/' + controller.getStateType() + '.animdef';
		/**
		 * The promise that is used to tell when the animdef is loaded.
		 * @type {Promise<void>}
		 */
		this.promise = controller.getEntity().getScene().getEngine().getDownloader().download(url, true).then(async (download) => {
			if (download.status === 'cancelled') {
				return Promise.resolve();
			}
			else if (download.status === 'failed') {
				return Promise.reject(new Error('Failed to load animdata controller file "' + download.url + '": ' + download.errorMessage));
			}
			if (!(download.content instanceof ArrayBuffer)) {
				return Promise.reject(new Error('Failed to load animdata controller file "' + download.url + '": Not a binary file.'));
			}
			const reader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);
			const numCoverages = reader.readInt16();
			for (let coverageIndex = 0; coverageIndex < numCoverages; coverageIndex++) {
				const coverage = new Coverage();
				coverage.interval.min = reader.readFloat64();
				coverage.interval.max = reader.readFloat64();
				coverage.numDataFiles = reader.readInt16();
				coverage.numBuckets = reader.readInt32();
				coverage.bucketStepSize = reader.readFloat64();
				coverage.numBucketsPerAniminfoFile = reader.readInt16();
				this.coverages.push(coverage);
			}
			controller.__updateCoverage();
		});
	}
}

/** The animdata controller. Downloads animdata files to control the position and orientation of entities. */
class AnimdataController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The base url used to construct the other urls for the animdef, animinfo, and animdata files.
		 * @type {string}
		 * @private
		 */
		this._baseUrl = '';

		/**
		 * The state, currently either 'pos' or 'ori'.
		 * @type {string}
		 * @private
		 */
		this._stateType = '';

		/**
		 * The animdef file that contains all the other data.
		 * @type {AnimdefFile}
		 * @private
		 */
		this._animdef = null;

		/**
		 * The current data point used for updates.
		 * @type {DataPoint}
		 * @private
		 */
		this._currentDataPoint = null;

		/**
		 * Temporary data point used in calculations.
		 * @type {DataPoint}
		 * @private
		 */
		this._tempDataPoint = null;

		/**
		 * A shortcut for to get to the download method.
		 * @type {Engine}
		 * @private
		 */
		this._engine = this.getEntity().getScene().getEngine();

		/**
		 * The coverage set by setCoverage.
		 * @type {Interval}
		 * @private
		 */
		this._forcedCoverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();
		this._forcedCoverage.copy(this.getCoverage());
	}

	/**
	 * Returns the base url used to download the animdata.
	 * @returns {string}
	 */
	getUrl() {
		return this._baseUrl;
	}

	/**
	 * Returns the state type (pos or ori)
	 * @returns {string}
	 */
	getStateType() {
		return this._stateType;
	}

	/**
	 * Sets the base url used to download the animdata.
	 * @param {string} baseUrl
	 * @param {string} stateType
	 */
	setBaseUrlAndStateType(baseUrl, stateType) {
		this._baseUrl = baseUrl;
		this._stateType = stateType;
		this._currentDataPoint = new DataPoint(this);
		this._tempDataPoint = new DataPoint(this);
		this._animdef = new AnimdefFile(this);

		// Let the base controller know that this changes the position or orientation.
		if (this._stateType === 'pos') {
			this.addModifiedState('position');
			this.addModifiedState('velocity');
		}
		else if (this._stateType === 'ori') {
			this.addModifiedState('orientation');
		}
	}

	/**
	 * Sets the time interval over which the controller is valid.
	 * @param {Interval} coverage
	 * @override
	*/
	setCoverage(coverage) {
		this._forcedCoverage.copy(coverage);
		this.__updateCoverage();
	}

	/**
	 * Since animdata has a possibly narrower coverage than the base controller (forced) coverage, this updates the base controller coverage to reflect that.
	 * @internal
	 */
	__updateCoverage() {
		const realCoverage = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
		if (this._animdef !== null && this._animdef.coverages.length > 0) {
			realCoverage.copy(this._animdef.coverages[0].interval);
			for (let i = 1; i < this._animdef.coverages.length; i++) {
				realCoverage.union(realCoverage, this._animdef.coverages[i].interval);
			}
			realCoverage.intersection(realCoverage, this._forcedCoverage);
		}
		else {
			realCoverage.copy(this._forcedCoverage);
			realCoverage.max = realCoverage.min;
		}
		super.setCoverage(realCoverage);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(realCoverage);
	}

	/**
	 * If the animdata is pos, updates the position.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		if (this._stateType === 'pos') {
			const state = /** @type {PosState} */(this._tempDataPoint.state);
			if (this._tempDataPoint.interval.min !== time) {
				if (this._getDataPointAtTime(this._tempDataPoint, time)) {
					position.copy(state.position);
				}
			}
			else {
				position.copy(state.position);
			}
		}
	}

	/**
	 * If the animdata is pos, updates the velocity.
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, time) {
		if (this._stateType === 'pos') {
			const state = /** @type {PosState} */(this._tempDataPoint.state);
			if (this._tempDataPoint.interval.min !== time) {
				if (this._getDataPointAtTime(this._tempDataPoint, time)) {
					velocity.copy(state.velocity);
				}
			}
			else {
				velocity.copy(state.velocity);
			}
		}
	}

	/**
	 * If the animdata is ori, updates the orientation.
	 * @param {Quaternion} orientation
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, time) {
		if (this._stateType === 'ori') {
			const state = /** @type {OriState} */(this._tempDataPoint.state);
			if (this._getDataPointAtTime(this._tempDataPoint, time)) {
				orientation.copy(state.orientation);
			}
		}
	}

	/**
	 * Returns a new promise that resolves when the controller is loaded.
	 * @returns {Promise<void>}
	 * @override
	 */
	getLoadedPromise() {
		return this.downloadDataForInterval(new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(this._engine.getTime(), this._engine.getTime()));
	}

	/**
	 * This does whatever is necessary to download the data for the given interval. Returns a promise that will resolve when all the data is loaded.
	 * @param {Interval} interval - The interval over which to download the data.
	 * @returns {Promise<void>}
	 */
	downloadDataForInterval(interval) {
		if (this._animdef === null) {
			return null;
		}
		return this._animdef.promise.then(async () => {
			const animinfoPromises = [];

			// For each coverage...
			for (let coverageIndex = 0; coverageIndex < this._animdef.coverages.length; coverageIndex++) {
				const coverage = this._animdef.coverages[coverageIndex];

				// If the interval is within the coverage,
				if (coverage.interval.intersects(interval)) {
					// Calculate the set of animinfos that would cover the interval.
					const animinfoIndexStart = Math.floor((Math.max(interval.min, coverage.interval.min) - coverage.interval.min) / coverage.bucketStepSize / coverage.numBucketsPerAniminfoFile);
					const animinfoIndexEnd = Math.floor((Math.min(interval.max, coverage.interval.max) - 0.0001 - coverage.interval.min) / coverage.bucketStepSize / coverage.numBucketsPerAniminfoFile);

					// For each animinfo in that set...
					for (let animinfoIndex = animinfoIndexStart; animinfoIndex <= animinfoIndexEnd; animinfoIndex++) {
						// If that animinfo hasn't been loaded yet,
						if (!coverage.animinfos.has(animinfoIndex)) {
							coverage.animinfos.set(animinfoIndex, new AniminfoFile(this, coverageIndex, animinfoIndex));
						}

						const animinfo = coverage.animinfos.get(animinfoIndex);
						animinfoPromises.push(animinfo.promise.then(() => {
							const animdataPromises = [];

							// For each file overlap in the animinfo...
							for (const fileOverlap of animinfo.fileOverlaps.values()) {
								// If the interval overlaps with the file overlap,
								if (fileOverlap.interval.intersects(interval)) {
									const animdataIndex = fileOverlap.fileIndex;

									// If that animdata hasn't been downloaded yet,
									if (!coverage.animdatas.has(animdataIndex)) {
										coverage.animdatas.set(animdataIndex, new AnimdataFile(this, coverageIndex, animdataIndex));
									}

									const animdata = coverage.animdatas.get(animdataIndex);
									animdataPromises.push(animdata.promise);
								}
							}
							return Promise.all(animdataPromises).then();
						}));
					}
					return Promise.all(animinfoPromises).then();
				}
			}
		});
	}

	/**
	 * Returns a new state of the controller type.
	 * @returns {State}
	 * @internal	*/
	__getNewState() {
		if (this._stateType === 'pos') {
			return new PosState();
		}
		else if (this._stateType === 'ori') {
			return new OriState();
		}
		else {
			return null;
		}
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		if (this._currentDataPoint !== null) {
			if (this._getDataPointAtTime(this._currentDataPoint, this._engine.getTime())) {
				if (this._stateType === 'pos') {
					const state = /** @type {PosState} */(this._currentDataPoint.state);
					this.getEntity().setPosition(state.position);
					this.getEntity().setVelocity(state.velocity);
				}
				if (this._stateType === 'ori') {
					const state = /** @type {OriState} */(this._currentDataPoint.state);
					this.getEntity().setOrientation(state.orientation);
				}
			}
		}
	}

	/**
	 * Sets outDataPoint to the state associated with the time and returns true. If it doesn't exist, it starts the download process for that time and returns false.
	 * @param {DataPoint} outDataPoint - the state to be set
	 * @param {number} time - the time to check
	 * @returns {boolean}
	 * @private
	 */
	_getDataPointAtTime(outDataPoint, time) {
		// For every coverage in the animdef,
		for (let coverageIndex = 0; coverageIndex < this._animdef.coverages.length; coverageIndex++) {
			const coverage = this._animdef.coverages[coverageIndex];

			// If the time is within the coverage,
			if (coverage.interval.contains(time)) {
				// Calculate the animinfo that would cover the time.
				const animinfoIndex = Math.floor((time - coverage.interval.min) / coverage.bucketStepSize / coverage.numBucketsPerAniminfoFile);

				// If that animinfo has been downloaded, else download it.
				if (coverage.animinfos.has(animinfoIndex)) {
					const animinfo = coverage.animinfos.get(animinfoIndex);

					// Calculate the bucket of the animinfo that would cover the time.
					const bucketIndexInAniminfoFile = Math.floor((time - coverage.interval.min) / coverage.bucketStepSize) - animinfoIndex * coverage.numBucketsPerAniminfoFile;
					const bucket = animinfo.buckets[bucketIndexInAniminfoFile];

					if (bucket === undefined) {
						return false;
					}

					// For each bucket overlap in the bucket (should be a very small number)...
					for (let bucketOverlapIndex = 0; bucketOverlapIndex < bucket.bucketOverlaps.length; bucketOverlapIndex++) {
						const bucketOverlap = bucket.bucketOverlaps[bucketOverlapIndex];
						const animdataIndex = bucketOverlap.fileIndex;

						// If the animdata covers the time,
						if (animinfo.fileOverlaps.get(animdataIndex).interval.contains(time)) {
							// If the animdata has been downloaded, else download it.
							if (coverage.animdatas.has(animdataIndex)) {
								const animdata = coverage.animdatas.get(animdataIndex);

								// For each data point index in the bucket overlap...
								for (let dataPointIndexIndex = 0; dataPointIndexIndex < bucketOverlap.dataPointIndices.length; dataPointIndexIndex++) {
									const dataPointIndex = bucketOverlap.dataPointIndices[dataPointIndexIndex];
									const dataPoint = animdata.dataPoints[dataPointIndex];

									if (dataPoint === undefined) {
										return false;
									}

									// If the data point covers the time, return the data point.
									if (dataPoint.interval.contains(time)) {
										const u = (time - dataPoint.interval.min) / dataPoint.interval.length();
										outDataPoint.interval.min = time;
										outDataPoint.interval.max = time;
										outDataPoint.state.interpolate(dataPoint.state, animdata.dataPoints[dataPointIndex + 1].state, dataPoint.interval.length(), u);
										return true;
									}
								}
								return false;
							}
							else {
								coverage.animdatas.set(animdataIndex, new AnimdataFile(this, coverageIndex, animdataIndex));
								return false;
							}
						}
					}
					return false;
				}
				else {
					coverage.animinfos.set(animinfoIndex, new AniminfoFile(this, coverageIndex, animinfoIndex));
					return false;
				}
			}
		}
		return false;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/base_controller.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/base_controller.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseController": function() { return /* binding */ BaseController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The base class for all controllers.
 */
class BaseController extends _internal__WEBPACK_IMPORTED_MODULE_0__.EntityItem {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The interval over which the controller is valid.
		 * @type {Interval}
		 * @private
		 */
		this._coverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		this._coverage.freeze();

		/**
		 * The modified states.
		 * @type {Set<string>}
		 * @private
		 */
		this._modifiedStates = new Set();

		/**
		 * The dependent states. In the format of '<entity name>.<state>'.
		 * @type {Set<string>}
		 * @private
		 */
		this._dependentStates = new Set();

		// Add this to the controller dependency graph.
		this.getEntity().getScene().getControllerDependencyGraph().addItem(this);
	}

	/**
	 * Destroys the controller resources.
	 * @override
	 * @internal
	 */
	__destroy() {
		this.getEntity().getScene().getControllerDependencyGraph().removeItem(this);
		super.__destroy();
	}

	// STATES AND DEPENDENCIES

	/**
	 * Adds a modified state to the controller.
	 * @param {string} modifiedState
	 * @protected
	 */
	addModifiedState(modifiedState) {
		if (!this._modifiedStates.has(modifiedState)) {
			this._modifiedStates.add(modifiedState);
			this.getEntity().getScene().getControllerDependencyGraph().needsSorting();
			if (modifiedState === 'position' || modifiedState === 'orientation') {
				this.getEntity().__updateCoverage();
			}
		}
	}

	/**
	 * Removes a modified state.
	 * @param {string} modifiedState
	 * @protected
	 */
	removeModifiedState(modifiedState) {
		if (this._modifiedStates.delete(modifiedState)) {
			this.getEntity().getScene().getControllerDependencyGraph().needsSorting();
			if (modifiedState === 'position' || modifiedState === 'orientation') {
				this.getEntity().__updateCoverage();
			}
		}
	}

	/**
	 * Returns true if this has the modified state.
	 * @param {string} modifiedState
	 * @returns {boolean}
	 */
	hasModifiedState(modifiedState) {
		return this._modifiedStates.has(modifiedState);
	}

	/**
	 * Adds a dependent state.
	 * @param {string} entityName
	 * @param {string} dependentState
	 * @protected
	 */
	addDependentState(entityName, dependentState) {
		if (!this._dependentStates.has(entityName + '.' + dependentState)) {
			this._dependentStates.add(entityName + '.' + dependentState);
			this.getEntity().getScene().getControllerDependencyGraph().needsSorting();
		}
	}

	/**
	 * Removes a dependent state.
	 * @param {string} entityName
	 * @param {string} dependentState
	 * @protected
	 */
	removeDependentState(entityName, dependentState) {
		if (this._dependentStates.delete(entityName + '.' + dependentState)) {
			this.getEntity().getScene().getControllerDependencyGraph().needsSorting();
		}
	}

	/**
	 * Returns true if this has the dependent state.
	 * @param {string} entityName
	 * @param {string} dependentState
	 * @returns {boolean}
	 */
	hasDependentState(entityName, dependentState) {
		return this._dependentStates.has(entityName + '.' + dependentState);
	}

	/**
	 * Gets an iterator to the modified states.
	 * @returns {Set<string>}
	 * @internal
	 */
	get __modifiedStates() {
		return this._modifiedStates;
	}

	/**
	 * Gets the time interval over which the controller is valid.
	 * @returns {Interval}
	 */
	getCoverage() {
		return this._coverage;
	}

	/**
	 * Sets the time interval over which the controller is valid.
	 * @param {Interval} coverage
	 */
	setCoverage(coverage) {
		this._coverage.thaw();
		this._coverage.copy(coverage);
		this._coverage.freeze();
		this.getEntity().__updateCoverage();
	}

	/**
	 * Updates the given position for the given time.
	 * @param {Vector3} _position - The position to update.
	 * @param {number} _time - The time to check
	 */
	__updatePositionAtTime(_position, _time) { }

	/**
	 * Updates the given velocity for the given time.
	 * @param {Vector3} _velocity - The velocity to update.
	 * @param {number} _time - The time to check
	 */
	__updateVelocityAtTime(_velocity, _time) { }

	/**
	 * Updates given orientation for the given time.
	 * @param {Quaternion} _orientation - The orientation to update.
	 * @param {number} _time - The time to check.
	 */
	__updateOrientationAtTime(_orientation, _time) { }

	/**
	 * Converts the entity item to a nice string.
	 * @returns {string}
	 * @override
	 */
	toString() {
		let typeIndex = 0;
		// Search the controllers for the type.
		for (let i = 0, l = this.getEntity().getNumControllers(); i < l; i++) {
			const controller = this.getEntity().getController(i);
			if (this === controller) {
				break;
			}
			if (this.getType() === controller.getType()) {
				typeIndex += 1;
			}
		}
		return this.getEntity().getName() + '.' + this.getType() + '.' + typeIndex;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/coverage_controller.js":
/*!**********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/coverage_controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CoverageController": function() { return /* binding */ CoverageController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that calls enter and functions based on a coverage.
 */
class CoverageController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The time interval over which the coverage is active.
		 * @type {Interval}
		 * @private
		 */
		this.coverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();

		/**
		 * The function called when the time enters the coverage.
		 * @type {((entity: Entity) => any) | undefined}
		 * @private
		 */
		this.enterFunction = undefined;

		/**
		 * The function called when the time exits the coverage.
		 * @type {((entity: Entity) => any) | undefined}
		 * @private
		 */
		this.exitFunction = undefined;

		/**
		 * The function called when the time is inside the coverage, every frame.
		 * @type {((entity: Entity) => any) | undefined}
		 * @private
		 */
		this.updateFunction = undefined;

		/**
		 * Flag determining if the coverage is active or not.
		 * @type {boolean}
		 * @private
		 */
		this.active = false;

		/**
		 * The last real time the update function ran.
		 * @type {number}
		 * @private
		 */
		this.lastUpdateTime = Number.NEGATIVE_INFINITY;

		/**
		 * How often to run the update function, in milliseconds. 0 means run every frame.
		 * @type {number}
		 * @private
		 */
		this.updateInterval = 0;
	}

	/**
	 * Sets the coverage.
	 * @param {Interval} coverage
	 * @override
	 */
	setCoverage(coverage) {
		this.coverage.copy(coverage);
	}

	/**
	 * Sets the enter function. This function will be triggered once when the time enters the coverage.
	 * @param {((entity: Entity) => any) | undefined} enterFunction
	 */
	setEnterFunction(enterFunction) {
		this.enterFunction = enterFunction;
	}

	/**
	 * Sets the exit function. This function will be triggered once when the time exits the coverage.
	 * @param {((entity: Entity) => any) | undefined} exitFunction
	 */
	setExitFunction(exitFunction) {
		this.exitFunction = exitFunction;
	}

	/**
	 * Sets the update function. This function will be triggered every frame that the time is within the coverage.
	 * @param {((entity: Entity) => any) | undefined} updateFunction
	 */
	setUpdateFunction(updateFunction) {
		this.updateFunction = updateFunction;
	}

	/**
	 * Sets how often to run the update function, in seconds. The default 0 means run every frame.
	 * @param {number} updateInterval
	 */
	setUpdateInterval(updateInterval) {
		this.updateInterval = updateInterval * 1000;
	}

	/**
	 * Updates the position and orientation if they are fixed.
	 * @override
	 * @internal
	 */
	__update() {
		const time = this.getEntity().getScene().getEngine().getTime();

		// If this is the first coverage controller, we'll trigger all of the exit functions() necessary.
		if (this.getTypeIndex() === 0) {
			for (let i = 0; ; i++) {
				const coverageController = this.getEntity().getControllerByClass(CoverageController, i);
				if (coverageController === null) {
					break;
				}
				const newActive = coverageController.coverage.contains(time);
				if (coverageController.active && !newActive) {
					if (coverageController.exitFunction) {
						coverageController.exitFunction(this.getEntity());
					}
				}
			}
		}

		// Now call the enter function.
		const newActive = this.coverage.contains(time);
		if (!this.active && newActive) {
			if (this.enterFunction) {
				this.enterFunction(this.getEntity());
			}
		}

		// Call the update function.
		if (newActive && this.updateFunction) {
			const now = Date.now();
			if (now - this.lastUpdateTime >= this.updateInterval) {
				this.lastUpdateTime = now;
				this.updateFunction(this.getEntity());
			}
		}
		this.active = newActive;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/dynamo_controller.js":
/*!********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/dynamo_controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DynamoController": function() { return /* binding */ DynamoController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


class Point {
	/**
	 * Load the point from the reader.
	 * @param {Reader} reader
	 */
	load(reader) {
		/**
		 * @type {number}
		 */
		this.time = reader.readFloat64();
	}

	/**
	 * Sets this to the calculated point in between two points.
	 * @param {[Point, Point]} _points
	 * @param {number} _time
	 * @param {Object<string, number>} _header
	 * @param {boolean} _incremental
	 * @abstract
	 */
	calculate(_points, _time, _header, _incremental) { }

	/**
	 * Apply the point to the entity.
	 * @param {Entity} _entity
	 * @abstract
	 */
	apply(_entity) { }

	/**
	 * Sets the entity's point to NaN to clear out any data.
	 * @param {Entity} _entity
	 * @abstract
	 */
	setNaN(_entity) { }

	/**
	 * Reads the header information for this type from the reader.
	 * @param {Reader} _reader
	 * @returns {Object<string, number>}
	 */
	static readHeader(_reader) {
		return {};
	}
}

class PosPoint extends Point {
	constructor() {
		super();
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Load the point from the reader.
	 * @param {Reader} reader
	 * @override
	 */
	load(reader) {
		super.load(reader);

		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
	}

	/**
	 * Sets this to the calculated point in between two points.
	 * @param {[PosPoint, PosPoint]} points
	 * @param {number} time
	 * @param {Object<string, number>} _header
	 * @param {boolean} _incremental
	 * @override
	 */
	calculate(points, time, _header, _incremental) {
		this.time = time;
		const totalT = points[1].time - points[0].time;
		const u = (time - points[0].time) / totalT;
		const oneSubU = 1.0 - u;
		const oneSubUSq = oneSubU * oneSubU;
		const uSq = u * u;
		const a = (1.0 + 2.0 * u) * oneSubUSq;
		const b = u * oneSubUSq;
		const c = uSq * (3.0 - 2.0 * u);
		const d = uSq * -oneSubU;
		this.position.mult(points[0].position, a);
		this.position.addMult(this.position, points[0].velocity, totalT * b);
		this.position.addMult(this.position, points[1].position, c);
		this.position.addMult(this.position, points[1].velocity, totalT * d);
		const sixUSqSubU = 6.0 * (uSq - u);
		const aV = sixUSqSubU;
		const bV = 3.0 * uSq - 4.0 * u + 1.0;
		const cV = -sixUSqSubU;
		const dV = 3.0 * uSq - 2.0 * u;
		this.velocity.mult(points[0].position, aV / totalT);
		this.velocity.addMult(this.velocity, points[0].velocity, bV);
		this.velocity.addMult(this.velocity, points[1].position, cV / totalT);
		this.velocity.addMult(this.velocity, points[1].velocity, dV);
	}

	/**
	 * Apply the point to the entity.
	 * @param {Entity} entity
	 * @override
	 */
	apply(entity) {
		entity.setPosition(this.position);
		entity.setVelocity(this.velocity);
	}

	/**
	 * Sets the entity's point to NaN to clear out any data.
	 * @param {Entity} entity
	 * @override
	 */
	setNaN(entity) {
		entity.setPosition(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
		entity.setVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
	}

	/**
	 * Reads the header information for this type from the reader.
	 * @param {Reader} _reader
	 * @returns {Object<string, number>}
	 * @override
	 */
	static readHeader(_reader) {
		return {};
	}
}

class LinPoint extends Point {
	constructor() {
		super();
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Load the point from the reader.
	 * @param {Reader} reader
	 * @override
	 */
	load(reader) {
		super.load(reader);
		this.position.set(reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
		this.velocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);
	}

	/**
	 * Sets this to the calculated point in between two points.
	 * @param {[LinPoint, LinPoint]} points
	 * @param {number} time
	 * @param {Object<string, number>} _header
	 * @param {boolean} _incremental
	 * @override
	 */
	calculate(points, time, _header, _incremental) {
		this.time = time;
		if (points[1].time > points[0].time) {
			const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - points[0].time) / (points[1].time - points[0].time));
			this.position.lerp(points[0].position, points[1].position, u);
			this.velocity.sub(points[1].position, points[0].position);
			this.velocity.div(this.velocity, points[1].time - points[0].time);
		}
		else {
			this.position.copy(points[1].position);
			this.velocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);
		}
	}

	/**
	 * Apply the point to the entity.
	 * @param {Entity} entity
	 * @override
	 */
	apply(entity) {
		entity.setPosition(this.position);
		entity.setVelocity(this.velocity);
	}

	/**
	 * Sets the entity's point to NaN to clear out any data.
	 * @param {Entity} entity
	 * @override
	 */
	setNaN(entity) {
		entity.setPosition(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
		entity.setVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
	}

	/**
	 * Reads the header information for this type from the reader.
	 * @param {Reader} _reader
	 * @returns {Object<string, number>}
	 * @override
	 */
	static readHeader(_reader) {
		return {};
	}
}

class OriPoint extends Point {
	constructor() {
		super();
		this.orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this.angularVelocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Load the point from the reader.
	 * @param {Reader} reader
	 * @override
	 */
	load(reader) {
		super.load(reader);

		this.orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion(reader.readFloat64(), reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
		this.angularVelocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
	}

	/**
	 * Sets this to the calculated point in between two points.
	 * @param {[OriPoint, OriPoint]} points
	 * @param {number} time
	 * @param {Object<string, number>} _header
	 * @param {boolean} incremental
	 * @override
	 */
	calculate(points, time, _header, incremental) {
		this.time = time;
		const orientation0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const orientation1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const u = (time - points[0].time) / (points[1].time - points[0].time);
		points[0]._project(orientation0, time, incremental);
		points[1]._project(orientation1, time, incremental);
		this.orientation.slerp(orientation0, orientation1, u);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation1);
		this.angularVelocity.slerp(points[0].angularVelocity, points[1].angularVelocity, u);
		this.angularVelocity.neg(this.angularVelocity);
		this.angularVelocity.rotate(this.orientation, this.angularVelocity);
	}

	/**
	 * Apply the point to the entity.
	 * @param {Entity} entity
	 * @override
	 */
	apply(entity) {
		entity.setOrientation(this.orientation);
		entity.setAngularVelocity(this.angularVelocity);
	}

	/**
	 * Apply the point, projected in time, to the orientation, if it applies.
	 * @param {Quaternion} orientation
	 * @param {number} time
	 * @param {boolean} incremental
	 */
	_project(orientation, time, incremental) {
		const rotationAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		rotationAxis.normalize(this.angularVelocity);
		rotation.setFromAxisAngle(rotationAxis, this.angularVelocity.magnitude() * (time - this.time));
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(rotationAxis);
		if (incremental) {
			rotation.multInverseR(this.orientation, rotation);
			orientation.mult(orientation, rotation);
		}
		else {
			orientation.multInverseR(this.orientation, rotation);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
	}

	/**
	 * Sets the entity's point to NaN to clear out any data.
	 * @param {Entity} entity
	 * @override
	 */
	setNaN(entity) {
		entity.setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion[NaN]);
		entity.setAngularVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
	}

	/**
	 * Reads the header information for this type from the reader.
	 * @param {Reader} _reader
	 * @returns {Object<string, number>}
	 * @override
	 */
	static readHeader(_reader) {
		return {};
	}
}

class QuatPoint extends Point {
	constructor() {
		super();
		this.orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this.angularVelocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Load the point from the reader.
	 * @param {Reader} reader
	 * @override
	 */
	load(reader) {
		super.load(reader);

		this.orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion(reader.readFloat64(), reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
	}

	/**
	 * Sets this to the calculated point in between two points.
	 * @param {[QuatPoint, QuatPoint]} points
	 * @param {number} time
	 * @param {Object<string, number>} _header
	 * @param {boolean} _incremental
	 * @override
	 */
	calculate(points, time, _header, _incremental) {
		this.time = time;
		const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - points[0].time) / (points[1].time - points[0].time));
		this.orientation.slerp(points[0].orientation, points[1].orientation, u);
	}

	/**
	 * Apply the point to the entity.
	 * @param {Entity} entity
	 * @override
	 */
	apply(entity) {
		entity.setOrientation(this.orientation);
		entity.setAngularVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);
	}

	/**
	 * Sets the entity's point to NaN to clear out any data.
	 * @param {Entity} entity
	 * @override
	 */
	setNaN(entity) {
		entity.setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion[NaN]);
		entity.setAngularVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
	}

	/**
	 * Reads the header information for this type from the reader.
	 * @param {Reader} _reader
	 * @returns {Object<string, number>}
	 * @override
	 */
	static readHeader(_reader) {
		return {};
	}
}

class OrbPoint extends Point {
	constructor() {
		super();
		this.oe = new _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements();
		this.oe.orbitOrientation.freeze();

		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Load the point from the reader.
	 * @param {Reader} reader
	 * @override
	 */
	load(reader) {
		super.load(reader);
		this.oe.epoch = this.time;

		this.oe.semiMajorAxis = reader.readFloat64();
		this.oe.eccentricity = reader.readFloat64();
		this.oe.meanAngularMotion = reader.readFloat64();
		this.oe.meanAnomalyAtEpoch = reader.readFloat64();
		this.oe.orbitOrientation.thaw();
		this.oe.orbitOrientation.set(reader.readFloat64(), reader.readFloat64(), reader.readFloat64(), reader.readFloat64());
		this.oe.orbitOrientation.freeze();
	}

	/**
	 * Sets this to the calculated point in between two points.
	 * @param {[OrbPoint, OrbPoint]} points
	 * @param {number} time
	 * @param {Object<string, number>} header
	 * @param {boolean} incremental
	 * @override
	 */
	calculate(points, time, header, incremental) {
		this.time = time;
		this.oe.epoch = time;
		const position0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const position1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const velocity0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const velocity1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - points[0].time) / (points[1].time - points[0].time));
		points[0]._project(position0, velocity0, time, header, incremental);
		points[1]._project(position1, velocity1, time, header, incremental);
		this.position.lerp(position0, position1, u);
		this.velocity.lerp(velocity0, velocity1, u);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position1);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(velocity0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(velocity1);
	}

	/**
	 * Apply the point to the entity.
	 * @param {Entity} entity
	 * @override
	 */
	apply(entity) {
		entity.setPosition(this.position);
		entity.setVelocity(this.velocity);
	}

	/**
	 * Apply the point, projected in time, to the position, if it applies.
	 * @param {Vector3} position
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @param {Object<string, number>} header
	 * @param {boolean} incremental
	 */
	_project(position, velocity, time, header, incremental) {
		const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const newVelocity = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();

		// Project the position and velocity.
		this.oe.project(newPosition, newVelocity, time);

		// Get and multiply by the body factor so that the orbit works relative to the other object and not the focus.
		let bodyFactor = 1;
		if (header['body'] === 1) {
			bodyFactor = header['gravitationalParameter2'] / (header['gravitationalParameter1'] + header['gravitationalParameter2']);
		}
		else if (header['body'] === 2) {
			bodyFactor = -header['gravitationalParameter1'] / (header['gravitationalParameter1'] + header['gravitationalParameter2']);
		}
		newPosition.mult(newPosition, bodyFactor);
		newVelocity.mult(newVelocity, bodyFactor);

		// Rotate the vectors by the orbit orientation.
		if (incremental) {
			position.add(newPosition, position);
		}
		else {
			position.copy(newPosition);
		}
		velocity.copy(newVelocity);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newVelocity);
	}

	/**
	 * Sets the entity's point to NaN to clear out any data.
	 * @param {Entity} entity
	 * @override
	 */
	setNaN(entity) {
		entity.setPosition(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
		entity.setVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
	}

	/**
	 * Reads the header information for this type from the reader.
	 * @param {Reader} reader
	 * @returns {Object<string, number>}
	 * @override
	 */
	static readHeader(reader) {
		return {
			gravitationalParameter1: reader.readFloat64(),
			gravitationalParameter2: reader.readFloat64()
		};
	}
}

class PointSet {
	/**
	 * @param {typeof Point} PointClass
	 * @param {number} version
	 * @param {number} numberOfDigits
	 * @param {string} name
	 */
	constructor(PointClass, version, numberOfDigits, name) {
		/**
		 * The type of data.
		 * @type {typeof Point}
		 */
		this._PointClass = PointClass;

		/**
		 * The version of the dynamo type.
		 * @type {number}
		 * @private
		 */
		this._version = version;

		/**
		 * The number of digits for every index file's level.
		 * @type {number}
		 * @private
		 */
		this._numberOfDigits = numberOfDigits;

		/**
		 * The name to be used when loading the point set.
		 * @type {string}
		 */
		this._name = name;

		/**
		 * The array of points sets.
		 * @type {PointSet[]}
		 */
		this._pointSets = [];

		/**
		 * The array of points.
		 * @type {Point[]}
		 */
		this._points = [];

		/**
		 * The hint index used for getting the point or point set index.
		 * @type {number}
		 * @private
		 */
		this._hintIndex = 0;

		/**
		 * The interval which covers the points.
		 * @type {Interval}
		 */
		this._interval = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);

		/**
		 * State that determines whether the point set data is not loaded, loading, or loaded.
		 * @type {number}
		 */
		this._loadedState = PointSet.State.NOT_LOADED;

		/**
		 * The timestamp when this point set was loaded.
		 * @type {number}
		 */
		this._accessedTime = Number.POSITIVE_INFINITY;
	}

	/**
	 * Returns the name of the point set, used in downloading the file.
	 * @returns {string}
	 */
	getName() {
		return this._name;
	}

	/**
	 * Returns the loaded state of the point set.
	 * @returns {number}
	 */
	getLoadedState() {
		return this._loadedState;
	}

	/**
	 * Returns the loaded state of the point set.
	 * @returns {number}
	 */
	getLoadedTime() {
		return this._accessedTime;
	}

	/**
	 * Returns true if the point set has point sets.
	 * @returns {boolean}
	 */
	hasPointSets() {
		return this._pointSets.length !== 0;
	}

	/**
	 * Returns true if the point set has points.
	 * @returns {boolean}
	 */
	hasPoints() {
		return this._points.length !== 0;
	}

	/**
	 * Loads the data from a reader.
	 * @param {Reader} reader
	 */
	load(reader) {
		// Point set if it is in the definition file.
		let containsPoints = true;
		if (this._version === 2 || (this._version === 1 && this._name === 'def')) {
			containsPoints = (reader.readByte() === 1);
		}

		if (containsPoints) {
			// Read the data points.
			const numPoints = reader.readInt32();
			for (let i = 0; i < numPoints; i++) {
				const point = new this._PointClass();
				point.load(reader);
				this._points.push(point);
			}
			// Adjust the interval to match the data points.
			if (this._points.length > 0) {
				this._interval.min = this._points[0].time;
				this._interval.max = this._points[this._points.length - 1].time;
			}
		}
		else {
			// Read the data sets.
			const numPointSets = reader.readInt32();
			if (this._version === 1) {
				this._numberOfDigits = Math.ceil(Math.log10(numPointSets));
			}
			for (let i = 0; i < numPointSets; i++) {
				let newName = '';
				if (this._name === 'def') {
					newName = (i + '').padStart(this._numberOfDigits, '0');
				}
				else {
					newName = this._name + '_' + (i + '').padStart(this._numberOfDigits, '0');
				}
				const pointSet = new PointSet(this._PointClass, this._version, this._numberOfDigits, newName);
				pointSet._interval.min = reader.readFloat64();
				if (this._version === 1) {
					pointSet._interval.max = reader.readFloat64();
				}
				else {
					if (i > 0) {
						this._pointSets[i - 1]._interval.max = pointSet._interval.min;
					}
				}
				this._pointSets.push(pointSet);
			}
			if (this._version === 2) {
				this._pointSets.splice(this._pointSets.length - 1, 1);
			}
			// Adjust the interval to match the data points.
			if (this._pointSets.length > 0) {
				this._interval.min = this._pointSets[0]._interval.min;
				this._interval.max = this._pointSets[this._pointSets.length - 1]._interval.max;
			}
		}

		// Set the loaded flag to true and set the time loaded.
		this._loadedState = PointSet.State.LOADED;
		this._accessedTime = Date.now();
	}

	/**
	 * Loads the point set from a url.
	 * @param {Downloader} downloader
	 * @param {string} baseUrl
	 */
	loadFromUrl(downloader, baseUrl) {
		this._loadedState = PointSet.State.LOADING;
		downloader.download(baseUrl + '/' + this._name + '.dyn', true).then(async (download) => {
			if (download.status === 'cancelled') {
				return Promise.resolve();
			}
			else if (download.status === 'failed') {
				return Promise.reject(new Error('Failed to load dynamo controller file "' + download.url + '": ' + download.errorMessage));
			}
			if (!(download.content instanceof ArrayBuffer)) {
				return Promise.reject(new Error('Failed to load dynamo controller file "' + download.url + '": Not a binary file.'));
			}
			const reader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);
			this.load(reader);
		});
	}

	/**
	 * Unloads one point set that hasn't been accessed recently. Returns true if a point set was unloaded.
	 * @returns {boolean}
	 */
	unloadOldPointSet() {
		// Remove the oldest point set.
		for (let i = 0, l = this._pointSets.length; i < l; i++) {
			const pointSet = this._pointSets[i];
			if (pointSet._loadedState === PointSet.State.LOADED) {
				if (Date.now() - pointSet._accessedTime > 15000) { // If this point set hasn't been accessed in 15 seconds, expire it.
					pointSet.unload();
					return true;
				}
				else {
					if (pointSet.unloadOldPointSet()) {
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Unloads the data.
	 */
	unload() {
		this._loadedState = PointSet.State.NOT_LOADED;
		this._accessedTime = Number.POSITIVE_INFINITY;
		this._pointSets = [];
		this._points = [];
	}

	/**
	 * Gets the point set index for the given time, using a starting index as a hint to make things faster.
	 * @param {number} time
	 * @returns {PointSet}
	 */
	getPointSet(time) {
		this._accessedTime = Date.now();
		if (this._pointSets.length === 0) {
			return null;
		}
		// Use hint index to see if we can quickly find the right point set.
		if (this._pointSets[this._hintIndex]._interval.contains(time)) {
			// do nothing
		}
		else if (this._hintIndex - 1 >= 0 && this._pointSets[this._hintIndex - 1]._interval.contains(time)) {
			this._hintIndex -= 1;
		}
		else if (this._hintIndex + 1 < this._pointSets.length && this._pointSets[this._hintIndex + 1]._interval.contains(time)) {
			this._hintIndex += 1;
		}
		// Do a binary search to find the right point set index.
		else {
			let min = 0;
			let max = this._pointSets.length - 1;
			let index = 0;
			while (min !== max) {
				index = Math.ceil((min + max) / 2);
				if (time < this._pointSets[index]._interval.min) {
					max = index - 1;
				}
				else {
					min = index;
				}
			}
			this._hintIndex = min;
		}
		return this._pointSets[this._hintIndex];
	}

	/**
	 * Gets the point index for the given time, using a starting index as a hint to make things faster.
	 * @param {[Point | null, Point | null]} points
	 * @param {number} time
	 */
	getPoints(points, time) {
		this._accessedTime = Date.now();
		if (this._points.length === 0) {
			points[0] = null;
			points[1] = null;
			return;
		}
		// Use hint index to see if we can quickly find the right point.
		if (this._hintIndex + 1 < this._points.length && this._points[this._hintIndex].time <= time && time < this._points[this._hintIndex + 1].time) {
			// do nothing
		}
		else if (this._hintIndex - 1 >= 0 && this._points[this._hintIndex - 1].time <= time && time < this._points[this._hintIndex].time) {
			this._hintIndex -= 1;
		}
		else if (this._hintIndex + 2 < this._points.length && this._points[this._hintIndex + 1].time <= time && time < this._points[this._hintIndex + 2].time) {
			this._hintIndex += 1;
		}
		// Do a binary search to find the right point index.
		else {
			let min = 0;
			let max = this._points.length - 2;
			let index = 0;
			while (min !== max) {
				index = Math.ceil((min + max) / 2);
				if (time < this._points[index].time) {
					max = index - 1;
				}
				else {
					min = index;
				}
			}
			this._hintIndex = min;
		}
		points[0] = this._points[this._hintIndex];
		points[1] = this._points[this._hintIndex + 1];
	}
}

PointSet.State = {
	NOT_LOADED: 0,
	LOADING: 1,
	LOADED: 2
};

/**
 * A controller that animates via the Dynamo file format.
 */
class DynamoController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The base url within which the Dynamo files are contained.
		 * @type {string}
		 * @private
		 */
		this._baseUrl = '';

		/**
		 * The flag that says whether all data is loaded for the current time.
		 * @type {boolean}
		 * @private
		 */
		this._dataLoadedAtCurrentTime = false;

		/**
		 * The time offset that is applied to the dynamo when reading data.
		 * @type {number}
		 * @private
		 */
		this._timeOffset = 0;

		/**
		 * The version of the dynamo type.
		 * @type {number}
		 * @private
		 */
		this._version = 0;

		/**
		 * The point type.
		 * @type {string}
		 * @private
		 */
		this._pointType = '';

		/**
		 * The class of the point type.
		 * @type {typeof Point}
		 * @private
		 */
		this._PointClass = null;

		/**
		 * The number of digits for every index file's level.
		 * @type {number}
		 * @private
		 */
		this._numberOfDigits = 0;

		/**
		 * Point-specific header information for use in calculations.
		 * @type {Object<string, number>}
		 * @private
		 */
		this._header = {
			body: 0
		};

		/**
		 * A flag that determines whether the controller incrementally changes the position each frame instead of setting the position.
		 * @type {boolean}
		 * @private
		 */
		this._incremental = false;

		/**
		 * The root point set in the definition file.
		 * @type {PointSet}
		 * @private
		 */
		this._pointSet = null;

		/**
		 * A reference to the downloader for downloading files.
		 * @type {Downloader}
		 * @private
		 */
		this._downloader = entity.getScene().getEngine().getDownloader();

		/**
		 * Temporary point for calculations.
		 * @type {[Point | null, Point | null]}
		 * @private
		 */
		this._points = [null, null];

		/**
		 * The last known good points used in the update function.
		 * @type {[Point | null, Point | null]}
		 * @private
		 */
		this._lastPoints = [null, null];

		/**
		 * The last time used in the update function.
		 * @type {number}
		 * @private
		 */
		this._lastTime = Number.NaN;

		/**
		 * Temporary point for calculations.
		 * @type {Point}
		 * @private
		 */
		this._pCalc = null;

		/**
		 * The user coverage that limits the coverage coming from the data.
		 * @type {Interval}
		 * @private
		 */
		this._userCoverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		this._userCoverage.freeze();
	}

	/**
	 * Gets the point type. It can be 'pos', 'lin', 'orb', 'ori', or 'quat'.
	 * @returns {string}
	 */
	getPointType() {
		return this._pointType;
	}

	/**
	 * Gets the value of a header key.
	 * @param {string} key
	 * @returns {number}
	 */
	getHeaderValue(key) {
		return this._header[key];
	}

	/**
	 * Sets a key and value in the header information that the controller may use when updating.
	 * @param {string} key
	 * @param {number} value
	 */
	setHeaderValue(key, value) {
		this._header[key] = value;
	}

	/**
	 * Returns true if the controller incrementally changes the position each frame instead of setting the position. Defaults to false.
	 * @returns {boolean}
	 */
	isIncremental() {
		return this._incremental;
	}

	/**
	 * Sets whether the controller incrementally changes the position each frame instead of setting the position.
	 * @param {boolean} incremental
	 */
	setIncremental(incremental) {
		this._incremental = incremental;
	}

	/**
	 * Gets the base url within which the Dynamo files are contained.
	 * @returns {string}
	 */
	getBaseUrl() {
		return this._baseUrl;
	}

	/**
	 * Sets the base url within which the Dynamo files are contained.
	 * @param {string} baseUrl
	 */
	setBaseUrl(baseUrl) {
		// Clear out previous dynamo.
		if (this._baseUrl !== '') {
			this._downloader.cancel(this._baseUrl + '/def.dyn');
			this._pointSet = null;
			this._PointClass = null;
			this._userCoverage.thaw();
			this._userCoverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
			this._userCoverage.freeze();
			super.setCoverage(new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY));
			this.addModifiedState('position');
			this.addModifiedState('velocity');
			this.addModifiedState('orientation');
			this.addModifiedState('angularVelocity');
			this._dataLoadedAtCurrentTime = false;
		}

		this._baseUrl = baseUrl;
		if (this._baseUrl.endsWith('/')) {
			this._baseUrl = this._baseUrl.slice(0, -1);
		}

		this._loadDef();
	}

	/**
	 * Gets a promise when the initial dynamo (the def file) is loaded.
	 * @returns {Promise<void>}
	 * @override
	 */
	getLoadedPromise() {
		return new Promise((resolve) => {
			const engine = this.getEntity().getScene().getEngine();
			const callback = () => {
				const time = engine.getTime();
				if (this.isDestroyed() || !this.isEnabled() || !this.getEntity().isEnabled() || this._baseUrl === '' || (this._pointSet !== null && !this.getCoverage().contains(time)) || this._dataLoadedAtCurrentTime) {
					engine.removeCallback(callback);
					resolve();
				}
			};
			engine.addCallback(callback, true);
		});
	}

	/**
	 * Gets the time offset that is applied to the dynamo when reading data.
	 * @returns {number}
	 */
	getTimeOffset() {
		return this._timeOffset;
	}

	/**
	 * Sets the time offset that is applied to the dynamo when reading data.
	 * @param {number} timeOffset
	 */
	setTimeOffset(timeOffset) {
		const oldTimeOffset = this._timeOffset;
		this._timeOffset = timeOffset;
		// Adjust the coverage offset to reflect new offset.
		const newCoverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval();
		newCoverage.copy(this.getCoverage());
		newCoverage.min += this._timeOffset - oldTimeOffset;
		newCoverage.max += this._timeOffset - oldTimeOffset;
		super.setCoverage(newCoverage);
		// It doesn't change the point set intervals.
	}

	/**
	 * Sets the time interval over which the controller is valid.
	 * @param {Interval} coverage
	 * @override
	 */
	setCoverage(coverage) {
		this._userCoverage.thaw();
		this._userCoverage.copy(coverage);
		this._userCoverage.freeze();
		const finalCoverage = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
		if (this._pointSet !== null) {
			finalCoverage.intersection(this._userCoverage, this._pointSet._interval);
		}
		else {
			finalCoverage.copy(new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));
		}
		finalCoverage.min += this._timeOffset;
		finalCoverage.max += this._timeOffset;
		super.setCoverage(finalCoverage);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(finalCoverage);
	}

	/**
	 * Gets the orbital elements at the given time.
	 * @param {OrbitalElements} orbitalElements
	 * @param {number} time
	 */
	getOrbitalElements(orbitalElements, time) {
		if (this._PointClass === OrbPoint && this._pointSet !== null) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] !== null) {
				this._lastPoints[0] = this._points[0];
				this._lastPoints[1] = this._points[1];
			}
			if (this._lastPoints[0] !== null) {
				const oe0 = /** @type {OrbPoint} */(this._lastPoints[0]).oe;
				const oe1 = /** @type {OrbPoint} */(this._lastPoints[1]).oe;
				const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
				orbitalElements.eccentricity = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(oe0.eccentricity, oe1.eccentricity, u);
				orbitalElements.semiMajorAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(oe0.semiMajorAxis, oe1.semiMajorAxis, u);
				orbitalElements.epoch = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(oe0.epoch, oe1.epoch, u);
				orbitalElements.meanAngularMotion = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(oe0.meanAngularMotion, oe1.meanAngularMotion, u);
				orbitalElements.meanAnomalyAtEpoch = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerpAngle(oe0.meanAnomalyAtEpoch, oe1.meanAnomalyAtEpoch, u);
				orbitalElements.orbitOrientation.slerp(oe0.orbitOrientation, oe1.orbitOrientation, u);
			}
		}
	}

	/**
	 * Gets the eccentricity of the orbit at the given time, assuming it is the 'orb' type.
	 * @param {number} time
	 * @returns {number}
	 */
	getEccentricity(time) {
		if (this._PointClass === OrbPoint && this._pointSet !== null) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] !== null) {
				this._lastPoints[0] = this._points[0];
				this._lastPoints[1] = this._points[1];
			}
			if (this._lastPoints[0] !== null) {
				const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
				return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(/** @type {OrbPoint} */(this._lastPoints[0]).oe.eccentricity, /** @type {OrbPoint} */(this._lastPoints[1]).oe.eccentricity, u);
			}
		}
		return Number.NaN;
	}

	/**
	 * Gets the semi-major axis of the orbit at the given time, assuming it is the 'orb' type.
	 * @param {number} time
	 * @returns {number}
	 */
	getSemiMajorAxis(time) {
		if (this._PointClass === OrbPoint && this._pointSet !== null) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] !== null) {
				this._lastPoints[0] = this._points[0];
				this._lastPoints[1] = this._points[1];
			}
			if (this._lastPoints[0] !== null) {
				const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
				return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(/** @type {OrbPoint} */(this._lastPoints[0]).oe.semiMajorAxis, /** @type {OrbPoint} */(this._lastPoints[1]).oe.semiMajorAxis, u);
			}
		}
		return Number.NaN;
	}

	/**
	 * Gets the orbit orientation of the orbit at the given time, assuming it is the 'orb' type. The x-axis points toward the periapsis and the z-axis points in the direction of the angular momentum.
	 * @param {Quaternion} outOrbitOrientation
	 * @param {number} time
	 */
	getOrbitOrientation(outOrbitOrientation, time) {
		if (this._PointClass === OrbPoint && this._pointSet !== null) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] !== null) {
				this._lastPoints[0] = this._points[0];
				this._lastPoints[1] = this._points[1];
			}
			if (this._lastPoints[0] !== null) {
				const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - this._lastPoints[0].time) / (this._lastPoints[1].time - this._lastPoints[0].time));
				outOrbitOrientation.slerp(/** @type {OrbPoint} */(this._lastPoints[0]).oe.orbitOrientation, /** @type {OrbPoint} */(this._lastPoints[1]).oe.orbitOrientation, u);
			}
		}
	}

	/**
	 * Destroys any resources with the dynamo.
	 * @override
	 * @internal
	 */
	__destroy() {
		// Cancel any download.
		if (this._baseUrl !== '') {
			this._downloader.cancel(this._baseUrl + '/def.dyn');
		}
		super.__destroy();
	}

	/**
	 * If the type has positions, updates the position.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		if (this._pointSet === null) { // No def file loaded yet, so the time may or may not be covered, so set it to NaN.
			position.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			return;
		}
		if (/** @type {PosPoint | LinPoint | OrbPoint} */(this._pCalc).position === undefined || !this.getCoverage().contains(time)) {
			return; // It's not a position type or it's not covered.
		}
		if (this._pCalc.time !== time) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] === null) { // No valid data yet, so set to NaN.
				position.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
				return;
			}
			this._pCalc.calculate(this._points, time - this._timeOffset, this._header, this._incremental);
		}
		position.copy(/** @type {PosPoint | LinPoint | OrbPoint} */(this._pCalc).position);
	}

	/**
	 * If the type has positions, updates the velocity.
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, time) {
		if (this._pointSet === null) { // No def file loaded yet, so the time may or may not be covered, so set it to NaN.
			velocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			return;
		}
		else if (/** @type {PosPoint | LinPoint | OrbPoint} */(this._pCalc).velocity === undefined || !this.getCoverage().contains(time)) {
			return; // It's not a velocity type or it's not covered.
		}
		if (this._pCalc.time !== time) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] === null) { // No valid data yet, so set to NaN.
				velocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
				return;
			}
			this._pCalc.calculate(this._points, time - this._timeOffset, this._header, this._incremental);
		}
		velocity.copy(/** @type {PosPoint | LinPoint | OrbPoint} */(this._pCalc).velocity);
	}

	/**
	 * If the type has orientations, updates the orientation.
	 * @param {Quaternion} orientation
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, time) {
		if (this._pointSet === null) { // No def file loaded yet, so the time may or may not be covered, so set it to NaN.
			orientation.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion[NaN]);
			return;
		}
		if (/** @type {OriPoint | QuatPoint} */(this._pCalc).orientation === undefined || !this.getCoverage().contains(time)) {
			return; // It's not an orientation type or it's not covered.
		}
		if (this._pCalc.time !== time) {
			this._getPointsAtTime(this._points, time);
			if (this._points[0] === null) { // No valid data yet, so set to NaN.
				orientation.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion[NaN]);
				return;
			}
			this._pCalc.calculate(this._points, time - this._timeOffset, this._header, this._incremental);
		}
		orientation.copy(/** @type {OriPoint | QuatPoint} */(this._pCalc).orientation);
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		const entity = this.getEntity();
		const engine = entity.getScene().getEngine();
		const time = engine.getTime();
		if (this._pointSet !== null) {
			this._pointSet.unloadOldPointSet();
			this._getPointsAtTime(this._points, time);
			if (this._points[0] !== null) {
				// Apply the data.
				this._pCalc.calculate(this._points, time - this._timeOffset, this._header, this._incremental);
				this._pCalc.apply(entity);
				// Record these as the last known good values.
				this._lastPoints[0] = this._points[0];
				this._lastPoints[1] = this._points[1];
				this._dataLoadedAtCurrentTime = true;
			}
			// Data for the current time is still loading.
			else {
				// If we've got good previous data, apply it, otherwise do nothing.
				if (this._lastPoints[0] !== null && this._lastPoints[1] !== null) {
					// Apply the last known good data.
					this._pCalc.calculate(this._lastPoints, time - this._timeOffset, this._header, this._incremental);
					this._pCalc.apply(entity);
				}
				this._dataLoadedAtCurrentTime = false;
			}
		}
		else { // No def.dyn file has yet been loaded.
			this.getEntity().setPosition(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			this.getEntity().setVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			this.getEntity().setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion[NaN]);
			this.getEntity().setAngularVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			this._dataLoadedAtCurrentTime = false;
		}
		this._lastTime = time;
	}

	async _loadDef() {
		// Save the url here since it may change in the async process.
		const url = this._baseUrl;

		/**
		 * The promise that is used to tell when the dyndef is loaded.
		 * @type {Promise<void>}
		 */
		return this._downloader.download(this._baseUrl + '/def.dyn', true).then(async (download) => {
			if (download.status === 'cancelled') {
				return Promise.resolve();
			}
			else if (download.status === 'failed') {
				return Promise.reject(new Error('Failed to load dynamo controller file "' + download.url + '": ' + download.errorMessage));
			}
			if (!(download.content instanceof ArrayBuffer)) {
				return Promise.reject(new Error('Failed to load dynamo controller file "' + download.url + '": Not a binary file.'));
			}

			// Open the reader.
			const reader = new _internal__WEBPACK_IMPORTED_MODULE_0__.Reader(download.content);

			// Version
			this._version = reader.readInt16();
			if (this._version !== 1 && this._version !== 2) {
				throw new Error(download.url + ' is not Dynamo version 1 or 2');
			}

			// Type
			this._pointType = reader.readString();
			if (this._pointType === 'pos') {
				this._PointClass = PosPoint;
			}
			else if (this._pointType === 'lin') {
				this._PointClass = LinPoint;
			}
			else if (this._pointType === 'ori') {
				this._PointClass = OriPoint;
			}
			else if (this._pointType === 'quat') {
				this._PointClass = QuatPoint;
			}
			else if (this._pointType === 'orb') {
				this._PointClass = OrbPoint;
			}

			// Set the calculation point.
			this._pCalc = new this._PointClass();

			// Let the base controller know that this changes the position or orientation.
			if (this._PointClass === PosPoint || this._PointClass === LinPoint || this._PointClass === OrbPoint) {
				this.addModifiedState('position');
				this.addModifiedState('velocity');
				this.removeModifiedState('orientation');
				this.removeModifiedState('angularVelocity');
			}
			else if (this._PointClass === OriPoint || this._PointClass === QuatPoint) {
				this.addModifiedState('orientation');
				this.addModifiedState('angularVelocity');
				this.removeModifiedState('position');
				this.removeModifiedState('velocity');
			}

			// Read the number of digits for each level of the file names.
			if (this._version === 2) {
				this._numberOfDigits = reader.readByte();
			}

			// Header
			this._header = Object.assign(this._header, this._PointClass.readHeader(reader));

			this._pointSet = new PointSet(this._PointClass, this._version, this._numberOfDigits, 'def');
			this._pointSet.load(reader);

			// Update the coverage.
			const finalCoverage = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
			finalCoverage.intersection(this._userCoverage, this._pointSet._interval);
			finalCoverage.min += this._timeOffset;
			finalCoverage.max += this._timeOffset;
			super.setCoverage(finalCoverage);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(finalCoverage);
		}).catch((error) => {
			if (error instanceof Error) {
				error.message = `While loading dynamo "${url}/def.dyn": ${error.message}`;
			}
			throw error;
		});
	}

	/**
	 * Gets the points p0 and p1 at the given time.
	 * @param {[Point | null, Point | null]} points
	 * @param {number} time
	 */
	_getPointsAtTime(points, time) {
		let pointSet = this._pointSet;
		while (true) {
			if (pointSet.hasPoints()) {
				pointSet.getPoints(points, time - this._timeOffset);
				return;
			}
			else if (pointSet.getLoadedState() === PointSet.State.LOADED) {
				pointSet = pointSet.getPointSet(time - this._timeOffset);
				if (pointSet === null) {
					points[0] = null;
					points[1] = null;
					return;
				}
			}
			else if (pointSet.getLoadedState() === PointSet.State.NOT_LOADED) {
				pointSet.loadFromUrl(this._downloader, this._baseUrl);
				points[0] = null;
				points[1] = null;
				return;
			}
			else {
				points[0] = null;
				points[1] = null;
				return;
			}
		}
	}
}

DynamoController.maxLoadedPointSetsPerController = 5;


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/fixed_controller.js":
/*!*******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/fixed_controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedController": function() { return /* binding */ FixedController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A controller that sets a fixed position and/or orientation. */
class FixedController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		// The position to be updated. If null, the position is not fixed.
		this._position = null;

		// The orientation to be updated. If null, the orientation is not fixed.
		this._orientation = null;
	}

	/**
	 * Gets the position to be fixed, or null if the position is not fixed. Don't modify this directly.
	 * @returns {Vector3}
	 */
	getPosition() {
		return this._position;
	}

	/**
	 * Sets the position. Use null to unfix the position.
	 * @param {Vector3} position
	 */
	setPosition(position) {
		if (position !== null) {
			if (this._position === null) {
				this._position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			}
			this._position.thaw();
			this._position.copy(position);
			this._position.freeze();
		}
		else {
			this._position = null;
		}
		if (position !== null) {
			this.addModifiedState('position');
			this.addModifiedState('velocity');
		}
		else {
			this.removeModifiedState('position');
			this.removeModifiedState('velocity');
		}
	}

	/**
	 * Gets the orientation to be fixed, or null if the orientation is not fixed. Don't modify this directly.
	 * @returns {Quaternion}
	 */
	getOrientation() {
		return this._orientation;
	}

	/**
	 * Sets the orientation.
	 * @param {Quaternion} orientation
	 */
	setOrientation(orientation) {
		if (orientation !== null) {
			if (this._orientation === null) {
				this._orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			}
			this._orientation.thaw();
			this._orientation.copy(orientation);
			this._orientation.freeze();
		}
		else {
			this._orientation = null;
		}
		if (orientation !== null) {
			this.addModifiedState('orientation');
		}
		else {
			this.removeModifiedState('orientation');
		}
	}

	/**
	 * If the position is fixed, updates the position to the fixed position.
	 * @param {Vector3} position
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, _time) {
		if (this._position !== null) {
			position.copy(this._position);
		}
	}

	/**
	 * If the position is fixed, updates the velocity to zero.
	 * @param {Vector3} velocity
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, _time) {
		if (this._position !== null) {
			velocity.set(0, 0, 0);
		}
	}

	/**
	 * If the orientation is fixed, updates the orientation to the fixed orientation.
	 * @param {Quaternion} orientation
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, _time) {
		if (this._orientation !== null) {
			orientation.copy(this._orientation);
		}
	}

	/**
	 * Updates the position and orientation if they are fixed.
	 * @override
	 * @internal
	 */
	__update() {
		if (this._position !== null) {
			this.getEntity().setPosition(this._position);
			this.getEntity().setVelocity(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);
		}
		if (this._orientation !== null) {
			this.getEntity().setOrientation(this._orientation);
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/fixed_to_parent_controller.js":
/*!*****************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/fixed_to_parent_controller.js ***!
  \*****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FixedToParentController": function() { return /* binding */ FixedToParentController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A controller that rotates the position and orientation by the parent's orientation last frame change.
 *  Great for objects that are connected to their parents or landers.
 *  It needs to added as the last controller to work. */
class FixedToParentController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The parent's last orientation.
		 * @type {Quaternion}
		 * @private
		 */
		this._lastParentOrientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();

		// Start off with the correct last orientation.
		const parent = this.getEntity().getParent();
		if (parent !== null) {
			this._lastParentOrientation.copy(parent.getOrientation());
		}

		// Let the base controller know that this changes the orientation.
		this.addModifiedState('position');
		this.addModifiedState('orientation');

		// Add the dependency on the parent's orientation.
		this.addDependentState('parent', 'orientation');
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		const parent = this.getEntity().getParent();
		if (parent !== null) {
			const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			rotation.inverse(this._lastParentOrientation);
			rotation.mult(parent.getOrientation(), rotation);
			const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			position.rotate(rotation, this.getEntity().getPosition());
			this.getEntity().setPosition(position);
			orientation.mult(rotation, this.getEntity().getOrientation());
			this.getEntity().setOrientation(orientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
			this._lastParentOrientation.copy(parent.getOrientation());
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/free_fly_controller.js":
/*!**********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/free_fly_controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FreeFlyController": function() { return /* binding */ FreeFlyController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A camera controller that flies around freely.
 */
class FreeFlyController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The sensitivity for dragging.
		 * @type {number}
		 * @private
		 */
		this._dragSensitivity = 0.07;

		/**
		 * The smoothness of the dragging. Zero means no smoothness.
		 * @type {number}
		 * @private
		 */
		this._dragSmoothness = 0.8;

		/**
		 * The current value applied every frame to the movement.
		 * @type {Vector3}
		 * @private
		 */
		this._moveSmoothedValue = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0.0, 0.0, 0.0);

		/**
		 * The flag that determines whether the camera changes parent to whatever it is closer to.
		 * @type {boolean}
		 * @private
		 */
		this._changeParentToNearestEntity = true;

		/**
		 * The vector that runs every frame emulating user input.
		 * @type {Vector3}
		 * @private
		 */
		this._forcedMoving = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		this._isMoving = false;

		// Let the base controller know that this changes the position.
		this.addModifiedState('position');

		this.addDependentState('parent', 'orientation');
		this.addDependentState('parent', 'radius');
	}

	/**
	 * Gets the drag sensitivity. Defaults to 0.01.
	 * @returns {number}
	 */
	getDragSensitivity() {
		return this._dragSensitivity;
	}

	/**
	 * Sets the drag sensitivity.
	 * @param {number} dragSensitivity
	 */
	setDragSensitivity(dragSensitivity) {
		this._dragSensitivity = dragSensitivity;
	}

	/**
	 * Gets the drag smoothness. Defaults to 0.8.
	 * @returns {number}
	 */
	getDragSmoothness() {
		return this._dragSmoothness;
	}

	/**
	 * Sets the drag smoothness, between 0 and 1.
	 * @param {number} dragSmoothness
	 */
	setDragSmoothness(dragSmoothness) {
		this._dragSmoothness = dragSmoothness;
	}

	/**
	 * Gets the flag that determines whether the camera changes parent to whatever it is closer to. Defaults to true.
	 * @returns {boolean}
	 */
	getChangeParentToNearestEntity() {
		return this._changeParentToNearestEntity;
	}

	/**
	 * Sets the flag that determines whether the camera changes parent to whatever it is closer to. This requires this entity to have a camera component for faster checking.
	 * @param {boolean} changeParentToNearestEntity
	 */
	setChangeParentToNearestEntity(changeParentToNearestEntity) {
		this._changeParentToNearestEntity = changeParentToNearestEntity;
	}

	/**
	 * Gets the vector that runs every frame emulating user input. Defaults to Vector3.Zero.
	 * @returns {Vector3}
	 */
	getForcedMoving() {
		return this._forcedMoving;
	}

	/**
	 * Sets the vector that runs every frame emulating user input.
	 * @param {Vector3} forcedMoving
	 */
	setForcedMoving(forcedMoving) {
		this._forcedMoving = forcedMoving;
	}

	/**
	 * Updates the entity's position.
	 * @override
	 * @internal
	 */
	__update() {
		// If it has no parent, don't do anything.
		if (this.getEntity().getParent() === null) {
			return;
		}

		// Update the parent, if needed. Only do it if there was any input.
		if (this._changeParentToNearestEntity && (this.getEntity().getParent() === null || this._isMoving)) {
			const scene = this.getEntity().getScene();
			const cameraComponent = /** @type {CameraComponent} */(this.getEntity().get('camera'));
			let nearestEntity = null;
			let nearestDistance = Number.POSITIVE_INFINITY;
			for (let i = 0, l = scene.getNumEntities(); i < l; i++) {
				const entity = scene.getEntity(i);
				if (entity === this.getEntity() || !entity.canOcclude()) {
					continue;
				}
				const distance = entity.getCameraSpacePosition(cameraComponent).magnitude() - entity.getOcclusionRadius();
				if (nearestDistance > distance) {
					nearestDistance = distance;
					nearestEntity = entity;
				}
			}

			// Switch parents. Since it's happening in the update function.
			if (nearestEntity !== null && nearestEntity !== this.getEntity().getParent()) {
				this.getEntity().setParent(nearestEntity);
			}
		}

		// Set the position and orientation if they have never been set before.
		if (this.getEntity().getOrientation().isNaN()) {
			this.getEntity().setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		if (this.getEntity().getPosition().isNaN()) {
			this.getEntity().setPosition(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0));
		}

		// Get the move value from the controls.
		const move = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		move.set(0.0, 0.0, 0.0);
		const input = this.getEntity().getScene().getEngine().getInput();
		const viewport = input.getActiveViewport();
		if (viewport !== null) {
			const camera = viewport.getCamera();
			if (camera !== null && camera.getEntity() === this.getEntity()) {
				// Get the multipliers.
				let moveMultiplier = 1;
				if (input.isKeyPressed('x')) {
					moveMultiplier = 0.05;
				}
				if (input.isShiftPressed()) {
					moveMultiplier = 5;
				}

				// Add zoom movement.
				const zoomOffset = input.getZoomedOffset();
				if (zoomOffset !== 0) {
					move.y += -zoomOffset * this._dragSensitivity * moveMultiplier;
				}

				// Add key movement.
				if (input.isKeyPressed('w')) {
					move.y += this._dragSensitivity * moveMultiplier;
				}
				if (input.isKeyPressed('s')) {
					move.y -= this._dragSensitivity * moveMultiplier;
				}
				if (input.isKeyPressed('d')) {
					move.x += this._dragSensitivity * moveMultiplier;
				}
				if (input.isKeyPressed('a')) {
					move.x -= this._dragSensitivity * moveMultiplier;
				}
				if (input.isKeyPressed('e')) {
					move.z += this._dragSensitivity * moveMultiplier;
				}
				if (input.isKeyPressed('q')) {
					move.z -= this._dragSensitivity * moveMultiplier;
				}
				move.y += this._dragSensitivity * moveMultiplier * cameraFreeFlyParameters.velocity;
			}
		}

		// Add the forced moving.
		move.add(move, this._forcedMoving);

		this._isMoving = (move.magnitudeSqr() > 0);

		// Apply smoothing.
		this._moveSmoothedValue.lerp(move, this._moveSmoothedValue, this._dragSmoothness);
		if (!this._isMoving && this._moveSmoothedValue.magnitudeSqr() < 0.0000001) {
			this._moveSmoothedValue.set(0.0, 0.0, 0.0);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(move);

		// Get the distance to the current parent.
		let distance = Number.POSITIVE_INFINITY;
		const spheroid = /** @type {SpheroidComponent} */(this.getEntity().getParent().getComponentByType('spheroid'));
		if (spheroid !== null && !this.getEntity().getParent().getOrientation().isNaN()) {
			const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			position.rotateInverse(this.getEntity().getParent().getOrientation(), this.getEntity().getPosition());
			const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
			spheroid.llaFromXYZ(lla, position);
			distance = Math.min(distance, lla.alt);
			_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		}
		else {
			distance = Math.min(distance, this.getEntity().getPosition().magnitude() - this.getEntity().getParent().getOcclusionRadius());
		}
		distance = Math.max(0.1, distance);

		// Do the move.
		const oldPosition = this.getEntity().getPosition();
		const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const rotatedMove = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		rotatedMove.rotate(this.getEntity().getOrientation(), this._moveSmoothedValue);
		newPosition.addMult(oldPosition, rotatedMove, distance);
		this.getEntity().setPosition(newPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(rotatedMove);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/ground_clamp_controller.js":
/*!**************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/ground_clamp_controller.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "GroundClampController": function() { return /* binding */ GroundClampController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * @typedef {Object} HasGetGroundPosition
 * @property {(outPosition: Vector3, outHeightDir: Vector3, position: Vector3) => void} getGroundPosition
 */

/**
 * A controller that clamps an entty to the ground.
 */
class GroundClampController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The component to clamp to.
		 * @type {ComponentRef<BaseComponent & HasGetGroundPosition>}
		 * @private
		 */
		this._groundComponentRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());

		/**
		 * The offset in the up direction.
		 * @type {number}
		 * @private
		 */
		this._distanceFromGround = 0;

		/**
		 * The frame-up vector for use in clamping correctly to slanted surfaces.
		 * @type {Vector3}
		 * @private
		 */
		this._up = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);

		// Let the base controller know that this changes the position.
		this.addModifiedState('position');
	}

	/**
	 * Sets the component to clamp to. Defaults to the nearest ancestor spheroid or null.
	 * @param {string} entityName
	 * @param {string} componentType
	 * @param {number} [componentTypeIndex]
	 */
	setGroundComponentRef(entityName, componentType, componentTypeIndex) {
		this.removeDependentState(this._groundComponentRef.getEntityName(), 'orientation');
		this._groundComponentRef.setByType(entityName, componentType, componentTypeIndex);
		this.addDependentState(entityName, 'orientation');
	}

	/**
	 * Gets the distance in the up direction from the ground.
	 * @returns {number}
	 */
	getDistanceFromGround() {
		return this._distanceFromGround;
	}

	/**
	 * Sets the distance in the up direction from the ground. Negative is below the ground. Defaults to 0.
	 * @param {number} distanceFromGround
	 */
	setDistanceFromGround(distanceFromGround) {
		this._distanceFromGround = distanceFromGround;
	}

	/**
	 * Sets the frame-up vector for use in clamping correctly to slanted surfaces.
	 * @param {Vector3} up
	 */
	setUp(up) {
		this._up.copy(up);
	}

	/**
	 * Updates a position for the given time.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		// Get the entity parent.
		const entityParentNameAtTime = this.getEntity().getParentAtTime(time);
		const entityParentAtTime = this.getEntity().getScene().getEntity(entityParentNameAtTime);
		if (entityParentAtTime === null) {
			return;
		}
		// Get the ground component, or get the nearest ancestor with a spheroid.
		let groundComponent = this._groundComponentRef.get();
		if (groundComponent === null) {
			let parent = this.getEntity().getParent();
			while (parent !== null) {
				groundComponent = /** @type {SpheroidComponent} */(parent.getComponentByType('spheroid'));
				if (groundComponent !== null) {
					break;
				}
				parent = parent.getParent();
			}
			if (groundComponent === null) {
				return;
			}
		}
		const groundComponentEntity = groundComponent.getEntity();
		// Get the position of the entity in the component entity's frame-space.
		const entityPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const heightDir = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const groundOrientationAtTime = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		groundComponentEntity.getOrientationAtTime(groundOrientationAtTime, time);
		entityParentAtTime.getPositionRelativeToEntity(entityPosition, position, groundComponentEntity, time);
		entityPosition.rotateInverse(groundOrientationAtTime, entityPosition);
		// Get the height at the given position.
		if (groundComponent.getGroundPosition !== undefined) {
			groundComponent.getGroundPosition(entityPosition, heightDir, entityPosition);
		}
		if (!entityPosition.isNaN()) {
			const entityUp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const entityOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			this.getEntity().getOrientationAtTime(entityOrientation, time);
			entityUp.rotate(entityOrientation, this._up);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(entityOrientation);
			entityUp.rotateInverse(groundOrientationAtTime, entityUp);
			const cosUpAndGroundUp = Math.abs(entityUp.dot(heightDir));
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(entityUp);
			// Add on the up offset.
			entityPosition.addMult(entityPosition, heightDir, Math.min(this._distanceFromGround / cosUpAndGroundUp, this._distanceFromGround + this.getEntity().getExtentsRadius()));
			// Get the position back into the entity-space of the parent.
			entityPosition.rotate(groundOrientationAtTime, entityPosition);
			groundComponentEntity.getPositionRelativeToEntity(position, entityPosition, entityParentAtTime, time);
		}
		else {
			position.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
		}
		// Cleanup.
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(entityPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(heightDir);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(groundOrientationAtTime);
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		if (this.getEntity().getParent() === null) {
			return;
		}
		// Get the ground component, or get the nearest ancestor with a spheroid.
		let groundComponent = this._groundComponentRef.get();
		if (groundComponent === null) {
			let parent = this.getEntity().getParent();
			while (parent !== null) {
				groundComponent = /** @type {SpheroidComponent} */(parent.getComponentByType('spheroid'));
				if (groundComponent !== null) {
					break;
				}
				parent = parent.getParent();
			}
			if (groundComponent === null) {
				return;
			}
		}
		const groundComponentEntity = groundComponent.getEntity();
		// Get the position of the entity in the component entity's frame-space.
		const entityPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const heightDir = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.getEntity().getPositionRelativeToEntity(entityPosition, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, groundComponentEntity);
		entityPosition.rotateInverse(groundComponentEntity.getOrientation(), entityPosition);
		// Get the height at the given position.
		if (groundComponent.getGroundPosition !== undefined) {
			groundComponent.getGroundPosition(entityPosition, heightDir, entityPosition);
		}
		if (!entityPosition.isNaN()) {
			const entityUp = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			entityUp.rotate(this.getEntity().getOrientation(), this._up);
			entityUp.rotateInverse(groundComponentEntity.getOrientation(), entityUp);
			const cosUpAndGroundUp = Math.abs(entityUp.dot(heightDir));
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(entityUp);
			// Add on the up offset.
			entityPosition.addMult(entityPosition, heightDir, Math.min(this._distanceFromGround / cosUpAndGroundUp, this._distanceFromGround + this.getEntity().getExtentsRadius()));
			// Get the position back into the entity-space of the parent.
			entityPosition.rotate(groundComponentEntity.getOrientation(), entityPosition);
			groundComponentEntity.getPositionRelativeToEntity(entityPosition, entityPosition, this.getEntity().getParent());
		}
		else {
			entityPosition.copy(this.getEntity().getLastPosition());
		}
		// Set the position.
		this.getEntity().setPosition(entityPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(entityPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(heightDir);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/keyframe_controller.js":
/*!**********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/keyframe_controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyframeController": function() { return /* binding */ KeyframeController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller animates the position and orientation of an entity via keyframes.
 */
class KeyframeController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The position keyframes.
		 * @type {Array<{0: number, 1: PositionKeyframe}>}
		 * @private
		 */
		this._positionKeyframes = [];

		/**
		 * The orientation keyframes.
		 * @type {Array<{0: number, 1: OrientationKeyframe}>}
		 * @private
		 */
		this._orientationKeyframes = [];

		/**
		 * The flag that if true says that the times given are relative to the first update in real time,
		 * and if false says that the times are in ET time.
		 * @type {boolean}
		 * @private
		 */
		this._timesAreRealTime = false;

		/**
		 * The time of the first update, used when _timesAreRealTime is true.
		 * @type {number}
		 * @private
		 */
		this._timeOfFirstUpdate = NaN;

		// Set the coverage to nothing, since there are no keyframes.
		this.setCoverage(new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));

		// Helper vectors and quaternions for calculations.
		this._position0 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._position1 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._orientation0 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this._orientation1 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this._newPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._newVelocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._newOrientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this._tangent0 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._tangent1 = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._tempA = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._tempB = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}

	/**
	 * Adds a position keyframe.
	 * If positionOrEntity is an entity, the entity's position at the given time is used instead.
	 * @param {number} time
	 * @param {Vector3} position
	 * @param {string} [relativeToEntityPosition]
	 * @param {number} [relativeToEntityPositionTime]
	 * @param {string} [relativeToEntityOrientation]
	 * @param {number} [relativeToEntityOrientationTime]
	 */
	addPositionKeyframe(time, position, relativeToEntityPosition, relativeToEntityPositionTime, relativeToEntityOrientation, relativeToEntityOrientationTime) {
		/** @type {{0: number, 1: PositionKeyframe}} */
		const entry = [time, {
			position,
			relativeToEntityPosition: relativeToEntityPosition ? new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), relativeToEntityPosition) : undefined,
			relativeToEntityPositionTime,
			relativeToEntityOrientation: relativeToEntityOrientation ? new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), relativeToEntityOrientation) : undefined,
			relativeToEntityOrientationTime
		}];
		_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(entry, this._positionKeyframes, isLessAdd);
		if (this._positionKeyframes.length === 1) {
			this.addModifiedState('position');
			this.addModifiedState('velocity');
		}
		this._updateCoverage();
	}

	/**
	 * Removes a position keyframe. Returns true if the key was removed.
	 * @param {number} time
	 */
	removePositionKeyframe(time) {
		const found = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.remove(time, this._positionKeyframes, isLess, isEqual);
		if (found) {
			if (this._positionKeyframes.length === 0) {
				this.removeModifiedState('position');
				this.removeModifiedState('velocity');
			}
			this._updateCoverage();
		}
		return found;
	}

	/**
	 * Adds an orientation keyframe.
	 * If orientationOrEntity is an entity, the entity's orientation at the given time is used instead.
	 * @param {number} time
	 * @param {Quaternion} orientation
	 * @param {string} [relativeToEntityOrientation]
	 * @param {number} [relativeToEntityOrientationTime]
	 */
	addOrientationKeyframe(time, orientation, relativeToEntityOrientation, relativeToEntityOrientationTime) {
		/** @type {{0: number, 1: OrientationKeyframe}} */
		const entry = [time, {
			orientation,
			relativeToEntityOrientation: relativeToEntityOrientation ? new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene(), relativeToEntityOrientation) : undefined,
			relativeToEntityOrientationTime
		}];
		_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(entry, this._orientationKeyframes, isLessAdd);
		if (this._orientationKeyframes.length === 1) {
			this.addModifiedState('orientation');
		}
		this._updateCoverage();
	}

	/**
	 * Removes an orientation keyframe. Returns true if the key was removed.
	 * @param {number} time
	 */
	removeOrientationKeyframe(time) {
		const found = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.remove(time, this._orientationKeyframes, isLess, isEqual);
		if (found) {
			if (this._orientationKeyframes.length === 0) {
				this.removeModifiedState('orientation');
			}
			this._updateCoverage();
		}
		return found;
	}

	/**
	 * Gets the flag that if true says that the times given are relative to the first update in real time,
	 * and if false says that the times are in ET time.
	 * @returns {boolean}
	 */
	areTimesRealTime() {
		return this._timesAreRealTime;
	}

	/**
	 * Sets the flag that if true says that the times given are relative to the first update in real time,
	 * and if false says that the times are in ET time.
	 * @param {boolean} timesAreRealTime
	 */
	setTimesAreRealTime(timesAreRealTime) {
		this._timesAreRealTime = timesAreRealTime;
		this._updateCoverage();
	}

	/**
	 * Sets the position to the keyframed position at the given time.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		this._getPositionAtTime(position, time);
	}

	/**
	 * Sets the velocity to the keyframed velocity at the given time.
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, time) {
		this._getVelocityAtTime(velocity, time);
	}

	/**
	 * Sets the orientation to the keyframed orientation at the given time.
	 * @param {Quaternion} orientation
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, time) {
		this._getOrientationAtTime(orientation, time);
	}

	/**
	 * Updates the position and orientation from the keyframes.
	 * @override
	 * @internal
	 */
	__update() {
		const engine = this.getEntity().getScene().getEngine();
		let time = 0;
		if (this._timesAreRealTime) {
			if (isNaN(this._timeOfFirstUpdate)) {
				this._timeOfFirstUpdate = Date.now() / 1000;
			}
			else {
				time = Date.now() / 1000 - this._timeOfFirstUpdate;
			}
		}
		else {
			time = engine.getTime();
		}
		if (this._getPositionAtTime(this._newPosition, time)) {
			this.getEntity().setPosition(this._newPosition);
		}
		if (this._getVelocityAtTime(this._newVelocity, time)) {
			this.getEntity().setVelocity(this._newVelocity);
		}
		if (this._getOrientationAtTime(this._newOrientation, time)) {
			this.getEntity().setOrientation(this._newOrientation);
		}
	}

	/**
	 * Sets outPosition to the position at the given time. Returns true if they were set.
	 * @param {Vector3} outPosition
	 * @param {number} time
	 * @returns {boolean}
	 * @private
	 */
	_getPositionAtTime(outPosition, time) {
		const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._positionKeyframes, isLess);
		if (index < this._positionKeyframes.length) { // Any time before or at the ending time.
			if (index === 0) { // Any time before or at the beginning time.
				if (this._positionKeyframes[0][0] === time) { // It's right at the beginning time.
					this._getPositionOfKeyframe(outPosition, this._positionKeyframes[0]);
					return true;
				}
			}
			else { // Any time after the beginning time.
				const index0 = index - 1;
				const index1 = index;
				const time0 = this._positionKeyframes[index0][0];
				const time1 = this._positionKeyframes[index1][0];
				this._getPositionOfKeyframe(this._position0, this._positionKeyframes[index0]);
				this._getPositionOfKeyframe(this._position1, this._positionKeyframes[index1]);
				if (index0 > 0) {
					const timeA = this._positionKeyframes[index0 - 1][0];
					this._getPositionOfKeyframe(this._tempA, this._positionKeyframes[index0 - 1]);
					this._tempA.sub(this._position0, this._tempA);
					this._tempB.sub(this._position1, this._position0);
					this._tempB.mult(this._tempB, 0.5);
					this._tangent0.addMult(this._tempB, this._tempA, 0.5 * (time1 - time0) / (time0 - timeA));
				}
				else {
					this._tangent0.sub(this._position1, this._position0);
				}
				if (index1 < this._positionKeyframes.length - 1) {
					const timeB = this._positionKeyframes[index1 + 1][0];
					this._getPositionOfKeyframe(this._tempB, this._positionKeyframes[index1 + 1]);
					this._tempA.sub(this._position1, this._position0);
					this._tempB.sub(this._tempB, this._position1);
					this._tempA.mult(this._tempA, 0.5);
					this._tangent1.addMult(this._tempA, this._tempB, 0.5 * (time1 - time0) / (timeB - time1));
				}
				else {
					this._tangent1.sub(this._position1, this._position0);
				}
				const u = (time - time0) / (time1 - time0);
				this._cubicHermiteSpline(outPosition, this._position0, this._position1, this._tangent0, this._tangent1, u);
				return true;
			}
		}
		return false;
	}

	/**
	 * Sets outVelocity to the velocity at the given time. Returns true if they were set.
	 * @param {Vector3} outVelocity
	 * @param {number} time
	 * @returns {boolean}
	 * @private
	 */
	_getVelocityAtTime(outVelocity, time) {
		const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._positionKeyframes, isLess);
		if (index < this._positionKeyframes.length) { // Any time before or at the ending time.
			if (index === 0) { // Any time before or at the beginning time.
				if (this._positionKeyframes[0][0] === time) { // It's right at the beginning time.
					if (this._positionKeyframes.length > 1) {
						const time0 = this._positionKeyframes[0][0];
						const time1 = this._positionKeyframes[1][0];
						this._getPositionOfKeyframe(this._position0, this._positionKeyframes[0]);
						this._getPositionOfKeyframe(this._position1, this._positionKeyframes[1]);
						outVelocity.sub(this._position1, this._position0);
						outVelocity.div(outVelocity, time1 - time0);
					}
					else {
						outVelocity.set(0, 0, 0);
					}
					return true;
				}
			}
			else { // Any time after the beginning time.
				const index0 = index - 1;
				const index1 = index;
				const time0 = this._positionKeyframes[index0][0];
				const time1 = this._positionKeyframes[index1][0];
				this._getPositionOfKeyframe(this._position0, this._positionKeyframes[index0]);
				this._getPositionOfKeyframe(this._position1, this._positionKeyframes[index1]);
				if (index0 > 0) {
					const timeA = this._positionKeyframes[index0 - 1][0];
					this._getPositionOfKeyframe(this._tempA, this._positionKeyframes[index0 - 1]);
					this._tempA.sub(this._position0, this._tempA);
					this._tempB.sub(this._position1, this._position0);
					this._tempB.mult(this._tempB, 0.5);
					this._tangent0.addMult(this._tempB, this._tempA, 0.5 * (time1 - time0) / (time0 - timeA));
				}
				else {
					this._tangent0.sub(this._position1, this._position0);
				}
				if (index1 < this._positionKeyframes.length - 1) {
					const timeB = this._positionKeyframes[index1 + 1][0];
					this._getPositionOfKeyframe(this._tempB, this._positionKeyframes[index1 + 1]);
					this._tempA.sub(this._position1, this._position0);
					this._tempB.sub(this._tempB, this._position1);
					this._tempA.mult(this._tempA, 0.5);
					this._tangent1.addMult(this._tempA, this._tempB, 0.5 * (time1 - time0) / (timeB - time1));
				}
				else {
					this._tangent1.sub(this._position1, this._position0);
				}
				const u = (time - time0) / (time1 - time0);
				this._cubicHermiteSplineDerivative(outVelocity, this._position0, this._position1, this._tangent0, this._tangent1, u);
				outVelocity.div(outVelocity, time1 - time0);
				return true;
			}
		}
		return false;
	}

	/**
	 * Sets outOrientation to the orientation at the given time. Returns true if it was set.
	 * @param {Quaternion} outOrientation
	 * @param {number} time
	 * @returns {boolean}
	 * @private
	 */
	_getOrientationAtTime(outOrientation, time) {
		const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._orientationKeyframes, isLess);
		if (index < this._orientationKeyframes.length) { // Any time before or at the ending time.
			if (index === 0) { // Any time before or at the beginning time.
				if (this._orientationKeyframes[0][0] === time) { // It's right at the beginning time.
					this._getOrientationOfKeyframe(outOrientation, this._orientationKeyframes[0]);
					return true;
				}
			}
			else { // Any time after the beginning time.
				const index0 = index - 1;
				const index1 = index;
				const time0 = this._orientationKeyframes[index0][0];
				this._getOrientationOfKeyframe(this._orientation0, this._orientationKeyframes[index0]);
				const time1 = this._orientationKeyframes[index1][0];
				this._getOrientationOfKeyframe(this._orientation1, this._orientationKeyframes[index1]);
				outOrientation.slerp(this._orientation0, this._orientation1, (time - time0) / (time1 - time0));
				return true;
			}
		}
		return false;
	}

	/**
	 * Gets the position from a keyframe value.
	 * @param {Vector3} outPosition
	 * @param {{0: number, 1: PositionKeyframe}} keyframe
	 * @private
	 */
	_getPositionOfKeyframe(outPosition, keyframe) {
		const positionKeyframe = keyframe[1];
		outPosition.copy(positionKeyframe.position);
		if (positionKeyframe.relativeToEntityOrientation !== undefined) {
			const time = keyframe[1].relativeToEntityOrientationTime !== undefined ? keyframe[1].relativeToEntityOrientationTime : keyframe[0];
			const otherEntity = positionKeyframe.relativeToEntityOrientation.get();
			if (otherEntity !== null) {
				const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				otherEntity.getOrientationAtTime(orientation, time);
				outPosition.rotate(orientation, outPosition);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
			}
			else {
				outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			}
		}
		if (positionKeyframe.relativeToEntityPosition !== undefined) {
			const time = keyframe[1].relativeToEntityPositionTime !== undefined ? keyframe[1].relativeToEntityPositionTime : keyframe[0];
			const relativeToEntityPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const otherEntity = positionKeyframe.relativeToEntityPosition.get();
			if (otherEntity !== null) {
				otherEntity.getPositionRelativeToEntity(relativeToEntityPosition, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity().getParent(), time);
				outPosition.add(relativeToEntityPosition, outPosition);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(relativeToEntityPosition);
			}
			else {
				outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			}
		}
	}

	/**
	 * Gets the orientation from a keyframe value.
	 * @param {Quaternion} outOrientation
	 * @param {{0: number, 1: OrientationKeyframe}} keyframe
	 * @private
	 */
	_getOrientationOfKeyframe(outOrientation, keyframe) {
		const orientationKeyframe = keyframe[1];
		if (orientationKeyframe.relativeToEntityOrientation !== undefined) {
			const time = keyframe[1].relativeToEntityOrientationTime !== undefined ? keyframe[1].relativeToEntityOrientationTime : keyframe[0];
			const otherEntity = orientationKeyframe.relativeToEntityOrientation.get();
			if (otherEntity !== null) {
				otherEntity.getOrientationAtTime(outOrientation, time);
				outOrientation.mult(outOrientation, orientationKeyframe.orientation);
			}
			else {
				outOrientation.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion[NaN]);
			}
		}
		else {
			outOrientation.copy(orientationKeyframe.orientation);
		}
	}

	/**
	 * Updates the coverage.
	 * @private
	 */
	_updateCoverage() {
		if (this._timesAreRealTime) {
			this.setCoverage(_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.Infinite);
		}
		else {
			const coverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
			if (this._positionKeyframes.length > 0) {
				coverage.min = Math.min(coverage.min, this._positionKeyframes[0][0]);
				coverage.max = Math.max(coverage.max, this._positionKeyframes[this._positionKeyframes.length - 1][0]);
			}
			if (this._orientationKeyframes.length > 0) {
				coverage.min = Math.min(coverage.min, this._orientationKeyframes[0][0]);
				coverage.max = Math.max(coverage.max, this._orientationKeyframes[this._orientationKeyframes.length - 1][0]);
			}
			this.setCoverage(coverage);
		}
	}

	/**
	 * Sets outP to the cubic hermite spline of the given parameters.
	 * @param {Vector3} outP
	 * @param {Vector3} p0
	 * @param {Vector3} p1
	 * @param {Vector3} t0
	 * @param {Vector3} t1
	 * @param {number} u
	 */
	_cubicHermiteSpline(outP, p0, p1, t0, t1, u) {
		const u2 = u * u;
		const u3 = u * u2;
		const c0 = 2 * u3 - 3 * u2 + 1;
		const c1 = u3 - 2 * u2 + u;
		const c2 = -2 * u3 + 3 * u2;
		const c3 = u3 - u2;
		outP.x = c0 * p0.x + c1 * t0.x + c2 * p1.x + c3 * t1.x;
		outP.y = c0 * p0.y + c1 * t0.y + c2 * p1.y + c3 * t1.y;
		outP.z = c0 * p0.z + c1 * t0.z + c2 * p1.z + c3 * t1.z;
	}

	/**
	 * Sets outP to the derivative of the cubic hermite spline of the given parameters.
	 * @param {Vector3} outV
	 * @param {Vector3} p0
	 * @param {Vector3} p1
	 * @param {Vector3} t0
	 * @param {Vector3} t1
	 * @param {number} u
	 */
	_cubicHermiteSplineDerivative(outV, p0, p1, t0, t1, u) {
		const u2 = u * u;
		const c0 = 6 * u2 - 6 * u;
		const c1 = 3 * u2 - 4 * u + 1;
		const c2 = -6 * u2 + 6 * u;
		const c3 = 3 * u2 - 2 * u;
		outV.x = c0 * p0.x + c1 * t0.x + c2 * p1.x + c3 * t1.x;
		outV.y = c0 * p0.y + c1 * t0.y + c2 * p1.y + c3 * t1.y;
		outV.z = c0 * p0.z + c1 * t0.z + c2 * p1.z + c3 * t1.z;
	}
}

/**
 * @typedef PositionKeyframe
 * @property {Vector3} position
 * @property {EntityRef} [relativeToEntityPosition]
 * @property {number} [relativeToEntityPositionTime]
 * @property {EntityRef} [relativeToEntityOrientation]
 * @property {number} [relativeToEntityOrientationTime]
 */

/**
 * @typedef OrientationKeyframe
 * @property {Quaternion} orientation
 * @property {EntityRef} [relativeToEntityOrientation]
 * @property {number} [relativeToEntityOrientationTime]
 */

/**
 * An isLess function that uses two keyframes.
 * @callback IsLessAddFunction
 * @param {{0: number, 1: PositionKeyframe | OrientationKeyframe}} a
 * @param {{0: number, 1: PositionKeyframe | OrientationKeyframe}} b
 * @returns {boolean}
 */

/**
 * An isLess function that uses a keyframe and a time.
 * @callback IsLessFunction
 * @param {{0: number, 1: PositionKeyframe | OrientationKeyframe}} a
 * @param {number} b
 * @returns {boolean}
 */

/**
 * An isLess function that uses a keyframe and a time.
 * @callback IsEqualFunction
 * @param {{0: number, 1: PositionKeyframe | OrientationKeyframe}} a
 * @param {number} b
 * @returns {boolean}
 */

/**
 * A helper function for the keyframe sorting.
 * @type {IsLessAddFunction}
 */
const isLessAdd = (a, b) => (a[0] < b[0]);

/**
 * A helper function for the keyframe sorting.
 * @type {IsLessFunction}
 */
const isLess = (a, b) => (a[0] < b);

/**
 * A helper function for the keyframe sorting.
 * @type {IsEqualFunction}
 */
const isEqual = (a, b) => (a[0] === b);


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/look_controller.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/look_controller.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LookController": function() { return /* binding */ LookController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A camera controller that looks around the user with an optional axis.
 */
class LookController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The sensitivity for dragging.
		 * @type {number}
		 * @private
		 */
		this._dragSensitivity = 0.03;

		/**
		 * The smoothness of the dragging. Zero means no smoothness.
		 * @type {number}
		 * @private
		 */
		this._dragSmoothness = 0.8;

		/**
		 * The current value applied every frame to the yaw axis rotation.
		 * @type {number}
		 * @private
		 */
		this._yawAngleSmoothedValue = 0.0;

		/**
		 * The current value applied every frame to the pitch axis rotation.
		 * @type {number}
		 * @private
		 */
		this._pitchAngleSmoothedValue = 0.0;

		/**
		 * The axis around which to yaw. It can be 'none', 'x-axis', 'y-axis', 'z-axis', or 'position'.
		 * @type {string}
		 * @private
		 */
		this._yawAxisType = 'none';

		/**
		 * The yaw axis reference entity.
		 * @type {Entity}
		 * @private
		 */
		this._yawAxisEntity = null;

		// Let the base controller know that this changes the orientation.
		this.addModifiedState('orientation');
	}

	/**
	 * Gets the drag sensitivity. Defaults to 0.01.
	 * @returns {number}
	 */
	getDragSensitivity() {
		return this._dragSensitivity;
	}

	/**
	 * Sets the drag sensitivity.
	 * @param {number} dragSensitivity
	 */
	setDragSensitivity(dragSensitivity) {
		this._dragSensitivity = dragSensitivity;
	}

	/**
	 * Gets the drag smoothness. Defaults to 0.8.
	 * @returns {number}
	 */
	getDragSmoothness() {
		return this._dragSmoothness;
	}

	/**
	 * Sets the drag smoothness, between 0 and 1.
	 * @param {number} dragSmoothness
	 */
	setDragSmoothness(dragSmoothness) {
		this._dragSmoothness = dragSmoothness;
	}

	/**
	 * Gets the axis around which to yaw.
	 * @returns {string}
	 */
	getYawAxisType() {
		return this._yawAxisType;
	}

	/**
	 * Sets the axis around which to yaw. It can be 'none', 'x-axis', 'y-axis', 'z-axis', or 'position'.
	 * @param {string} yawAxisType
	 */
	setYawAxisType(yawAxisType) {
		if (this._yawAxisType === yawAxisType) {
			return;
		}
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.removeDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.removeDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
		this._yawAxisType = yawAxisType;
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.addDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.addDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
	}

	/**
	 * Gets the yaw axis reference entity. Defaults to this entity's parent.
	 * @returns {Entity}
	 */
	getYawAxisEntity() {
		return this._yawAxisEntity;
	}

	/**
	 * Sets the yaw axis reference entity.
	 * @param {Entity} yawAxisEntity
	 */
	setYawAxisEntity(yawAxisEntity) {
		if (this._yawAxisEntity === yawAxisEntity) {
			return;
		}
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.removeDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.removeDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
		this._yawAxisEntity = yawAxisEntity;
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.addDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.addDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
	}

	/**
	 * Updates the entity's position and orientation.
	 * @override
	 * @internal
	 */
	__update() {
		// If the yaw axis entity is null, set it to the parent.
		if (this._yawAxisEntity === null) {
			this._yawAxisEntity = this.getEntity().getParent();
			if (this._yawAxisEntity !== null) {
				if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
					this.addDependentState(this._yawAxisEntity.getName(), 'orientation');
				}
				else if (this._yawAxisType === 'position') {
					this.addDependentState(this._yawAxisEntity.getName(), 'position');
				}
			}
		}

		// Set the position and orientation if they have never been set before.
		if (this.getEntity().getOrientation().isNaN()) {
			this.getEntity().setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}

		// Get the look multiplier for if 'x' is pressed.
		const input = this.getEntity().getScene().getEngine().getInput();
		let lookMultiplier = 2;
		if (input.isKeyPressed('x')) {
			lookMultiplier = 0.05;
		}

		// Factor in the field of view of the camera.
		const camera = /** @type {CameraComponent} */(this.getEntity().getComponentByType('camera'));
		if (camera !== null) {
			lookMultiplier *= Math.min(1, camera.getFieldOfView());
		}

		// Get the yaw and pitch from input.
		let yawAngle = 0;
		let pitchAngle = 0;
		const viewport = input.getActiveViewport();
		if (viewport !== null) {
			const camera = viewport.getCamera();
			if (camera !== null && camera.getEntity() === this.getEntity()) {
				// Add mouse movement.
				const draggedOffset = input.getDraggedOffset();
				yawAngle = -cameraFreeFlyParameters.xAngleDv * this._dragSensitivity;
				pitchAngle = -cameraFreeFlyParameters.yAngleDv * this._dragSensitivity;
			}
		}

		// Apply smoothing.
		this._yawAngleSmoothedValue = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(yawAngle, this._yawAngleSmoothedValue, this._dragSmoothness);
		this._pitchAngleSmoothedValue = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(pitchAngle, this._pitchAngleSmoothedValue, this._dragSmoothness);
		if (Math.abs(this._yawAngleSmoothedValue) < 0.0001 * lookMultiplier) {
			this._yawAngleSmoothedValue = 0;
		}
		if (Math.abs(this._pitchAngleSmoothedValue) < 0.0001 * lookMultiplier) {
			this._pitchAngleSmoothedValue = 0;
		}

		// Get the yaw axis.
		const yawAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		if (this._yawAxisType === 'x-axis' && this._yawAxisEntity !== null) { // Use the x-axis of the reference entity.
			this._yawAxisEntity.getOrientation().getAxis(yawAxis, 0);
		}
		else if (this._yawAxisType === 'y-axis' && this._yawAxisEntity !== null) { // Use the y-axis of the reference entity.
			this._yawAxisEntity.getOrientation().getAxis(yawAxis, 1);
		}
		else if (this._yawAxisType === 'z-axis' && this._yawAxisEntity !== null) { // Use the z-axis of the reference entity.
			this._yawAxisEntity.getOrientation().getAxis(yawAxis, 2);
		}
		else if (this._yawAxisType === 'position' && this._yawAxisEntity !== null) { // Use the position of the reference entity.
			yawAxis.normalize(this._yawAxisEntity.getPosition());
		}
		else {
			this.getEntity().getOrientation().getAxis(yawAxis, 2); // Use the entity's z-axis.
		}

		// If the yaw axis isn't ready, just work as if the yaw axis type is 'none'.
		if (yawAxis.isNaN()) {
			this.getEntity().getOrientation().getAxis(yawAxis, 2);
		}

		// Get the current orientation.
		const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		orientation.copy(this.getEntity().getOrientation());

		// Rotate the orientation so that its z-axis is upright.
		const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const zAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const yAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.getEntity().getOrientation().getAxis(yAxis, 1);
		this.getEntity().getOrientation().getAxis(zAxis, 2);
		const angle = zAxis.angleAroundAxis(yawAxis, yAxis);
		rotation.setFromAxisAngle(yAxis, angle);
		rotation.normalize(rotation);
		orientation.mult(rotation, orientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(zAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(yAxis);

		// Get the pitch axis.
		const pitchAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		orientation.getAxis(pitchAxis, 0);

		// Rotate the target orientation by the pitch axis.
		rotation.setFromAxisAngle(pitchAxis, this._pitchAngleSmoothedValue);
		orientation.mult(rotation, orientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(pitchAxis);

		// Rotate the target orientation by the yaw axis.
		rotation.setFromAxisAngle(yawAxis, this._yawAngleSmoothedValue);
		orientation.mult(rotation, orientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(yawAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);

		// Set the current position.
		this.getEntity().setOrientation(orientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/model_animate_controller.js":
/*!***************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/model_animate_controller.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ModelAnimateController": function() { return /* binding */ ModelAnimateController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller animates using the model's keyframed animations.
 */
class ModelAnimateController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The animations.
		 * @type {Animation[]}
		 * @private
		 */
		this._animations = [];
	}

	/**
	 * Sets the animation to be at the joint on the specified model.
	 * @param {ModelComponent} model - the model of the joint
	 * @param {string} jointName - the joint on which the animation will be played
	 * @param {string} animationName - the name of the animation
	 * @param {Interval} interval - the interval over which the animation will be played
	 */
	setAnimation(model, jointName, animationName, interval) {
		if (model === null) {
			throw new Error('Null model specified.');
		}
		this._animations.push({
			model,
			jointName,
			animationName,
			interval,
			animationClip: null,
			rootObject: null,
			jointObject: null,
			animationMixer: null
		});
	}

	/**
	 * Updates the position and orientation from the keyframes.
	 * @override
	 * @internal
	 */
	__update() {
		const time = this.getEntity().getScene().getEngine().getTime();

		for (let i = 0, l = this._animations.length; i < l; i++) {
			const animation = this._animations[i];
			// If the model component no longer exists, remove the animation.
			if (animation.model.isDestroyed()) {
				this._animations.splice(i, 1);
				i--;
				continue;
			}
			// If the Three.js object doesn't yet exist, it's still loading.
			if (animation.model.getThreeJsObjects()[0] === null) {
				animation.rootObject = null;
				continue;
			}
			// If the model within the model component has been unloaded or reloaded, reset things.
			if (animation.rootObject !== animation.model.getThreeJsObjects()[0]) {
				animation.rootObject = animation.model.getThreeJsObjects()[0];
				animation.animationClip = null;
				animation.jointObject = null;
				animation.animationMixer = null;
			}
			// Get the animation clip if we don't yet have it.
			if (animation.animationClip === null) {
				animation.animationClip = animation.model.getAnimationClip(animation.animationName);
			}
			// Get the joint object if we don't yet have it.
			if (animation.jointObject === null) {
				const subObject = animation.model.getThreeJsObjectByName(animation.jointName);
				if (subObject !== null) {
					animation.jointObject = subObject;
				}
			}
			// If we have both the animation clip and joint object, but not the mixer, create it.
			if (animation.animationMixer === null && animation.animationClip !== null && animation.jointObject !== null) {
				animation.animationMixer = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AnimationMixer(animation.jointObject);
				animation.animationMixer.clipAction(animation.animationClip).play();
			}

			if (animation.animationMixer !== null) {
				const timeWithinAnimation = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((time - animation.interval.min) / (animation.interval.max - animation.interval.min));
				const keyFrameTime = (animation.animationClip.duration * timeWithinAnimation) * (animation.animationClip.tracks[0].times.length - 1) / animation.animationClip.tracks[0].times.length;
				animation.animationMixer.setTime(keyFrameTime);
				animation.animationMixer.update(0);
			}
		}
	}
}

/**
 * @typedef Animation
 * @property {ModelComponent} model
 * @property {string} jointName
 * @property {string} animationName
 * @property {Interval} interval
 * @property {THREE.Object3D} rootObject
 * @property {THREE.Object3D} jointObject
 * @property {THREE.AnimationClip} animationClip
 * @property {THREE.AnimationMixer } animationMixer
 */


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/orbit_controller.js":
/*!*******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/orbit_controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitController": function() { return /* binding */ OrbitController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * An orbit camera controller orbiting around a specific axis.
 */
class OrbitController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The sensitivity for dragging.
		 * @type {number}
		 * @private
		 */
		this._dragSensitivity = 0.01;

		/**
		 * The smoothness of the dragging. Zero means no smoothness.
		 * @type {number}
		 * @private
		 */
		this._dragSmoothness = 0.8;

		/**
		 * The current value applied every frame to the yaw axis rotation.
		 * @type {number}
		 * @private
		 */
		this._yawChangeSmoothedValue = 0.0;

		/**
		 * The current value applied every frame to the pitch axis rotation.
		 * @type {number}
		 * @private
		 */
		this._pitchChangeSmoothedValue = 0.0;

		/**
		 * The axis around which to yaw. It can be 'none', 'x-axis', 'y-axis', 'z-axis', or 'position'.
		 * @type {string}
		 * @private
		 */
		this._yawAxisType = 'none';

		/**
		 * The yaw axis reference entity.
		 * @type {Entity}
		 * @private
		 */
		this._yawAxisEntity = null;

		/**
		 * The axis around which to pitch. It can be 'none', 'x-axis', 'y-axis', 'z-axis', or 'position'.
		 * @type {string}
		 * @private
		 */
		this._pitchAxisType = 'none';

		/**
		 * The pitch axis reference entity.
		 * @type {Entity}
		 * @private
		 */
		this._pitchAxisEntity = null;

		/**
		 * When true, the entity will slow as it gets closer to its parent's occlusion radius.
		 * @type {boolean}
		 * @private
		 */
		this._slowWhenCloseToParent = false;

		/**
		 * The limits of the yaw angle.
		 * @type {Interval}
		 * @private
		 */
		this._yawAngleLimits = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		this._yawAngleLimits.freeze();

		/**
		 * The limits of the pitch angle.
		 * @type {Interval}
		 * @private
		 */
		this._pitchAngleLimits = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		this._pitchAngleLimits.freeze();

		// Let the base controller know that this changes the position and orientation.
		this.addModifiedState('position');
		this.addModifiedState('orientation');
	}

	/**
	 * Gets the drag sensitivity. Defaults to 0.01.
	 * @returns {number}
	 */
	getDragSensitivity() {
		return this._dragSensitivity;
	}

	/**
	 * Sets the drag sensitivity.
	 * @param {number} dragSensitivity
	 */
	setDragSensitivity(dragSensitivity) {
		this._dragSensitivity = dragSensitivity;
	}

	/**
	 * Gets the drag smoothness. Defaults to 0.8.
	 * @returns {number}
	 */
	getDragSmoothness() {
		return this._dragSmoothness;
	}

	/**
	 * Sets the drag smoothness, between 0 and 1.
	 * @param {number} dragSmoothness
	 */
	setDragSmoothness(dragSmoothness) {
		this._dragSmoothness = dragSmoothness;
	}

	/**
	 * Gets the axis around which to yaw. It defaults to 'none'.
	 * @returns {string}
	 */
	getYawAxisType() {
		return this._yawAxisType;
	}

	/**
	 * Sets the axis around which to yaw. It can be 'none', 'x-axis', 'y-axis', 'z-axis', or 'position'.
	 * @param {string} yawAxisType
	 */
	setYawAxisType(yawAxisType) {
		if (this._yawAxisType === yawAxisType) {
			return;
		}
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.removeDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.removeDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
		this._yawAxisType = yawAxisType;
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.addDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.addDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
	}

	/**
	 * Gets the axis around which to pitch. It defaults to 'none'.
	 * @returns {string}
	 */
	getPitchAxisType() {
		return this._pitchAxisType;
	}

	/**
	 * Sets the axis around which to pitch. It can be 'none', 'x-axis', 'y-axis', 'z-axis', or 'position'.
	 * @param {string} pitchAxisType
	 */
	setPitchAxisType(pitchAxisType) {
		if (this._pitchAxisType === pitchAxisType) {
			return;
		}
		if (this._pitchAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._pitchAxisType)) {
				this.removeDependentState(this._pitchAxisEntity.getName(), 'orientation');
			}
			else if (this._pitchAxisType === 'position') {
				this.removeDependentState(this._pitchAxisEntity.getName(), 'position');
			}
		}
		this._pitchAxisType = pitchAxisType;
		if (this._pitchAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._pitchAxisType)) {
				this.addDependentState(this._pitchAxisEntity.getName(), 'orientation');
			}
			else if (this._pitchAxisType === 'position') {
				this.addDependentState(this._pitchAxisEntity.getName(), 'position');
			}
		}
	}

	/**
	 * Gets the yaw axis reference entity. Defaults to this entity's parent.
	 * @returns {Entity}
	 */
	getYawAxisEntity() {
		return this._yawAxisEntity;
	}

	/**
	 * Sets the yaw axis reference entity.
	 * @param {Entity} yawAxisEntity
	 */
	setYawAxisEntity(yawAxisEntity) {
		if (this._yawAxisEntity === yawAxisEntity) {
			return;
		}
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.removeDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.removeDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
		this._yawAxisEntity = yawAxisEntity;
		if (this._yawAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._yawAxisType)) {
				this.addDependentState(this._yawAxisEntity.getName(), 'orientation');
			}
			else if (this._yawAxisType === 'position') {
				this.addDependentState(this._yawAxisEntity.getName(), 'position');
			}
		}
	}

	/**
	 * Gets the pitch axis reference entity. Defaults to this entity's parent.
	 * @returns {Entity}
	 */
	getPitchAxisEntity() {
		return this._pitchAxisEntity;
	}

	/**
	 * Sets the pitch axis reference entity.
	 * @param {Entity} pitchAxisEntity
	 */
	setPitchAxisEntity(pitchAxisEntity) {
		if (this._pitchAxisEntity === pitchAxisEntity) {
			return;
		}
		if (this._pitchAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._pitchAxisType)) {
				this.removeDependentState(this._pitchAxisEntity.getName(), 'orientation');
			}
			else if (this._pitchAxisType === 'position') {
				this.removeDependentState(this._pitchAxisEntity.getName(), 'position');
			}
		}
		this._pitchAxisEntity = pitchAxisEntity;
		if (this._pitchAxisEntity !== null) {
			if (['x-axis', 'y-axis', 'z-axis'].includes(this._pitchAxisType)) {
				this.addDependentState(this._pitchAxisEntity.getName(), 'orientation');
			}
			else if (this._pitchAxisType === 'position') {
				this.addDependentState(this._pitchAxisEntity.getName(), 'position');
			}
		}
	}

	/**
	 * Gets the limits of the yaw angle.
	 * @returns {Interval}
	 */
	getYawAngleLimits() {
		return this._yawAngleLimits;
	}

	/**
	 * Sets the limits of the yaw angle.
	 * @param {Interval} yawAngleLimits
	 */
	setYawAngleLimits(yawAngleLimits) {
		this._yawAngleLimits.thaw();
		this._yawAngleLimits.copy(yawAngleLimits);
		this._yawAngleLimits.freeze();
	}

	/**
	 * Gets the limits of the pitch angle.
	 * @returns {Interval}
	 */
	getPitchAngleLimits() {
		return this._pitchAngleLimits;
	}

	/**
	 * Sets the limits of the pitch angle.
	 * @param {Interval} pitchAngleLimits
	 */
	setPitchAngleLimits(pitchAngleLimits) {
		this._pitchAngleLimits.thaw();
		this._pitchAngleLimits.copy(pitchAngleLimits);
		this._pitchAngleLimits.freeze();
	}

	/**
	 * Returns whether the entity will slow as it gets closer to its parent's occlusion radius.
	 * @returns {boolean}
	 */
	isSlowWhenCloseToParent() {
		return this._slowWhenCloseToParent;
	}

	/**
	 * Sets whether the entity will slow as it gets closer to its parent's occlusion radius.
	 * @param {boolean} enabled
	 */
	slowWhenCloseToParent(enabled) {
		this._slowWhenCloseToParent = enabled;
	}

	/**
	 * Updates the entity's position and orientation.
	 * @override
	 * @internal
	 */
	__update() {
		// There is no pivot, so don't do anything.
		if (this.getEntity().getParent() === null) {
			return;
		}

		// Set the position and orientation if they have never been set before.
		if (this.getEntity().getOrientation().isNaN()) {
			this.getEntity().setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		if (this.getEntity().getPosition().isNaN()) {
			this.getEntity().setPosition(new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -1, 0));
		}

		// Get the orbit multiplier for if 'x' or 'shift' is pressed.
		const input = this.getEntity().getScene().getEngine().getInput();
		let orbitMultiplier = 1;
		if (input.isKeyPressed('x')) {
			orbitMultiplier = 0.05;
		}
		if (input.isShiftPressed()) {
			orbitMultiplier = 5;
		}
		// Factor in the field of view of the camera.
		const camera = /** @type {CameraComponent} */(this.getEntity().getComponentByType('camera'));
		if (camera !== null) {
			orbitMultiplier *= Math.min(1, camera.getFieldOfView());
		}

		// Get the azimuth and elevation change from the input.
		let yawChange = 0;
		let pitchChange = 0;
		const viewport = input.getActiveViewport();
		if (viewport !== null) {
			const camera = viewport.getCamera();
			if (camera !== null && camera.getEntity() === this.getEntity()) {
				// Add mouse/touch movement.
				const draggedOffset = input.getDraggedOffset();
				yawChange = -draggedOffset.x * this._dragSensitivity * orbitMultiplier;
				pitchChange = draggedOffset.y * this._dragSensitivity * orbitMultiplier;

				// Add key movement.
				if (input.isKeyPressed('d')) {
					yawChange += this._dragSensitivity * orbitMultiplier;
				}
				if (input.isKeyPressed('a')) {
					yawChange -= this._dragSensitivity * orbitMultiplier;
				}
				if (input.isKeyPressed('e')) {
					pitchChange -= this._dragSensitivity * orbitMultiplier;
				}
				if (input.isKeyPressed('q')) {
					pitchChange += this._dragSensitivity * orbitMultiplier;
				}
				yawChange += this._dragSensitivity * orbitMultiplier * cameraOrbitParameters.yaw;
				pitchChange += this._dragSensitivity * orbitMultiplier * cameraOrbitParameters.pitch;
			}
		}

		// Apply smoothing.
		this._yawChangeSmoothedValue = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(yawChange, this._yawChangeSmoothedValue, this._dragSmoothness);
		this._pitchChangeSmoothedValue = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(pitchChange, this._pitchChangeSmoothedValue, this._dragSmoothness);
		if (Math.abs(this._yawChangeSmoothedValue) < 0.0001 * orbitMultiplier) {
			this._yawChangeSmoothedValue = 0;
		}
		if (Math.abs(this._pitchChangeSmoothedValue) < 0.0001 * orbitMultiplier) {
			this._pitchChangeSmoothedValue = 0;
		}

		// Get the yaw axis.
		const yawAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		// If the yaw axis entity is null, set it to the parent.
		if (this._yawAxisEntity === null) {
			this._yawAxisEntity = this.getEntity().getParent();
		}
		if (this._yawAxisType === 'x-axis' && this._yawAxisEntity !== null) { // Use the x-axis of the reference entity.
			this._yawAxisEntity.getOrientation().getAxis(yawAxis, 0);
		}
		else if (this._yawAxisType === 'y-axis' && this._yawAxisEntity !== null) { // Use the y-axis of the reference entity.
			this._yawAxisEntity.getOrientation().getAxis(yawAxis, 1);
		}
		else if (this._yawAxisType === 'z-axis' && this._yawAxisEntity !== null) { // Use the z-axis of the reference entity.
			this._yawAxisEntity.getOrientation().getAxis(yawAxis, 2);
		}
		else if (this._yawAxisType === 'position' && this._yawAxisEntity !== null) { // Use the position of the reference entity.
			yawAxis.normalize(this._yawAxisEntity.getPosition());
		}
		else {
			this.getEntity().getOrientation().getAxis(yawAxis, 2); // Use the entity's z-axis.
		}

		// If the yaw axis isn't ready, just work as if the yaw axis type is 'none'.
		if (yawAxis.isNaN() || yawAxis.isZero()) {
			this.getEntity().getOrientation().getAxis(yawAxis, 2);
		}

		// Get the pitch axis.
		const pitchAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		// If the pitch axis entity is null, set it to the parent.
		if (this._pitchAxisEntity === null) {
			this._pitchAxisEntity = this.getEntity().getParent();
		}
		if (this._pitchAxisType === 'x-axis' && this._pitchAxisEntity !== null) { // Use the x-axis of the reference entity.
			this._pitchAxisEntity.getOrientation().getAxis(pitchAxis, 0);
		}
		else if (this._pitchAxisType === 'y-axis' && this._pitchAxisEntity !== null) { // Use the y-axis of the reference entity.
			this._pitchAxisEntity.getOrientation().getAxis(pitchAxis, 1);
		}
		else if (this._pitchAxisType === 'z-axis' && this._pitchAxisEntity !== null) { // Use the z-axis of the reference entity.
			this._pitchAxisEntity.getOrientation().getAxis(pitchAxis, 2);
		}
		else if (this._pitchAxisType === 'position' && this._pitchAxisEntity !== null) { // Use the position of the reference entity.
			pitchAxis.normalize(this._pitchAxisEntity.getPosition());
		}
		else {
			this.getEntity().getOrientation().getAxis(pitchAxis, 0); // Use the entity's x-axis.
		}

		// If the pitch axis isn't ready, just work as if the pitch axis type is 'none'.
		if (pitchAxis.isNaN() || pitchAxis.isZero()) {
			this.getEntity().getOrientation().getAxis(pitchAxis, 0);
		}

		// Make the pitch axis orthonormal to the yaw axis.
		pitchAxis.setNormalTo(yawAxis, pitchAxis);

		// Get the axes as a quaternion frame.
		const axisFrame = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		axisFrame.setFromAxes(pitchAxis, undefined, yawAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(pitchAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(yawAxis);

		// Get the current position angles relative to the axes.
		const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		position.rotateInverse(axisFrame, this.getEntity().getPosition());

		// Calculate the slow factor.
		let slowFactor = 1.0;
		if (this._slowWhenCloseToParent) {
			const radius = this.getEntity().getParent().getOcclusionRadius();
			slowFactor = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp((position.magnitude() - radius) / radius, 0.001, 1.0);
		}

		// Add in the pitch and yaw changes.
		const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLLAFromXYZOnSphere(lla, position, 0);
		lla.lat += this._pitchChangeSmoothedValue * slowFactor;
		lla.lon += this._yawChangeSmoothedValue * slowFactor;

		// Set upper limits for pitch so that it doesn't go beyond the yaw axis.
		if (lla.lat < 0.0001 - _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi) {
			lla.lat = 0.0001 - _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi;
		}
		if (lla.lat > _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi - 0.0001) {
			lla.lat = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.halfPi - 0.0001;
		}

		// Apply pitch and yaw limits.
		if (lla.lat < this._pitchAngleLimits.min) {
			lla.lat = this._pitchAngleLimits.min;
		}
		if (lla.lat > this._pitchAngleLimits.max) {
			lla.lat = this._pitchAngleLimits.max;
		}
		if (lla.lon < this._yawAngleLimits.min) {
			lla.lon = this._yawAngleLimits.min;
		}
		if (lla.lon > this._yawAngleLimits.max) {
			lla.lon = this._yawAngleLimits.max;
		}

		// Set the position from the new LLA and clean up.
		_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getXYZFromLLAOnSphere(position, lla, 0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		position.rotate(axisFrame, position);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(axisFrame);
		this.getEntity().setPosition(position);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/orbit_keyframe_controller.js":
/*!****************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/orbit_keyframe_controller.js ***!
  \****************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitKeyframeController": function() { return /* binding */ OrbitKeyframeController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


class OrbitKeyframeController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The positions that this entity will be in.
		 * @type {PositionKeyframe[]}
		 * @private
		 */
		this._positionKeyframes = [];

		/**
		 * The entities that will be focused on by the camera.
		 * @type {FocusKeyframe[]}
		 * @private
		 */
		this._focusKeyframes = [];

		/**
		 * The up directions that this entity will orient to.
		 * @type {UpKeyframe[]}
		 * @private
		 */
		this._upKeyframes = [];

		/**
		 * The time of the first update.
		 * @type {number}
		 * @private
		 */
		this._timeOfFirstUpdate = NaN;

		/**
		 * The direction of the first update.
		 * @type {Vector3}
		 * @private
		 */
		this._directionOfFirstUpdate = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * The resolve function that will be called when the keyframes complete.
		 * @type {function():void}
		 * @private
		 */
		this._resolvePromise = null;

		/**
		 * The reject function that will be called if the keyframes fail to complete.
		 * @type {function():void}
		 * @private
		 */
		this._rejectPromise = null;

		/**
		 * The promise that resolves or rejects at the end of the keyframes.
		 * @type {Promise<void>}
		 * @private
		 */
		this._endPromise = new Promise((resolve, reject) => {
			this._resolvePromise = resolve;
			this._rejectPromise = reject;
		});

		this.addModifiedState('position');
		this.addModifiedState('velocity');
		this.addModifiedState('orientation');
		this.addModifiedState('angularVelocity');
	}

	/**
	 * Sets a position keyframe. Use undefined to remove the keyframe.
	 * @param {number} time
	 * @param {Vector3 | undefined} position
	 * @param {string} relativeToEntity
	 */
	setPositionKeyframe(time, position, relativeToEntity) {
		if (position !== undefined) {
			const keyframe = new PositionKeyframe(this.getEntity().getScene());
			keyframe.time = time;
			keyframe.position.copy(position);
			keyframe.relativeTo.setName(relativeToEntity);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(keyframe, this._positionKeyframes, isLess);
		}
		else {
			const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._positionKeyframes, isLessThanTime);
			if (index < this._positionKeyframes.length && time === this._positionKeyframes[index].time) {
				this._positionKeyframes.splice(index, 1);
			}
		}
	}

	/**
	 * Sets a focus keyframe. Use undefined to remove the keyframe.
	 * @param {number} time
	 * @param {string | undefined} focus
	 */
	setFocusKeyframe(time, focus) {
		if (focus !== undefined) {
			const keyframe = new FocusKeyframe(this.getEntity().getScene());
			keyframe.time = time;
			keyframe.focus.setName(focus);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(keyframe, this._focusKeyframes, isLess);
		}
		else {
			const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._focusKeyframes, isLessThanTime);
			if (index < this._focusKeyframes.length && time === this._focusKeyframes[index].time) {
				this._focusKeyframes.splice(index, 1);
			}
		}
	}

	/**
	 * Sets a position keyframe. Use undefined to remove the keyframe.
	 * @param {number} time
	 * @param {Vector3 | undefined} up
	 */
	setUpKeyframe(time, up) {
		if (up !== undefined) {
			const keyframe = new UpKeyframe();
			keyframe.time = time;
			keyframe.up.copy(up);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(keyframe, this._upKeyframes, isLess);
		}
		else {
			const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._upKeyframes, isLessThanTime);
			if (index < this._upKeyframes.length && time === this._upKeyframes[index].time) {
				this._upKeyframes.splice(index, 1);
			}
		}
	}

	/**
	 * Gets the promise that resolves at the end of the keyframes.
	 * @returns {Promise<void>}
	 */
	getEndPromise() {
		return this._endPromise;
	}

	/**
	 * Destroys the controller.
	 * @override
	 * @internal
	 */
	__destroy() {
		super.__destroy();

		if (this._rejectPromise !== null) {
			this._rejectPromise();
		}
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		// Get the entity, since it is used a lot.
		const entity = this.getEntity();

		// Get the time since the start.
		let time = 0;
		if (isNaN(this._timeOfFirstUpdate)) {
			// Get the parent.
			const parent = entity.getParent();
			if (parent === null) {
				return;
			}

			// Set the time and direction of the first update to now the y-axis of the entity, respectively.
			this._timeOfFirstUpdate = Date.now() / 1000;
			entity.getOrientation().getAxis(this._directionOfFirstUpdate, 1);

			// Add an initial position keyframe.
			const positionKeyframe = new PositionKeyframe(entity.getScene());
			positionKeyframe.time = 0;
			positionKeyframe.position.copy(entity.getPosition());
			positionKeyframe.relativeTo.setName(parent.getName());
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(positionKeyframe, this._positionKeyframes, isLess);

			// Add an initial focus keyframe. The '' focus means use the first frame's direction (set above).
			const keyframe = new FocusKeyframe(entity.getScene());
			keyframe.time = 0;
			keyframe.focus.setName('');
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(keyframe, this._focusKeyframes, isLess);

			// Add an initial up keyframe.
			const upKeyframe = new UpKeyframe();
			upKeyframe.time = 0;
			entity.getOrientation().getAxis(upKeyframe.up, 2);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add(upKeyframe, this._upKeyframes, isLess);
		}
		else {
			time = Date.now() / 1000 - this._timeOfFirstUpdate;
		}

		// Apply the position keyframes.
		let doneWithPositionKeyframes = false;
		const positionKeyframeIndex = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._positionKeyframes, isLessThanTime);
		if (positionKeyframeIndex > 0 && positionKeyframeIndex < this._positionKeyframes.length) {
			// Get the keyframes.
			const keyframe0 = this._positionKeyframes[positionKeyframeIndex - 1];
			const keyframe1 = this._positionKeyframes[positionKeyframeIndex];

			// Get the relative-to entities for the corresponding names.
			const relativeToEntity0 = keyframe0.relativeTo.get();
			const relativeToEntity1 = keyframe1.relativeTo.get();
			if (relativeToEntity0 !== null && relativeToEntity1 !== null) {
				// Get the lerp value.
				let u = (time - keyframe0.time) / (keyframe1.time - keyframe0.time);

				// Update the parent entity depending on if we're in the first or second half.
				let parentEntity = relativeToEntity0;
				if (u >= 0.5) {
					parentEntity = relativeToEntity1;
				}
				if (entity.getParent() !== parentEntity) {
					entity.setParent(parentEntity);
				}

				// Get the positions relative to the appropriate entity.
				const position0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				const position1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				relativeToEntity0.getPositionRelativeToEntity(position0, keyframe0.position, relativeToEntity1);
				relativeToEntity1.getPositionRelativeToEntity(position1, keyframe1.position, relativeToEntity0);

				// Get the u lerp value scaled so that is exponential, relating to the radius of the current parent.
				let dist00 = Math.max(0, keyframe0.position.magnitude() - relativeToEntity0.getOcclusionRadius());
				let dist10 = Math.max(0, position1.magnitude() - relativeToEntity0.getOcclusionRadius());
				let dist01 = Math.max(0, position0.magnitude() - relativeToEntity1.getOcclusionRadius());
				let dist11 = Math.max(0, keyframe1.position.magnitude() - relativeToEntity1.getOcclusionRadius());
				dist00 = Math.max(dist00, dist10 / 10000); // Make sure they aren't too far different.
				dist10 = Math.max(dist10, dist00 / 10000); // Otherwise the smaller distance starts out
				dist01 = Math.max(dist01, dist11 / 10000); //   way to slow.
				dist11 = Math.max(dist11, dist10 / 10000);
				if (dist00 !== dist10 && dist01 !== dist11) {
					const u0 = (Math.pow(dist10, u) * Math.pow(dist00, 1 - u) - dist00) / (dist10 - dist00);
					const u1 = (Math.pow(dist11, u) * Math.pow(dist01, 1 - u) - dist01) / (dist11 - dist01);
					u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(u0, u1, u);
				}

				// Adjust the lerp value to ease-in-out.
				const sq = u * u;
				u = sq / (2 * (sq - u) + 1);

				// Get the positions relative to the current parent.
				relativeToEntity0.getPositionRelativeToEntity(position0, keyframe0.position, parentEntity);
				relativeToEntity1.getPositionRelativeToEntity(position1, keyframe1.position, parentEntity);

				// Set the position.
				const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				if (relativeToEntity0 === relativeToEntity1) {
					newPosition.slerp(position0, position1, u);
				}
				else {
					newPosition.lerp(position0, position1, u);
				}
				entity.setPosition(newPosition);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position0);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position1);
			}
		}
		// Flag that we're done with position keyframes.
		else if (positionKeyframeIndex === this._positionKeyframes.length) {
			// Get the last keyframe.
			const keyframe = this._positionKeyframes[this._positionKeyframes.length - 1];

			// Get the focus entity.
			const relativeToEntity = keyframe.relativeTo.get();

			// Update the parent entity depending on if we're in the first or second half.
			if (entity.getParent() !== relativeToEntity) {
				entity.setParent(relativeToEntity);
			}

			// Set the position.
			entity.setPosition(keyframe.position);

			// Flag that we're done with position keyframes.
			doneWithPositionKeyframes = true;
		}

		// Set the forward vector by default to the current parent.
		const forward = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		forward.setMagnitude(entity.getPosition(), -1);

		// Set the up vector by default to the current up.
		const up = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		entity.getOrientation().getAxis(up, 2);

		// Apply the focus keyframes. Apply the result to the forward vector if valid.
		let doneWithFocusKeyframes = false;
		const focusKeyframeIndex = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._focusKeyframes, isLessThanTime);
		if (focusKeyframeIndex > 0 && focusKeyframeIndex < this._focusKeyframes.length) {
			// Get the keyframes.
			const keyframe0 = this._focusKeyframes[focusKeyframeIndex - 1];
			const keyframe1 = this._focusKeyframes[focusKeyframeIndex];

			// Get the focus entities for the corresponding names.
			const focusEntity0 = keyframe0.focus.get();
			const focusEntity1 = keyframe1.focus.get();
			const parentEntity = entity.getParent();

			if ((keyframe0.focus.getName() === '' || focusEntity0 !== null)
				&& (keyframe1.focus.getName() === '' || focusEntity1 !== null)
				&& parentEntity !== null) {
				// Get the u lerp value.
				let u = (time - keyframe0.time) / (keyframe1.time - keyframe0.time);

				// Adjust the lerp value to ease-in-out.
				const sq = u * u;
				u = sq / (2 * (sq - u) + 1);

				// Get the two focus directions.
				const direction0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				const direction1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				if (keyframe0.focus.getName() !== '') {
					parentEntity.getPositionRelativeToEntity(direction0, entity.getPosition(), focusEntity0);
					direction0.setMagnitude(direction0, -1);
				}
				else {
					direction0.copy(this._directionOfFirstUpdate);
				}
				if (keyframe1.focus.getName() !== '') {
					parentEntity.getPositionRelativeToEntity(direction1, entity.getPosition(), focusEntity1);
					direction1.setMagnitude(direction1, -1);
				}
				else {
					direction1.copy(this._directionOfFirstUpdate);
				}
				forward.slerp(direction0, direction1, u);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(direction0);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(direction1);
			}
		}
		else if (focusKeyframeIndex === this._focusKeyframes.length) {
			// Get the last keyframe.
			const keyframe = this._focusKeyframes[this._focusKeyframes.length - 1];

			// Get the focus entity.
			const focusEntity = keyframe.focus.get();
			const parentEntity = entity.getParent();

			// Set the forward vector.
			if ((keyframe.focus.getName() === '' || focusEntity !== null) && parentEntity !== null) {
				parentEntity.getPositionRelativeToEntity(forward, entity.getPosition(), focusEntity);
				forward.setMagnitude(forward, -1);
			}

			// Flag that we're done with focus keyframes.
			doneWithFocusKeyframes = true;
		}
		else {
			// Get te first keyframe.
			const keyframe = this._focusKeyframes[0];

			// Get the focus entity.
			const focusEntity = keyframe.focus.get();
			const parentEntity = entity.getParent();

			// Set the forward vector.
			if ((keyframe.focus.getName() === '' || focusEntity !== null) && parentEntity !== null) {
				if (keyframe.focus.getName() !== '') {
					parentEntity.getPositionRelativeToEntity(forward, entity.getPosition(), focusEntity);
					forward.setMagnitude(forward, -1);
				}
				else {
					forward.copy(this._directionOfFirstUpdate);
				}
			}
		}

		// Apply the focus keyframes. Apply the result to the forward vector if valid.
		let doneWithUpKeyframes = false;
		const upKeyframeIndex = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._upKeyframes, isLessThanTime);
		if (upKeyframeIndex > 0 && upKeyframeIndex < this._upKeyframes.length) {
			// Get the keyframes.
			const keyframe0 = this._upKeyframes[upKeyframeIndex - 1];
			const keyframe1 = this._upKeyframes[upKeyframeIndex];

			// Get the u lerp value.
			let u = (time - keyframe0.time) / (keyframe1.time - keyframe0.time);

			// Adjust the lerp value to ease-in-out.
			const sq = u * u;
			u = sq / (2 * (sq - u) + 1);

			// Get the two up directions.
			up.slerp(keyframe0.up, keyframe1.up, u);
		}
		else if (upKeyframeIndex === this._upKeyframes.length) {
			// Get the last keyframe.
			const keyframe = this._upKeyframes[this._upKeyframes.length - 1];

			// Set the up vector.
			up.copy(keyframe.up);

			// Flag that we're done with up keyframes.
			doneWithUpKeyframes = true;
		}

		// Set the orientation from the forward and up vectors.
		const newOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		up.setNormalTo(forward, up);
		newOrientation.setFromAxes(undefined, forward, up);
		entity.setOrientation(newOrientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(forward);

		// If done with all of the keyframes, call the end promise.
		if (doneWithPositionKeyframes && doneWithFocusKeyframes && doneWithUpKeyframes) {
			this._rejectPromise = null;
			this._resolvePromise();
		}
	}
}

class Keyframe {
	constructor() {
		/**
		 * The time for the keyframe.
		 * @type {number}
		 */
		this.time = NaN;
	}
}

/**
 * A position keyframe.
 */
class PositionKeyframe extends Keyframe {
	/** @param {Scene} scene */
	constructor(scene) {
		super();

		/**
		 * The position for the keyframe.
		 * @type {Vector3}
		 */
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * The reference to the relative-to entity.
		 * @type {EntityRef}
		 */
		this.relativeTo = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(scene);
	}
}

/**
 * A focus keyframe.
 */
class FocusKeyframe extends Keyframe {
	/** @param {Scene} scene */
	constructor(scene) {
		super();

		/**
		 * The reference to the focus entity.
		 * @type {EntityRef}
		 */
		this.focus = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(scene);
	}
}

/**
 * An up keyframe.
 */
class UpKeyframe extends Keyframe {
	constructor() {
		super();

		/**
		 * The up for the keyframe.
		 * @type {Vector3}
		 */
		this.up = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
	}
}

/**
 * A helper function for the keyframe sorting.
 * @param {Keyframe} a
 * @param {Keyframe} b
 */
function isLess(a, b) {
	return a.time < b.time;
}

/**
 * A helper function for the keyframe sorting.
 * @param {Keyframe} a
 * @param {number} time
 */
function isLessThanTime(a, time) {
	return a.time < time;
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/orbital_elements_controller.js":
/*!******************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/orbital_elements_controller.js ***!
  \******************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitalElementsController": function() { return /* binding */ OrbitalElementsController; },
/* harmony export */   "OrbitalElementsKeyFrame": function() { return /* binding */ OrbitalElementsKeyFrame; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller animates the position and orientation of an entity via orbital elements.
 */
class OrbitalElementsController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The position keyframes.
		 * @type {OrbitalElementsKeyFrame[]}
		 * @private
		 */
		this._orbitalElementsKeyFrames = [];

		// Set the coverage to nothing, since there are no orbital elements.
		this.setCoverage(new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY));

		// Modifies the position.
		this.addModifiedState('position');
		this.addModifiedState('velocity');
	}

	/**
	 * Gets the number of orbital elements.
	 * @returns {number}
	 */
	getNumOrbitalElements() {
		return this._orbitalElementsKeyFrames.length;
	}

	/**
	 * Gets an orbital element at the index.
	 * @param {number} index
	 * @returns {OrbitalElementsKeyFrame}
	 */
	getOrbitalElements(index) {
		return this._orbitalElementsKeyFrames[index];
	}

	/**
	 * Adds an orbital element.
	 * @param {number} time
	 * @param {OrbitalElements} orbitalElements
	 */
	addOrbitalElements(time, orbitalElements) {
		_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add({ time: time, oe: orbitalElements }, this._orbitalElementsKeyFrames, isLessAdd, isEqualAdd);
		this._updateCoverage();
	}

	/**
	 * Removes an orbital element at the index.
	 * @param {number} index
	 */
	removeOrbitalElements(index) {
		if (index < 0 || this._orbitalElementsKeyFrames.length <= index) {
			throw new Error(`Invalid index for ${this}.removeOrbitalElements`);
		}
		this._orbitalElementsKeyFrames.splice(index, 1);
		this._updateCoverage();
	}

	/**
	 * Sets the position to the keyframed position at the given time.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		this._getPositionAtTime(position, time);
	}

	/**
	 * Sets the velocity to the keyframed velocity at the given time.
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, time) {
		this._getVelocityAtTime(velocity, time);
	}

	/**
	 * Updates the position and orientation from the keyframes.
	 * @override
	 * @internal
	 */
	__update() {
		const engine = this.getEntity().getScene().getEngine();
		const time = engine.getTime();
		if (this._getPositionAtTime(_tempPosition, time)) {
			this.getEntity().setPosition(_tempPosition);
		}
		if (this._getVelocityAtTime(_tempVelocity, time)) {
			this.getEntity().setVelocity(_tempVelocity);
		}
	}

	/**
	 * Sets outPosition to the position at the given time. Returns true if they were set.
	 * @param {Vector3} outPosition
	 * @param {number} time
	 * @returns {boolean}
	 * @private
	 */
	_getPositionAtTime(outPosition, time) {
		const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._orbitalElementsKeyFrames, isLess);
		const keyFrame0 = this._orbitalElementsKeyFrames[Math.max(index - 1, 0)];
		const keyFrame1 = this._orbitalElementsKeyFrames[Math.min(index, this._orbitalElementsKeyFrames.length - 1)];
		const position0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const position1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		keyFrame0.oe.project(position0, _tempVelocity, time);
		keyFrame1.oe.project(position1, _tempVelocity, time);
		const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(keyFrame1.time !== keyFrame0.time ? ((time - keyFrame0.time) / (keyFrame1.time - keyFrame0.time)) : 0);
		outPosition.slerp(position0, position1, u);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position1);
		return true;
	}

	/**
	 * Sets outVelocity to the velocity at the given time. Returns true if they were set.
	 * @param {Vector3} outVelocity
	 * @param {number} time
	 * @returns {boolean}
	 * @private
	 */
	_getVelocityAtTime(outVelocity, time) {
		const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._orbitalElementsKeyFrames, isLess);
		const keyFrame0 = this._orbitalElementsKeyFrames[Math.max(index - 1, 0)];
		const keyFrame1 = this._orbitalElementsKeyFrames[Math.min(index, this._orbitalElementsKeyFrames.length - 1)];
		const velocity0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const velocity1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		keyFrame0.oe.project(_tempPosition, velocity0, time);
		keyFrame1.oe.project(_tempPosition, velocity1, time);
		const u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(keyFrame1.time !== keyFrame0.time ? ((time - keyFrame0.time) / (keyFrame1.time - keyFrame0.time)) : 0);
		outVelocity.slerp(velocity0, velocity1, u);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(velocity0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(velocity1);
		return true;
	}

	/**
	 * Updates the coverage.
	 * @private
	 */
	_updateCoverage() {
		const coverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
		if (this._orbitalElementsKeyFrames.length > 1) {
			coverage.min = Math.min(coverage.min, this._orbitalElementsKeyFrames[0].time);
			coverage.max = Math.max(coverage.max, this._orbitalElementsKeyFrames[this._orbitalElementsKeyFrames.length - 1].time);
		}
		this.setCoverage(coverage);
	}
}

/**
 * Orbital elements key frame as a time-orbital elements pair.
 */
class OrbitalElementsKeyFrame {
	constructor() {
		/**
		 * The time for the key frame.
		 * @type {number}
		 */
		this.time = 0;

		/**
		 * The orbital elements.
		 * @type {OrbitalElements}
		 */
		this.oe = new _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements();
	}
};

/**
 * @callback CompareAdd
 * @param {OrbitalElementsKeyFrame} a
 * @param {OrbitalElementsKeyFrame} b
 * @returns {boolean}
 */

/**
 * @callback Compare
 * @param {OrbitalElementsKeyFrame} a
 * @param {number} b
 * @returns {boolean}
 */

/**
 * A helper function for sorting.
 * @type {CompareAdd}
 */
const isLessAdd = (a, b) => (a.time < b.time);

/**
 * A helper function for sorting.
 * @type {Compare}
 */
const isLess = (a, time) => (a.time < time);

/**
 * A helper function for sorting.
 * @type {CompareAdd}
 */
const isEqualAdd = (a, b) => (a.time === b.time);

/**
 * Helper vector for calculations.
 * @type {Vector3}
 */
const _tempPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

/**
 * Helper vector for calculations.
 * @type {Vector3}
 */
const _tempVelocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/pick_controller.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/pick_controller.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PickController": function() { return /* binding */ PickController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A pick controller. It lets the user pick a location on a given entity.
 */
class PickController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The entity to be picked.
		 * @type {Entity}
		 * @private
		 */
		this._pickedEntity = null;

		/**
		 * The callback to be called when the user picks a location on the entity.
		 * @type {(position: Vector3) => void}
		 * @private
		 */
		this._callback = null;

		/**
		 * @type {boolean}
		 * @private
		 */
		this._triggerOnHover = false;

		/**
		 * @type {Vector3}
		 * @private
		 */
		this._pickedPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._pickedPosition.freeze();
	}

	/**
	 * Gets the entity to be picked.
	 * @returns {Entity}
	 */
	getPickedEntity() {
		return this._pickedEntity;
	}

	/**
	 * Sets the entity to be picked.
	 * @param {Entity} entity
	 */
	setPickedEntity(entity) {
		this._pickedEntity = entity;
	}

	/**
	 * Returns the callback to be called when the user picks a position on the entity. The position is in the entity-frame of the picked entity.
	 * @returns {(position: Vector3) => void}
	 */
	getCallback() {
		return this._callback;
	}

	/**
	 * Sets the callback to be called when the user picks a position on the entity. The position is in the entity-frame of the picked entity.
	 * @param {(position: Vector3) => void} callback
	 */
	setCallback(callback) {
		this._callback = callback;
	}

	/**
	 * Gets whether the callback is triggered when hovering or just selecting.
	 * @returns {boolean}
	 */
	getTriggerOnHover() {
		return this._triggerOnHover;
	}

	/**
	 * Sets whether the callback is triggered when hovering or just selecting.
	 * @param {boolean} triggerOnHover
	 */
	setTriggerOnHover(triggerOnHover) {
		this._triggerOnHover = triggerOnHover;
	}

	/**
	 * Gets the last picked position. The position is in the entity-frame of the picked entity.
	 * @returns {Vector3}
	 */
	getPickedPosition() {
		return this._pickedPosition;
	}

	/**
	 * Takes input and calls the callback if there is any selection.
	 * @override
	 * @internal
	 */
	__update() {
		const input = this.getEntity().getScene().getEngine().getInput();

		if ((input.isSelected() || this._triggerOnHover) && this._callback !== null && this._pickedEntity !== null) {
			const viewport = input.getActiveViewport();
			if (viewport !== null) {
				const camera = viewport.getCamera();
				if (camera !== null && camera.getEntity() === this.getEntity()) {
					const pickedPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
					// Get the picked position in normal space.
					viewport.getNormalSpacePositionFromPixelSpacePosition(pickedPosition, input.getCursorPosition());

					// Get the picked position in camera space.
					camera.getCameraSpacePositionFromNormalSpacePosition(pickedPosition, pickedPosition);

					// Turn it into a ray of length 1, going from the camera.
					pickedPosition.normalize(pickedPosition);

					// If there is a spheroid, we want to intersect with that. If not, we'll just use a sphere.
					const interval = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
					const spheroid = /** @type {SpheroidComponent} */(this.getEntity().getParent().getComponentByType('spheroid'));
					if (spheroid !== null) {
						// We scale up the ray and entity position and rotate them into the picked entity's orientation frame.
						const ratio = spheroid.getEquatorialRadius() / spheroid.getPolarRadius();
						pickedPosition.rotateInverse(this._pickedEntity.getOrientation(), pickedPosition);
						pickedPosition.z *= ratio;
						const entityPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						entityPosition.copy(this._pickedEntity.getCameraSpacePosition(camera));
						entityPosition.rotateInverse(this._pickedEntity.getOrientation(), entityPosition);
						entityPosition.z *= ratio;
						_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(interval, pickedPosition, entityPosition, spheroid.getEquatorialRadius());
						pickedPosition.z /= ratio;
						pickedPosition.rotate(this._pickedEntity.getOrientation(), pickedPosition);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(entityPosition);
					}
					else {
						const entityPosition = this._pickedEntity.getCameraSpacePosition(camera);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(interval, pickedPosition, entityPosition, this._pickedEntity.getOcclusionRadius());
					}
					if (!Number.isNaN(interval.min)) {
						// Convert the picked position from camera space to entity space.
						this._pickedPosition.thaw();
						this._pickedPosition.mult(pickedPosition, interval.min);
						camera.getEntity().getPositionRelativeToEntity(this._pickedPosition, this._pickedPosition, this._pickedEntity);
						this._pickedPosition.freeze();

						// Call the callback.
						this.getEntity().getScene().getEngine().addCallback(this._callback.bind(undefined, this._pickedPosition), false);
					}
					_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(interval);
					_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(pickedPosition);
				}
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/roll_controller.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/roll_controller.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RollController": function() { return /* binding */ RollController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A roll camera controller.
 */
class RollController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The sensitivity for rolling.
		 * @type {number}
		 * @private
		 */
		this._rollSensitivity = 0.1;

		/**
		 * The smoothness of the rolling. Zero means no smoothness.
		 * @type {number}
		 * @private
		 */
		this._rollSmoothness = 0.8;

		/**
		 * The current value applied every frame to the roll axis rotation.
		 * @type {number}
		 * @private
		 */
		this._rollAngleSmoothedValue = 0.0;

		// Let the base controller know that this changes the orientation.
		this.addModifiedState('orientation');
	}

	/**
	 * Gets the roll sensitivity. Defaults to 0.01.
	 * @returns {number}
	 */
	getRollSensitivity() {
		return this._rollSensitivity;
	}

	/**
	 * Sets the roll sensitivity.
	 * @param {number} rollSensitivity
	 */
	setRollSensitivity(rollSensitivity) {
		this._rollSensitivity = rollSensitivity;
	}

	/**
	 * Gets the roll smoothness. Defaults to 0.8.
	 * @returns {number}
	 */
	getRollSmoothness() {
		return this._rollSmoothness;
	}

	/**
	 * Sets the roll smoothness, between 0 and 1.
	 * @param {number} rollSmoothness
	 */
	setRollSmoothness(rollSmoothness) {
		this._rollSmoothness = rollSmoothness;
	}

	/**
	 * Updates the entity's position and orientation.
	 * @override
	 * @internal
	 */
	__update() {
		// Set the position and orientation if they have never been set before.
		if (this.getEntity().getOrientation().isNaN()) {
			this.getEntity().setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}

		// Get the azimuth, elevation, and roll from input.
		let rollAngle = 0;
		const input = this.getEntity().getScene().getEngine().getInput();
		const viewport = input.getActiveViewport();
		if (viewport !== null) {
			const camera = viewport.getCamera();
			if (camera !== null && camera.getEntity() === this.getEntity()) {
				let rollMultiplier = 1;
				if (input.isKeyPressed('x')) {
					rollMultiplier = 0.05;
				}
				if (input.isShiftPressed()) {
					rollMultiplier = 5;
				}

				// Do touch rotate movement.
				const rotatedOffset = input.getRotatedOffset();
				if (rotatedOffset !== 0) {
					rollAngle += _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(rotatedOffset * this._rollSensitivity * rollMultiplier, -0.1, +0.1);
				}

				// Add key movement.
				if (input.isKeyPressed('c')) {
					rollAngle += this._rollSensitivity * rollMultiplier;
				}
				if (input.isKeyPressed('z')) {
					rollAngle -= this._rollSensitivity * rollMultiplier;
				}
				rollAngle += rollAngle + this._rollSensitivity * rollMultiplier * cameraOrbitParameters.roll;
			}
		}

		// Apply smoothing.
		this._rollAngleSmoothedValue = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(rollAngle, this._rollAngleSmoothedValue, this._rollSmoothness);
		if (Math.abs(this._rollAngleSmoothedValue) < 0.0001) {
			this._rollAngleSmoothedValue = 0;
		}

		// Apply the roll.
		if (this._rollAngleSmoothedValue !== 0) {
			// Rotate the orientation by the forward (y) axis.
			const newOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			rotation.setFromAxisAngle(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, this._rollAngleSmoothedValue);
			newOrientation.mult(this.getEntity().getOrientation(), rotation);
			this.getEntity().setOrientation(newOrientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/rotate_by_entity_orientation_controller.js":
/*!******************************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/rotate_by_entity_orientation_controller.js ***!
  \******************************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RotateByEntityOrientationController": function() { return /* binding */ RotateByEntityOrientationController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A controller that rotates the position and orientation by the parent's orientation.
 *  Great for objects that are connected to their parents or landers.
 *  It needs to added as the last controller to work. */
class RotateByEntityOrientationController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The entity whose orientation will be used.
		 * @type {EntityRef}
		 * @private
		 */
		this._entityRef = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * A flag that determines whether the controller is rotating the position of the entity.
		 * @type {boolean}
		 * @private
		 */
		this._rotatingPosition = true;

		/**
		 * A flag that determines whether the controller is rotating the orientation of the entity.
		 * @type {boolean}
		 * @private
		 */
		this._rotatingOrientation = true;

		// Let the base controller know that this changes the position and orientation.
		this.addModifiedState('position');
		this.addModifiedState('orientation');
	}

	/**
	 * Sets the entity whose orientation will be used. If the name is '', the current parent will be used.
	 * @param {string} name
	 */
	setEntityForOrientation(name) {
		// Remove the dependency on the previous entity's orientation.
		if (this._entityRef.getName() !== '') {
			this.addDependentState(this._entityRef.getName(), 'orientation');
		}

		// Set the entity reference.
		this._entityRef.setName(name);

		// Add the dependency on the new entity's orientation.
		this.addDependentState(name, 'orientation');
	}

	/**
	 * Returns whether the controller is rotating the position of the entity. Defaults to true.
	 * @returns {boolean}
	 */
	isRotatingPosition() {
		return this._rotatingPosition;
	}

	/**
	 * Sets whether the controller is rotating the position of the entity.
	 * @param {boolean} rotatingPosition
	 */
	setRotatingPosition(rotatingPosition) {
		this._rotatingPosition = rotatingPosition;
		if (rotatingPosition) {
			this.addModifiedState('position');
		}
		else {
			this.removeModifiedState('position');
		}
	}

	/**
	 * Returns true if the controller is rotating the orientation of the entity. Defaults to true.
	 * @returns {boolean}
	 */
	isRotatingOrientation() {
		return this._rotatingOrientation;
	}

	/**
	 * Sets whether the controller is rotating the orientation of the entity.
	 * @param {boolean} rotatingOrientation
	 */
	setRotatingOrientation(rotatingOrientation) {
		this._rotatingOrientation = rotatingOrientation;
		if (rotatingOrientation) {
			this.addModifiedState('orientation');
		}
		else {
			this.removeModifiedState('orientation');
		}
	}

	/**
	 * Updates the position to be rotated by the parent orientation.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		if (this._rotatingPosition) {
			const entity = this._entityRef.getName() !== '' ? this._entityRef.get() : this.getEntity().getScene().getEntity(this.getEntity().getParentAtTime(time));
			if (entity !== null) {
				const entityOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				entity.getOrientationAtTime(entityOrientation, time);
				position.rotate(entityOrientation, position);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(entityOrientation);
			}
		}
	}

	/**
	 * Updates the velocity to be rotated by the parent orientation.
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, time) {
		if (this._rotatingPosition) {
			const entity = this._entityRef.getName() !== '' ? this._entityRef.get() : this.getEntity().getScene().getEntity(this.getEntity().getParentAtTime(time));
			if (entity !== null) {
				const entityOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				entity.getOrientationAtTime(entityOrientation, time);
				velocity.rotate(entityOrientation, velocity);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(entityOrientation);
			}
		}
	}

	/**
	 * If the orientation is fixed, updates the orientation to the fixed orientation.
	 * @param {Quaternion} orientation
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, time) {
		if (this._rotatingOrientation) {
			const entity = this._entityRef.getName() !== '' ? this._entityRef.get() : this.getEntity().getScene().getEntity(this.getEntity().getParentAtTime(time));
			if (entity !== null) {
				const entityOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				entity.getOrientationAtTime(entityOrientation, time);
				orientation.mult(entityOrientation, orientation);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(entityOrientation);
			}
		}
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		const entity = this._entityRef.getName() !== '' ? this._entityRef.get() : this.getEntity().getParent();
		if (entity !== null) {
			if (this._rotatingPosition) {
				const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				position.rotate(entity.getOrientation(), this.getEntity().getPosition());
				this.getEntity().setPosition(position);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
			}
			if (this._rotatingOrientation) {
				const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				orientation.mult(entity.getOrientation(), this.getEntity().getOrientation());
				this.getEntity().setOrientation(orientation);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/rotate_controller.js":
/*!********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/rotate_controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RotateController": function() { return /* binding */ RotateController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that rotates an entity's position and/or orientation by a rotation quaternion.
 */
class RotateController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The rotation.
		 * @type {Quaternion}
		 * @private
		 */
		this._rotation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this._rotation.freeze();

		/**
		 * A flag that determines whether the controller is rotating the position of the entity.
		 * @type {boolean}
		 * @private
		 */
		this._rotatingPosition = true;

		/**
		 * A flag that determines whether the controller is rotating the orientation of the entity.
		 * @type {boolean}
		 * @private
		 */
		this._rotatingOrientation = true;

		// Let the base controller know that this changes the position and orientation.
		this.addModifiedState('position');
		this.addModifiedState('orientation');
	}

	/**
	 * Gets the rotation. Defaults to Quaterion(1, 0, 0, 0).
	 * @returns {Quaternion}
	 */
	getRotation() {
		return this._rotation;
	}

	/**
	 * Sets the rotation.
	 * @param {Quaternion} rotation
	 */
	setRotation(rotation) {
		this._rotation.thaw();
		this._rotation.copy(rotation);
		this._rotation.freeze();
	}

	/**
	 * Returns whether the controller is rotating the position of the entity. Defaults to true.
	 * @returns {boolean}
	 */
	isRotatingPosition() {
		return this._rotatingPosition;
	}

	/**
	 * Sets whether the controller is rotating the position of the entity.
	 * @param {boolean} rotatingPosition
	 */
	setRotatingPosition(rotatingPosition) {
		this._rotatingPosition = rotatingPosition;
		if (rotatingPosition) {
			this.addModifiedState('position');
		}
		else {
			this.removeModifiedState('position');
		}
	}

	/**
	 * Returns true if the controller is rotating the orientation of the entity. Defaults to true.
	 * @returns {boolean}
	 */
	isRotatingOrientation() {
		return this._rotatingOrientation;
	}

	/**
	 * Sets whether the controller is rotating the orientation of the entity.
	 * @param {boolean} rotatingOrientation
	 */
	setRotatingOrientation(rotatingOrientation) {
		this._rotatingOrientation = rotatingOrientation;
		if (rotatingOrientation) {
			this.addModifiedState('orientation');
		}
		else {
			this.removeModifiedState('orientation');
		}
	}

	/**
	 * Updates a position for the given time.
	 * @param {Vector3} position
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, _time) {
		if (this._rotatingPosition) {
			position.rotate(this._rotation, position);
		}
	}

	/**
	 * Updates a velocity for the given time.
	 * @param {Vector3} velocity
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, _time) {
		if (this._rotatingPosition) {
			velocity.rotate(this._rotation, velocity);
		}
	}

	/**
	 * Updates given orientation for the given time.
	 * @param {Quaternion} orientation - The orientation to update.
	 * @param {number} _time - The time to check.
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, _time) {
		if (this._rotatingOrientation) {
			orientation.mult(this._rotation, orientation);
		}
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		if (this._rotatingPosition) {
			const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			newPosition.rotate(this._rotation, this.getEntity().getPosition());
			this.getEntity().setPosition(newPosition);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
		}
		if (this._rotatingOrientation) {
			const newOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			newOrientation.mult(this._rotation, this.getEntity().getOrientation());
			this.getEntity().setOrientation(newOrientation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/scale_controller.js":
/*!*******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/scale_controller.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ScaleController": function() { return /* binding */ ScaleController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that scales the position of the entity.
 */
class ScaleController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		// The amount to scale the position.
		this._scale = 1.0;

		// Let the base controller know that this changes the position.
		this.addModifiedState('position');
	}

	/**
	 * Gets the scale factor. Defaults to 1.
	 * @return {number}
	 */
	getScale() {
		return this._scale;
	}

	/**
	 * Sets the scale factor.
	 * @param {number} scale
	 */
	setScale(scale) {
		this._scale = scale;
	}

	/**
	 * Updates the position based on time.
	 * @param {Vector3} position
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, _time) {
		position.mult(position, this._scale);
	}

	/**
	 * Updates the velocity based on time.
	 * @param {Vector3} velocity
	 * @param {number} _time
	 * @override
	 * @internal
	 */
	__updateVelocityAtTime(velocity, _time) {
		velocity.mult(velocity, this._scale);
	}

	/**
	 * Takes input and updates the target distance. Then updates the entity's position.
	 * @override
	 * @internal
	 */
	__update() {
		const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		newPosition.mult(this.getEntity().getPosition(), this._scale);
		this.getEntity().setPosition(newPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/select_controller.js":
/*!********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/select_controller.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SelectController": function() { return /* binding */ SelectController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A selection controller. */
class SelectController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * @type {(entity: Entity) => any}
		 * @private
		 */
		this._callback = null;
	}

	/**
	 * Returns the callback to be called when the user selects an entity.
	 * @returns {(entity: Entity) => any}
	 */
	getCallback() {
		return this._callback;
	}

	/**
	 * Sets the callback to be called when the user selects an entity. If the user selects but does not select an entity, the param passed is null.
	 * @param {(entity: Entity) => any} callback
	 */
	setCallback(callback) {
		this._callback = callback;
	}

	/**
	 * Takes input and calls the callback if there is any selection.
	 * @override
	 * @internal
	 */
	__update() {
		const input = this.getEntity().getScene().getEngine().getInput();

		if (input.isSelected() && this._callback !== null) {
			const viewport = input.getActiveViewport();
			if (viewport !== null) {
				const camera = viewport.getCamera();
				if (camera !== null && camera.getEntity() === this.getEntity()) {
					// Get the selected position in normal space.
					const entityPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
					viewport.getNormalSpacePositionFromPixelSpacePosition(entityPosition, input.getSelectedPosition());

					// Search every entity for label that contains the normal-space position. Choose the nearest one.
					let intersectedEntity = null;
					let intersectedEntityDistance = 0;
					const entityPosition2D = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
					entityPosition2D.set(entityPosition.x, entityPosition.y);
					const numEntities = this.getEntity().getScene().getNumEntities();
					for (let entityI = 0; entityI < numEntities; entityI++) {
						const entity = this.getEntity().getScene().getEntity(entityI);
						if (entity.isEnabled()) {
							const label = /** @type {LabelComponent} */(entity.getComponentByType('label'));
							if (label !== null && label.getLoadState() === 'loaded') {
								const labelBounds = label.getNormalSpaceBounds(camera);
								if (labelBounds !== undefined && labelBounds.contains(entityPosition2D)) {
									const entityDistance = entity.getCameraSpacePosition(camera).magnitude();
									if (intersectedEntity === null || intersectedEntityDistance > entityDistance) {
										intersectedEntity = entity;
										intersectedEntityDistance = entityDistance;
									}
								}
							}
						}
					}
					_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(entityPosition2D);

					// If it didn't find a label selection, check the entities themselves.
					if (intersectedEntity === null) {
						camera.getCameraSpacePositionFromNormalSpacePosition(entityPosition, entityPosition);
						entityPosition.mult(entityPosition, 1 / entityPosition.magnitude());

						// Get a ray in camera coordinates to search for intersecting entities.
						intersectedEntity = camera.getNearestIntersectingEntity(entityPosition);
					}
					_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(entityPosition);

					// Call the callback whether something was selected or not.
					this.getEntity().getScene().getEngine().addCallback(this._callback.bind(null, intersectedEntity), false);
				}
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/set_parent_controller.js":
/*!************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/set_parent_controller.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SetParentController": function() { return /* binding */ SetParentController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that sets the parent every frame. Not normally needed except when another controller sets the parent,
 * such as the transition controller.
 */
class SetParentController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The parent to transition to.
		 * @type {EntityRef}
		 * @private
		 */
		this._parent = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());
	}

	/**
	 * Gets the parent to set.
	 * @returns {string}
	 */
	getParent() {
		return this._parent.getName();
	}

	/**
	 * Sets the parent to set.
	 * @param {string} parent
	 */
	setParent(parent) {
		if (this._parent.getName() !== '') {
			this.removeDependentState(this._parent.getName(), 'position');
		}
		this._parent.setName(parent);
		if (this._parent.getName() !== '') {
			this.addDependentState(this._parent.getName(), 'position');
		}
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		const parent = this._parent.get();
		this.getEntity().setParent(parent);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/spin_controller.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/spin_controller.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpinController": function() { return /* binding */ SpinController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that rotates an entity by an axis at a certain rate.
 */
class SpinController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The axis around which to rotate the entity.
		 * @type {Vector3}
		 * @private
		 */
		this._axis = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);
		this._axis.freeze();

		/**
		 * The flag that determines whether the axis is relative to the entity's orientation.
		 * @type {boolean}
		 * @private
		 */
		this._axisRelativeToEntity = true;

		/**
		 * The rate in radians per second to rotate the entity.
		 * @type {number}
		 * @private
		 */
		this._rate = 0;

		/**
		 * The reference angle in radians, the phase, of the entity at the reference time.
		 * @type {number}
		 * @private
		 */
		this._referenceAngle = 0;

		/**
		 * The reference time when the entity is at the reference phase angle.
		 * @type {number}
		 * @private
		 */
		this._referenceTime = undefined;

		/**
		 * A flag that determines whether to clamp the rate at the real-time rate.
		 * @type {boolean}
		 * @private
		 */
		this._clampedToRealTime = false;

		/**
		 * A flag that says whether real-time or Pioneer time is used.
		 * @type {boolean}
		 * @private
		 */
		this._usingRealTime = false;

		/**
		 * A flag that says whether the position is also rotating.
		 * @type {boolean}
		 * @private
		 */
		this._rotatingPosition = false;

		/**
		 * The joint for the model to spin. If empty, the entity itself is used.
		 * @type {string}
		 * @private
		 */
		this._joint = '';

		/**
		 * The joint's ThreeJs object.
		 * @type {THREE.Object3D}
		 * @private
		 */
		this._jointObject = null;

		/**
		 * The model for the joint.
		 * @type {ModelComponent}
		 * @private
		 */
		this._model = null;

		/**
		 * A recording of the last time of Pioneer.
		 * @type {number}
		 * @private
		 */
		this._lastTime = entity.getScene().getEngine().getTime();

		// Let the base controller know that this changes the orientation.
		this.addModifiedState('orientation');
	}

	/**
	 * Gets the axis around which to rotate the entity. It defaults to the z-axis.
	 * @returns {Vector3}
	 */
	getAxis() {
		return this._axis;
	}

	/**
	 * Gets the flag that determines whether the axis is relative to the entity's orientation. Defaults to true.
	 * @returns {boolean}
	 */
	isAxisRelativeToEntity() {
		return this._axisRelativeToEntity;
	}

	/**
	 * Sets the axis around which to rotate the entity.
	 * @param {Vector3} axis - The axis.
	 * @param {boolean} relativeToEntity - If true, the axis is relative to the entity's orientation.
	 */
	setAxis(axis, relativeToEntity) {
		this._axis.thaw();
		this._axis.copy(axis);
		this._axis.freeze();
		this._axisRelativeToEntity = relativeToEntity;
	}

	/**
	 * Gets the rate in radians per second to rotate the entity. Defaults to 0.
	 * @returns {number}
	 */
	getRate() {
		return this._rate;
	}

	/**
	 * Sets the rate in radians per second to rotate the entity.
	 * @param {number} rate
	 */
	setRate(rate) {
		this._rate = rate;
	}

	/**
	 * Gets the reference angle in radians, the phase, of the entity at the reference time. Defaults to 0.
	 * @returns {number}
	 */
	getReferenceAngle() {
		return this._referenceAngle;
	}

	/**
	 * Sets the reference angle in radians, the phase, of the entity at the reference time.
	 * @param {number} referenceAngle
	 */
	setReferenceAngle(referenceAngle) {
		this._referenceAngle = referenceAngle;
	}

	/**
	 * Gets the reference time when the entity is at the reference phase angle. If this is undefined, the previous frame's time is used. Defaults to undefined.
	 * @returns {number}
	 */
	getReferenceTime() {
		return this._referenceTime;
	}

	/**
	 * Sets the reference time when the entity is at the reference phase angle.
	 * @param {number} referenceTime
	 */
	setReferenceTime(referenceTime) {
		this._referenceTime = referenceTime;
	}

	/**
	 * Gets whether to clamp the rate at the real-time rate. Defaults to false. Ignored when there is a reference time.
	 * @returns {boolean}
	 */
	isClampedToRealTime() {
		return this._clampedToRealTime;
	}

	/**
	 * Sets whether to clamp the rate at the real-time rate.
	 * @param {boolean} clampedToRealTime
	*/
	setClampedToRealTime(clampedToRealTime) {
		this._clampedToRealTime = clampedToRealTime;
	}

	/**
	 * Gets the flag that says whether real-time or Pioneer time is used.
	 * @returns {boolean}
	 */
	isUsingRealTime() {
		return this._usingRealTime;
	}

	/**
	 * Sets the flag that says whether real-time or Pioneer time is used.
	 * @param {boolean} usingRealTime
	*/
	setUsingRealTime(usingRealTime) {
		this._usingRealTime = usingRealTime;
	}

	/**
	 * Gets the flag that says whether the position is also rotating.
	 * @returns {boolean}
	 */
	isRotatingPosition() {
		return this._rotatingPosition;
	}

	/**
	 * Sets the flag that says whether the position is also rotating.
	 * @param {boolean} rotatingPosition
	*/
	setRotatingPosition(rotatingPosition) {
		this._rotatingPosition = rotatingPosition;
		if (rotatingPosition) {
			this.addModifiedState('position');
		}
		else {
			this.removeModifiedState('position');
		}
	}

	/**
	 * Sets the spin to be at the joint on the specified model. If no model is given, the first model in the entity is used.
	 * @param {string} joint
	 * @param {ModelComponent} [model]
	 */
	setJoint(joint, model) {
		this._joint = joint;
		if (!model) {
			const modelFromEntity = /** @type {ModelComponent} */(this.getEntity().get('model'));
			if (modelFromEntity !== null) {
				this._model = modelFromEntity;
			}
		}
		else {
			this._model = model;
		}
		if (this._joint !== '') {
			this.removeModifiedState('orientation');
		}
		else {
			this.addModifiedState('orientation');
		}
	}

	/**
	 * If the position is fixed, updates the position to the fixed position.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		if (this._rotatingPosition) {
			// Get the deltaTime, the time since the last update, possibly clamped.
			let deltaTime = 0;
			if (!this._usingRealTime) { // Using real time.
				if (this._referenceTime !== undefined) {
					deltaTime = time - this._referenceTime;
					deltaTime -= this._referenceAngle / this._rate;
				}
			}

			// Calculate the rotation quaternion from the deltaTime.
			const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			rotation.setFromAxisAngle(this._axis, this._rate * deltaTime);

			// If the joint object is valid,
			if (this._jointObject === null) {
				// Apply the rotation to the new orientation.
				if (this._axisRelativeToEntity) {
					const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
					this.getEntity().getOrientationAtTime(orientation, time);
					rotation.mult(orientation, rotation);
					rotation.multInverseR(rotation, orientation);
					_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
				}

				// Set the position if flagged.
				position.rotate(rotation, position);
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
		}
	}

	/**
	 * If the orientation is fixed, updates the orientation to the fixed orientation.
	 * @param {Quaternion} orientation
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updateOrientationAtTime(orientation, time) {
		// Make sure there is a valid orientation to start.
		if (orientation.isNaN()) {
			orientation.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}

		// Get the deltaTime, the time since the last update, possibly clamped.
		let deltaTime = 0;
		if (!this._usingRealTime) { // Using real time.
			if (this._referenceTime !== undefined) {
				deltaTime = time - this._referenceTime;
				deltaTime -= this._referenceAngle / this._rate;
			}
		}

		// Calculate the rotation quaternion from the deltaTime.
		const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		rotation.setFromAxisAngle(this._axis, this._rate * deltaTime);

		// If the joint object is valid,
		if (this._jointObject === null) {
			// Apply the rotation to the new orientation.
			if (this._axisRelativeToEntity) {
				rotation.mult(orientation, rotation);
				rotation.multInverseR(rotation, orientation);
			}
			orientation.mult(rotation, orientation);
			orientation.normalize(orientation);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		// Make sure there is a valid orientation to start.
		if (this.getEntity().getOrientation().isNaN()) {
			this.getEntity().setOrientation(_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}

		// Get the deltaTime, the time since the last update, possibly clamped.
		const engine = this.getEntity().getScene().getEngine();
		let deltaTime = 0;
		if (this._usingRealTime) { // Using real time.
			deltaTime = engine.getDeltaTime();
		}
		else { // Using Pioneer time.
			if (this._referenceTime !== undefined) {
				deltaTime = engine.getTime() - this._referenceTime;
				deltaTime -= this._referenceAngle / this._rate;
			}
			else {
				deltaTime = engine.getTime() - this._lastTime;
				if (this._clampedToRealTime) {
					const deltaRealTime = engine.getDeltaTime();
					deltaTime = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(deltaTime, -deltaRealTime, deltaRealTime);
				}
			}
		}

		// Calculate the rotation quaternion from the deltaTime.
		const rotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		rotation.setFromAxisAngle(this._axis, this._rate * deltaTime);

		// If a joint is specified, setup the joint's ThreeJs object.
		if (this._jointObject !== null && this._model.getThreeJsObjects()[0] !== null) {
			this._jointObject = null;
		}
		if (this._joint !== '' && (this._jointObject === null || this._jointObject.name !== this._joint) && this._model !== null) {
			const subObject = this._model.getThreeJsObjectByName(this._joint);
			if (subObject !== null) {
				this._jointObject = subObject;
			}
		}
		// If the joint object is valid,
		const entityOrientation = this.getEntity().getOrientation();
		if (this._jointObject !== null) {
			if (!this._axisRelativeToEntity) {
				rotation.multInverseL(entityOrientation, rotation);
				rotation.mult(rotation, entityOrientation);
			}
			_tempThreeJsQuaternion.set(rotation.x, rotation.y, rotation.z, rotation.w);
			this._jointObject.quaternion.multiplyQuaternions(_tempThreeJsQuaternion, this._jointObject.quaternion);
			if (this._rotatingPosition) {
				this._jointObject.position.applyQuaternion(_tempThreeJsQuaternion);
			}
		}
		else {
			// Apply the rotation to the new orientation.
			const newOrientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			if (this._axisRelativeToEntity) {
				rotation.mult(entityOrientation, rotation);
				rotation.multInverseR(rotation, entityOrientation);
			}
			newOrientation.mult(rotation, entityOrientation);
			newOrientation.normalize(newOrientation);

			// Set the orientation and angular velocity.
			const newAngularVelocity = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			newAngularVelocity.mult(this._axis, this._rate);
			if (this._axisRelativeToEntity) {
				newAngularVelocity.rotate(newOrientation, newAngularVelocity);
			}
			this.getEntity().setOrientation(newOrientation);
			this.getEntity().setAngularVelocity(newAngularVelocity);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newAngularVelocity);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);

			// Set the position if flagged.
			if (this._rotatingPosition) {
				const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				newPosition.rotate(rotation, this.getEntity().getPosition());
				this.getEntity().setPosition(newPosition);
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);

		this._lastTime = engine.getTime();
	}
}

/**
 * A temporary ThreeJs Quaternion.
 * @type {THREE.Quaternion}
 */
const _tempThreeJsQuaternion = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Quaternion();


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/tap_controller.js":
/*!*****************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/tap_controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TapController": function() { return /* binding */ TapController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * An tap controller calls a callback when the user taps the view.
 */
class TapController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The callback to call when the user taps.
		 * @type {() => any}
		 * @private
		 */
		this._tapCallback = null;
	}

	/**
	 * Gets the callback to call when the user taps.
	 * @returns {() => any}
	 */
	getTapCallback() {
		return this._tapCallback;
	}

	/**
	 * Sets a callback to call when the user taps.
	 * @param {() => any} callback
	 */
	setTapCallback(callback) {
		this._tapCallback = callback;
	}

	/**
	 * Updates the entity's position and orientation.
	 * @override
	 * @internal
	 */
	__update() {
		// Get the input system.
		const input = this.getEntity().getScene().getEngine().getInput();
		// If the user clicked/tapped and didn't drag.
		if (input.isSelected() || !input.getDraggedOffset().isZero()) {
			// Call the callback.
			if (this._tapCallback !== null) {
				this._tapCallback();
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/transition_controller.js":
/*!************************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/transition_controller.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TransitionController": function() { return /* binding */ TransitionController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * @callback TransitionFunction
 * @param {Entity} entity
 * @param {Vector3} initialPosition
 * @param {Vector3} finalPosition
 * @param {Quaternion} initialOrientation
 * @param {Quaternion} finalOrientation
 * @param {number} u
 */

/**
 * A transition controller.
 */
class TransitionController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * @type {Vector3}
		 * @private
		 */
		this._initialPosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		this._initialPosition.copy(entity.getPosition());

		/**
		 * @type {Quaternion}
		 * @private
		 */
		this._initialOrientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
		this._initialOrientation.copy(entity.getOrientation());

		/**
		 * @type {EntityRef}
		 * @private
		 */
		this._initialParent = new _internal__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * @type {number}
		 * @private
		 */
		this._transitionStart = Number.NaN;

		/**
		 * @type {number}
		 * @private
		 */
		this._transitionTime = 1;

		/**
		 * @type {TransitionFunction}
		 * @private
		 */
		this._transitionFunction = this._lerpTransitionFunction;

		/**
		 * The resolve function that will be called when the transition completes.
		 * @type {function():void}
		 * @private
		 */
		this._resolvePromise = null;

		/**
		 * The reject function that will be called if the endPromise rejects.
		 * @type {function(string):void}
		 * @private
		 */
		this._rejectPromise = null;

		/**
		 * The promise that resolves at the end of the transition.
		 * @type {Promise<void>}
		 * @private
		 */
		this._endPromise = new Promise((resolve, reject) => {
			this._resolvePromise = resolve;
			this._rejectPromise = reject;
		});

		// Set the initial parent to the current parent.
		const parent = this.getEntity().getParent();
		if (parent !== null) {
			this._initialParent.setName(parent.getName());
		}

		// If there is another transition controller already, destroy it.
		const existingController = this.getEntity().getControllerByType('transition');
		if (existingController !== null) {
			this.getEntity().removeController(existingController);
		}

		// Add a beginning setParent controller, since the controllers before this one expect to be in the destination parent frame.
		const setParentController = /** @type {SetParentController} */(this.getEntity().addController('setParent', 'transitionSetParent', this.getEntity().getController(0)));
		if (parent !== null) {
			setParentController.setParent(parent.getName());
		}
	}

	/**
	 * Gets the transition time in seconds.
	 * @returns {number}
	 */
	getTransitionTime() {
		return this._transitionTime;
	}

	/**
	 * Sets the transition time in seconds.
	 * @param {number} transitionTime
	 */
	setTransitionTime(transitionTime) {
		this._transitionTime = transitionTime;
	}

	/**
	 * Sets the transition function.
	 * @param {TransitionFunction} transitionFunction
	 */
	setTransitionFunction(transitionFunction) {
		this._transitionFunction = transitionFunction;
	}

	/**
	 * Gets the parent to transition to.
	 * @returns {string}
	 */
	getParent() {
		const setParentController = /** @type {SetParentController} */(this.getEntity().getController('transitionSetParent'));
		if (setParentController !== null) {
			return setParentController.getName();
		}
		else {
			const parent = this.getEntity().getParent();
			if (parent !== null) {
				return parent.getName();
			}
			return null;
		}
	}

	/**
	 * Sets the parent to transition to.
	 * @param {string} parent
	 */
	setParent(parent) {
		const setParentController = /** @type {SetParentController} */(this.getEntity().getController('transitionSetParent'));
		if (setParentController !== null) {
			setParentController.setParent(parent);
		}
	}

	/**
	 * Gets the promise that resolves at the end of the transition.
	 * On a failure, the reject function takes a string describing what went wrong.
	 * @returns {Promise<void>}
	 */
	getEndPromise() {
		return this._endPromise;
	}

	/**
	 * Destroys the controller resources.
	 * @override
	 * @internal
	 */
	__destroy() {
		super.__destroy();

		// Remove the setParent controller.
		const setParentController = this.getEntity().getController('transitionSetParent');
		if (setParentController !== null) {
			this.getEntity().removeController(setParentController);
		}

		// Reject if the transition controller completed early.
		if (this._transitionTime !== 0) {
			this._rejectPromise('Transition controller was destroyed before completing.');
		}
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		// When this update runs, the previous controllers in the entity controller list have updated themselves,
		// including the first setParent controller created by this. Now we just interpolate between the
		// initialPosition/Orientation variables and the entity's updated position and orientation.

		// Get the initial parent and final parent.
		const initialParent = this._initialParent.get();
		const finalParent = this.getEntity().getParent();

		// There's no final parent any more, so we error.
		if (finalParent === null) {
			this._transitionTime = 0;
			this.getEntity().removeController(this);
			this._rejectPromise('The final parent was destroyed or disabled before the transition could complete.');
		}

		// Set the start time for the transition on the first update.
		if (Number.isNaN(this._transitionStart)) {
			this._transitionStart = Date.now() / 1000.0;
		}

		// If we're before the half-way point or just went over it this frame.
		const setParentController = /** @type {SetParentController} */(this.getEntity().getController('transitionSetParent'));
		if (setParentController !== null) {
			// If there's no initial parent,
			if (initialParent === null) {
				this.getEntity().getScene().getEngine().addCallback(() => {
					this._transitionTime = 0;
					this.getEntity().removeController(this);
					if (this._initialParent.getName() !== '') { // There's supposed to be an initial parent, but no more.
						this._rejectPromise(`The initial parent "${this._initialParent.getName()}" was destroyed or disabled before the first half of the transition could complete.`);
					}
					else { // Never was an initial parent, so just finish the transition.
						this._resolvePromise();
					}
				}, false);
				return;
			}
			// If we're over the half-way point, remove the setParent controller and adjust the frame of the initial position.
			if (Date.now() / 1000.0 - this._transitionStart >= this._transitionTime / 2.0 || initialParent === finalParent) {
				// Remove the setParent controller.
				this.getEntity().removeController(setParentController);
				// Change the initial position to be in the frame of the final parent.
				if (initialParent !== finalParent && initialParent !== null && finalParent !== null) {
					initialParent.getPositionRelativeToEntity(this._initialPosition, this._initialPosition, finalParent);
				}
			}
			// We're before the half-way point and at a different parent, so switch to the initial parent.
			else {
				this.getEntity().setParent(initialParent);
			}
		}

		// Get the final position and orientation.
		const finalPosition = this.getEntity().getPosition();
		const finalOrientation = this.getEntity().getOrientation();

		// Do the transition.
		let u = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01((Date.now() / 1000.0 - this._transitionStart) / this._transitionTime);
		if (Number.isNaN(u)) {
			u = 1.0;
		}
		this._transitionFunction(this.getEntity(), this._initialPosition, finalPosition, this._initialOrientation, finalOrientation, u);

		// If we've passed the transition time, clean it all up.
		if (Date.now() / 1000.0 - this._transitionStart >= this._transitionTime) {
			this.getEntity().getScene().getEngine().addCallback(() => {
				this._transitionTime = 0;
				this.getEntity().removeController(this);
				this._resolvePromise();
			}, false);
		}
	}

	/**
	 * A default function that lerps between positions and slerps between orientations.
	 * @param {Entity} entity
	 * @param {Vector3} initialPosition
	 * @param {Vector3} finalPosition
	 * @param {Quaternion} initialOrientation
	 * @param {Quaternion} finalOrientation
	 * @param {number} u
	 */
	_lerpTransitionFunction(entity, initialPosition, finalPosition, initialOrientation, finalOrientation, u) {
		const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		position.lerp(initialPosition, finalPosition, u);
		orientation.slerp(initialOrientation, finalOrientation, u);

		// Set the new position and orientation.
		entity.setPosition(position);
		entity.setOrientation(orientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/translate_controller.js":
/*!***********************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/translate_controller.js ***!
  \***********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TranslateController": function() { return /* binding */ TranslateController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A controller that translates the position of the entity.
 */
class TranslateController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The translation.
		 * @type {Vector3}
		 * @private
		 */
		this._translation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 0);
		this._translation.freeze();

		/**
		 * Whether the translation is relative to the orientation.
		 * @type {boolean}
		 * @private
		 */
		this._relativeToOrientation = false;

		// Let the base controller know that this changes the position.
		this.addModifiedState('position');
	}

	/**
	 * Gets the translation. Defaults to Vector3(0, 0, 0).
	 * @returns {Vector3}
	 */
	getTranslation() {
		return this._translation;
	}

	/**
	 * Sets the translation.
	 * @param {Vector3} translation
	 */
	setTranslation(translation) {
		this._translation.thaw();
		this._translation.copy(translation);
		this._translation.freeze();
	}

	/**
	 * Sets whether the translation is relative to the orientation.
	 * @param {boolean} relativeToOrientation
	 */
	setRelativeToOrientation(relativeToOrientation) {
		this._relativeToOrientation = relativeToOrientation;
	}

	/**
	 * Updates a position for the given time.
	 * @param {Vector3} position
	 * @param {number} time
	 * @override
	 * @internal
	 */
	__updatePositionAtTime(position, time) {
		const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		if (this._relativeToOrientation) {
			const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			this.getEntity().getOrientationAtTime(orientation, time);
			newPosition.rotate(orientation, this._translation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
		}
		else {
			newPosition.copy(this._translation);
		}
		position.add(newPosition, position);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
	}

	/**
	 * Updates the controller.
	 * @override
	 * @internal
	 */
	__update() {
		const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		if (this._relativeToOrientation) {
			newPosition.rotate(this.getEntity().getOrientation(), this._translation);
		}
		else {
			newPosition.copy(this._translation);
		}
		newPosition.add(newPosition, this.getEntity().getPosition());
		this.getEntity().setPosition(newPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/controllers/zoom_controller.js":
/*!******************************************************************!*\
  !*** ../pioneer/engine/src/scene/controllers/zoom_controller.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZoomController": function() { return /* binding */ ZoomController; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A zoom camera controller.
 */
class ZoomController extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		// The sensitivity for zooming.
		this._zoomSensitivity = 0.05;

		/**
		 * The smoothness of the zooming. Zero means no smoothness.
		 * @type {number}
		 * @private
		 */
		this._zoomSmoothness = 0.8;

		/**
		 * The current value applied every frame to the movement.
		 * @type {number}
		 * @private
		 */
		this._zoomSmoothedValue = 1.0;

		/**
		 * The distance that it will be clamped to.
		 * @type {Interval}
		 * @private
		 */
		this._distanceClamp = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(0.001, Number.POSITIVE_INFINITY);
		this._distanceClamp.freeze();

		/**
		 * If true, it will use the distance to the radius of the spheroid instead of the entity position distance.
		 * @type {boolean}
		 * @private
		 */
		this._useSpheroidRadiusForDistance = false;

		// Let the base controller know that this changes the position.
		this.addModifiedState('position');
	}

	/**
	 * Gets the zoom sensitivity. Defaults to 0.01.
	 * @returns {number}
	 */
	getZoomSensitivity() {
		return this._zoomSensitivity;
	}

	/**
	 * Sets the zoom sensitivity.
	 * @param {number} zoomSensitivity
	 */
	setZoomSensitivity(zoomSensitivity) {
		this._zoomSensitivity = zoomSensitivity;
	}

	/**
	 * Gets the zoom smoothness. Defaults to 0.8.
	 * @returns {number}
	 */
	getZoomSmoothness() {
		return this._zoomSmoothness;
	}

	/**
	 * Sets the zoom smoothness, between 0 and 1.
	 * @param {number} zoomSmoothness
	 */
	setZoomSmoothness(zoomSmoothness) {
		this._zoomSmoothness = zoomSmoothness;
	}

	/**
	 * Gets the interval to which it will be clamped (frozen).
	 * @returns {Interval}
	 */
	getDistanceClamp() {
		return this._distanceClamp;
	}

	/**
	 * Sets the distance that it will be clamped to.
	 * @param {Interval} distanceClamp - the value to set
	 */
	setDistanceClamp(distanceClamp) {
		this._distanceClamp.thaw();
		this._distanceClamp.copy(distanceClamp);
		this._distanceClamp.freeze();
	}

	/**
	 * Returns true if it will use the distance to the radius of the spheroid instead of the entity position distance.
	 * @returns {boolean}
	 */
	getUseSpheroidRadiusForDistance() {
		return this._useSpheroidRadiusForDistance;
	}

	/**
	 * Sets if it will use the distance to the radius of the spheroid instead of the entity position distance.
	 * @param {boolean} enabled
	 */
	setUseSpheroidRadiusForDistance(enabled) {
		this._useSpheroidRadiusForDistance = enabled;
	}

	/**
	 * Takes input and updates the target distance. Then updates the entity's position.
	 * @override
	 * @internal
	 */
	__update() {
		const input = this.getEntity().getScene().getEngine().getInput();

		// Update the target distance.
		let zoomChange = 1.0;
		const viewport = input.getActiveViewport();
		if (viewport !== null) {
			const camera = viewport.getCamera();
			if (camera !== null && camera.getEntity() === this.getEntity()) {
				let zoomMultiplier = 1;
				if (input.isKeyPressed('x')) {
					zoomMultiplier = 0.05;
				}
				if (input.isShiftPressed()) {
					zoomMultiplier = 5;
				}

				// Do zoom/scroll movement.
				const zoomOffset = input.getZoomedOffset();
				if (zoomOffset !== 0) {
					zoomChange *= Math.pow(2, zoomOffset * this._zoomSensitivity * zoomMultiplier);
				}

				// Do key movement.
				if (input.isKeyPressed('w')) {
					zoomChange /= Math.pow(2, this._zoomSensitivity * zoomMultiplier);
				}
				if (input.isKeyPressed('s')) {
					zoomChange *= Math.pow(2, this._zoomSensitivity * zoomMultiplier);
				}
				zoomChange *= Math.pow(2, this._zoomSensitivity * zoomMultiplier * cameraOrbitParameters.zoom);
			}
		}

		// Apply smoothing.
		this._zoomSmoothedValue = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(zoomChange, this._zoomSmoothedValue, this._zoomSmoothness), 0.8, 1.25);
		if (Math.abs(1.0 - this._zoomSmoothedValue) < 0.0000001) {
			this._zoomSmoothedValue = 1.0;
		}

		// Get the current distance from the position.
		let currentDistance = 1;
		const lla = _internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		if (this._useSpheroidRadiusForDistance && this.getEntity().getParent() !== null) {
			const spheroid = /** @type {SpheroidComponent} */(this.getEntity().getParent().getComponentByType('spheroid'));
			if (spheroid !== null) {
				const positionOriented = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				positionOriented.rotateInverse(this.getEntity().getParent().getOrientation(), this.getEntity().getPosition());
				spheroid.llaFromXYZ(lla, positionOriented);
				currentDistance = lla.alt;
				_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionOriented);
			}
			else {
				currentDistance = this.getEntity().getPosition().magnitude() - this.getEntity().getParent().getOcclusionRadius();
			}
		}
		else {
			currentDistance = this.getEntity().getPosition().magnitude();
		}
		if (Number.isNaN(currentDistance)) {
			currentDistance = 1;
		}

		// Update the current distance and apply clamping.
		currentDistance *= this._zoomSmoothedValue;
		if (currentDistance < this._distanceClamp.min) {
			currentDistance = this._distanceClamp.min;
			this._zoomSmoothedValue = 1.0;
		}
		if (currentDistance > this._distanceClamp.max) {
			currentDistance = this._distanceClamp.max;
			this._zoomSmoothedValue = 1.0;
		}

		// Set the position from the current distance.
		const newPosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		let newMagnitude = currentDistance;
		if (this._useSpheroidRadiusForDistance && this.getEntity().getParent() !== null) {
			const spheroid = /** @type {SpheroidComponent} */(this.getEntity().getParent().getComponentByType('spheroid'));
			if (spheroid !== null) {
				lla.alt = currentDistance;
				spheroid.xyzFromLLA(newPosition, lla);
				newMagnitude = newPosition.magnitude();
			}
			else {
				newMagnitude = currentDistance + this.getEntity().getParent().getOcclusionRadius();
			}
		}
		newPosition.normalize(this.getEntity().getPosition());
		newPosition.mult(newPosition, newMagnitude);
		this.getEntity().setPosition(newPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
		_internal__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/entity.js":
/*!*********************************************!*\
  !*** ../pioneer/engine/src/scene/entity.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entity": function() { return /* binding */ Entity; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The main class that defines an object in space. It has position, orientation, components, controllers, and size.
 * @extends {CollectionItem<Scene>}
 */
class Entity extends _internal__WEBPACK_IMPORTED_MODULE_0__.CollectionItem {
	/**
	 * Constructor.
	 * @param {string} type - the type of the entity (always 'entity');
	 * @param {string} name - the name of the entity
	 * @param {Scene} scene - the scene
	 */
	constructor(type, name, scene) {
		super(type, name, scene);

		/**
		 * Flag that the user can use to enable or disable the entity (and its children).
		 * @type {boolean}
		 * @private
		 */
		this._enabled = true;

		/**
		 * The flag that says whether any ancestor is disabled, making this disabled.
		 * @type {boolean}
		 * @private
		 */
		this._disabledByAncestor = false;

		/**
		 * Flag that indicates whether the entity has been destroyed.
		 * @type {boolean}
		 * @private
		 */
		this._destroyed = false;

		/**
		 * The parent of the entity.
		 * @type {Entity}
		 * @private
		 */
		this._parent = null;

		/**
		 * The parent of the entity at the beginning of the last frame.
		 * @type {Entity}
		 * @private
		 */
		this._lastParent = null;

		/**
		 * The children of the entity.
		 * @type {Entity[]}
		 * @private
		 */
		this._children = [];

		/**
		 * The time starts for parents as `[start time, parent name]`, sorted by start times.
		 * @type {[number, string][]}
		 * @private
		 */
		this._parentingTable = [];

		/**
		 * A list of callbacks to call when the parent changes.
		 * @type {((entity: Entity, oldParent: Entity, newParent: Entity) => void)[]}
		 * @private
		 */
		this._parentChangedCallbacks = [];

		/**
		 * A list of callbacks to call when the child changes.
		 * @type {((entity: Entity, child: Entity, added: boolean) => void)[]}
		 * @private
		 */
		this._childChangedCallbacks = [];

		/**
		 * The entity state.
		 * @type {EntityState}
		 * @private
		 */
		this._state = new EntityState();

		/**
		 * The entity state from the previous frame.
		 * @type {EntityState}
		 * @private
		 */
		this._lastState = new EntityState();

		/**
		 * The position of the entity relative to the camera's position.
		 * @type {FastMap<CameraComponent, Vector3>}
		 * @private
		 */
		this._cameraSpacePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The position of the entity in normal-space.
		 * @type {FastMap<CameraComponent, Vector3>}
		 * @private
		 */
		this._normalSpacePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The position of the entity in pixel-space.
		 * @type {FastMap<CameraComponent, Vector2>}
		 * @private
		 */
		this._pixelSpacePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The normal-space extents radius of the entity.
		 * @type {FastMap<CameraComponent, number>}
		 * @private
		 */
		this._normalSpaceExtentsRadius = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The pixel-space extents radius of the entity.
		 * @type {FastMap<CameraComponent, number>}
		 * @private
		 */
		this._pixelSpaceExtentsRadius = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The greatest pixel-space extents radius of the entity in any camera.
		 * @type {number}
		 * @private
		 */
		this._greatestPixelSpaceExtentsRadius = 0.0;

		/**
		 * The collection of components.
		 * @type {Collection<BaseComponent, Entity>}
		 * @private
		*/
		this._components = new _internal__WEBPACK_IMPORTED_MODULE_0__.Collection(this, _internal__WEBPACK_IMPORTED_MODULE_0__.Types.Components);

		/**
		 * The collection of controllers.
		 * @type {Collection<BaseController, Entity>}
		 * @private
		*/
		this._controllers = new _internal__WEBPACK_IMPORTED_MODULE_0__.Collection(this, _internal__WEBPACK_IMPORTED_MODULE_0__.Types.Controllers);

		/**
		 * The radius of the entity.
		 * @type {number}
		 * @private
		 */
		this._occlusionRadius = 0;

		/**
		 * The radius of the entity.
		 * @type {number}
		 * @private
		 */
		this._extentsRadius = 0;

		/**
		 * A user-set flag that determines whether things like labels get hidden behind the entity.
		 * @type {boolean}
		 * @private
		 */
		this._canOcclude = true;

		/**
		 * The position coverage of the controllers.
		 * @type {Interval}
		 * @private
		 */
		this._positionCoverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		this._positionCoverage.freeze();

		/**
		 * The orientation coverage of the controllers.
		 * @type {Interval}
		 * @private
		 */
		this._orientationCoverage = new _internal__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		this._orientationCoverage.freeze();

		/**
		 * A flag that is true if the entity's position coverage contains the current time.
		 * @type {boolean}
		 * @private
		 */
		this._isInPositionCoverage = false;

		/**
		 * A flag that is true if the entity's orientation coverage contains the current time.
		 * @type {boolean}
		 * @private
		 */
		this._isInOrientationCoverage = false;
	}

	// NAME, SCENE, ENABLED, VISIBILITY

	/**
	 * Returns the scene.
	 * @returns {Scene}
	 */
	getScene() {
		return this.__getCollectionParent();
	}

	/**
	 * Returns true if the entity is enabled.
	 * @returns {boolean}
	 */
	isEnabled() {
		return this._enabled && !this._disabledByAncestor;
	}

	/**
	 * Gets the flag that says whether any ancestor is disabled, making this disabled.
	 * @returns {boolean}
	 */
	isDisabledByAncestor() {
		return this._disabledByAncestor;
	}

	/**
	 * Sets whether the entity is enabled or not. Affects visibility and updating
	 * of all components and controllers. Does not include children.
	 * @param {boolean} enabled
	 */
	setEnabled(enabled) {
		// If the flag has changed.
		if (this._enabled !== enabled) {
			// Update the flag.
			this._enabled = enabled;
			// Update the components and children's disabledByAncestor flags.
			this._updateEnabled();
		}
	}

	/**
	 * Updates the enabled flag after its been set.
	 * @private
	 */
	_updateEnabled() {
		// Update the component load states, which depends on the entity's enabled flag.
		for (let i = 0; i < this._components.size; i++) {
			this._components.get(i).__updateLoadState();
		}
		// Update the children.
		for (let i = 0, l = this._children.length; i < l; i++) {
			this._children[i]._updateDisabledByAncestor();
		}
	}

	/**
	 * Updates the disabledByAncestor flag.
	 * @private
	 */
	_updateDisabledByAncestor() {
		// Check if any ancestor is disabled.
		let newDisabledByAncestor = false;
		let ancestor = this._parent;
		while (ancestor !== null) {
			if (!ancestor._enabled || ancestor._disabledByAncestor) {
				newDisabledByAncestor = true;
				break;
			}
			ancestor = ancestor._parent;
		}
		// If the disabledByAncestor flag has changed, update it and its children.
		if (this._disabledByAncestor !== newDisabledByAncestor) {
			// Update the flag.
			this._disabledByAncestor = newDisabledByAncestor;
			// Update the components and children's disabledByAncestor flags.
			this._updateEnabled();
		}
	}

	/**
	 * Checks if the entity item has been destroyed.
	 * @returns {boolean}
	 */
	isDestroyed() {
		return this._destroyed;
	}

	// POSITION, ORIENTATION, ETC

	/**
	 * Gets the position (frozen).
	 * @returns {Vector3}
	 */
	getPosition() {
		return this._state.position;
	}

	/**
	 * Sets the position. Called by controllers when they set the position of the entity.
	 * @param {Vector3} position - the value to set
	 */
	setPosition(position) {
		this._state.position.thaw();
		this._state.position.copy(position);
		this._state.position.freeze();
	}

	/**
	 * Gets the velocity (frozen).
	 * @returns {Vector3}
	 */
	getVelocity() {
		return this._state.velocity;
	}

	/**
	 * Sets the velocity. Called by controllers when they set the velocity of the entity.
	 * @param {Vector3} velocity - the value to set
	 */
	setVelocity(velocity) {
		this._state.velocity.thaw();
		this._state.velocity.copy(velocity);
		this._state.velocity.freeze();
	}

	/**
	 * Gets the orientation (frozen).
	 * @returns {Quaternion}
	 */
	getOrientation() {
		return this._state.orientation;
	}

	/**
	 * Sets the orientation. Called by controllers when they set the orientation of the entity.
	 * @param {Quaternion} orientation - the value to set
	 */
	setOrientation(orientation) {
		this._state.orientation.thaw();
		this._state.orientation.copy(orientation);
		this._state.orientation.freeze();
	}

	/**
	 * Gets the rotational velocity (frozen).
	 * @returns {Vector3}
	 */
	getAngularVelocity() {
		return this._state.angularVelocity;
	}

	/**
	 * Sets the rotational velocity. Called by controllers when they set the rotational velocity of the entity.
	 * @param {Vector3} angularVelocity - the value to set
	 */
	setAngularVelocity(angularVelocity) {
		this._state.angularVelocity.thaw();
		this._state.angularVelocity.copy(angularVelocity);
		this._state.angularVelocity.freeze();
	}

	/**
	 * Gets the position on the previous frame.
	 * @returns {Vector3}
	 */
	getLastPosition() {
		return this._lastState.position;
	}

	/**
	 * Gets the velocity on the previous frame.
	 * @returns {Vector3}
	 */
	getLastVelocity() {
		return this._lastState.velocity;
	}

	/**
	 * Gets the orientation on the previous frame.
	 * @returns {Quaternion}
	 */
	getLastOrientation() {
		return this._lastState.orientation;
	}

	/**
	 * Gets the angular velocity on the previous frame.
	 * @returns {Vector3}
	 */
	getLastAngularVelocity() {
		return this._lastState.angularVelocity;
	}

	/**
	 * Gets the position given in this frame relative to the given entity.
	 * @param {Vector3} outPosition - the result
	 * @param {Vector3} positionInThisFrame - the position in this frame
	 * @param {Entity} entity - the entity. If null, defaults to the root.
	 * @param {number} [time] - an optional time to use.
	 */
	getPositionRelativeToEntity(outPosition, positionInThisFrame, entity, time) {
		/**
		 * @type {Entity}
		 */
		let e = this;
		outPosition.copy(positionInThisFrame);
		if (time === undefined) {
			const lca = this.getLowestCommonAncestor(entity);
			if (lca === null) {
				outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
				return;
			}
			outPosition.add(outPosition, e.getPosition());
			while (e !== lca) {
				e = e.getParent();
				outPosition.add(outPosition, e.getPosition());
			}
			if (entity !== null) {
				e = entity;
				outPosition.sub(outPosition, e.getPosition());
				while (e !== lca) {
					e = e.getParent();
					outPosition.sub(outPosition, e.getPosition());
				}
			}
		}
		else { // A specific time was requested.
			const scene = this.getScene();
			const ePosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const lca = this.getLowestCommonAncestorAtTime(entity, time);
			if (lca !== null) {
				e.getPositionAtTime(ePosition, time);
				outPosition.add(outPosition, ePosition);
				while (e !== lca) {
					const eName = e.getParentAtTime(time);
					e = scene.getEntity(eName);
					if (e === null) {
						outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
						return;
					}
					e.getPositionAtTime(ePosition, time);
					outPosition.add(outPosition, ePosition);
				}
				if (entity !== null) {
					e = entity;
					e.getPositionAtTime(ePosition, time);
					outPosition.sub(outPosition, ePosition);
					while (e !== lca) {
						const eName = e.getParentAtTime(time);
						e = scene.getEntity(eName);
						if (e === null) {
							outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
							return;
						}
						e.getPositionAtTime(ePosition, time);
						outPosition.sub(outPosition, ePosition);
					}
				}
			}
			else {
				outPosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(ePosition);
		}
	}

	/**
	 * Gets the velocity given in this frame relative to the given entity.
	 * @param {Vector3} outVelocity - the result
	 * @param {Vector3} velocityInThisFrame - the velocity in this frame
	 * @param {Entity} entity - the entity. If null, defaults to the root.
	 * @param {number} [time] - an optional time to use.
	 */
	getVelocityRelativeToEntity(outVelocity, velocityInThisFrame, entity, time) {
		/**
		 * @type {Entity}
		 */
		let e = this;
		outVelocity.copy(velocityInThisFrame);
		if (time === undefined) {
			const lca = this.getLowestCommonAncestor(entity);
			if (lca === null) {
				outVelocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
				return;
			}
			outVelocity.add(outVelocity, e.getVelocity());
			while (e !== lca) {
				e = e.getParent();
				outVelocity.add(outVelocity, e.getVelocity());
			}
			if (entity !== null) {
				e = entity;
				outVelocity.sub(outVelocity, e.getVelocity());
				while (e !== lca) {
					e = e.getParent();
					outVelocity.sub(outVelocity, e.getVelocity());
				}
			}
		}
		else { // A specific time was requested.
			const scene = this.getScene();
			const eVelocity = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const lca = this.getLowestCommonAncestorAtTime(entity, time);
			if (lca !== null) {
				e.getVelocityAtTime(eVelocity, time);
				outVelocity.add(outVelocity, eVelocity);
				while (e !== lca) {
					const eName = e.getParentAtTime(time);
					e = scene.getEntity(eName);
					if (e === null) {
						outVelocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
						return;
					}
					e.getVelocityAtTime(eVelocity, time);
					outVelocity.add(outVelocity, eVelocity);
				}
				if (entity !== null) {
					e = entity;
					e.getVelocityAtTime(eVelocity, time);
					outVelocity.sub(outVelocity, eVelocity);
					while (e !== lca) {
						const eName = e.getParentAtTime(time);
						e = scene.getEntity(eName);
						if (e === null) {
							outVelocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
							return;
						}
						e.getVelocityAtTime(eVelocity, time);
						outVelocity.sub(outVelocity, eVelocity);
					}
				}
			}
			else {
				outVelocity.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(eVelocity);
		}
	}

	/**
	 * Sets outPosition to the entity position at the given time. If the time is omitted, the current time is used.
	 * @param {Vector3} outPosition
	 * @param {number} [time]
	 */
	getPositionAtTime(outPosition, time) {
		if (!this.isEnabled()) {
			outPosition.set(Number.NaN, Number.NaN, Number.NaN);
		}
		else {
			if (time === undefined || this._controllers.size === 0) {
				outPosition.copy(this._state.position);
			}
			else {
				outPosition.set(Number.NaN, Number.NaN, Number.NaN);
			}
			for (let i = 0; i < this._controllers.size; i++) {
				const controller = this._controllers.get(i);
				if (controller.hasModifiedState('position') && controller.getCoverage().contains(time) && controller.isEnabled()) {
					controller.__updatePositionAtTime(outPosition, time);
				}
			}
		}
	}

	/**
	 * Sets outVelocity to the entity velocity at the given time. If the time is omitted, the current time is used.
	 * @param {Vector3} outVelocity
	 * @param {number} [time]
	 */
	getVelocityAtTime(outVelocity, time) {
		if (!this.isEnabled()) {
			outVelocity.set(Number.NaN, Number.NaN, Number.NaN);
		}
		else {
			if (time === undefined || this._controllers.size === 0) {
				outVelocity.copy(this._state.velocity);
			}
			else {
				outVelocity.set(Number.NaN, Number.NaN, Number.NaN);
			}
			for (let i = 0; i < this._controllers.size; i++) {
				const controller = this._controllers.get(i);
				if (controller.hasModifiedState('velocity') && controller.getCoverage().contains(time) && controller.isEnabled()) {
					controller.__updateVelocityAtTime(outVelocity, time);
				}
			}
		}
	}

	/**
	 * Sets outOrientation to the entity orientation at the given time. If the time is omitted, the current time is used.
	 * @param {Quaternion} outOrientation - the orientation to be set
	 * @param {number} [time] - the time to check
	 */
	getOrientationAtTime(outOrientation, time) {
		if (!this.isEnabled()) {
			outOrientation.set(Number.NaN, Number.NaN, Number.NaN, Number.NaN);
		}
		else {
			if (time === undefined || this._controllers.size === 0) {
				outOrientation.copy(this._state.orientation);
			}
			else {
				outOrientation.set(Number.NaN, Number.NaN, Number.NaN, Number.NaN);
			}
			for (let i = 0; i < this._controllers.size; i++) {
				const controller = this._controllers.get(i);
				if (controller.hasModifiedState('orientation') && controller.getCoverage().contains(time) && controller.isEnabled()) {
					controller.__updateOrientationAtTime(outOrientation, time);
				}
			}
		}
	}

	// RADII

	/**
	 * Gets the occlusion radius of the entity. For non-spherical entities, this is a rough approximation of the bulk of the entity.
	 * @returns {number}
	 */
	getOcclusionRadius() {
		return this._occlusionRadius;
	}

	/**
	 * Gets the extents radius of the entity. For non-spherical entities, this is how far any part of the entity extends.
	 * @returns {number}
	 */
	getExtentsRadius() {
		return this._extentsRadius;
	}

	/**
	 * Sets the radius of the entity. For non-spherical entities, this is a rough approximation of the bulk of the entity.
	 * @param {number} radius - the value to set
	 */
	setOcclusionRadius(radius) {
		this._occlusionRadius = radius;
	}

	/**
	 * Sets the radius of the entity. For non-spherical entities, this is how far any part of the entity extends.
	 * @param {number} radius - the value to set
	 */
	setExtentsRadius(radius) {
		this._extentsRadius = radius;
	}

	// COVERAGE

	/**
	 * Gets the position coverage of the entity's controllers. If there are no position coverages, it returns an infinite coverage.
	 * @returns {Interval}
	 */
	getPositionCoverage() {
		return this._positionCoverage;
	}

	/**
	 * Gets the orientation coverage of the entity's controllers. If there are no orientation coverages, it returns an infinite coverage.
	 * @returns {Interval}
	 */
	getOrientationCoverage() {
		return this._orientationCoverage;
	}

	/**
	 * Gets the flag that is true if the entity's position coverage contains the current time.
	 * @returns {boolean}
	 */
	isInPositionCoverage() {
		return this._isInPositionCoverage;
	}

	/**
	 * Gets flag that is true if the entity's orientation coverage contains the current time.
	 * @returns {boolean}
	 */
	isInOrientationCoverage() {
		return this._isInOrientationCoverage;
	}

	/**
	 * Copies the current state to the last state.
	 * @internal
	 */
	__updateLastState() {
		this._lastState.position.thaw();
		this._lastState.position.copy(this._state.position);
		this._lastState.position.freeze();

		this._lastState.velocity.thaw();
		this._lastState.velocity.copy(this._state.velocity);
		this._lastState.velocity.freeze();

		this._lastState.orientation.thaw();
		this._lastState.orientation.copy(this._state.orientation);
		this._lastState.orientation.freeze();

		this._lastState.angularVelocity.thaw();
		this._lastState.angularVelocity.copy(this._state.angularVelocity);
		this._lastState.angularVelocity.freeze();
	}

	/**
	 * Updates the position and orientation coverage of the entity from the controllers.
	 * @internal
	 */
	__updateCoverage() {

		// Thaw the coverages.
		this._positionCoverage.thaw();
		this._orientationCoverage.thaw();

		// Initially set them to be no coverage.
		this._positionCoverage.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);
		this._orientationCoverage.set(Number.POSITIVE_INFINITY, Number.NEGATIVE_INFINITY);

		// Go through each controller and union the coverages for position and orientation.
		let numPositionControllers = 0;
		let numOrientationControllers = 0;
		for (let i = 0; i < this._controllers.size; i++) {
			const controller = this._controllers.get(i);
			if (controller.isEnabled()) {
				if (controller.hasModifiedState('position')) {
					this._positionCoverage.union(this._positionCoverage, controller.getCoverage());
					numPositionControllers++;
				}
				if (controller.hasModifiedState('orientation')) {
					this._orientationCoverage.union(this._orientationCoverage, controller.getCoverage());
					numOrientationControllers++;
				}
			}
		}

		// If there are no coverages, set them to infinity.
		if (numPositionControllers === 0) {
			this._positionCoverage.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		}
		if (numOrientationControllers === 0) {
			this._orientationCoverage.set(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
		}

		// Also limit to the position coverage parenting table coverages.
		if (this._parentingTable.length > 0) {
			const firstEntry = this._parentingTable[0];
			const lastEntry = this._parentingTable[this._parentingTable.length - 1];
			this._positionCoverage.min = Math.max(this._positionCoverage.min, firstEntry[1] !== '' ? firstEntry[0] : Number.POSITIVE_INFINITY);
			this._positionCoverage.max = Math.min(this._positionCoverage.max, lastEntry[1] !== '' ? Number.POSITIVE_INFINITY : lastEntry[0]);
		}

		// Refreeze the coverages.
		this._positionCoverage.freeze();
		this._orientationCoverage.freeze();
	}

	// OCCLUSION

	/**
	 * Returns whether the entity can occlude objects in the occlusion system. Returns true by default.
	 * @returns {boolean}
	 */
	canOcclude() {
		return this._canOcclude;
	}

	/**
	 * Sets whether the entity can occlude objects in the occlusion system.
	 * @param {boolean} canOcclude
	 */
	setCanOcclude(canOcclude) {
		this._canOcclude = canOcclude;
	}

	/**
	 * Returns true if the entity is occluding the camera-space position.
	 * @param {CameraComponent} camera
	 * @param {Vector3} cameraSpacePosition
	 * @returns {boolean}
	 */
	isOccludingPosition(camera, cameraSpacePosition) {
		if (!this._canOcclude || !this.isInPositionCoverage()) {
			return false;
		}
		const occludingRadius = Math.min(this._occlusionRadius, this.getCameraSpacePosition(camera).magnitude());
		const interval = _internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.get();
		_internal__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLineSphereIntersectionWithLineStartAtOrigin(interval, cameraSpacePosition, this.getCameraSpacePosition(camera), occludingRadius);
		const occluding = interval.min < interval.max && (0 <= interval.min + interval.max) && (interval.min + interval.max < 2);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Interval.pool.release(interval);
		return occluding;
	}

	// PARENTING

	/**
	 * Gets the parent of the entity.
	 * If the parent has been set but is not yet in the scene, it returns null.
	 * @returns {Entity}
	 */
	getParent() {
		return this._parent;
	}

	/**
	 * Gets the parent name of the entity at the given time.
	 * @param {number} time
	 * @returns {string}
	 */
	getParentAtTime(time) {
		const index = _internal__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._parentingTable, isStartTimeLessThanTime);
		if (index < this._parentingTable.length && time === this._parentingTable[index][0]) {
			return this._parentingTable[index][1];
		}
		else if (index > 0) {
			return this._parentingTable[index - 1][1];
		}
		else {
			if (this._parentingTable.length > 0) {
				return '';
			}
			else { // There's no parenting table, so just choose the current parent, or '' if there's none.
				return this._parent !== null ? this._parent.getName() : '';
			}
		}
	}

	/**
	 * Sets the parent of the entity.
	 * @param {Entity} parent - the new parent or its name
	 */
	setParent(parent) {
		// If it already set, just return.
		if (parent === this._parent) {
			return;
		}

		// Make sure the position stays the same relative to the new parent.
		const position = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.getPositionRelativeToEntity(position, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, parent);
		if (!position.isNaN()) {
			this.setPosition(position);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);

		// Remove the old parent's child link.
		if (this._parent !== null) {
			for (let i = 0; i < this._parent._children.length; i++) {
				const child = this._parent._children[i];
				if (child === this) {
					this._parent._children.splice(i, 1);
				}
			}
		}

		// Change to the new parent, saving the old parent for the callbacks.
		const oldParent = this._parent;
		this._parent = parent;

		// Add the new parent's child link.
		if (this._parent !== null) {
			this._parent._children.push(this);
		}

		// Clear the camera references of the entity and all of its descendants components,
		// since with a new parent, it might have a new set of connected cameras.
		// The prepareForRender and setCameraDependentVariables functions will enable them again in any connected camera.
		this._clearCameraReferences();

		// Update the disabledByAncestors flag.
		this._updateDisabledByAncestor();

		// Call any parent changed callbacks.
		for (let i = 0, l = this._parentChangedCallbacks.length; i < l; i++) {
			this._parentChangedCallbacks[i](this, oldParent, this._parent);
		}

		// Call any child changed callbacks for the old and new parents.
		if (oldParent !== null) {
			for (let i = 0, l = oldParent._childChangedCallbacks.length; i < l; i++) {
				oldParent._childChangedCallbacks[i](oldParent, this, false);
			}
		}
		if (this._parent !== null) {
			for (let i = 0, l = this._parent._childChangedCallbacks.length; i < l; i++) {
				this._parent._childChangedCallbacks[i](this._parent, this, true);
			}
		}
	}

	/**
	 * Clears the camera references for when an entity changes its parent and may be visible in a new camera or no camera.
	 * The variables will repopulate with any camera that calls the prepareForRender and updateCameraVariables functions.
	 * @private
	 */
	_clearCameraReferences() {
		// Clear all of the camera dependent variables to be repopulated again.
		this._cameraSpacePosition.clear();
		this._normalSpacePosition.clear();
		this._pixelSpacePosition.clear();
		this._normalSpaceExtentsRadius.clear();
		this._pixelSpaceExtentsRadius.clear();

		// Do the same for components, and also make them invisible until a camera tries to render them again in prepareForRender.
		for (let i = 0, l = this._components.size; i < l; i++) {
			const component = this._components.get(i);
			component.__clearCameraDependentsBase();
		}

		// Do this for all of the descendants as well.
		for (let i = 0, l = this._children.length; i < l; i++) {
			this._children[i]._clearCameraReferences();
		}
	}

	/**
	 * Gets the number of child entities. Good for iterating over child entities.
	 * @return {number}
	 */
	getNumChildren() {
		return this._children.length;
	}

	/**
	 * Gets the child entity at index i. Good for iterating over child entities.
	 * @param {number} i - the index
	 * @returns {Entity}
	 */
	getChild(i) {
		return this._children[i];
	}

	/**
	 * Gets the lowest common ancestor between this and another entity.
	 * @param {Entity} entity
	 * @returns {Entity}
	 */
	getLowestCommonAncestor(entity) {
		if (entity === null) {
			return null;
		}
		let entityThis = /** @type {Entity} */(this);
		let entityOther = entity;
		let levelThis = 0;
		let levelOther = 0;
		// Get the levels of the two entities relative to the root.
		while (entityThis.getParent() !== null) {
			levelThis += 1;
			entityThis = entityThis.getParent();
		}
		while (entityOther.getParent() !== null) {
			levelOther += 1;
			entityOther = entityOther.getParent();
		}
		// Whichever has the greatest level depth, move up to have the same level as the least level depth.
		entityThis = this;
		entityOther = entity;
		while (levelThis > levelOther) {
			levelThis -= 1;
			entityThis = entityThis.getParent();
		}
		while (levelOther > levelThis) {
			levelOther -= 1;
			entityOther = entityOther.getParent();
		}
		// Move up the ancestors for both until a common ancestor is found.
		while (entityThis !== entityOther && entityThis !== null) {
			entityThis = entityThis.getParent();
			entityOther = entityOther.getParent();
		}
		return entityThis; // If they didn't have a common ancestor, this will correctly be null.
	}

	/**
	 * Gets the lowest common ancestor between this and another entity at a given time.
	 * @param {Entity} entity
	 * @param {number} time
	 * @returns {Entity}
	 */
	getLowestCommonAncestorAtTime(entity, time) {
		if (entity === null) {
			return null;
		}
		let entityThis = /** @type {Entity} */(this);
		let entityOther = entity;
		let levelThis = 0;
		let levelOther = 0;
		const scene = this.getScene();
		// Get the levels of the two entities relative to the root.
		while (true) {
			const parentName = entityThis.getParentAtTime(time);
			if (parentName === '') {
				break;
			}
			const parent = scene.getEntity(parentName);
			if (parent === null) {
				return null;
			}
			levelThis += 1;
			entityThis = parent;
		}
		while (true) {
			const parentName = entityOther.getParentAtTime(time);
			if (parentName === '') {
				break;
			}
			const parent = scene.getEntity(parentName);
			if (parent === null) {
				return null;
			}
			levelOther += 1;
			entityOther = parent;
		}
		// Whichever has the greatest level depth, move up to have the same level as the least level depth.
		entityThis = this;
		entityOther = entity;
		while (levelThis > levelOther) {
			levelThis -= 1;
			const parentName = entityThis.getParentAtTime(time);
			const parent = scene.getEntity(parentName);
			if (parent === null) {
				return null;
			}
			entityThis = parent;
		}
		while (levelOther > levelThis) {
			levelOther -= 1;
			const parentName = entityOther.getParentAtTime(time);
			const parent = scene.getEntity(parentName);
			if (parent === null) {
				return null;
			}
			entityOther = parent;
		}
		// Move up the ancestors for both until a common ancestor is found.
		while (entityThis !== entityOther && entityThis !== null) {
			const parentThisName = entityThis.getParentAtTime(time);
			const parentThis = scene.getEntity(parentThisName);
			if (parentThis === null) {
				return null;
			}
			entityThis = parentThis;
			const parentOtherName = entityOther.getParentAtTime(time);
			const parentOther = scene.getEntity(parentOtherName);
			if (parentOther === null) {
				return null;
			}
			entityOther = parentOther;
		}
		return entityThis; // If they didn't have a common ancestor, this will correctly be null.
	}

	/**
	 * Gets the number of parenting table entries. Can be used for a `for` loop.
	 * @returns {number}
	 */
	getNumParentingTableEntries() {
		return this._parentingTable.length;
	}

	/**
	 * Gets a parenting table entry.
	 * @param {number} index
	 * @returns {readonly [number, string]}
	 */
	getParentingTableEntry(index) {
		return this._parentingTable[index];
	}

	/**
	 * Adds an entry to the parenting table.
	 * @param {number} startTime - The starting time of the interval. The next entry will denote the ending time.
	 * @param {string} parentName - The name of the parent for the interval.
	 */
	addParentingTableEntry(startTime, parentName) {
		_internal__WEBPACK_IMPORTED_MODULE_0__.Sort.add([startTime, parentName], this._parentingTable, isStartTimeLess, isStartTimeEqual);
		this.__updateCoverage();
	}

	/**
	 * Removes an entry from the parenting table.
	 * @param {number} index
	 */
	removeParentingTableEntry(index) {
		this._parentingTable.splice(index);
		this.__updateCoverage();
	}

	/**
	* Clears all entries from the parenting table.
	*/
	clearParentingTableEntries() {
		this._parentingTable = [];
		this.__updateCoverage();
	}

	/**
	 * Adds a parent changed callback.
	 * @param {(entity: Entity, oldParent: Entity, newParent: Entity) => void} callback
	 */
	addParentChangedCallback(callback) {
		this._parentChangedCallbacks.push(callback);
	}

	/**
	 * Removes a parent changed callback.
	 * @param {(entity: Entity, oldParent: Entity, newParent: Entity) => void} callback
	 */
	removeParentChangedCallback(callback) {
		const index = this._parentChangedCallbacks.indexOf(callback);
		if (index !== -1) {
			this._parentChangedCallbacks.splice(index, 1);
		}
	}

	/**
	 * Adds a child changed callback.
	 * @param {(entity: Entity, child: Entity, added: boolean) => void} callback
	 */
	addChildChangedCallback(callback) {
		this._childChangedCallbacks.push(callback);
	}

	/**
	 * Removes a child changed callback.
	 * @param {(entity: Entity, child: Entity, added: boolean) => void} callback
	 */
	removeChildChangedCallback(callback) {
		const index = this._childChangedCallbacks.indexOf(callback);
		if (index !== -1) {
			this._childChangedCallbacks.splice(index, 1);
		}
	}

	// COMPONENTS

	/**
	 * Gets the number of components.
	 * @returns {number}
	 */
	getNumComponents() {
		return this._components.size;
	}

	/**
	 * Gets the component from either the name or the index. It returns null if the component is not found.
	 * @param {string|number} nameOrIndex
	 * @returns {BaseComponent | null}
	 */
	getComponent(nameOrIndex) {
		return this._components.get(nameOrIndex);
	}

	/**
	 * Gets the index'th component of the given type. The index is base 0. Returns null if none is found.
	 * @param {string} type
	 * @param {number} [index=0]
	 * @returns {BaseComponent | null}
	 */
	getComponentByType(type, index = 0) {
		return this._components.getByType(type, index);
	}

	/**
	 * Gets the index'th component of the given type. The index is base 0. Returns null if none is found.
 	 * @template {BaseComponent} Class
	 * @param {import('../utils/collection').TypeConstructor<Class, Entity>} ComponentClass
	 * @param {number} [index=0]
	 * @returns {Class | null}
	 */
	getComponentByClass(ComponentClass, index = 0) {
		return this._components.getByClass(ComponentClass, index);
	}

	/**
	 * Adds a component.
	 * @param {string} type - type of the component
	 * @param {string} [name=''] - name of the component (optional)
	 * @param {BaseComponent} [beforeComponent=undefined] - insert before this component (optional)
	 * @returns {BaseComponent}
	 */
	addComponent(type, name, beforeComponent) {
		return this._components.add(type, name, beforeComponent);
	}

	/**
	 * Create an item using with the given name and return it.
	 * @template {BaseComponent} Class
	 * @param {import('../utils/collection').TypeConstructor<Class, Entity>} ClassConstructor
	 * @param {string} [name=''] - the name of the item to be created
	 * @param {BaseComponent} [beforeComponent] - insert the item before this item
	 * @returns {Class}
	 */
	addComponentByClass(ClassConstructor, name, beforeComponent) {
		return this._components.addByClass(ClassConstructor, name, beforeComponent);
	}

	/**
	 * Removes a component.
	 * @param {BaseComponent|string|number} componentOrNameOrIndex - the component, name, or index to remove.
	 */
	removeComponent(componentOrNameOrIndex) {
		this._components.remove(componentOrNameOrIndex);
	}

	/**
	 * Removes all components.
	 */
	clearComponents() {
		this._components.clear();
	}

	// CONTROLLERS

	/**
	 * Gets the number of controllers.
	 * @returns {number}
	 */
	getNumControllers() {
		return this._controllers.size;
	}

	/**
	 * Gets the controller from either the name or the index. It returns null if the controller is not found.
	 * @param {string|number} nameOrIndex
	 * @returns {BaseController | null}
	 */
	getController(nameOrIndex) {
		return this._controllers.get(nameOrIndex);
	}

	/**
	 * Gets the index'th controller of the given type. The index is base 0. Returns null if none is found.
	 * @param {string} type
	 * @param {number} [index=0]
	 * @returns {BaseController | null}
	 */
	getControllerByType(type, index = 0) {
		return this._controllers.getByType(type, index);
	}

	/**
	 * Gets the index'th controller of the given type. The index is base 0. Returns null if none is found.
 	 * @template {BaseController} Class
	 * @param {import('../utils/collection').TypeConstructor<Class, Entity>} ControllerClass
	 * @param {number} [index=0]
	 * @returns {Class | null}
	 */
	getControllerByClass(ControllerClass, index = 0) {
		return this._controllers.getByClass(ControllerClass, index);
	}

	/**
	 * Adds a controller.
	 * @param {string} type - type of the controller
	 * @param {string} [name=''] - name of the controller (optional)
	 * @param {BaseController} [beforeController=undefined] - insert before this controller (optional)
	 * @returns {BaseController}
	 */
	addController(type, name, beforeController) {
		const controller = this._controllers.add(type, name, beforeController);
		this.__updateCoverage();
		return controller;
	}

	/**
	 * Create an item using with the given name and return it.
	 * @template {BaseController} Class
	 * @param {import('../utils/collection').TypeConstructor<Class, Entity>} ClassConstructor
	 * @param {string} [name=''] - the name of the item to be created
	 * @param {BaseController} [beforeController] - insert the item before this item
	 * @returns {Class}
	 */
	addControllerByClass(ClassConstructor, name, beforeController) {
		return this._controllers.addByClass(ClassConstructor, name, beforeController);
	}

	/**
	 * Removes a controller.
	 * @param {BaseController|string|number} controllerOrNameOrIndex - the controller, name, or index to remove.
	 */
	removeController(controllerOrNameOrIndex) {
		this._controllers.remove(controllerOrNameOrIndex);
		this.__updateCoverage();
	}

	/**
	 * Removes all controllers.
	 */
	clearControllers() {
		this._controllers.clear();
		this.__updateCoverage();
	}

	// CAMERA DEPENDENT POSITION AND RADII

	/**
	 * Gets the camera-space position relative to the camera (frozen). Returns Vector.NaN if there is no position for that camera.
	 * @param {CameraComponent} camera
	 * @returns {Vector3}
	 */
	getCameraSpacePosition(camera) {
		const pos = this._cameraSpacePosition.get(camera);
		if (pos !== undefined) {
			return pos;
		}
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN];
	}

	/**
	 * Gets the normal-space position relative to the camera (frozen). Returns Vector.NaN if there is no position for that camera.
	 * @param {CameraComponent} camera
	 * @returns {Vector3}
	 */
	getNormalSpacePosition(camera) {
		const pos = this._normalSpacePosition.get(camera);
		if (pos !== undefined) {
			return pos;
		}
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN];
	}

	/**
	 * Gets the pixel-space position (frozen). Returns Vector.NaN if there is no position for that camera.
	 * @param {CameraComponent} camera
	 * @returns {Vector2}
	 */
	getPixelSpacePosition(camera) {
		const pos = this._pixelSpacePosition.get(camera);
		if (pos !== undefined) {
			return pos;
		}
		return _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2[NaN];
	}

	/**
	 * Gets the normal-space occlusion radius. Returns Number.NaN if there is no occlusion radius for that camera.
	 * @param {CameraComponent} camera
	 * @returns {number}
	 */
	getNormalSpaceOcclusionRadius(camera) {
		if (this._extentsRadius !== 0) {
			// Since normal-space radii are proportional to entity-space radii,
			// we can just use the normal-space extents radius and multiply the factor.
			return this.getNormalSpaceExtentsRadius(camera) * this._occlusionRadius / this._extentsRadius;
		}
		else {
			return 0;
		}
	}

	/**
	 * Gets the normal-space extents radius. Returns Number.NaN if there is no extents radius for that camera.
	 * @param {CameraComponent} camera
	 * @returns {number}
	 */
	getNormalSpaceExtentsRadius(camera) {
		const radius = this._normalSpaceExtentsRadius.get(camera);
		if (radius !== undefined) {
			return radius;
		}
		else {
			return Number.NaN;
		}
	}

	/**
	 * Gets the pixel-space occlusion radius. Returns Number.NaN if there is no occlusion radius for that camera.
	 * @param {CameraComponent} camera
	 * @returns {number}
	 */
	getPixelSpaceOcclusionRadius(camera) {
		if (this._extentsRadius !== 0) {
			// Since pixel-space radii are proportional to entity-space radii,
			// we can just use the pixel-space extents radius and multiply the factor.
			return this.getPixelSpaceExtentsRadius(camera) * this._occlusionRadius / this._extentsRadius;
		}
		else {
			return 0;
		}
	}

	/**
	 * Gets the pixel-space extents radius. Returns Number.NaN if there is no extents radius for that camera.
	 * @param {CameraComponent} camera
	 * @returns {number}
	 */
	getPixelSpaceExtentsRadius(camera) {
		const radius = this._pixelSpaceExtentsRadius.get(camera);
		if (radius !== undefined) {
			return radius;
		}
		else {
			return Number.NaN;
		}
	}

	/**
	 * Gets the greatest pixel-space occlusion radius in all cameras.
	 * @returns {number}
	 */
	getGreatestPixelSpaceOcclusionRadius() {
		if (this._extentsRadius !== 0) {
			// Since pixel-space radii are proportional to entity-space radii,
			// we can just use the pixel-space extents radius and multiply the factor.
			return this.getGreatestPixelSpaceExtentsRadius() * this._occlusionRadius / this._extentsRadius;
		}
		else {
			return 0;
		}
	}

	/**
	 * Gets the greatest pixel-space extents radius in all cameras.
	 * @returns {number}
	 */
	getGreatestPixelSpaceExtentsRadius() {
		return this._greatestPixelSpaceExtentsRadius;
	}

	/**
	 * Sets the camera dependent variables.
	 * @param {CameraComponent} camera
	 * @param {Vector3} newCameraSpacePosition
	 * @internal
	 */
	__setCameraDependentVariables(camera, newCameraSpacePosition) {
		// Get the viewport using the camera, and if none, do nothing.
		const viewport = camera.getViewport();
		if (viewport === null) {
			return;
		}

		// Do the camera-space position.
		let cameraSpacePosition = this._cameraSpacePosition.get(camera);
		if (cameraSpacePosition === undefined) {
			cameraSpacePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			this._cameraSpacePosition.set(camera, cameraSpacePosition);
		}
		else {
			cameraSpacePosition.thaw();
		}
		cameraSpacePosition.copy(newCameraSpacePosition);
		cameraSpacePosition.freeze();

		// Do the normal-space position.
		let normalSpacePosition = this._normalSpacePosition.get(camera);
		if (normalSpacePosition === undefined) {
			normalSpacePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			this._normalSpacePosition.set(camera, normalSpacePosition);
		}
		else {
			normalSpacePosition.thaw();
		}
		camera.getNormalSpacePositionFromCameraSpacePosition(normalSpacePosition, cameraSpacePosition);
		normalSpacePosition.freeze();

		// Do the pixel-space position.
		let pixelSpacePosition = this._pixelSpacePosition.get(camera);
		if (pixelSpacePosition === undefined) {
			pixelSpacePosition = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2();
			this._pixelSpacePosition.set(camera, pixelSpacePosition);
		}
		else {
			pixelSpacePosition.thaw();
		}
		viewport.getPixelSpacePositionFromNormalSpacePosition(pixelSpacePosition, normalSpacePosition);
		pixelSpacePosition.freeze();

		// Do the normal-space extents radius.
		const normalSpaceExtentsRadius = camera.getNormalSpaceRadiusFromRadius(this._extentsRadius, cameraSpacePosition.magnitude());
		this._normalSpaceExtentsRadius.set(camera, normalSpaceExtentsRadius);

		// Do the pixel-space extents radius.
		const pixelSpaceExtentsRadius = viewport.getPixelSpaceRadiusFromNormalSpaceRadius(normalSpaceExtentsRadius);
		this._pixelSpaceExtentsRadius.set(camera, pixelSpaceExtentsRadius);
	}

	/**
	 * Removes the camera from any camera-dependent variables. Called during camera clean up.
	 * @param {CameraComponent} camera
	 * @internal	*/
	__removeCameraDependents(camera) {
		this._cameraSpacePosition.delete(camera);
		this._normalSpacePosition.delete(camera);
		this._pixelSpacePosition.delete(camera);
		this._normalSpaceExtentsRadius.delete(camera);
		this._pixelSpaceExtentsRadius.delete(camera);
		for (let i = 0; i < this._components.size; i++) {
			this._components.get(i).__removeCameraDependentsBase(camera);
		}
	}

	// GET

	/**
	 * Gets the component or controller described in the parameters. It is a shortcut function to make things easier on the user. It returns undefined if it is not found.
	 * @param {string} componentOrControllerType - the type of the component or controller [optional]
	 * @param {number} [componentOrControllerTypeIndex=0] - the index of the type, in case there are more than one of the same type [optional]
	 * @returns {BaseComponent|BaseController}
	 */
	get(componentOrControllerType, componentOrControllerTypeIndex = 0) {
		const component = this._components.getByType(componentOrControllerType, componentOrControllerTypeIndex);
		if (component !== null) {
			return component;
		}
		else {
			return this._controllers.getByType(componentOrControllerType, componentOrControllerTypeIndex);
		}
	}

	// LOADING

	/**
	 * Returns a new promise that resolves when every component is loaded.
	 * @returns {Promise<void>}
	 */
	getLoadedPromise() {
		const promises = [];
		if (this.isEnabled()) {
			for (let i = 0; i < this._controllers.size; i++) {
				promises.push(this._controllers.get(i).getLoadedPromise());
			}
			for (let i = 0; i < this._components.size; i++) {
				promises.push(this._components.get(i).getLoadedPromise());
			}
		}
		return Promise.all(promises).then();
	}

	/**
	 * Converts the entity to a nice string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		return this.getName();
	}

	// CLEANUP

	/**
	 * Destroys the entity resources.
	 * @override
	 * @internal
	 */
	__destroy() {
		// Set the destroyed flag to true.
		this._destroyed = true;

		// Call super.
		super.__destroy();

		// Disconnect all of the children from this.
		for (let i = 0; i < this._children.length; i++) {
			this._children[i].setParent(null);
		}
		// Disconnect this from its parent.
		if (this._parent !== null) {
			this.setParent(null);
		}
		// Destroy the controllers.
		this._controllers.__destroy();
		// Destroy the components.
		this._components.__destroy();
	}

	// MAIN LOOP FUNCTIONS

	/**
	 * Updates the parents of the entity via the controllers.
	 * @param {number} currentTime
	 * @internal
	 */
	__updateParent(currentTime) {
		const parentName = this.getParentAtTime(currentTime);
		if (parentName !== '') {
			const parent = this.getScene().getEntity(parentName);
			if (parent !== this._parent) {
				this.setParent(parent);
			}
		}
		else if (this._parent !== null) {
			this.setParent(null);
		}

		if (this._parent !== this._lastParent) {
			// Notify the controller dependency graph that it needs resorting.
			this.getScene().getControllerDependencyGraph().needsSorting();
			this._lastParent = this._parent;
		}
	}

	/**
	 * Updates the flags that are true if the entity's coverages contain the current time.
	 * @param {number} currentTime
	 * @internal
	 */
	__updateIsInCoverages(currentTime) {
		this._isInPositionCoverage = this._positionCoverage.contains(currentTime);
		this._isInOrientationCoverage = this._orientationCoverage.contains(currentTime);

		// Update the component load states, which depends on the position and orientation coverage.
		for (let i = 0; i < this._components.size; i++) {
			this._components.get(i).__updateLoadState();
		}
	}

	/**
	 * Updates the greatest pixel-space radii and the camera-non-specific parts of the components.
	 * @internal
	 */
	__updateVisuals() {
		// Update the greatest pixel extents radius for use by components and controllers.
		this._greatestPixelSpaceExtentsRadius = 0.0;
		for (let i = 0, l = this._pixelSpaceExtentsRadius.size; i < l; i++) {
			const pixelSpaceExtentsRadius = this._pixelSpaceExtentsRadius.getAt(i).value;
			if (this._greatestPixelSpaceExtentsRadius < pixelSpaceExtentsRadius) {
				this._greatestPixelSpaceExtentsRadius = pixelSpaceExtentsRadius;
			}
		}

		// Updates the camera-independent parts of the components.
		for (let i = 0, l = this._components.size; i < l; i++) {
			const component = this._components.get(i);
			if (component.isEnabled()) {
				component.__updateBase();
			}
		}
	}

	/**
	 * It traverses the scene graph, starting with the camera, setting the camera-space positions, and updating the occlusion.
	 * @param {CameraComponent} camera - the camera we're rendering
	 * @param {Entity} comingFrom - the entity we just came from
	 * @param {boolean} comingFromChild - true if comingFrom is a child of this
	 * @internal
	 */
	__updateCameraVariables(camera, comingFrom, comingFromChild) {
		if (this.isEnabled()) {
			// Update this camera-space position relative to the child that we're coming from.
			const cameraSpacePosition = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			if (this === camera.getEntity()) {
				// We're the camera, so we're always at the camera-space origin.
				cameraSpacePosition.set(0, 0, 0);
			}
			else if (comingFromChild) {
				// We're moving up the scene graph toward the root, so we get the child's world position and add the negative position.
				cameraSpacePosition.sub(comingFrom.getCameraSpacePosition(camera), comingFrom.getPosition());
			}
			else {
				// We're moving down the scene graph, so we just add on the local to the parent world position.
				cameraSpacePosition.add(comingFrom.getCameraSpacePosition(camera), this._state.position);
			}
			this.__setCameraDependentVariables(camera, cameraSpacePosition);

			// Add the entity to the occluding entities if its radius is large enough.
			if (this._canOcclude && this.getPixelSpaceOcclusionRadius(camera) >= 1) {
				camera.__addToOccludingEntities(this);
			}
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraSpacePosition);

			// Updates the camera-dependent parts of the components.
			for (let i = 0, l = this._components.size; i < l; i++) {
				const component = this._components.get(i);
				if (component !== camera && component.isEnabled()) {
					component.__updateCameraVariablesBase(camera);
				}
			}
		}

		// Update the parent if we're still going up. Update the parent position.
		if (this._parent !== null && (comingFromChild || this === camera.getEntity())) {
			this._parent.__updateCameraVariables(camera, this, true);
		}

		// Update the children.
		for (let i = 0, l = this._children.length; i < l; i++) {
			const child = this._children[i];
			if (child === comingFrom) {
				continue; // don't go back down a child that we've already updated.
			}
			child.__updateCameraVariables(camera, this, false);
		}
	}

	/**
	 * Prepares all of its components for rendering.
	 * @param {CameraComponent} camera - the camera we're rendering
	 * @internal
	 */
	__prepareForRender(camera) {
		// Prepare the components for render.
		for (let i = 0, l = this._components.size; i < l; i++) {
			const component = this._components.get(i);
			if (!('__render' in component)) {
				component.__prepareForRenderBase(camera);
			}
		}
	}
}

class EntityState {
	constructor() {
		/**
		 * The position of the entity relative to its parent's position.
		 * @type {Vector3}
		 */
		this.position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(Number.NaN, Number.NaN, Number.NaN);
		this.position.freeze();

		/**
		* The velocity of the entity.
		* @type {Vector3}
		*/
		this.velocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(Number.NaN, Number.NaN, Number.NaN);
		this.velocity.freeze();

		/**
		* The orientation of the entity. Not relative to parent.
		* @type {Quaternion}
		*/
		this.orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion(Number.NaN, Number.NaN, Number.NaN, Number.NaN);
		this.orientation.freeze();

		/**
		* The rotational velocity of the entity. Not relative to parent.
		* @type {Vector3}
		*/
		this.angularVelocity = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3(Number.NaN, Number.NaN, Number.NaN);
		this.angularVelocity.freeze();
	}
}

// Functions for the start time to parent list sorting.

/**
 * Returns true if a < b.
 * @param {[number, string]} a
 * @param {[number, string]} b
 */
function isStartTimeLess(a, b) {
	return a[0] < b[0];
}

/**
 * Returns true if a === b.
 * @param {[number, string]} a
 * @param {[number, string]} b
 */
function isStartTimeEqual(a, b) {
	return a[0] === b[0];
}

/**
 * Returns true if a < b.
 * @param {[number, string]} a
 * @param {number} b
 */
function isStartTimeLessThanTime(a, b) {
	return a[0] < b;
}


/***/ }),

/***/ "../pioneer/engine/src/scene/entity_item.js":
/*!**************************************************!*\
  !*** ../pioneer/engine/src/scene/entity_item.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EntityItem": function() { return /* binding */ EntityItem; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The base class for all components and controllers.
 * @extends {CollectionItem<Entity>}
 */
class EntityItem extends _internal__WEBPACK_IMPORTED_MODULE_0__.CollectionItem {
	/**
	 * Constructor.
	 * @param {string} type - The type of the entity item.
	 * @param {string} name - The name of the entity item.
	 * @param {Entity} entity - The containing entity.
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * Flag that indicates whether the entity item is enabled or disabled.
		 * @type {boolean}
		 * @private
		*/
		this._enabled = true;

		/**
		 * Flag that indicates whether the item has been destroyed.
		 * @type {boolean}
		 * @private
		 */
		this._destroyed = false;
	}

	/**
	 * Returns the entity that contains the entity item.
	 * @returns {Entity}
	 */
	getEntity() {
		return this.__getCollectionParent();
	}

	/**
	 * Checks if the entity item has been destroyed.
	 * @returns {boolean}
	 */
	isDestroyed() {
		return this._destroyed;
	}

	/**
	 * Destroys the entity item's resources.
	 * @override
	 * @abstract
	 */
	__destroy() {
		this._destroyed = true;
		super.__destroy();
	}

	/**
	 * Returns true if the entity item is enabled.
	 * @returns {boolean}
	 */
	isEnabled() {
		return this._enabled;
	}

	/**
	 * Sets whether the entity item is enabled.
	 * @param {boolean} enabled
	 */
	setEnabled(enabled) {
		this._enabled = enabled;
	}

	/**
	 * Returns a new promise that resolves when the component is loaded.
	 * @returns {Promise<void>}
	 */
	getLoadedPromise() {
		return Promise.resolve();
	}

	/**
	 * Updates the entity item.
	 * @abstract
	 */
	__update() {
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/scene.js":
/*!********************************************!*\
  !*** ../pioneer/engine/src/scene/scene.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Scene": function() { return /* binding */ Scene; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The scene which contains all entities.
 * @extends {CollectionItem<Engine>}
 */
class Scene extends _internal__WEBPACK_IMPORTED_MODULE_0__.CollectionItem {
	/**
	 * Constructs the scene.
	 * @param {string} type - the type of the scene (always 'scene');
	 * @param {string} name - the name of the scene
	 * @param {Engine} engine - the Pioneer engine
	 */
	constructor(type, name, engine) {
		super(type, name, engine);

		/**
		 * The collection of entities.
		 * @type {Collection<Entity, Scene>}
		 * @private
		*/
		this._entities = new _internal__WEBPACK_IMPORTED_MODULE_0__.Collection(this, new Map([['entity', _internal__WEBPACK_IMPORTED_MODULE_0__.Entity]]));

		/**
		 * The controller dependency graph.
		 * @type {DependencyGraph<BaseController>}
		 * @private
		 */
		this._controllerDependencyGraph = new _internal__WEBPACK_IMPORTED_MODULE_0__.DependencyGraph();

		/**
		 * The ambient light color. The amount of light when there are no light sources.
		 * @type {Color}
		 * @private
		 */
		this._ambientLightColor = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0.02, 0.02, 0.02);
		this._ambientLightColor.freeze();

		/**
		 * The list of light sources.
		 * @type {Array<ComponentRef<LightSourceComponent>>}
		 * @private
		 */
		this._lightSources = [];

		/**
		 * The ThreeJS scene.
		 * @type {THREE.Scene}
		 * @private
		 */
		this._threeJsScene = null;

		// Initialize Three.JS
		this._threeJsScene = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Scene();

		// Setup the controller dependency graph functions.
		this._controllerDependencyGraph.setUpdateItemCallback((controller) => {
			if (controller.getEntity().isEnabled() && controller.getCoverage().contains(controller.getEntity().getScene().getEngine().getTime()) && controller.isEnabled()) {
				controller.__update();
			}
		});
		this._controllerDependencyGraph.setCompareItemCallback((a, b) => {
			if (a === b) {
				return false;
			}
			if (!a.getEntity().isEnabled() || !b.getEntity().isEnabled() || !a.isEnabled() || !b.isEnabled()) {
				return false;
			}
			const time = a.getEntity().getScene().getEngine().getTime();
			if (!a.getCoverage().contains(time) || !b.getCoverage().contains(time)) {
				return false;
			}

			// Ensure that later controllers in an entity are dependent on earlier controllers.
			if (a.getEntity() === b.getEntity()) {
				const entity = a.getEntity();
				for (let i = 0, l = entity.getNumControllers(); i < l; i++) {
					const controller = entity.getController(i);
					if (b === controller) {
						return true;
					}
					if (a === controller) {
						break;
					}
				}
			}

			// Children's controllers are dependent on parent's controllers for position and velocity.
			if (a.getEntity().getParent() === b.getEntity()) {
				if ((a.hasModifiedState('position') && b.hasModifiedState('position')) || (a.hasModifiedState('velocity') && b.hasModifiedState('velocity'))) {
					return true;
				}
				// A special case for 'parent' as a shortcut to whatever the parent is, since it happens so often.
				for (const modifiedState of b.__modifiedStates) {
					if (a.hasDependentState('parent', modifiedState)) {
						return true;
					}
				}
			}

			// Check if a's dependent states are in b's modified states.
			for (const modifiedState of b.__modifiedStates) {
				if (a.hasDependentState(b.getEntity().getName(), modifiedState)) {
					return true;
				}
			}

			return false;
		});
	}

	/**
	 * Returns the engine.
	 * @returns {Engine}
	 */
	getEngine() {
		return this.__getCollectionParent();
	}

	/**
	 * Gets an entity by name.
	 * @param {string|number} nameOrIndex - the name or index of the entity
	 * @returns {Entity}
	 */
	getEntity(nameOrIndex) {
		return this._entities.get(nameOrIndex);
	}

	/**
	 * Gets the number of entities.
	 * @returns {number}
	*/
	getNumEntities() {
		return this._entities.size;
	}

	/**
	 * Adds an entity.
	 * @param {string} name - the name of the entity to be added
	 * @returns {Entity}
	 */
	addEntity(name) {
		return this._entities.add('entity', name);
	}

	/**
	 * Removes an entity.
	 * @param {Entity|string|number} entityOrNameOrIndex - the entity, name, or index to be removed
	 */
	removeEntity(entityOrNameOrIndex) {
		this._entities.remove(entityOrNameOrIndex);
	}

	/**
	 * Moves an entity to another scene.
	 * @param {Entity|string|number} entityOrNameOrIndex - the entity, name, or index to be moved
	 * @param {Scene} scene - the other scene to which the entity will be moved
	 */
	moveEntity(entityOrNameOrIndex, scene) {
		const entity = this._entities.get(entityOrNameOrIndex);
		this._entities.move(entityOrNameOrIndex, scene._entities);
		// Update the controller dependency graph for both.
		for (let i = 0, l = entity.getNumControllers(); i < l; i++) {
			this._controllerDependencyGraph.removeItem(entity.getController(i));
			scene._controllerDependencyGraph.addItem(entity.getController(i));
		}
		// Update any light sources.
		for (let i = 0, l = entity.getNumComponents(); i < l; i++) {
			const component = entity.getComponent(i);
			if (component.getType() === 'lightSource' && component.getLoadState() === 'loaded') {
				for (let j = 0, k = this._lightSources.length; j < k; j++) {
					if (this._lightSources[j].getEntityName() === entity.getName()
						&& this._lightSources[j].getComponentTypeIndex() === component.getTypeIndex()) {
						this.__removeLightSource(entity.getName(), component.getTypeIndex());
						this.__addLightSource(entity.getName(), component.getTypeIndex());
						break;
					}
				}
			}
		}
	}

	/**
	 * Gets the entity, component, or controller described in the parameters. If the component/controller type is omitted, it will return the entity. It is a shortcut function to make things easier on the user. It returns undefined if it is not found.
	 * @param {string} entityNameOrIndex - the name or index of the entity
	 * @param {string?} componentOrControllerType - the type of the component or controller [optional]
	 * @param {number?} componentOrControllerTypeIndex - the index of the type, in case there are more than one of the same type [optional]
	 * @returns {Entity|BaseComponent|BaseController}
	 */
	get(entityNameOrIndex, componentOrControllerType = undefined, componentOrControllerTypeIndex = 0) {
		const entity = this._entities.get(entityNameOrIndex);
		if (componentOrControllerType === undefined || entity === null) {
			return entity;
		}
		return entity.get(componentOrControllerType, componentOrControllerTypeIndex);
	}

	/**
	 * Gets the controller dependency graph.
	 * @returns {DependencyGraph<BaseController>}
	 */
	getControllerDependencyGraph() {
		return this._controllerDependencyGraph;
	}

	/**
	 * Gets the ambient light color. Defaults to RGB(0.02, 0.02, 0.02).
	 * @returns {Color}
	 */
	getAmbientLightColor() {
		return this._ambientLightColor;
	}

	/**
	 * Sets the ambient light color.
	 * @param {Color} color
	 */
	setAmbientLightColor(color) {
		this._ambientLightColor.thaw();
		this._ambientLightColor.copy(color);
		this._ambientLightColor.freeze();
	}

	/**
	 * Adds a light source. Does nothing if it already is added. It should only be called by the LightSourceComponent.
	 * @param {string} entityName - The name of the entity that has the light source.
	 * @param {number} typeIndex - If there is more than one light source component on an entity, this specifies which one.
	 * @internal
	 */
	__addLightSource(entityName, typeIndex = 0) {
		// If there is already a light source of the given entity name and type index, do nothing.
		for (let i = 0, l = this._lightSources.length; i < l; i++) {
			const otherLightSource = this._lightSources[i];
			if (otherLightSource.getEntityName() === entityName
				&& otherLightSource.getComponentTypeIndex() === typeIndex) {
				throw new Error(`Light source on ${entityName} with type index ${typeIndex} already added.`);
			}
		}
		// Add the new light source.
		const lightSource = /** @type {ComponentRef<LightSourceComponent>} */(new _internal__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this));
		lightSource.setByType(entityName, 'lightSource', typeIndex);
		this._lightSources.push(lightSource);
	}

	/**
	 * Removes a light source. Does nothing if it already is removed. It should only be called by the LightSourceComponent.
	 * @param {string} entityName - The name of the entity that has the light source.
	 * @param {number} typeIndex - If there is more than one light source component on an entity, this specifies which one.
	 * @internal
	 */
	__removeLightSource(entityName, typeIndex = 0) {
		for (let i = 0, l = this._lightSources.length; i < l; i++) {
			const otherLightSource = this._lightSources[i];
			if (otherLightSource.getEntityName() === entityName
				&& otherLightSource.getComponentTypeIndex() === typeIndex) {
				// Remove the light source.
				this._lightSources.splice(i, 1);
				return;
			}
		}
		throw new Error(`Light source on ${entityName} with type index ${typeIndex} not found.`);
	}

	/**
	 * Gets the light source at index i.
	 * @param {number} i
	 * @returns {LightSourceComponent}
	 */
	getLightSource(i) {
		if (0 <= i && i < this._lightSources.length) {
			return this._lightSources[i].get();
		}
		return null;
	}

	/**
	 * Gets the number of light sources.
	 * @returns {number}
	 */
	getNumLightSources() {
		return this._lightSources.length;
	}

	/**
	 * Returns a new promise that resolves when every entity is loaded.
	 * @returns {Promise<void>}
	 */
	getLoadedPromise() {
		const promises = [];
		for (let i = 0, l = this._entities.size; i < l; i++) {
			promises.push(this._entities.get(i).getLoadedPromise());
		}
		return Promise.all(promises).then();
	}

	/**
	 * Cleans up the scene.
	 * @override
	 * @internal
	 */
	__destroy() {
		super.__destroy();

		this._entities.__destroy();
	}

	/**
	 * Returns the ThreeJS scene so that components can use it.
	 * @returns {THREE.Scene}
	 */
	getThreeJsScene() {
		return this._threeJsScene;
	}

	/**
	 * Updates the scene. Updates parents, is-in-coverages, and calls update on all entities' controllers using the dependency graph.
	 * @internal
	 */
	__update() {
		const currentTime = this.getEngine().getTime();
		for (let i = this._entities.size - 1; i >= 0; i--) {
			const entity = this._entities.get(i);
			entity.__updateLastState();
			entity.__updateParent(currentTime);
			entity.__updateIsInCoverages(currentTime);
		}

		this._controllerDependencyGraph.update();
	}

	/**
	 * Updates the camera-non-specific visual parts of the entities.
	 * @internal
	 */
	__updateVisuals() {
		for (let i = this._entities.size - 1; i >= 0; i--) {
			const entity = this._entities.get(i);
			if (entity.isInPositionCoverage() && entity.isEnabled()) {
				this._entities.get(i).__updateVisuals();
			}
		}
	}

	/**
	 * Removes the camera from any camera-dependent variables. Called by camera on clean up.
	 * @param {CameraComponent} camera
	 * @internal	*/
	__removeCameraDependents(camera) {
		for (let i = this._entities.size - 1; i >= 0; i--) {
			this._entities.get(i).__removeCameraDependents(camera);
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/scene/types.js":
/*!********************************************!*\
  !*** ../pioneer/engine/src/scene/types.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Types": function() { return /* binding */ Types; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The class that holds the different mappings from component and controller names to their corresponding constructors.
 */
class Types {
}

/**
 * @typedef {typeof Pioneer.BaseComponent} BaseComponentType
 */

/**
 * The mapping of component type names to component constructors.
 * @type {Map<string, BaseComponentType>}
 * @internal
 */
Types.Components = new Map();
Types.Components.set('atmosphere', _internal__WEBPACK_IMPORTED_MODULE_0__.AtmosphereComponent);
Types.Components.set('camera', _internal__WEBPACK_IMPORTED_MODULE_0__.CameraComponent);
Types.Components.set('cmts', _internal__WEBPACK_IMPORTED_MODULE_0__.CMTSComponent);
Types.Components.set('cometTail', _internal__WEBPACK_IMPORTED_MODULE_0__.CometTailComponent);
Types.Components.set('connectedSprite', _internal__WEBPACK_IMPORTED_MODULE_0__.ConnectedSpriteComponent);
Types.Components.set('div', _internal__WEBPACK_IMPORTED_MODULE_0__.DivComponent);
Types.Components.set('dynEnvMap', _internal__WEBPACK_IMPORTED_MODULE_0__.DynamicEnvironmentMapComponent);
Types.Components.set('gizmo', _internal__WEBPACK_IMPORTED_MODULE_0__.GizmoComponent);
Types.Components.set('label', _internal__WEBPACK_IMPORTED_MODULE_0__.LabelComponent);
Types.Components.set('lightSource', _internal__WEBPACK_IMPORTED_MODULE_0__.LightSourceComponent);
Types.Components.set('model', _internal__WEBPACK_IMPORTED_MODULE_0__.ModelComponent);
Types.Components.set('orbitalParticles', _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalParticlesComponent);
Types.Components.set('particleSpray', _internal__WEBPACK_IMPORTED_MODULE_0__.ParticleSprayComponent);
Types.Components.set('rings', _internal__WEBPACK_IMPORTED_MODULE_0__.RingsComponent);
Types.Components.set('skybox', _internal__WEBPACK_IMPORTED_MODULE_0__.SkyboxComponent);
Types.Components.set('spheroid', _internal__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent);
Types.Components.set('spheroidLOD', _internal__WEBPACK_IMPORTED_MODULE_0__.SpheroidLODComponent);
Types.Components.set('spout', _internal__WEBPACK_IMPORTED_MODULE_0__.SpoutComponent);
Types.Components.set('sprite', _internal__WEBPACK_IMPORTED_MODULE_0__.SpriteComponent);
Types.Components.set('starfield', _internal__WEBPACK_IMPORTED_MODULE_0__.StarfieldComponent);
Types.Components.set('trail', _internal__WEBPACK_IMPORTED_MODULE_0__.TrailComponent);

/**
 * @typedef {typeof Pioneer.BaseController} BaseControllerType
 */

/**
 * The mapping of controller type names to controller constructors.
 * @type {Map<string, BaseControllerType>}
 * @internal
 */
Types.Controllers = new Map();
Types.Controllers.set('align', _internal__WEBPACK_IMPORTED_MODULE_0__.AlignController);
Types.Controllers.set('animdata', _internal__WEBPACK_IMPORTED_MODULE_0__.AnimdataController);
Types.Controllers.set('coverage', _internal__WEBPACK_IMPORTED_MODULE_0__.CoverageController);
Types.Controllers.set('dynamo', _internal__WEBPACK_IMPORTED_MODULE_0__.DynamoController);
Types.Controllers.set('fixed', _internal__WEBPACK_IMPORTED_MODULE_0__.FixedController);
Types.Controllers.set('fixedToParent', _internal__WEBPACK_IMPORTED_MODULE_0__.FixedToParentController);
Types.Controllers.set('freeFly', _internal__WEBPACK_IMPORTED_MODULE_0__.FreeFlyController);
Types.Controllers.set('groundClamp', _internal__WEBPACK_IMPORTED_MODULE_0__.GroundClampController);
Types.Controllers.set('keyframe', _internal__WEBPACK_IMPORTED_MODULE_0__.KeyframeController);
Types.Controllers.set('look', _internal__WEBPACK_IMPORTED_MODULE_0__.LookController);
Types.Controllers.set('modelAnimate', _internal__WEBPACK_IMPORTED_MODULE_0__.ModelAnimateController);
Types.Controllers.set('orbit', _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitController);
Types.Controllers.set('orbitKeyframe', _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitKeyframeController);
Types.Controllers.set('orbitalElements', _internal__WEBPACK_IMPORTED_MODULE_0__.OrbitalElementsController);
Types.Controllers.set('pick', _internal__WEBPACK_IMPORTED_MODULE_0__.PickController);
Types.Controllers.set('roll', _internal__WEBPACK_IMPORTED_MODULE_0__.RollController);
Types.Controllers.set('rotate', _internal__WEBPACK_IMPORTED_MODULE_0__.RotateController);
Types.Controllers.set('rotateByEntityOrientation', _internal__WEBPACK_IMPORTED_MODULE_0__.RotateByEntityOrientationController);
Types.Controllers.set('scale', _internal__WEBPACK_IMPORTED_MODULE_0__.ScaleController);
Types.Controllers.set('select', _internal__WEBPACK_IMPORTED_MODULE_0__.SelectController);
Types.Controllers.set('setParent', _internal__WEBPACK_IMPORTED_MODULE_0__.SetParentController);
Types.Controllers.set('spin', _internal__WEBPACK_IMPORTED_MODULE_0__.SpinController);
Types.Controllers.set('tap', _internal__WEBPACK_IMPORTED_MODULE_0__.TapController);
Types.Controllers.set('transition', _internal__WEBPACK_IMPORTED_MODULE_0__.TransitionController);
Types.Controllers.set('translate', _internal__WEBPACK_IMPORTED_MODULE_0__.TranslateController);
Types.Controllers.set('zoom', _internal__WEBPACK_IMPORTED_MODULE_0__.ZoomController);




/***/ }),

/***/ "../pioneer/engine/src/shaders/basic.js":
/*!**********************************************!*\
  !*** ../pioneer/engine/src/shaders/basic.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicShader": function() { return /* binding */ BasicShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const BasicShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		color: 'vec4',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
		attribute vec3 position;
		uniform mat4 modelViewMatrix;
		uniform mat4 projectionMatrix;

		${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

		void main() {
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
		}
			`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			uniform vec4 color;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

			void main() {
				gl_FragColor = color;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/basic_alpha.js":
/*!****************************************************!*\
  !*** ../pioneer/engine/src/shaders/basic_alpha.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BasicAlphaShader": function() { return /* binding */ BasicAlphaShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const BasicAlphaShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		color: 'vec4',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		transparent: true,
		depthWrite: false,
		side: 'double',
		blending: 'normal'
	},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			attribute vec3 position;
			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}
			`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			uniform vec4 color;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}
	
			void main() {
				gl_FragColor = color;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/connected_sprite.js":
/*!*********************************************************!*\
  !*** ../pioneer/engine/src/shaders/connected_sprite.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConnectedSpriteShader": function() { return /* binding */ ConnectedSpriteShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const ConnectedSpriteShader = {
	uniforms: {
		projectionMatrix: 'highp mat4',
		vAxis: 'vec3',
		color: 'vec4',
		colorTexture: 'sampler2D',
		width1: 'float',
		width2: 'float',
		textureYOffset: 'float',
		repeatAmount: 'float',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		side: 'double',
		transparent: true,
		depthWrite: false,
		blending: 'normal'
	},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			attribute vec2 position;

			uniform mat4 modelMatrix;
			uniform mat4 viewMatrix;
			uniform mat4 projectionMatrix;

			uniform vec3 vAxis;
			uniform float width1;
			uniform float width2;

			varying vec2 vPosition;
			varying float vU;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			void main() {

				// Get the horizontal axis.
				float width = mix(width1, width2, position.y);
				vec3 viewVAxis = (viewMatrix * vec4(vAxis, 0)).xyz;
				vec2 viewHAxisXZ = normalize(cross(vec3(0, 1, 0), viewVAxis)).xz;
				vec4 viewHAxis = vec4(viewHAxisXZ.x, 0, viewHAxisXZ.y, 0);

				// Get the view position.
				vec4 modelPosition = modelMatrix * vec4(0, 0, 0, 1) + vec4(vAxis, 0) * position.y;
				vec4 viewPosition = viewMatrix * modelPosition;

				// Set the final projected position.
				gl_Position = projectionMatrix * viewPosition + projectionMatrix * viewHAxis * width * position.x;

				// Setup a vPosition and vU for use in the fragment shader.
				vPosition = vec2(0.5 * (position.x + 1.0), position.y);
				#ifdef PIXEL_BASED
					vPosition.y *= abs(gl_Position.w);
				#endif
				vU = position.y;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			uniform vec4 color;
			uniform sampler2D colorTexture;
			uniform float width1;
			uniform float width2;
			uniform float textureYOffset;
			uniform float repeatAmount;

			varying vec2 vPosition;
			varying float vU;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

			void main() {

				// If we're using pixel-based, we need to undo the perspective divide that happened.
				#ifdef PIXEL_BASED
					vec2 uv = vec2(vPosition.x, vPosition.y * gl_FragCoord.w);
				#else
					vec2 uv = vPosition;
				#endif

				// Get a correct use that uses the repeat amount and y offset.
				// There's a complicated formula, because the widths may be different and the shape of the sprite may be a trapezoid.
				float f = width2 * vU / (width1 * (1.0 - vU) + width2 * vU);
				float uFactor = step(vU, uv.x);
				uv.x = (1.0 - uFactor) * uv.x * f / vU + uFactor * (1.0 + (uv.x - 1.0) * (1.0 - f) / (1.0 - vU));
				uv.y = uv.y * repeatAmount + textureYOffset;

				// Apply the texture and color.
				gl_FragColor = color * texture2D(colorTexture, uv);

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/line.js":
/*!*********************************************!*\
  !*** ../pioneer/engine/src/shaders/line.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineShader": function() { return /* binding */ LineShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const LineShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		pixelSize: 'vec2',
		alphaMultiplier: 'float',
		dashLength: 'float',
		dashGapLength: 'float',
		glowWidth: 'float',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		transparent: true,
		depthWrite: false,
		side: 'double',
		blending: 'additive'
	},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			attribute vec3 position;
			attribute vec3 positionPrev;
			attribute vec3 positionNext;
			attribute vec4 color;
			attribute float width;
			attribute float dashOffset;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;
			uniform vec2 pixelSize;
			uniform float glowWidth;

			varying vec4 fColor;
			varying float fDashOffset;
			varying float fWidth;
			varying float fOffsetScalar;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			void main() {
				// Get the line vertices into pixel space.
				vec4 view_center = modelViewMatrix * vec4(position, 1.0);
				vec4 view_prev = modelViewMatrix * vec4(positionPrev, 1.0);
				vec4 view_next = modelViewMatrix * vec4(positionNext, 1.0);
				vec4 projected_center = projectionMatrix * view_center;
				vec4 projected_prev = projectionMatrix * view_prev;
				vec4 projected_next = projectionMatrix * view_next;
				vec2 ndc_center = projected_center.xy / view_center.y;
				vec2 ndc_prev = projected_prev.xy / view_prev.y;
				vec2 ndc_next = projected_next.xy / view_next.y;
				vec2 pixel_center = (ndc_center.xy + 1.0) / 2.0 * pixelSize;
				vec2 pixel_prev = (ndc_prev.xy + 1.0) / 2.0 * pixelSize;
				vec2 pixel_next = (ndc_next.xy + 1.0) / 2.0 * pixelSize;

				// Get the offset of the part perpendicular to the lines.
				vec2 l0 = normalize(pixel_center - pixel_prev);
				vec2 l1 = normalize(pixel_next - pixel_center);
				float offsetScalar = sign(width) * (abs(width) / 2.0 + glowWidth);
				vec2 offset = vec2(offsetScalar, offsetScalar);
				if (pixel_center == pixel_prev) {
					if (pixel_center == pixel_next) {
						offset = vec2(0.0, 0.0);
					}
					else {
						offset *= vec2(-l1.y, l1.x);
					}
				}
				else if (pixel_center == pixel_next) {
					offset *= vec2(-l0.y, l0.x);
				}
				else {
					offset *= normalize(vec2(-l0.y - l1.y, l0.x + l1.x));
					offset /= max(0.25, sqrt((1.0 + dot(l0, l1)) / 2.0));
				}

				// Re-add the perpendicular part to the center as the final vertex.
				ndc_center = (pixel_center + offset) / pixelSize * 2.0 - 1.0;
				gl_Position = vec4(ndc_center * view_center.y, projected_center.z, projected_center.w);

				// Set the varyings.
				fColor = color;
				fDashOffset = dashOffset;
				fWidth = width;
				fOffsetScalar = offsetScalar;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}
			`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			uniform float alphaMultiplier;
			uniform float dashLength;
			uniform float dashGapLength;
			uniform float glowWidth;

			varying vec4 fColor;
			varying float fDashOffset;
			varying float fWidth;
			varying float fOffsetScalar;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

			float line_dash_func() {
				float u = mod(fDashOffset, dashLength + dashGapLength);
				return float(u < dashLength);
			}

			float edgeGlow() {
				if (glowWidth > 0.0) {
					float value = clamp((fWidth / 2.0 + glowWidth - abs(fOffsetScalar)) / glowWidth, 0.0, 1.0);
					if (value < 1.0) {
						value *= 0.75;
					}
					return value;
				}
				return 1.0;
			}

			void main() {
				gl_FragColor = fColor;
				gl_FragColor.a *= alphaMultiplier * edgeGlow() * line_dash_func();

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/log_depth.js":
/*!**************************************************!*\
  !*** ../pioneer/engine/src/shaders/log_depth.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderChunkLogDepth": function() { return /* binding */ ShaderChunkLogDepth; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ "../pioneer/engine/node_modules/three/build/three.module.js");


class ShaderChunkLogDepth {
	/** Uniforms for the built-in shaders. */
	static Uniforms = {
		invertDepth: 'float',
		nearDistance: 'float',
		midDistance: 'float'
	};

	/** Code for the header of the vertex shader. */
	static VertexHead = `
		#ifdef L_EXT_frag_depth
			varying float depth;
		#else
			uniform float nearDistance;
			uniform float midDistance;
		#endif
	`;

	/** Code for the end of the vertex shader main() function. */
	static Vertex = `
		#ifdef L_EXT_frag_depth
			depth = gl_Position.w;
		#else
			float z = gl_Position.w;
			if (z < midDistance) {
				gl_Position.z = nearDistance * (z - midDistance) / (midDistance - nearDistance);
			}
			else {
				float logFactor = 0.01254291648; // 1 / log2(1e24 - midDistance + 1.0)
				gl_Position.z = log2(z - midDistance + 1.0) * logFactor;
				gl_Position.z *= gl_Position.w;
			}
		#endif
	`;

	/** Code for the header of the fragment shader. */
	static FragmentHead = `
		#ifdef L_EXT_frag_depth
			uniform float invertDepth;
			uniform float nearDistance;
			uniform float midDistance;
			varying float depth;
		#endif
	`;

	/** Code for the end of the fragment shader main() function. */
	static Fragment = `
		#ifdef L_EXT_frag_depth
			float logFactor = 0.01254291648; // 1 / log2(1 + 1e24)
			float nearFactor = 0.5 * (depth - nearDistance) / (midDistance - nearDistance);
			float farFactor = 0.5 * (1.0 + log2(1.0 + depth - midDistance) * logFactor);
			gl_FragDepthEXT = (1.0 - 2.0 * invertDepth) * (depth >= midDistance ? farFactor : nearFactor) + invertDepth;
		#endif
	`;

	/** Three.js uniform variables for custom materials.
	 *  Eventually I'd like to remove the need for this by having every material be in the shaders folder. */
	static ThreeUniforms = {
		invertDepth: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),
		nearDistance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0),
		midDistance: new three__WEBPACK_IMPORTED_MODULE_0__.Uniform(0)
	};
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/plumes.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/shaders/plumes.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PlumesShader": function() { return /* binding */ PlumesShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const PlumesShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		colorTexture: 'sampler2D',
		colorMultiplier: 'vec4',
		speed: 'float',
		time: 'float',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		transparent: true,
		depthWrite: false,
		side: 'double',
		blending: 'normal'
	},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			attribute vec3 position;
			attribute vec2 uv;
			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			varying vec2 vUV;

			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				vUV = uv;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}
			`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			uniform sampler2D colorTexture;
			uniform vec4 colorMultiplier;
			uniform float speed;
			uniform float time;
			varying vec2 vUV;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

			vec2 v2_construct_func(float x, float y) {
				return vec2(x, y);
			}
			float s_mult_func(float s1, float s2) {
				return s1 * s2;
			}
			float s_mod_func(float s1, float s2) {
				return mod(s1, s2);
			}
			vec2 v2s_mult_func(vec2 v, float s) {
				return v * s;
			}
			vec2 v2_add_func(vec2 v1, vec2 v2) {
				return v1 + v2;
			}
			vec4 texture_func(sampler2D tex, vec2 uv) {
				return texture2D(tex, uv);
			}
			vec4 v4v4_mult_func(vec4 v1, vec4 v2) {
				return v1 * v2;
			}
			float s_sub_func(float s1, float s2) {
				return s1 - s2;
			}
			vec4 alpha_mult_func(vec4 color, float alpha) {
				return vec4(color.rgb, color.a * alpha);
			}
			void main() {
				vec2 yAxis = v2_construct_func(0.0, 1.0);
				float yMultiplier = s_mult_func(time, speed);
				float yMultiplierMod = s_mod_func(yMultiplier, 1.0);
				vec2 uvOffset = v2s_mult_func(yAxis, yMultiplierMod);
				vec2 finalUV = v2_add_func(vUV, uvOffset);
				vec4 textureOffset = texture_func(colorTexture, finalUV);
				vec4 color = v4v4_mult_func(textureOffset, colorMultiplier);
				float fade = s_sub_func(1.0, vUV.y);
				vec4 color_with_fade = alpha_mult_func(color, fade);
				gl_FragColor = color_with_fade;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/sprite.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/shaders/sprite.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteShader": function() { return /* binding */ SpriteShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const SpriteShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		pixelBased: 'float',
		color: 'vec4',
		colorTexture: 'sampler2D',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		transparent: true,
		depthWrite: false,
		side: 'double',
		blending: 'normal'
	},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			attribute vec3 position;
			attribute vec2 uv;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;
			uniform float pixelBased;

			varying vec2 vUV;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			void main() {
				gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
				if (pixelBased != 0.0) {
					gl_Position /= abs(gl_Position.w);
				}
				vUV = uv;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}
			`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			uniform vec4 color;
			uniform sampler2D colorTexture;

			varying vec2 vUV;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

			void main() {
				gl_FragColor = texture2D(colorTexture, vUV) * color;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/sprite_particles.js":
/*!*********************************************************!*\
  !*** ../pioneer/engine/src/shaders/sprite_particles.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteParticlesShader": function() { return /* binding */ SpriteParticlesShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const SpriteParticlesShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		transparent: true,
		depthWrite: false,
		side: 'double',
		blending: 'additive'
	},
	vertex: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			attribute vec3 position;
			attribute vec4 color;
			attribute vec3 offset;
			attribute float scale;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			varying vec4 fColor;
			varying vec2 fPosition;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			void main() {
				vec4 viewPosition = modelViewMatrix * vec4(offset, 1.0) + vec4(position, 0.0) * scale;
				gl_Position = projectionMatrix * viewPosition;
				fColor = color;
				fPosition = position.xz;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}
			`
	},
	fragment: {
		extensions: [
			'EXT_frag_depth'
		],
		code: `
			precision highp float;

			varying vec4 fColor;
			varying vec2 fPosition;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

			void main() {
				gl_FragColor = fColor * (1.0 - length(fPosition));

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/shaders/trail.js":
/*!**********************************************!*\
  !*** ../pioneer/engine/src/shaders/trail.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TrailShader": function() { return /* binding */ TrailShader; }
/* harmony export */ });
/* harmony import */ var _log_depth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./log_depth */ "../pioneer/engine/src/shaders/log_depth.js");


const TrailShader = {
	uniforms: {
		modelViewMatrix: 'mat4',
		projectionMatrix: 'highp mat4',

		pixelSize: 'vec2',
		alphaMultiplier: 'float',
		dashLength: 'float',
		dashGapLength: 'float',
		glowWidth: 'float',
		indexStart: 'float',
		indexCount: 'float',
		indexLength: 'float',
		color: 'vec4',
		alphaFade: 'float',
		widthMin: 'float',
		widthMax: 'float',

		..._log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Uniforms
	},
	properties: {
		transparent: true,
		depthWrite: false,
		side: 'double',
		blending: 'additive'
	},
	vertex: {
		extensions: ['EXT_frag_depth'],
		code: `
			attribute vec3 positionCurr;
			attribute vec3 positionPrev;
			attribute vec3 positionNext;
			attribute float side;
			attribute float index;
			attribute float dashOffset;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			uniform vec2 pixelSize;
			uniform float glowWidth;
			uniform float indexStart;
			uniform float indexCount;
			uniform float indexLength;
			uniform float widthMin;
			uniform float widthMax;

			varying vec4 fColor;
			varying float fDashOffset;
			varying float fWidth;
			varying float fOffsetScalar;
			varying float fIndexU;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

			void main() {
				// Get the width depending on the length.
				float indexU = mod(index - indexStart + indexLength, indexLength) / (indexCount - 1.0);
				float width = mix(widthMin, widthMax, indexU);

				// Get the line vertices into pixel space.
				vec4 viewCenter = modelViewMatrix * vec4(positionCurr, 1.0);
				vec4 viewPrev = modelViewMatrix * vec4(positionPrev, 1.0);
				vec4 viewNext = modelViewMatrix * vec4(positionNext, 1.0);
				vec4 projectedCenter = projectionMatrix * viewCenter;
				vec4 projected_prev = projectionMatrix * viewPrev;
				vec4 projected_next = projectionMatrix * viewNext;
				vec2 ndcCenter = projectedCenter.xy / viewCenter.y;
				vec2 ndcPrev = projected_prev.xy / viewPrev.y;
				vec2 ndcNext = projected_next.xy / viewNext.y;
				vec2 pixelCenter = (ndcCenter.xy + 1.0) / 2.0 * pixelSize;
				vec2 pixelPrev = (ndcPrev.xy + 1.0) / 2.0 * pixelSize;
				vec2 pixelNext = (ndcNext.xy + 1.0) / 2.0 * pixelSize;

				// Get the offset of the part perpendicular to the lines.
				vec2 l0 = normalize(pixelCenter - pixelPrev);
				vec2 l1 = normalize(pixelNext - pixelCenter);
				float offsetScalar = side * (width / 2.0 + glowWidth);
				vec2 offset = vec2(offsetScalar, offsetScalar);
				if (pixelCenter == pixelPrev) {
					if (pixelCenter == pixelNext) {
						offset = vec2(0.0, 0.0);
					}
					else {
						offset *= vec2(-l1.y, l1.x);
					}
				}
				else if (pixelCenter == pixelNext) {
					offset *= vec2(-l0.y, l0.x);
				}
				else {
					offset *= normalize(vec2(-l0.y - l1.y, l0.x + l1.x));
					offset /= sqrt((1.0 + max(0.0, dot(l0, l1))) / 2.0);
				}

				// Re-add the perpendicular part to the center as the final vertex.
				ndcCenter = (pixelCenter + offset) / pixelSize * 2.0 - 1.0;
				gl_Position = vec4(ndcCenter * viewCenter.y, projectedCenter.z, projectedCenter.w);

				// Set the varyings.
				fIndexU = indexU;
				fDashOffset = dashOffset;
				fWidth = width;
				fOffsetScalar = offsetScalar;

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
			}
			`
	},
	fragment: {
		extensions: ['EXT_frag_depth'],
		code: `
			precision highp float;

			uniform vec4 color;
			uniform float alphaMultiplier;
			uniform float alphaFade;
			uniform float dashLength;
			uniform float dashGapLength;
			uniform float glowWidth;

			varying float fIndexU;
			varying float fDashOffset;
			varying float fWidth;
			varying float fOffsetScalar;

			${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}
	
			float lineDash() {
				float u = mod(fDashOffset, dashLength + dashGapLength);
				return float(u < dashLength);
			}

			float edgeGlow() {
				if (glowWidth > 0.0) {
					float value = clamp((fWidth / 2.0 + glowWidth - abs(fOffsetScalar)) / glowWidth, 0.0, 1.0);
					if (value < 1.0) {
						value *= 0.75;
					}
					return value;
				}
				return 1.0;
			}

			void main() {
				gl_FragColor = color;
				gl_FragColor.a *= alphaMultiplier * edgeGlow() * lineDash() * mix(alphaFade, 1.0, fIndexU);

				${_log_depth__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
			}
			`
	}
};


/***/ }),

/***/ "../pioneer/engine/src/texture_loader.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/texture_loader.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureLoader": function() { return /* binding */ TextureLoader; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The texture loader. Responsible for loading all textures.
 * If `useCompression` is used for any of the functions, the appropriate extension is retrieved from Capabilities,
 * and it plus the '.ktx' extension replace the extension of the original url. See {@link Capabilities} for more detail.
 */
class TextureLoader extends _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Loader {
	/**
	 * Constructor.
	 * @param {Downloader} downloader - The download manager.
	 * @param {THREE.WebGLRenderer} renderer
	 */
	constructor(downloader, renderer) {
		super();

		/**
		 * The downloader.
		 * @type {Downloader}
		 * @protected
		 */
		this._downloader = downloader;

		/**
		 * The threejs renderer.
		 * @type {THREE.WebGLRenderer}
		 * @protected
		 */
		this._renderer = renderer;

		/**
		 * The cross origin attribute value use in loads.
		 * @type {string}
		 * @protected
		 */
		this._crossOrigin = 'anonymous';

		/**
		 * The path value used in loads.
		 * @type {string}
		 * @protected
		 */
		this._path = undefined;

		/**
		 * A pre-loaded 1x1 white texture.
		 * @type {THREE.Texture}
		 * @protected
		 */
		this._white = null;

		/**
		 * A pre-loaded 1x1 black texture.
		 * @type {THREE.Texture}
		 * @protected
		 */
		this._black = null;

		/**
		 * A pre-loaded 1x1 clear texture.
		 * @type {THREE.Texture}
		 * @protected
		 */
		this._clear = null;

		/**
		 * A pre-loaded 1x1 pink texture.
		 * @type {THREE.Texture}
		 * @protected
		 */
		this._pink = null;

		/**
		 * A pre-loaded 1x1 gray texture.
		 * @type {THREE.Texture}
		 * @protected
		 */
		this._gray = null;

		/**
		 * A ThreeJs texture loader for use by the load function.
		 * @type {THREE.TextureLoader}
		 * @protected
		 */
		this._threeJsTextureLoader = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.TextureLoader();

		// Configure the loaders.
		this._threeJsTextureLoader.setCrossOrigin(this._crossOrigin);
		this._threeJsTextureLoader.setPath(this._path);

		// Setup the static pre-loaded textures.
		this._white = TextureLoader._newTexture(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1));
		this._black = TextureLoader._newTexture(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 1));
		this._clear = TextureLoader._newTexture(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 0));
		this._pink = TextureLoader._newTexture(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(1, 105 / 255, 180 / 255, 1));
		this._gray = TextureLoader._newTexture(new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0.4, 0.4, 0.4, 1));

		// Add this texture loader to the ThreeJs url handler. Complex loaders like GLTFLoader will use this.
		_internal__WEBPACK_IMPORTED_MODULE_0__.THREE.DefaultLoadingManager.addHandler(/.$/i, this);
	}

	/**
	 * Returns a promise that resolves when the texture is loaded into the uniform and rejects if there is an error.
	 * @param {THREE.IUniform} uniform - The uniform into which to load the texture.
	 * @param {string} url - The url of the texture to load.
	 * @param {boolean} useMipMaps - Whether or not to use mipmap textures. If true, only power-of-two textures are allowed.
	 * @returns {Promise<void>}
	 */
	async loadIntoUniform(uniform, url, useMipMaps) {
		return this.loadTexture(url, useMipMaps).then((texture) => {
			if (uniform.value !== null) {
				uniform.value.dispose();
			}
			uniform.value = texture;
		});
	}

	/**
	 * Returns a promise that resolves when the cube texture is loaded and rejects if there is an error.
	 * @param {string} url - The url of the texture to load. Every instance of $FACE is replaced by one of ['posx', 'negx', 'posy', 'negy', 'posz', 'negz'].
	 * @param {boolean} useMipMaps - Whether or not to use mipmap textures. If true, only power-of-two textures are allowed.
	 * @returns {Promise<THREE.CubeTexture>}
	 */
	async loadCubeTexture(url, useMipMaps) {
		const cubeTexture = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CubeTexture();
		const promises = [];
		for (let i = 0; i < 6; i++) {
			const newUrl = url.replace('$FACE', _cubeFaceNames[i]);
			promises.push(new Promise((resolve) => {
				this.loadTexture(newUrl, useMipMaps).then((texture) => {
					cubeTexture.images[i] = texture.image;
					resolve();
				});
			}));
		}
		return Promise.all(promises).then(() => {
			cubeTexture.needsUpdate = true;
			return cubeTexture;
		});
	}

	/**
	 * Returns a promise that resolves with a texture and rejects with an error.
	 * @param {string} url - The url of the texture to load.
	 * @param {boolean} useMipMaps - Whether or not to use mipmap textures. If true, only power-of-two textures are allowed.
	 * @returns {Promise<THREE.Texture>}
	 */
	async loadTexture(url, useMipMaps) {
		return new Promise((resolve, reject) => {
			this.load(url, (texture) => {
				resolve(texture);
			}, undefined, (message) => {
				reject(new Error(`Failed to load ${url}: ${message}`));
			}, useMipMaps);
		});
	}

	/**
	 * Generates an environment map with proper cube UV.
	 * @param {THREE.Texture|THREE.CubeTexture} texture
	 * @returns {THREE.Texture}
	 */
	generateEnvMap(texture) {
		let cubemap = texture;
		// Transforms equirectangular texture to cubemap texture if it is not already a cubemap
		if (!(texture instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CubeTexture)) {
			const options = {
				depthBuffer: false,
				stencilBuffer: false,
				generateMipmaps: true,
				minFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearMipMapLinearFilter,
				magFilter: _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter
			};
			cubemap = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.WebGLCubeRenderTarget(512, options).fromEquirectangularTexture(this._renderer, texture).texture;
		}

		const pmremGenerator = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.PMREMGenerator(this._renderer);
		pmremGenerator.compileEquirectangularShader();
		const envMap = pmremGenerator.fromEquirectangular(cubemap).texture;

		return envMap;
	}

	/**
	 * Loads a texture and calls the callbacks when it is done. The signature is to be compatible with THREE.TextureLoader.
	 * @param {string} url - The url of the texture to load.
	 * @param {(texture: THREE.Texture) => any} onLoad - The callback that is called when the texture is loaded.
	 * @param {(event: ProgressEvent<EventTarget>, request: XMLHttpRequest) => any} _onProgress - The callback that is called when there is progress loading the texture. It is currently unused.
	 * @param {(message: string) => any} onError - The callback that is called when there is an error loading the texture.
	 * @param {boolean} [useMipMaps] - Whether or not to use mipmap textures. If true, only power-of-two textures are allowed.
	 * @returns {THREE.Texture}
	 */
	load(url, onLoad, _onProgress, onError, useMipMaps) {
		// Process the URL
		url = this._downloader.processUrl(url);

		// Handle preloaded cases
		let texture = /** @type {THREE.Texture} */(null);
		if (url === 'white') {
			texture = this._white;
		}
		else if (url === 'black') {
			texture = this._black;
		}
		else if (url === 'clear') {
			texture = this._clear;
		}
		else if (url === 'pink') {
			texture = this._pink;
		}
		else if (url === 'gray') {
			texture = this._gray;
		}
		if (texture !== null) {
			onLoad(texture);
		}
		else {
			// Detect video types from url
			if (url.includes('.mp4')) {
				// Controls through videoTexture.image
				const videoElement = document.createElement('video');
				videoElement.src = url;
				videoElement.muted = true;
				videoElement.playsInline = true;
				videoElement.loop = false;
				videoElement.crossOrigin = 'anonymous';

				texture = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.VideoTexture(videoElement);
				texture.format = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RGBAFormat;
				texture.flipY = false;
				texture.needsUpdate = true;

				this._downloader.download(url, true).then((download) => {
					videoElement.src = URL.createObjectURL(new Blob([download.content], { type: 'video/mp4' }));
					videoElement.onerror = (event) => {
						onError(event.toString());
					};
					videoElement.oncanplaythrough = () => {
						onLoad(texture);
					};
					videoElement.load();
				});
			}
			else {
				// Load the texture.
				this._threeJsTextureLoader.load(url, (texture) => {
					texture.flipY = false;
					if (useMipMaps === false) {
						texture.minFilter = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter;
						texture.generateMipmaps = false;
					}
					texture.needsUpdate = true;
					onLoad(texture);
				}, undefined, (event) => {
					onError(event.message);
				});
			}
		}

		return texture;
	}

	/**
	 * Gets the cross origin attribute value used in loads. Present to be compatible with THREE.TextureLoader.
	 * @returns {string}
	 * @internal
	 */
	// @ts-ignore
	get crossOrigin() {
		return this._crossOrigin;
	}

	/**
	 * Sets the cross origin attribute value used in loads. Present to be compatible with THREE.TextureLoader.
	 * @param {string} crossOrigin - The cross origin attribute value.
	 * @override
	 * @internal
	 */
	set crossOrigin(crossOrigin) {
		this._crossOrigin = crossOrigin;
		if (this._threeJsTextureLoader) {
			this._threeJsTextureLoader.setCrossOrigin(this._crossOrigin);
		}
	}

	/**
	 * Set method for the cross origin attribute. Present to be compatible with THREE.TextureLoader.
	 * @param {string} crossOrigin - The cross origin attribute value.
	 * @returns {this}
	 * @override
	 * @internal
	 */
	setCrossOrigin(crossOrigin) {
		this.crossOrigin = crossOrigin;
		return this;
	}

	/**
	 * Gets the path value used in loads. Present to be compatible with THREE.TextureLoader.
	 * @returns {string}
	 * @internal
	 */
	// @ts-ignore
	get path() {
		return this._path;
	}

	/**
	 * Sets the path value used in loads. Present to be compatible with THREE.TextureLoader.
	 * @param {string} path - The path value.
	 * @override
	 * @internal
	 */
	set path(path) {
		this._path = path;
		if (this._threeJsTextureLoader) {
			this._threeJsTextureLoader.setPath(this._path);
		}
	}

	/**
	 * Set method for the path value. Present to be compatible with THREE.TextureLoader.
	 * @param {string} path - The path value.
	 * @returns {this}
	 * @override
	 * @internal
	 */
	setPath(path) {
		this.path = path;
		return this;
	}

	/**
	 * Returns a new 1x1 pixel THREE.Texture from the color.
	 * @param {Color} color - The color of the single pixel.
	 * @returns {THREE.Texture}
	 * @protected
	 */
	static _newTexture(color) {
		const canvas = document.createElement('canvas');
		canvas.width = 1;
		canvas.height = 1;
		const context = canvas.getContext('2d');
		context.fillStyle = 'rgba(' + (color.r * 255) + ',' + (color.g * 255) + ',' + (color.b * 255) + ',' + (color.a * 255) + ')';
		context.fillRect(0, 0, 1, 1);
		return new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CanvasTexture(canvas);
	}
}

/**
 * The cube face names for cube map texture loading.
 * @type {string[]}
 */
const _cubeFaceNames = [
	'posx',
	'negx',
	'posy',
	'negy',
	'posz',
	'negz'];


/***/ }),

/***/ "../pioneer/engine/src/texture_loader_compressed.js":
/*!**********************************************************!*\
  !*** ../pioneer/engine/src/texture_loader_compressed.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureLoaderCompressed": function() { return /* binding */ TextureLoaderCompressed; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * The texture loader. Responsible for loading all textures.
 * If `useCompression` is used for any of the functions, the appropriate extension is retrieved from Capabilities,
 * and it plus the '.ktx' extension replace the extension of the original url. See {@link Capabilities} for more detail.
 */
class TextureLoaderCompressed extends _internal__WEBPACK_IMPORTED_MODULE_0__.TextureLoader {
	/**
	 * Constructor.
	 * @param {Downloader} downloader - The download manager.
	 * @param {Config} config - The config manager.
	 * @param {THREE.WebGLRenderer} renderer
	 */
	constructor(downloader, config, renderer) {
		super(downloader, renderer);

		/**
		 * The config.
		 * @type {Config}
		 * @private
		 */
		this._config = config;

		/**
		 * A ThreeJs texture loader for use by the load function.
		 * @type {ThreeJsKTXLoader}
		 * @private
		 */
		this._threeJsKTXLoader = new _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsKTXLoader();

		// Configure the loaders.
		this._threeJsKTXLoader.setCrossOrigin(this._crossOrigin);
		this._threeJsKTXLoader.setPath(this._path);
	}

	/**
	 * Loads a texture and calls the callbacks when it is done. The signature is to be compatible with THREE.TextureLoader.
	 * @param {string} url - The url of the texture to load.
	 * @param {(texture: THREE.Texture) => any} onLoad - The callback that is called when the texture is loaded.
	 * @param {(event: ProgressEvent<EventTarget>, request: XMLHttpRequest) => any} onProgress - The callback that is called when there is progress loading the texture.
	 * @param {(message: string) => any} onError - The callback that is called when there is an error loading the texture.
	 * @param {boolean} [useMipMaps] - Whether or not to use mipmap textures. If true, only power-of-two textures are allowed.
	 * @returns {THREE.Texture}
	 * @override
	 */
	load(url, onLoad, onProgress, onError, useMipMaps) {
		// If it's a normal, just do regular texture.
		if (url.match(/_n\.[^.]+$/) !== null) {
			return super.load(url, onLoad, onProgress, onError, useMipMaps);
		}

		// Process the URL
		url = this._downloader.processUrl(url);

		// Handle preloaded cases
		let texture = null;
		if (url === 'white') {
			texture = this._white;
		}
		else if (url === 'black') {
			texture = this._black;
		}
		else if (url === 'clear') {
			texture = this._clear;
		}
		else if (url === 'pink') {
			texture = this._pink;
		}
		if (texture !== null) {
			onLoad(texture);
		}
		else {
			// Replace the url with the .ktx version.
			url = url.replace(/\.(\w+)$/, '-' + _internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.__getCompressedTextureExtension() + '.ktx');
			// Load the texture.
			this._threeJsKTXLoader.load(url, (texture) => {
				texture.flipY = false;
				texture.needsUpdate = true;
				if (useMipMaps === false) { // If undefined or true, it'll use mipmaps.
					texture.minFilter = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LinearFilter;
					texture.generateMipmaps = false;
				}
				// @ts-ignore
				texture.ktxFormat = texture.format; // This is needed because GLTFLoader forces the texture format to RGB/A. See https://github.com/mrdoob/three.js/issues/15763
				onLoad(texture);
			}, undefined, (event) => {
				onError(event.message);
			});
		}

		return texture;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/aer.js":
/*!******************************************!*\
  !*** ../pioneer/engine/src/utils/aer.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AER": function() { return /* binding */ AER; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** An azimuth, elevation, and range. */
class AER extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<AER>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * Constructor.
	 * @param {number} azimuth
	 * @param {number} elevation
	 * @param {number} range
	 */
	constructor(azimuth = 0, elevation = 0, range = 0) {
		super();

		/**
		 * azimuth
		 * @type {number}
		 * @private
		 */
		this._azimuth = azimuth;
		/**
		 * elevation
		 * @type {number}
		 * @private
		 */
		this._elevation = elevation;
		/**
		 * range
		 * @type {number}
		 * @private
		 */
		this._range = range;
	}

	/**
	 * Gets the azimuth.
	 * @returns {number}
	 */
	get azimuth() {
		return this._azimuth;
	}

	/**
	 * Sets the azimuth.
	 * @param {number} azimuth
	 */
	set azimuth(azimuth) {
		this.throwIfFrozen();
		this._azimuth = azimuth;
	}

	/**
	 * Gets the elevation.
	 * @returns {number}
	 */
	get elevation() {
		return this._elevation;
	}

	/**
	 * Sets the elevation.
	 * @param {number} elevation
	 */
	set elevation(elevation) {
		this.throwIfFrozen();
		this._elevation = elevation;
	}

	/**
	 * Gets the range.
	 * @returns {number}
	 */
	get range() {
		return this._range;
	}

	/**
	 * Sets the range.
	 * @param {number} range
	 */
	set range(range) {
		this.throwIfFrozen();
		this._range = range;
	}

	/**
	 * Returns a nicely formed string.
	 * @param {boolean} deg - whether or not to print in degrees or radians.
	 * @returns {string}
	 * @override
	 */
	toString(deg = false) {
		if (deg) {
			return '[' + _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(this._azimuth) + ', ' + _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(this._elevation) + ', ' + this._range + ']';
		}
		else {
			return '[' + this._azimuth + ', ' + this._elevation + ', ' + this._range + ']';
		}
	}

	/**
	 * Sets this to a.
	 * @param {AER} a
	 */
	copy(a) {
		this.throwIfFrozen();
		this._azimuth = a._azimuth;
		this._elevation = a._elevation;
		this._range = a._range;
	}

	/**
	 * Sets this to the parameters.
	 * @param {number} azimuth
	 * @param {number} elevation
	 * @param {number} range
	 */
	set(azimuth, elevation, range) {
		this.throwIfFrozen();
		this._azimuth = azimuth;
		this._elevation = elevation;
		this._range = range;
	}

	/**
	 * Sets this from the xyz equivalent of azimuth (rotation about z-axis starting from x-axis), elevation (from x-y plane), and range.
	 * @param {Vector3} xyz
	 */
	setFromVector(xyz) {
		this.throwIfFrozen();
		this._range = xyz.magnitude();
		this._elevation = Math.asin(xyz.z / this._range);
		this._azimuth = Math.atan2(xyz.y, xyz.x);
	}
}

/** @type {Pool<AER>} */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(AER);


/***/ }),

/***/ "../pioneer/engine/src/utils/base_ref.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/utils/base_ref.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "BaseRef": function() { return /* binding */ BaseRef; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * @typedef RefAble
 * @property {function(): boolean} isEnabled
 * @property {function(): boolean} isDestroyed
 */

/**
 * A reference to an object.
 * @template {RefAble} Type
 */
class BaseRef {
	/**
	 * Constructor.
	 * @param {Scene} scene
	 */
	constructor(scene) {
		/**
		 * The scene where this reference will search.
		 * @type {Scene}
		 * @protected
		 */
		this._scene = scene;

		/**
		 * The entity.
		 * @type {Type | null}
		 * @protected
		 */
		this._ref = null;

		/**
		 * The callback to be called when the reference changes.
		 * @type {((oldRef: Type | null, newRef: Type | null) => any) | null}
		 * @private
		 */
		this._refChangedCallback = null;
	}

	/**
	 * Gets the reference.
	 * @returns {Type | null}
	 */
	get() {
		this.update();
		return this._ref;
	}

	/**
	 * Sets a callback to be called when the reference changes.
	 * @param {((oldRef: Type | null, newRef: Type | null) => any) | null} refChangedCallback
	 */
	setRefChangedCallback(refChangedCallback) {
		this._refChangedCallback = refChangedCallback;
	}

	/**
	 * Updates the reference.
	 * @abstract
	 */
	update() {
	}

	/**
	 * Updates the ref, calling the callback if necessary.
	 * @param {Type | null} newRef
	 * @protected
	 */
	_setRef(newRef) {
		// Make sure the new ref is enabled, otherwise discard it.
		if (newRef !== null && !newRef.isEnabled()) {
			newRef = null;
		}
		// If they are different,
		if (this._ref !== newRef) {
			const oldRef = this._ref;
			// Set the ref.
			this._ref = newRef;
			// Call the callback.
			if (this._refChangedCallback !== null) {
				this._refChangedCallback(oldRef, this._ref);
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/cache.js":
/*!********************************************!*\
  !*** ../pioneer/engine/src/utils/cache.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cache": function() { return /* binding */ Cache; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A generic cache.
 * @template Type
 * @extends {FastIterable<Type>}
 */
class Cache extends _internal__WEBPACK_IMPORTED_MODULE_0__.FastIterable {
	/**
	 * Constructor.
	 * @param {(key: string) => Type} itemConstructor
	 * @param {(item: Type) => any} itemDestructor
	 */
	constructor(itemConstructor = null, itemDestructor = null) {
		super();

		/**
		 * The keys to entries.
		 * @type {FastMap<string, { item: Type, count: number }>}
		 * @private
		 */
		this._keysToEntries = new _internal__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The items to keys.
		 * @type {Map<Type, string>}
		 * @private
		 */
		this._itemToKeys = new Map();

		/**
		 * The item constructor.
		 * @type {(key: string) => Type}
		 * @private
		 */
		this._itemConstructor = itemConstructor;

		/**
		 * The item destructor.
		 * @type {(item: Type) => any}
		 * @private
		 */
		this._itemDestructor = itemDestructor;
	}

	/**
	 * Gets the item with the key. If it doesn't yet exist, it creates it.
	 * @param {string} key
	 * @returns {Type}
	 */
	get(key) {
		const entry = this._keysToEntries.get(key);
		if (entry === undefined) {
			const newEntry = {
				item: this._itemConstructor(key),
				count: 1
			};
			this._keysToEntries.set(key, newEntry);
			this._itemToKeys.set(newEntry.item, key);
			return newEntry.item;
		}
		else {
			entry.count += 1;
			return entry.item;
		}
	}

	/**
	 * Releases the item after a call to get.
	 * @param {Type} item
	 */
	release(item) {
		const key = this._itemToKeys.get(item);
		if (key !== undefined) {
			const entry = this._keysToEntries.get(key);
			entry.count -= 1;
			if (entry.count === 0) {
				this._itemDestructor(entry.item);
				this._keysToEntries.delete(key);
				this._itemToKeys.delete(item);
			}
		}
	}

	/**
	 * Gets the item of the given index.
	 * @param {number} index
	 * @returns {Type}
	 * @override
	 */
	getAt(index) {
		return this._keysToEntries.getAt(index).value.item;
	}

	/**
	 * Gets the number of key-value pairs.
	 * @returns {number}
	 * @override
	 */
	get size() {
		return this._keysToEntries.size;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/collection.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/collection.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CollectionItem": function() { return /* binding */ CollectionItem; },
/* harmony export */   "Collection": function() { return /* binding */ Collection; }
/* harmony export */ });
/** @module pioneer */

/**
 * A item within the Collection. This is meant to be subclassed.
 * @template CollectionParentType
 * @abstract
 */
class CollectionItem {
	/**
	 * Constructs an item.
	 * @constructor
	 * @param {string} type - the type of the item
	 * @param {string} name - the name of the item
	 * @param {CollectionParentType} collectionParent - the object that contains the collection
	 */
	constructor(type, name, collectionParent) {
		/**
		 * The type of the item.
		 * @type {string}
		 * @private
		 */
		this._type = type;

		/**
		 * The index of the item.
		 * @type {number}
		 * @private
		 */
		this._index = 0;

		/**
		 * The type index of the item.
		 * @type {number}
		 * @private
		 */
		this._typeIndex = 0;

		/**
		 * The name of the item.
		 * @type {string}
		 * @private
		 */
		this._name = name;

		/**
		 * The object that contains the collection.
		 * @type {CollectionParentType}
		 * @private
		 */
		this._collectionParent = collectionParent;
	}

	/**
	 * Gets the type.
	 * @returns {string}
	 */
	getType() {
		return this._type;
	}

	/**
	 * Gets the index.
	 * @returns {number}
	 */
	getIndex() {
		return this._index;
	}

	/**
	 * Sets the index. Only to be used internally by Collection.
	 * @param {number} index
	 * @internal
	 */
	__setIndex(index) {
		this._index = index;
	}

	/**
	 * Gets the type index.
	 * @returns {number}
	 */
	getTypeIndex() {
		return this._typeIndex;
	}

	/**
	 * Sets the type index. Only to be used internally by Collection.
	 * @param {number} typeIndex
	 * @internal
	 */
	__setTypeIndex(typeIndex) {
		this._typeIndex = typeIndex;
	}

	/**
	 * Gets the name.
	 * @returns {string}
	 */
	getName() {
		return this._name;
	}

	/**
	 * Gets the object that contains the collection. Only to be used internally by the class that contains this.
	 * @returns {CollectionParentType}
	 */
	__getCollectionParent() {
		return this._collectionParent;
	}

	/**
	 * Sets the object that contains the collection. Only to be used internally by the class that contains this.
	 * @param {CollectionParentType} collectionParent
	 */
	__setCollectionParent(collectionParent) {
		this._collectionParent = collectionParent;
	}

	/**
	 * Does whatever is necessary to clean up the resources used by the item.
	 * @abstract
	 */
	__destroy() {
	}
}

/**
 * The type constructor that takes a type, name, and its parent.
 * @template {CollectionItem<CollectionParentType>} ItemType
 * @template CollectionParentType
 * @typedef {new (type: string, name: string, parent: CollectionParentType) => ItemType} TypeConstructor
 */

/**
 * An ordered and named list of items. Every item constructor must be of the form Type(name, parent).
 * @template {CollectionItem<CollectionParentType>} ItemType
 * @template CollectionParentType
 */
class Collection {
	/**
	 * Constructs the collection.
	 * @constructor
	 * @param {CollectionParentType} parent - the object that contains this collection
	 * @param {Map<string, TypeConstructor<ItemType, CollectionParentType>>} types - the mapping from type names to type constructors
	 */
	constructor(parent, types) {
		/**
		 * The parent of this collection that the items can refer to.
		 * @type {CollectionParentType}
		 * @private
		 */
		this._parent = parent;

		/**
		 * The mapping from type names to type constructors.
		 * @type {Map<string, TypeConstructor<ItemType, CollectionParentType>>}
		 * @private
		 */
		this._types = types;

		/**
		 * The array of items to manage.
		 * @type {ItemType[]}
		 * @private
		 */
		this._items = [];

		/**
		 * The mapping from names to items.
		 * @type {Map<string, ItemType>}
		 * @private
		 */
		this._itemsByName = new Map();

		/**
		 * The mapping from type constructors to items in arrays.
		 * @type {Map<TypeConstructor<ItemType, CollectionParentType>, ItemType[]>}
		 * @private
		 */
		this._itemsByType = new Map();
	}

	/**
	 * Gets the item from either the item, name, or an index. It returns null if the item is not found.
	 * @param {ItemType|string|number} itemOrNameOrIndex - the item, its name, or its index to get
	 * @returns {ItemType | null}
	 */
	get(itemOrNameOrIndex) {
		const index = this._getByItemOrNameOrIndex(itemOrNameOrIndex);
		return index !== undefined ? this._items[index] : null;
	}

	/**
	 * Gets the index'th item of the given type. The index is base 0. Returns null if none is found.
	 * @param {string} typeName
	 * @param {number} [index=0]
	 * @returns {ItemType | null}
	 */
	getByType(typeName, index = 0) {
		const type = this._types.get(typeName);
		if (type === undefined) {
			return null;
		}
		const itemsOfType = this._itemsByType.get(type);
		if (itemsOfType === undefined) {
			return null;
		}
		if (index < 0 || index >= itemsOfType.length) {
			return null;
		}
		return itemsOfType[index];
	}

	/**
	 * Gets the index'th item of the given type. The index is base 0. Returns null if none is found.
	 * @template {ItemType} Class
	 * @param {TypeConstructor<Class, CollectionParentType>} ClassConstructor
	 * @param {number} [index=0]
	 * @returns {Class | null}
	 */
	getByClass(ClassConstructor, index = 0) {
		const typesList = this._itemsByType.get(ClassConstructor);
		if (typesList !== undefined && index >= 0 && index < typesList.length) {
			return /** @type {Class | null} */(typesList[index]);
		}
		return null;
	}

	/**
	 * Create an item using with the given name and return it.
	 * @param {string} type - the type of the item to be created
	 * @param {string} [name=''] - the name of the item to be created
	 * @param {ItemType} [beforeItem] - insert the item before this item
	 * @returns {ItemType}
	 */
	add(type, name = '', beforeItem) {
		// Check if the name already exists in the scene.
		if (name !== '' && this._itemsByName.has(name)) {
			throw new Error(`Already added "${name}".`);
		}
		const TypeConstructor = this._types.get(type);
		if (type === undefined) {
			throw new Error(`Type "${type}" not found.`);
		}
		let item;
		try {
			item = new TypeConstructor(type, name, this._parent);
		}
		catch (error) {
			if (error instanceof Error) {
				error.message = `While adding "${name}" of type "${type}": ${error.message}`;
			}
			throw error;
		}
		// Add the item to the lists.
		this._addToLists(name, item, beforeItem);
		// Return the newly created item.
		return item;
	}

	/**
	 * Create an item using with the given name and return it.
	 * @template {ItemType} Class
	 * @param {TypeConstructor<Class, CollectionParentType>} ClassConstructor
	 * @param {string} [name=''] - the name of the item to be created
	 * @param {ItemType} [beforeItem] - insert the item before this item
	 * @returns {Class}
	 */
	addByClass(ClassConstructor, name = '', beforeItem) {
		// Check if the name already exists in the scene.
		if (name !== '' && this._itemsByName.has(name)) {
			throw new Error(`Already added "${name}".`);
		}
		try {
			// Get the string type associated with the class, if there is one.
			let type = '';
			for (const entry of this._types.entries()) {
				if (entry[1] === ClassConstructor) {
					type = entry[0];
					break;
				}
			}
			// Create the new item.
			const item = new ClassConstructor(type, name, this._parent);
			// Add the item to the lists.
			this._addToLists(name, item, beforeItem);
			// Return the newly created item.
			return item;
		}
		catch (error) {
			if (error instanceof Error) {
				error.message = `While adding "${name}": ${error.message}`;
			}
			throw error;
		}
	}

	/**
	 * Moves an item to another collection of the same type.
	 * @param {ItemType|string|number} itemOrNameOrIndex - the item, its name, or its index to be moved
	 * @param {Collection<ItemType, CollectionParentType>} newCollection
	 * @param {ItemType} [beforeItem] - insert the item before this item in the new scene.
	 */
	move(itemOrNameOrIndex, newCollection, beforeItem) {
		// Get the index of the item.
		const index = this._getByItemOrNameOrIndex(itemOrNameOrIndex);
		// If the item isn't found, do nothing.
		if (index === undefined) {
			throw new Error('While moving item, the item is not found.');
		}
		// Get the item and name.
		const item = this._items[index];
		const name = item.getName();
		// Check if the name already exists in the new scene.
		if (name !== '' && newCollection._itemsByName.has(name)) {
			throw new Error(`Already added "${name}".`);
		}
		// Remove the item from this list.
		this._removeFromLists(index, name, item);
		// Add the item to the new list.
		newCollection._addToLists(name, item, beforeItem);
		// Update the parent.
		item.__setCollectionParent(newCollection._parent);
	}

	/**
	 * Remove and destroy an item.
	 * @param {ItemType|string|number} itemOrNameOrIndex - the item, its name, or its index to be removed
	 */
	remove(itemOrNameOrIndex) {
		// Get the index of the item.
		const index = this._getByItemOrNameOrIndex(itemOrNameOrIndex);
		// If the item isn't found, do nothing.
		if (index === undefined) {
			return;
		}
		// Get the item and name.
		const item = this._items[index];
		const name = item.getName();
		// Remove the item from the lists.
		this._removeFromLists(index, name, item);
		// Call the destroy function.
		item.__destroy();
	}

	/**
	 * Removes and destroys all of the items.
	 */
	clear() {
		for (let i = this._items.length - 1; i >= 0; i--) {
			this._items[i].__destroy();
		}
		this._items = [];
		this._itemsByName.clear();
		this._itemsByType.clear();
	}

	/**
	 * Gets the number of items.
	 * @returns {number}
	 */
	get size() {
		return this._items.length;
	}

	/**
	 * Adds an item to the lists.
	 * @param {string} name
	 * @param {ItemType} item
	 * @param {ItemType | undefined} beforeItem
	 * @private
	 */
	_addToLists(name, item, beforeItem) {
		// Add the item to the lists.
		const index = beforeItem !== undefined ? beforeItem.getIndex() : this._items.length;
		this._items.splice(index, 0, item);
		if (name !== '') {
			this._itemsByName.set(name, item);
		}
		this._updateIndices(index, item);
	}

	/**
	 * Removes an item from the lists.
	 * @param {number} index
	 * @param {string} name
	 * @param {ItemType} item
	 * @private
	 */
	_removeFromLists(index, name, item) {
		// Remove the item from the lists.
		this._items.splice(index, 1);
		if (name !== '') {
			this._itemsByName.delete(name);
		}
		this._updateIndices(index, item);
	}

	/**
	 * Update indices and type indices.
	 * @param {number} startingIndex
	 * @param {ItemType} item
	 * @private
	 */
	_updateIndices(startingIndex, item) {
		// Update the indices.
		for (let i = startingIndex; i < this._items.length; i++) {
			this._items[i].__setIndex(i);
		}
		// Update the type indices for this type.
		const type = /** @type {TypeConstructor<ItemType, CollectionParentType>} */(item.constructor);
		const typesList = this._itemsByType.set(type, []).get(type);
		let typeIndex = item.getTypeIndex();
		for (let i = 0; i < this._items.length; i++) {
			if (this._items[i].constructor === type) {
				this._items[i].__setTypeIndex(typeIndex);
				typesList.push(this._items[i]);
				typeIndex += 1;
			}
		}
		if (typesList.length === 0) {
			this._itemsByType.delete(type);
		}
	}

	__destroy() {
		for (let i = this._items.length - 1; i >= 0; i--) {
			this._items[i].__destroy();
		}
	}

	/**
	 * Gets the index of an item by item, name, or index.
	 * @param {ItemType|string|number} itemOrNameOrIndex
	 * @returns {number | undefined}
	 * @private
	 */
	_getByItemOrNameOrIndex(itemOrNameOrIndex) {
		if (typeof itemOrNameOrIndex === 'number') {
			if (itemOrNameOrIndex >= 0 && itemOrNameOrIndex < this._items.length) {
				return itemOrNameOrIndex;
			}
		}
		else { // item or name
			let item;
			if (typeof itemOrNameOrIndex === 'string') {
				item = this._itemsByName.get(itemOrNameOrIndex);
			}
			else {
				item = itemOrNameOrIndex;
			}
			for (let i = this._items.length - 1; i >= 0; i--) {
				if (this._items[i] === item) {
					return i;
				}
			}
		}
		return undefined;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/color.js":
/*!********************************************!*\
  !*** ../pioneer/engine/src/utils/color.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Color": function() { return /* binding */ Color; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** An RGBA color. All values are from 0 to 1. */
class Color extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<Color>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * Black vector
	 * @returns {Color}
	 */
	static get Black() {
		return _black;
	}

	/**
	 * Clear vector
	 * @returns {Color}
	 */
	static get Clear() {
		return _clear;
	}

	/**
	 * Constructor. Defaults to white. Can use just RGB.
	 * @param {number} r - red component [0 to 1]
	 * @param {number} g - green component [0 to 1]
	 * @param {number} b - blue component [0 to 1]
	 * @param {number} a - alpha component [0 to 1]
	 */
	constructor(r = 1, g = 1, b = 1, a = 1) {
		super();

		/**
		 * red
		 * @type {number}
		 * @private
		 */
		this._r = r;

		/**
		 * green
		 * @type {number}
		 * @private
		 */
		this._g = g;

		/**
		 * blue
		 * @type {number}
		 * @private
		 */
		this._b = b;

		/**
		 * alpha
		 * @type {number}
		 * @private
		 */
		this._a = a;
	}

	/**
	 * Gets the red component.
	 * @returns {number}
	 */
	get r() {
		return this._r;
	}

	/**
	 * Sets the red component.
	 * @param {number} r
	 */
	set r(r) {
		this.throwIfFrozen();
		this._r = r;
	}

	/**
	 * Gets the green component.
	 * @returns {number}
	 */
	get g() {
		return this._g;
	}

	/**
	 * Sets the green component.
	 * @param {number} g
	 */
	set g(g) {
		this.throwIfFrozen();
		this._g = g;
	}

	/**
	 * Gets the blue component.
	 * @returns {number}
	 */
	get b() {
		return this._b;
	}

	/**
	 * Sets the blue component.
	 * @param {number} b
	 */
	set b(b) {
		this.throwIfFrozen();
		this._b = b;
	}

	/**
	 * Gets the alpha component.
	 * @returns {number}
	 */
	get a() {
		return this._a;
	}

	/**
	 * Sets the alpha component.
	 * @param {number} a
	 */
	set a(a) {
		this.throwIfFrozen();
		this._a = a;
	}

	/**
	 * Returns a nicely formed string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		return '[' + this._r + ', ' + this._g + ', ' + this._b + ', ' + this._a + ']';
	}

	/**
	 * Sets this to a.
	 * @param {Color} a - the source color
	 */
	copy(a) {
		this.throwIfFrozen();
		this._r = a._r;
		this._g = a._g;
		this._b = a._b;
		this._a = a._a;
	}

	/**
	 * Sets this to the parameters. Can use just RGB.
	 * @param {number} r - red component [0 to 1]
	 * @param {number} g - green component [0 to 1]
	 * @param {number} b - blue component [0 to 1]
	 * @param {number} a - alpha component [0 to 1]
	 */
	set(r, g, b, a = 1) {
		this.throwIfFrozen();
		this._r = r;
		this._g = g;
		this._b = b;
		this._a = a;
	}

	/**
	 * Sets this to a + b.
	 * @param {Color} a
	 * @param {Color} b
	 */
	add(a, b) {
		this.throwIfFrozen();
		this._r = a._r + b._r;
		this._g = a._g + b._g;
		this._b = a._b + b._b;
		this._a = a._a + b._a;
	}

	/**
	 * Sets this to a - b.
	 * @param {Color} a
	 * @param {Color} b
	 */
	sub(a, b) {
		this.throwIfFrozen();
		this._r = a._r - b._r;
		this._g = a._g - b._g;
		this._b = a._b - b._b;
		this._a = a._a - b._a;
	}

	/**
	 * Sets this to a * b, where b is a number.
	 * @param {Color} a
	 * @param {number} b
	 */
	mult(a, b) {
		this.throwIfFrozen();
		this._r = a._r * b;
		this._g = a._g * b;
		this._b = a._b * b;
		this._a = a._a * b;
	}

	/**
	 * Sets this to a + b * c, where c is a number.
	 * @param {Color} a
	 * @param {Color} b
	 * @param {number} c
	 */
	addMult(a, b, c) {
		this.throwIfFrozen();
		this._r = a._r + b._r * c;
		this._g = a._g + b._g * c;
		this._b = a._b + b._b * c;
		this._a = a._a + b._a * c;
	}

	/**
	 * Sets this to a / b, where b is a number.
	 * @param {Color} a
	 * @param {number} b
	 */
	div(a, b) {
		this.throwIfFrozen();
		this._r = a._r / b;
		this._g = a._g / b;
		this._b = a._b / b;
		this._a = a._a / b;
	}

	/**
	 * Sets this to a * b, component-wise multiplication.
	 * @param {Color} a
	 * @param {Color} b
	 */
	scale(a, b) {
		this.throwIfFrozen();
		this._r = a._r * b._r;
		this._g = a._g * b._g;
		this._b = a._b * b._b;
		this._a = a._a * b._a;
	}

	/**
	 * Returns the value (average of r, g, b components).
	 * @returns {number}
	 */
	value() {
		return (this._r + this._g + this._b) / 3.0;
	}

	/**
	 * Returns the value of the least component (only r, g, b).
	 * @returns {number}
	 */
	min() {
		return Math.min(this._r, this._g, this._b);
	}

	/**
	 * Returns the value of the greatest component (only r, g, b).
	 * @returns {number}
	 */
	max() {
		return Math.max(this._r, this._g, this._b);
	}

	/**
	 * Sets this to the lerp between a and b.
	 * @param {Color} a - the color when u = 0
	 * @param {Color} b - the color when u = 1
	 * @param {number} u - the lerp parameter
	 */
	lerp(a, b, u) {
		this.throwIfFrozen();
		this._r = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._r, b._r, u);
		this._g = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._g, b._g, u);
		this._b = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._b, b._b, u);
		this._a = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._a, b._a, u);
	}
}

/**
 * @type {Pool<Color>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(Color);

const _black = new Color(0, 0, 0, 1);
_black.freeze();

const _clear = new Color(0, 0, 0, 1);
_clear.freeze();


/***/ }),

/***/ "../pioneer/engine/src/utils/component_ref.js":
/*!****************************************************!*\
  !*** ../pioneer/engine/src/utils/component_ref.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ComponentRef": function() { return /* binding */ ComponentRef; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A reference to a component.
 * @template {BaseComponent} Type
 * @extends BaseRef<Type>
 */
class ComponentRef extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseRef {
	/**
	 * Constructor.
	 * @param {Scene} scene
	 */
	constructor(scene) {
		super(scene);

		/**
		 * The name of the entity.
		 * @type {string}
		 * @private
		 */
		this._entityName = '';

		/**
		 * The name of the component.
		 * @type {string}
		 * @private
		 */
		this._componentName = '';

		/**
		 * The type of the component.
		 * @type {string}
		 * @private
		 */
		this._componentType = '';

		/**
		 * The index of the type of the component.
		 * @type {number}
		 * @private
		 */
		this._componentTypeIndex = 0;
	}

	/**
	 * Gets the entity name.
	 * @returns {string}
	 */
	getEntityName() {
		return this._entityName;
	}

	/**
	 * Gets the component name, if used.
	 * @returns {string}
	 */
	getComponentName() {
		return this._componentName;
	}

	/**
	 * Gets the component type, if used.
	 * @returns {string}
	 */
	getComponentType() {
		return this._componentType;
	}

	/**
	 * Gets the component type index, if the component type is used.
	 * @returns {number}
	 */
	getComponentTypeIndex() {
		return this._componentTypeIndex;
	}

	/**
	 * Sets the name of the reference component.
	 * @param {string} entityName
	 * @param {string} componentName
	 */
	setByName(entityName, componentName) {
		this._entityName = entityName;
		this._componentName = componentName;
		this._componentType = '';
	}

	/**
	 * Sets the type and index of the reference component.
	 * @param {string} entityName
	 * @param {string} componentType
	 * @param {number} [componentTypeIndex]
	 */
	setByType(entityName, componentType, componentTypeIndex = 0) {
		this._entityName = entityName;
		this._componentType = componentType;
		this._componentTypeIndex = componentTypeIndex;
		this._componentName = '';
	}

	/**
	 * Updates the reference.
	 * @override
	 */
	update() {
		// If there's no entity name or componentName/Type set, make sure the ref is null.
		if (this._entityName === '' || (this._componentName === '' && this._componentType === '')) {
			this._setRef(null);
		}
		// If there is an entity name and a componentName set, make sure the ref is valid and correct.
		else if (this._componentName !== '') {
			// Make sure the entity is correct.
			const entity = this._scene.getEntity(this._entityName);
			if (entity !== null && entity.isEnabled()) {
				// Make sure the component is correct.
				const ref = /** @type {Type} */(entity.getComponent(this._componentName));
				// Set the ref.
				this._setRef(ref);
			}
			else {
				this._setRef(null);
			}
		}
		// If there is an entity name and a componentType set, make sure the ref is valid and correct.
		else {
			// Make sure the entity is correct.
			const entity = this._scene.getEntity(this._entityName);
			if (entity !== null && entity.isEnabled()) {
				// Make sure the component is correct.
				const ref = /** @type {Type} */(entity.getComponentByType(this._componentType, this._componentTypeIndex));
				// Set the ref.
				this._setRef(ref);
			}
			else {
				this._setRef(null);
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/controller_ref.js":
/*!*****************************************************!*\
  !*** ../pioneer/engine/src/utils/controller_ref.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ControllerRef": function() { return /* binding */ ControllerRef; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A reference to a controller.
 * @template {BaseController} Type
 * @extends BaseRef<Type>
 */
class ControllerRef extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseRef {
	/**
	 * Constructor.
	 * @param {Scene} scene
	 */
	constructor(scene) {
		super(scene);

		/**
		 * The name of the entity.
		 * @type {string}
		 * @private
		 */
		this._entityName = '';

		/**
		 * The name of the controller.
		 * @type {string}
		 * @private
		 */
		this._controllerName = '';

		/**
		 * The type of the controller.
		 * @type {string}
		 * @private
		 */
		this._controllerType = '';

		/**
		 * The index of the type of the controller.
		 * @type {number}
		 * @private
		 */
		this._controllerTypeIndex = 0;
	}

	/**
	 * Gets the entity name.
	 * @returns {string}
	 */
	getEntityName() {
		return this._entityName;
	}

	/**
	 * Gets the controller name, if used.
	 * @returns {string}
	 */
	getControllerName() {
		return this._controllerName;
	}

	/**
	 * Gets the controller type, if used.
	 * @returns {string}
	 */
	getControllerType() {
		return this._controllerType;
	}

	/**
	 * Gets the controller type index, if the controller type is used.
	 * @returns {number}
	 */
	getControllerTypeIndex() {
		return this._controllerTypeIndex;
	}

	/**
	 * Sets the name of the reference controller.
	 * @param {string} entityName
	 * @param {string} controllerName
	 */
	setByName(entityName, controllerName) {
		this._entityName = entityName;
		this._controllerName = controllerName;
		this._controllerType = '';
	}

	/**
	 * Sets the type and index of the reference controller.
	 * @param {string} entityName
	 * @param {string} controllerType
	 * @param {number} [controllerTypeIndex]
	 */
	setByType(entityName, controllerType, controllerTypeIndex = 0) {
		this._entityName = entityName;
		this._controllerType = controllerType;
		this._controllerTypeIndex = controllerTypeIndex;
		this._controllerName = '';
	}

	/**
	 * Updates the reference.
	 * @override
	 */
	update() {
		// If there's no entity name or controllerName/Type set, make sure the ref is null.
		if (this._entityName === '' || (this._controllerName === '' && this._controllerType === '')) {
			this._setRef(null);
		}
		// If there is an entity name and a controllerName set, make sure the ref is valid and correct.
		else if (this._controllerName !== '') {
			// Make sure the entity is correct.
			const entity = this._scene.getEntity(this._entityName);
			if (entity !== null && entity.isEnabled()) {
				// Make sure the controller is correct.
				const ref = /** @type {Type} */(entity.getController(this._controllerName));
				// Set the ref.
				this._setRef(ref);
			}
			else {
				this._setRef(null);
			}
		}
		// If there is an entity name and a controllerType set, make sure the ref is valid and correct.
		else {
			// Make sure the entity is correct.
			const entity = this._scene.getEntity(this._entityName);
			if (entity !== null && entity.isEnabled()) {
				// Make sure the controller is correct.
				const ref = /** @type {Type} */(entity.getControllerByType(this._controllerType, this._controllerTypeIndex));
				// Set the ref.
				this._setRef(ref);
			}
			else {
				this._setRef(null);
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/cube_map.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/utils/cube_map.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CubeMap": function() { return /* binding */ CubeMap; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


class CubeMap {
	/**
	 * Converts an xyz vector to a uvFace vector. An array of cube map vectors may be passed in.
	 * @param {Vector3} outUVFace
	 * @param {Vector3} xyz
	 * @param {Vector3[][]} [cubeMapFaceFrames]
	 */
	static xyzToUVFace(outUVFace, xyz, cubeMapFaceFrames = this._defaultCubeMapFaceFrames) {
		/** @type {Vector3[]} */
		let basis;
		for (let i = 0; i < 6; i++) {
			const cubeMapFaceFrame = cubeMapFaceFrames[i];
			const outVector = cubeMapFaceFrame[2];
			let value0 = 0;
			let value1 = 0;
			let value2 = 0;
			let neg = false;
			if (outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis || outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg) {
				value0 = xyz.x;
				value1 = xyz.y;
				value2 = xyz.z;
				neg = (outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg);
			}
			else if (outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis || outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg) {
				value0 = xyz.y;
				value1 = xyz.z;
				value2 = xyz.x;
				neg = (outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg);
			}
			else {
				value0 = xyz.z;
				value1 = xyz.x;
				value2 = xyz.y;
				neg = (outVector === _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxisNeg);
			}
			if (Math.abs(value0) >= Math.abs(value1) && Math.abs(value0) >= Math.abs(value2)) {
				if ((value0 >= 0.0 && !neg) || (value0 < 0.0 && neg)) {
					basis = cubeMapFaceFrame;
					outUVFace.z = i;
				}
			}
		}
		if (basis === undefined) {
			outUVFace.set(NaN, NaN, NaN);
			return;
		}

		// Convert into the uv basis from the xyz basis.
		let z = basis[2].x * xyz.x + basis[2].y * xyz.y + basis[2].z * xyz.z;
		if (z < 0.0) {
			z = 1.0;
		}
		outUVFace.x = (basis[0].x * xyz.x + basis[0].y * xyz.y + basis[0].z * xyz.z) / z;
		outUVFace.y = (basis[1].x * xyz.x + basis[1].y * xyz.y + basis[1].z * xyz.z) / z;

		// Convert from -1 to +1, to 0 to 1.
		outUVFace.x = 0.5 * (outUVFace.x + 1.0);
		outUVFace.y = 0.5 * (outUVFace.y + 1.0);
	}
}

/**
 * The default vectors used for a cube map face frame orientation. The first dimension is 0-5 for each face and the second dimension are the +u, +v, and out vectors, respectively.
 * @type {Vector3[][]}
 */
CubeMap._defaultCubeMapFaceFrames = [
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxisNeg, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis],
	[_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxisNeg]
];


/***/ }),

/***/ "../pioneer/engine/src/utils/dependency_graph.js":
/*!*******************************************************!*\
  !*** ../pioneer/engine/src/utils/dependency_graph.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DependencyGraph": function() { return /* binding */ DependencyGraph; }
/* harmony export */ });
/** @module pioneer */

/**
 * A dependency graph. The nodes are the items and the arrows are determined by the comparison function.
 * @template ItemType
 */
class DependencyGraph {
	constructor() {
		/**
		 * The callback to be called for each item in the dependency graph.
		 * @type {(item: ItemType) => any}
		 * @private
		 */
		this._updateItemCallback = null;

		/**
		 * The callback to ber called when comparing items. True means item a is dependent on item b.
		 * @type {(a: ItemType, b: ItemType) => boolean}
		 * @private
		 */
		this._compareItemCallback = null;

		/**
		 * The list of items in the dependency graph.
		 * @type {Map<ItemType, Node<ItemType>>}
		 * @private
		 */
		this._nodes = new Map();

		/**
		 * The sorted nodes.
		 * @type {Array<Node<ItemType>>}
		 * @private
		 */
		this._sortedNodes = [];

		/**
		 * A boolean flag that determines of the dependency graph needs sorting.
		 * @type {boolean}
		 * @private
		 */
		this._needsSorting = false;
	}

	/**
	 * Sets the callback to be called for each item in the dependency graph.
	 * @param {(item: ItemType) => any} updateItemCallback
	 */
	setUpdateItemCallback(updateItemCallback) {
		this._updateItemCallback = updateItemCallback;
	}

	/**
	 * Sets the callback to be called for each item in the dependency graph.
	 * @param {(a: ItemType, b: ItemType) => boolean} compareItemCallback
	 */
	setCompareItemCallback(compareItemCallback) {
		this._compareItemCallback = compareItemCallback;
	}

	/**
	 * Adds an item.
	 * @param {ItemType} item
	 */
	addItem(item) {
		/** @type {Node<ItemType>} */
		const node = new Node(item);
		this._nodes.set(item, node);
		this._needsSorting = true;
	}

	/**
	 * Removes an item.
	 * @param {ItemType} item
	 */
	removeItem(item) {
		if (this._nodes.delete(item)) {
			this._needsSorting = true;
		}
	}

	/**
	 * Signals that the graph needs sorting.
	 */
	needsSorting() {
		this._needsSorting = true;
	}

	/**
	 * Sorts the dependency graph and then iterates through through the dependency graph, calling the callback on each item.
	 */
	update() {
		// Do the sorting if we need to do it.
		if (this._needsSorting) {
			// Reset all of the marks.
			for (const node of this._nodes.values()) {
				node.permanentMark = false;
				node.temporaryMark = false;
			}
			this._sortedNodes = [];

			// Sort the items using the depth-first algorithm.
			const iterator = this._nodes.values();
			do {
				const result = iterator.next();
				if (result.done) {
					break;
				}
				const keepGoing = this._visit(result.value);
				if (!keepGoing) {
					break;
				}
			} while (true);

			// It's sorted!
			this._needsSorting = false;
		}

		// Do the update on the items.
		for (let i = 0, l = this._sortedNodes.length; i < l; i++) {
			this._updateItemCallback(this._sortedNodes[i].item);
		}
	}

	/**
	 * The visit function in the depth-first sort algorithm.
	 * @param {Node<ItemType>} node
	 * @returns {boolean}
	 * @private
	 */
	_visit(node) {
		if (node.permanentMark) {
			return true;
		}
		if (node.temporaryMark) {
			throw new Error('Dependency cycle in graph: ' + node.item);
		}
		node.temporaryMark = true;
		for (const aNode of this._nodes.values()) {
			let nodeDependsOn = false;
			if (this._compareItemCallback) {
				nodeDependsOn = this._compareItemCallback(node.item, aNode.item);
			}
			if (nodeDependsOn) {
				try {
					this._visit(aNode);
				}
				catch (error) {
					if (error instanceof Error) {
						error.message = `${error.message} ← ${node.item}`;
					}
					throw error;
				}
			}
		}
		node.temporaryMark = false;
		node.permanentMark = true;
		this._sortedNodes.push(node);
		return true;
	}
}

/**
 * The node in the graph.
 * @template ItemType
 * @private
 */
class Node {
	/**
	 * Constructor.
	 * @param {ItemType} item
	 */
	constructor(item) {
		/**
		 * The item.
		 * @type {ItemType}
		 */
		this.item = item;

		/**
		 * A mark to help with depth-first topological sorting algorithm.
		 * @type {boolean}
		 */
		this.permanentMark = false;

		/**
		 * A mark to help with depth-first topological sorting algorithm.
		 * @type {boolean}
		 */
		this.temporaryMark = false;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/entity_ref.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/entity_ref.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EntityRef": function() { return /* binding */ EntityRef; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A reference to an entity.
 * @extends {BaseRef<Entity>}
 */
class EntityRef extends _internal__WEBPACK_IMPORTED_MODULE_0__.BaseRef {
	/**
	 * Constructor.
	 * @param {Scene} scene
	 * @param {string} [name]
	 */
	constructor(scene, name) {
		super(scene);

		/**
		 * The name of the entity to reference.
		 * @type {string}
		 * @private
		 */
		this._name = name !== undefined ? name : '';
	}

	/**
	 * Gets the name of the reference.
	 * @returns {string}
	 */
	getName() {
		return this._name;
	}

	/**
	 * Sets the name of the reference.
	 * @param {string} name
	 */
	setName(name) {
		this._name = name;
	}

	/**
	 * Updates the reference.
	 * @override
	 */
	update() {
		// If there's no name set, make sure the ref is null.
		if (this._name === '') {
			if (this._ref !== null) {
				this._setRef(null);
			}
		}
		// If there is a name, make sure the ref is valid and correct.
		else {
			if (this._ref === null || this._ref.isDestroyed() || !this._ref.isEnabled() || this._ref.getName() !== this._name) {
				// Get the new ref.
				const ref = this._scene.getEntity(this._name);
				// Set the ref.
				this._setRef(ref);
			}
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/fast_iterable.js":
/*!****************************************************!*\
  !*** ../pioneer/engine/src/utils/fast_iterable.js ***!
  \****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FastIterable": function() { return /* binding */ FastIterable; }
/* harmony export */ });
/** @module pioneer */

/**
 * A set of values, with the same functions as the standard Set object, except for iteration.
 * It has getAt(index) and size for iteration.
 * It's O(n) and garbage for removes, O(1) and no garbage for adds and iteration.
 * @template ValueType
 */
class FastIterable {
	/**
	 * Gets the value of the given index.
	 * @param {number} _index
	 * @returns {ValueType}
	 */
	getAt(_index) {
		throw new Error();
	}

	/**
	 * Gets the number of values.
	 * @returns {number}
	 */
	get size() {
		throw new Error();
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/fast_map.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/utils/fast_map.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FastMapEntry": function() { return /* binding */ FastMapEntry; },
/* harmony export */   "FastMap": function() { return /* binding */ FastMap; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * An entry in the map.
 * @template KeyType
 * @template ValueType
 */
class FastMapEntry {
	/**
	 * Constructor.
	 * @param {KeyType} key
	 * @param {ValueType} value
	 */
	constructor(key, value) {
		/**
		 * The key.
		 * @type {KeyType}
		 */
		this.key = key;

		/**
		 * The value.
		 * @type {ValueType}
		 */
		this.value = value;
	}
}

/**
 * A map of key-value pairs with the same functions as the standard Map object, except for iteration.
 * It has getAt(index) and size for iteration.
 * It's O(n) and garbage for removes, O(1) and no garbage for adds, gets, sets, and iteration.
 * @template KeyType
 * @template ValueType
 * @extends {FastIterable<FastMapEntry<KeyType, ValueType>>}
 */
class FastMap extends _internal__WEBPACK_IMPORTED_MODULE_0__.FastIterable {
	/**
	 * Constructor.
	 * @param {Iterable<FastMapEntry<KeyType, ValueType>>} [iterable]
	 */
	constructor(iterable) {
		super();

		/**
		 * The list of key-value pairs.
		 * @type {Array<FastMapEntry<KeyType, ValueType>>}
		 * @private
		 */
		this._entries = [];

		/**
		 * A mapping from keys to indices.
		 * @type {Map<KeyType, number>}
		 * @private
		 */
		this._keyMap = new Map();

		// Apply the iterable if it is supplied.
		if (iterable !== undefined) {
			for (const entry of iterable) {
				this._entries.push(new FastMapEntry(entry.key, entry.value));
				this._keyMap.set(entry.key, this._entries.length - 1);
			}
		}
	}

	/**
	 * Returns true if the key is in the map.
	 * @param {KeyType} key
	 * @returns {boolean}
	 */
	has(key) {
		return this._keyMap.has(key);
	}

	/**
	 * Gets the value given a key.
	 * @param {KeyType} key
	 * @returns {ValueType}
	 */
	get(key) {
		const index = this._keyMap.get(key);
		if (index !== undefined) {
			return this._entries[index].value;
		}
		return undefined;
	}

	/**
	 * Sets the value for the given key.
	 * @param {KeyType} key
	 * @param {ValueType} value
	 */
	set(key, value) {
		const index = this._keyMap.get(key);
		if (index !== undefined) {
			this._entries[index].value = value;
		}
		else {
			this._entries.push(new FastMapEntry(key, value));
			this._keyMap.set(key, this._entries.length - 1);
		}
	}

	/**
	 * Deletes the value for the given key. Returns true if the key existed.
	 * @param {KeyType} key
	 * @returns {boolean}
	 */
	delete(key) {
		const index = this._keyMap.get(key);
		if (index !== undefined) {
			this._entries.splice(index, 1);
			this._keyMap.delete(key);
			// Every index higher than the one deleted gets decremented by one. O(n) and generates garbage.
			for (const pair of this._keyMap) {
				if (pair[1] > index) {
					this._keyMap.set(pair[0], pair[1] - 1);
				}
			}
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * Deletes all of the key-value pairs.
	 */
	clear() {
		this._entries = [];
		this._keyMap.clear();
	}

	/**
	 * Gets the key-value pair of the given index.
	 * @param {number} index
	 * @returns {FastMapEntry<KeyType, ValueType>}
	 * @override
	 */
	getAt(index) {
		return this._entries[index];
	}

	/**
	 * Gets the number of key-value pairs.
	 * @returns {number}
	 * @override
	 */
	get size() {
		return this._entries.length;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/fast_set.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/utils/fast_set.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FastSet": function() { return /* binding */ FastSet; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A set of values, with the same functions as the standard Set object, except for iteration.
 * It has getAt(index) and size for iteration.
 * It's O(n) and garbage for removes, O(1) and no garbage for adds and iteration.
 * @template ValueType
 * @extends {FastIterable<ValueType>}
 */
class FastSet extends _internal__WEBPACK_IMPORTED_MODULE_0__.FastIterable {
	/**
	 * Constructor.
	 * @param {Iterable<ValueType>} [iterable]
	 */
	constructor(iterable) {
		super();

		/**
		 * The list of values.
		 * @type {Array<ValueType>}
		 * @private
		 */
		this._values = [];

		/**
		 * A mapping from values to indices.
		 * @type {Map<ValueType, number>}
		 * @private
		 */
		this._valueMap = new Map();

		// Apply the iterable if it is supplied.
		if (iterable !== undefined) {
			for (const key of iterable) {
				this._values.push(key);
				this._valueMap.set(key, this._values.length - 1);
			}
		}
	}

	/**
	 * Returns true if the value is in the set.
	 * @param {ValueType} value
	 * @returns {boolean}
	 */
	has(value) {
		return this._valueMap.has(value);
	}

	/**
	 * Adds the value.
	 * @param {ValueType} value
	 * @returns {FastSet<ValueType>}
	 */
	add(value) {
		const index = this._valueMap.get(value);
		if (index === undefined) {
			this._values.push(value);
			this._valueMap.set(value, this._values.length - 1);
		}
		return this;
	}

	/**
	 * Deletes the value. Returns true if the value existed.
	 * @param {ValueType} value
	 * @returns {boolean}
	 */
	delete(value) {
		const index = this._valueMap.get(value);
		if (index !== undefined) {
			this._values.splice(index, 1);
			this._valueMap.delete(value);
			// Every index higher than the one deleted gets decremented by one. O(n) and generates garbage.
			for (const pair of this._valueMap) {
				if (pair[1] > index) {
					this._valueMap.set(pair[0], pair[1] - 1);
				}
			}
			return true;
		}
		else {
			return false;
		}
	}

	/**
	 * Deletes all of the keys.
	 */
	clear() {
		this._values = [];
		this._valueMap.clear();
	}

	/**
	 * Gets the value of the given index.
	 * @param {number} index
	 * @returns {ValueType}
	 * @override
	 */
	getAt(index) {
		return this._values[index];
	}

	/**
	 * Gets the number of values.
	 * @returns {number}
	 * @override
	 */
	get size() {
		return this._values.length;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/fps.js":
/*!******************************************!*\
  !*** ../pioneer/engine/src/utils/fps.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "FPS": function() { return /* binding */ FPS; }
/* harmony export */ });
/** @module pioneer */

/**
 * An FPS calculator. All you need to do is run <code>update()</code> every frame, and it will produce an FPS.
 */
class FPS {
	constructor() {
		/**
		 * The number of samples to take when calculating the FPS.
		 * @type {number}
		 * @private
		 */
		this._numberOfSamples = 100;

		/**
		 * The buffer of samples.
		 * @type {Array<number>}
		 * @private
		 */
		this._samples = new Array(this._numberOfSamples);

		/**
		 * The current index in the buffer of samples.
		 * @type {number}
		 * @private
		 */
		this._index = 0;
	}

	/**
	 * Gets the number of samples to take when calculating the FPS.
	 * @returns {number}
	 */
	getNumberOfSamples() {
		return this._numberOfSamples;
	}

	/**
	 * Sets the number of samples to take when calculating the FPS. This will reset the sample buffer. The default is 100.
	 * @param {number} numberOfSamples - The number of samples in the buffer.
	 */
	setNumberOfSamples(numberOfSamples) {
		this._numberOfSamples = numberOfSamples;
		this._samples = new Array(this._numberOfSamples);
	}

	/**
	 * Gets the FPS given the current samples.
	 * @returns {number}
	 */
	getFPS() {
		let samplesTotal = 0;
		for (let i = 0; i < this._samples.length; i++) {
			samplesTotal += this._samples[i];
		}
		return this._samples.length / samplesTotal;
	}

	/**
	 * Updates the samples with the latest delta time.
	 * @param {number} deltaTime - The change in time between two frames.
	 */
	update(deltaTime) {
		this._samples[this._index] = deltaTime; // Used for frame-rate smoothing.
		this._index = (this._index + 1) % this._samples.length;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/freezable.js":
/*!************************************************!*\
  !*** ../pioneer/engine/src/utils/freezable.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Freezable": function() { return /* binding */ Freezable; }
/* harmony export */ });
/** @module pioneer */

/**
 * This is a class that dynamically makes an object frozen or thawed.
 * When it is frozen, it cannot be modified.
 * To use this, an object must extend this and then for every method that modifies the object, call throwIfFrozen().
 */
class Freezable {
	/**
	 * Constructor. Starts out thawed.
	 */
	constructor() {
		this._frozen = false;
	}

	/**
	 * Throws a TypeError if it is frozen.
	 */
	throwIfFrozen() {
		if (this._frozen) {
			throw new TypeError('The object is frozen.');
		}
	}

	/**
	 * Returns true if it is frozen.
	 * @returns {boolean}
	 */
	isFrozen() {
		return this._frozen;
	}

	/**
	 * Freezes the object.
	 */
	freeze() {
		this._frozen = true;
	}

	/**
	 * Thaws (unfreezes) the object.
	 */
	thaw() {
		this._frozen = false;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/geometry.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/utils/geometry.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Geometry": function() { return /* binding */ Geometry; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A class of geometry routines
 * @hideconstructor */
class Geometry {
	/**
	 * Given a line segment starting at p and going in the direction l (not unit), and a sphere of radius r at the origin, return the least lerp value such that 0 is at p and 1 is at p + l, that represents the an intersection between the line and the sphere. If there is no intersection NaN is returned.
	 * @param {Vector3} p - The starting point of the segment (returning 0 = p).
	 * @param {Vector3} l - The offset from the starting point (returning 1 = p + l).
	 * @param {number} r - The radius of the sphere at the origin.
	 * @returns {number}
	 */
	static getLineSphereIntersectionWithSphereAtOrigin(p, l, r) {
		const pp = p.dot(p);
		const pl = p.dot(l);
		const ll = l.dot(l);
		const underSquareRoot = pl * pl + (r * r - pp) * ll;
		if (underSquareRoot < 0) {
			return Number.NaN;
		}
		else {
			return (-pl - Math.sqrt(underSquareRoot)) / ll;
		}
	}

	/**
	 * Given a line segment starting at the origin and going toward l, and a sphere of radius r with its center at c, return the least lerp value such that 0 is at the origin and 1 is at l, that represents the an intersection between the line segment and the sphere. If there is no intersection NaN is returned.
	 * @param {Interval} out - The interval representing the near and far points of intersection.
	 * @param {Vector3} l - The end point of the line segment.
	 * @param {Vector3} c - The center of the sphere.
	 * @param {number} r - The radius of the sphere.
	 */
	static getLineSphereIntersectionWithLineStartAtOrigin(out, l, c, r) {
		const ll = l.dot(l);
		const lc = l.dot(c);
		const cc = c.dot(c);
		const underSquareRoot = lc * lc + (r * r - cc) * ll;
		if (underSquareRoot < 0) {
			out.min = out.max = Number.NaN;
		}
		else {
			const sqrt = Math.sqrt(underSquareRoot);
			out.min = (lc - sqrt) / ll;
			out.max = (lc + sqrt) / ll;
		}
	}

	/**
	 * Takes an XYZ and sets out to the equivalent LLA on a sphere.
	 * @param {LatLonAlt} outLLA - the LLA vector to be set
	 * @param {Vector3} xyz - the XYZ vector to convert
	 * @param {number} radius - the radius of the sphere
	 */
	static getLLAFromXYZOnSphere(outLLA, xyz, radius) {
		const xyLength = xyz.magnitudeXY();
		outLLA.lon = Math.atan2(xyz.y, xyz.x);
		outLLA.lat = Math.atan(xyz.z / xyLength);
		outLLA.alt = xyz.magnitude() - radius;
	}

	/**
	 * Takes an LLA and sets out to the equivalent XYZ on a sphere.
	 * @param {Vector3} outXYZ - the XYZ vector to be set
	 * @param {LatLonAlt} lla - the LLA vector to convert
	 * @param {number} radius - the radius of the sphere
	 */
	static getXYZFromLLAOnSphere(outXYZ, lla, radius) {
		outXYZ.x = (radius + lla.alt) * Math.cos(lla.lat) * Math.cos(lla.lon);
		outXYZ.y = (radius + lla.alt) * Math.cos(lla.lat) * Math.sin(lla.lon);
		outXYZ.z = (radius + lla.alt) * Math.sin(lla.lat);
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/interval.js":
/*!***********************************************!*\
  !*** ../pioneer/engine/src/utils/interval.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Interval": function() { return /* binding */ Interval; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** An interval with a minimum and maximum. */
class Interval extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<Interval>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * Infinite Interval
	 * @returns {Interval}
	 */
	static get Infinite() {
		return _infinite;
	}

	/**
	 * Constructor.
	 * @param {number} min - the minimum of the interval
	 * @param {number} max - the maximum of the interval
	 */
	constructor(min = 0, max = 0) {
		super();

		/**
		 * minumum
		 * @type {number}
		 * @private
		 */
		this._min = min;

		/**
		 * maximum
		 * @type {number}
		 * @private
		 */
		this._max = max;
	}

	/**
	 * Gets the minimum.
	 * @returns {number}
	 */
	get min() {
		return this._min;
	}

	/**
	 * Sets the minimum.
	 * @param {number} min
	 */
	set min(min) {
		this.throwIfFrozen();
		this._min = min;
	}

	/**
	 * Gets the maximum.
	 * @returns {number}
	 */
	get max() {
		return this._max;
	}

	/**
	 * Sets the maximum
	 * @param {number} max
	 */
	set max(max) {
		this.throwIfFrozen();
		this._max = max;
	}

	/**
	 * Returns a nicely formed string.
	 * @returns {string}
	 * @override
	 */
	toString() {
		return '[' + this._min + ', ' + this._max + ']';
	}

	/**
	 * Sets this to a.
	 * @param {Interval} a - the source interval
	 */
	copy(a) {
		this.throwIfFrozen();
		this._min = a._min;
		this._max = a._max;
	}

	/**
	 * Sets this to the parameters.
	 * @param {number} min - the minimum to set
	 * @param {number} max - the maximum to set
	 */
	set(min, max) {
		this.throwIfFrozen();
		this._min = min;
		this._max = max;
	}

	/**
	 * Returns the length (max - min). If this represents a integer interval, you'll need to add one.
	 * @returns {number}
	 */
	length() {
		return this._max - this._min;
	}

	/**
	 * Returns the value clamped to within this.
	 * @param {number} value - the value to clamp
	 * @returns {number}
	 */
	clamp(value) {
		return Math.min(Math.max(this._min, value), this._max);
	}

	/**
	 * Expands this to contain the value.
	 * @param {number} value
	 */
	expandTo(value) {
		this.throwIfFrozen();
		this._min = Math.min(this._min, value);
		this._max = Math.max(this._max, value);
	}

	/**
	 * Returns true if value is within this.
	 * @param {number} value - the value to check
	 * @returns {boolean}
	 */
	contains(value) {
		return this._min <= value && value < this._max;
	}

	/**
	 * Returns true if this intersects (not just touches) the other interval.
	 * @param {Interval} interval - the interval to check
	 * @returns {boolean}
	 */
	intersects(interval) {
		return this._min < interval._max && interval._min < this._max;
	}

	/**
	 * Sets this to the intersection of intervals a and b.
	 * @param {Interval} a
	 * @param {Interval} b
	*/
	intersection(a, b) {
		this.throwIfFrozen();
		this._min = Math.max(a._min, b._min);
		this._max = Math.min(a._max, b._max);
		if (this._max < this._min) {
			this._max = this._min;
		}
	}

	/**
	 * Sets this to the union of intervals a and b.
	 * @param {Interval} a
	 * @param {Interval} b
	 */
	union(a, b) {
		this.throwIfFrozen();
		this._min = Math.min(a._min, b._min);
		this._max = Math.max(a._max, b._max);
	}
}

/**
 * @type {Pool<Interval>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(Interval);

/**
 * Infinite Interval
 * @type {Interval}
 */
const _infinite = new Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY);
_infinite.freeze();


/***/ }),

/***/ "../pioneer/engine/src/utils/lat_lon_alt.js":
/*!**************************************************!*\
  !*** ../pioneer/engine/src/utils/lat_lon_alt.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LatLonAlt": function() { return /* binding */ LatLonAlt; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A latitude, longitude, and altitude */
class LatLonAlt extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<LatLonAlt>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * Constructor.
	 * @param {number} lat - Latitude
	 * @param {number} lon - Longitude
	 * @param {number} alt - Altitude
	 */
	constructor(lat = 0, lon = 0, alt = 0) {
		super();

		/**
		 * Latitude
		 * @type {number}
		 * @private
		 */
		this._lat = lat;

		/**
		 * Longitude
		 * @type {number}
		 * @private
		 */
		this._lon = lon;

		/**
		 * Altitude
		 * @type {number}
		 * @private
		 */
		this._alt = alt;
	}

	/**
	 * Gets the latitude.
	 * @returns {number}
	 */
	get lat() {
		return this._lat;
	}

	/**
	 * Sets the latitude.
	 * @param {number} lat
	 */
	set lat(lat) {
		this.throwIfFrozen();
		this._lat = lat;
	}

	/**
	 * Gets the longitude.
	 * @returns {number}
	 */
	get lon() {
		return this._lon;
	}

	/**
	 * Sets the longitude.
	 * @param {number} lon
	 */
	set lon(lon) {
		this.throwIfFrozen();
		this._lon = lon;
	}

	/**
	 * Gets the altitude.
	 * @returns {number}
	 */
	get alt() {
		return this._alt;
	}

	/**
	 * Sets the altitude.
	 * @param {number} alt
	 */
	set alt(alt) {
		this.throwIfFrozen();
		this._alt = alt;
	}

	/**
	 * Returns a nicely formed string.
	 * @param {boolean} deg - whether or not to print in degrees or radians.
	 * @returns {string}
	 * @override
	 */
	toString(deg = false) {
		if (deg) {
			return '[' + _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(this._lat) + ', ' + _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.radToDeg(this._lon) + ', ' + this._alt + ']';
		}
		else {
			return '[' + this._lat + ', ' + this._lon + ', ' + this._alt + ']';
		}
	}

	/**
	 * Sets this to a.
	 * @param {LatLonAlt} a
	 */
	copy(a) {
		this.throwIfFrozen();
		this._lat = a._lat;
		this._lon = a._lon;
		this._alt = a._alt;
	}

	/**
	 * Sets this to the parameters.
	 * @param {number} lat
	 * @param {number} lon
	 * @param {number} alt
	 */
	set(lat, lon, alt) {
		this.throwIfFrozen();
		this._lat = lat;
		this._lon = lon;
		this._alt = alt;
	}
}

/**
 * @type {Pool<LatLonAlt>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(LatLonAlt);


/***/ }),

/***/ "../pioneer/engine/src/utils/line_mesh.js":
/*!************************************************!*\
  !*** ../pioneer/engine/src/utils/line_mesh.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "LineMesh": function() { return /* binding */ LineMesh; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A helper class for drawing lines. It creates the objects and materials, but they are 'owned' by the component.
 */
class LineMesh {
	/**
	 * Constructor.
	 * @param {BaseComponent} component
	 */
	constructor(component) {
		/**
		 * The component that uses this.
		 * @type {BaseComponent}
		 * @private
		 */
		this._component = component;

		/**
		 * A global multiplier for the alpha channel.
		 * @type {number}
		 * @private
		 */
		this._alphaMultiplier = 1.0;

		/**
		 * The position that the line points are relative to.
		 * @type {Vector3}
		 * @private
		 */
		this._position = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * The orientation that the line points are relative to.
		 * @type {Quaternion}
		 * @private
		 */
		this._orientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();

		/**
		 * The scale that all points are multiplied by.
		 * @type {number}
		 * @private
		 */
		this._scale = 1;

		/**
		 * The line dash gap length.
		 * @type {number}
		 * @private
		 */
		this._dashGapLength = 0;

		/**
		 * The line dash length.
		 * @type {number}
		 * @private
		 */
		this._dashLength = 1;

		/**
		 * The width of the glow from full to clear along the edge of the lines.
		 * @type {number}
		 * @private
		 */
		this._glowWidth = 0;

		/**
		 * The Three.js objects. There needs to be a copy here since there may be multiple line meshes in the component.
		 * @type {Array<THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial | THREE.ShaderMaterial[]>>}
		 * @private
		 */
		this._threeJsObjects = [];

		/**
		 * The Three.js material.
		 * @type {THREE.ShaderMaterial}
		 * @private
		 */
		this._threeJsMaterial = null;

		// Create the material.
		this._threeJsMaterial = component.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('line');
		component.getThreeJsMaterials().push(this._threeJsMaterial);
		this._threeJsMaterial.uniforms['alphaMultiplier'].value = this._alphaMultiplier;
		this._threeJsMaterial.uniforms['dashLength'].value = this._dashLength;
		this._threeJsMaterial.uniforms['dashGapLength'].value = this._dashGapLength;
		this._threeJsMaterial.uniforms['glowWidth'].value = this._glowWidth;
	}

	/**
	 * Sets the positions. Each two positions is a line segment.
	 * @param {Vector3[]} positions
	 */
	setPositions(positions) {
		if (positions.length % 2 !== 0) {
			throw new Error('Number of positions in the LineMesh must be even.');
		}
		// Adjust the number of vertices. * 2 is because the line has width.
		this._adjustVerticesInGeometries(positions.length * 2);
		const positionPrev = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const positionNext = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const tangent = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const normal = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const segment = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		// Go through each geometry, setting the vertices. Each object holds up to _verticesPerGeometry vertices.
		let dashOffset = 0;
		for (let objectIndex = 0; objectIndex < this._threeJsObjects.length; objectIndex++) {
			const attribute = /** @type {THREE.InterleavedBufferAttribute} */(this._threeJsObjects[objectIndex].geometry.getAttribute('position'));
			const array = attribute.array;
			for (let i = 0; i < array.length / (2 * LineMesh._floatsPerVertex); i++) {
				const offset = i + objectIndex * (LineMesh._verticesPerGeometry / 2);
				array[i * 2 * LineMesh._floatsPerVertex + 0] = positions[offset].x;
				array[i * 2 * LineMesh._floatsPerVertex + 1] = positions[offset].y;
				array[i * 2 * LineMesh._floatsPerVertex + 2] = positions[offset].z;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 0] = positions[offset].x;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 1] = positions[offset].y;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 2] = positions[offset].z;
				// Get the positionPrev and positionNext.
				if (offset % 2 === 0) {
					if (positions[offset].equals(positions[_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(offset - 1, 0, positions.length)])) {
						positionPrev.copy(positions[_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(offset - 2, 0, positions.length)]);
						positionNext.copy(positions[offset + 1]);
					}
					else { // Disconnected segments, so just use the current position as the previous position.
						positionPrev.copy(positions[offset]);
						positionNext.copy(positions[offset + 1]);
						dashOffset = 0;
					}
				}
				else if (offset % 2 === 1) {
					if (positions[offset].equals(positions[_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(offset + 1, 0, positions.length)])) {
						positionPrev.copy(positions[offset - 1]);
						positionNext.copy(positions[_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(offset + 2, 0, positions.length)]);
					}
					else { // Disconnected segments, so just use the current position as the next position.
						positionPrev.copy(positions[offset - 1]);
						positionNext.copy(positions[offset]);
					}
					segment.sub(positions[offset], positions[offset - 1]);
					dashOffset += segment.magnitude();
				}
				array[i * 2 * LineMesh._floatsPerVertex + 3] = positionPrev.x;
				array[i * 2 * LineMesh._floatsPerVertex + 4] = positionPrev.y;
				array[i * 2 * LineMesh._floatsPerVertex + 5] = positionPrev.z;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 3] = positionPrev.x;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 4] = positionPrev.y;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 5] = positionPrev.z;
				array[i * 2 * LineMesh._floatsPerVertex + 6] = positionNext.x;
				array[i * 2 * LineMesh._floatsPerVertex + 7] = positionNext.y;
				array[i * 2 * LineMesh._floatsPerVertex + 8] = positionNext.z;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 6] = positionNext.x;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 7] = positionNext.y;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 8] = positionNext.z;

				array[i * 2 * LineMesh._floatsPerVertex + 14] = dashOffset;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 14] = dashOffset;
			}
			attribute.data.needsUpdate = true;
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(tangent);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(normal);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionPrev);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionNext);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(segment);
	}

	/**
	 * Sets the colors. Each two colors is a line segment.
	 * @param {Color[]} colors
	 */
	setColors(colors) {
		if (colors.length % 2 !== 0) {
			throw new Error('Number of colors in the LineMesh must be even.');
		}
		// Adjust the number of vertices. * 2 is because the line has width.
		this._adjustVerticesInGeometries(colors.length * 2);
		for (let objectIndex = 0; objectIndex < this._threeJsObjects.length; objectIndex++) {
			const attribute = /** @type {THREE.InterleavedBufferAttribute} */(this._threeJsObjects[objectIndex].geometry.getAttribute('color'));
			const array = attribute.array;
			for (let i = 0; i < array.length / (2 * LineMesh._floatsPerVertex); i++) {
				const offset = i + objectIndex * (LineMesh._verticesPerGeometry / 2);
				array[i * 2 * LineMesh._floatsPerVertex + 9] = colors[offset].r;
				array[i * 2 * LineMesh._floatsPerVertex + 10] = colors[offset].g;
				array[i * 2 * LineMesh._floatsPerVertex + 11] = colors[offset].b;
				array[i * 2 * LineMesh._floatsPerVertex + 12] = colors[offset].a;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 9] = colors[offset].r;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 10] = colors[offset].g;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 11] = colors[offset].b;
				array[(i * 2 + 1) * LineMesh._floatsPerVertex + 12] = colors[offset].a;
			}
			attribute.data.needsUpdate = true;
		}
	}

	/**
	 * Sets the positions. Each two positions is a line segment.
	 * @param {number[]|number} widths
	 */
	setWidths(widths) {
		if (typeof widths === 'number') {
			for (let objectIndex = 0; objectIndex < this._threeJsObjects.length; objectIndex++) {
				const attribute = /** @type {THREE.InterleavedBufferAttribute} */(this._threeJsObjects[objectIndex].geometry.getAttribute('width'));
				const array = attribute.array;
				for (let i = 0; i < array.length / (2 * LineMesh._floatsPerVertex); i++) {
					array[i * 2 * LineMesh._floatsPerVertex + 13] = widths;
					array[(i * 2 + 1) * LineMesh._floatsPerVertex + 13] = -widths;
				}
				attribute.data.needsUpdate = true;
			}
		}
		else {
			if (widths.length % 2 !== 0) {
				throw new Error('Number of widths in the LineMesh must be even.');
			}
			// Adjust the number of vertices. * 2 is because the line has width.
			this._adjustVerticesInGeometries(widths.length * 2);
			for (let objectIndex = 0; objectIndex < this._threeJsObjects.length; objectIndex++) {
				const attribute = /** @type {THREE.InterleavedBufferAttribute} */(this._threeJsObjects[objectIndex].geometry.getAttribute('width'));
				const array = attribute.array;
				for (let i = 0; i < array.length / (2 * LineMesh._floatsPerVertex); i++) {
					const offset = i + objectIndex * (LineMesh._verticesPerGeometry / 2);
					array[i * 2 * LineMesh._floatsPerVertex + 13] = widths[offset];
					array[(i * 2 + 1) * LineMesh._floatsPerVertex + 13] = -widths[offset];
				}
				attribute.data.needsUpdate = true;
			}
		}
	}

	/**
	 * Sets the line dash and gap length.
	 * @param {number} dashLength
	 * @param {number} dashGapLength
	 */
	setDashLength(dashLength, dashGapLength) {
		this._dashLength = dashLength;
		this._dashGapLength = dashGapLength;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, 'dashLength', this._dashLength);
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, 'dashGapLength', this._dashGapLength);
	}

	/**
	 * Set the width of the glow from full to clear along the edge of the lines.
	 * @param {number} glowWidth
	 */
	setGlowWidth(glowWidth) {
		this._glowWidth = glowWidth;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, 'glowWidth', this._glowWidth);
	}

	/**
	 * Sets the scale.
	 * @param {number} scale
	 */
	setScale(scale) {
		this._scale = scale;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(this._threeJsObjects, scale);
	}

	/**
	 * Gets the alpha multiplier. This value is multiplied into all line segments as an additional alpha control.
	 * @returns {number}
	 */
	getAlphaMultiplier() {
		return this._alphaMultiplier;
	}

	/**
	 * Sets the alpha multiplier. This value is multiplied into all line segments as an additional alpha control.
	 * @param {number} alphaMultiplier - from 0 to 1
	 */
	setAlphaMultiplier(alphaMultiplier) {
		this._alphaMultiplier = alphaMultiplier;
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this._threeJsMaterial, 'alphaMultiplier', this._alphaMultiplier);
	}

	/**
	 * Prepares the line mesh for rendering. It should be called by every component that uses it.
	 * @param {CameraComponent} camera
	 */
	prepareForRender(camera) {
		const pixelSize = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();

		// If the camera is a Spout camera, make the lines thicker and use Spout for the render size.
		if (camera.getType() === 'spout') {
			const spoutComponent = /** @type {SpoutComponent} */(camera);
			pixelSize.set(spoutComponent.getRenderWidth() * 0.1, spoutComponent.getRenderWidth() * 0.5 * 0.1);
		}
		// Otherwise use the viewport size.
		else {
			pixelSize.copy(camera.getViewport().getBounds().size);
		}

		// Set the pixel render size.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformVector2(this._threeJsMaterial, 'pixelSize', pixelSize);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(pixelSize);
	}

	/**
	 * Updates the number of Three.js objects and vertices if they have changed.
	 * @param {number} numVertices
	 * @private
	 */
	_adjustVerticesInGeometries(numVertices) {
		// The number of objects and meshes we'll be needing.
		// Each object can hold up to _verticesPerGeometry vertices,
		//   due to WebGL 1.0 limitations on the the bit size of index buffers (max 16 bits).
		const numThreeJsObjects = Math.ceil(numVertices / LineMesh._verticesPerGeometry);
		// Remove any excess objects that are no longer needed because there are now less vertices than before.
		while (this._threeJsObjects.length > numThreeJsObjects) {
			const objectToRemove = this._threeJsObjects[this._threeJsObjects.length - 1];
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyObject(objectToRemove);
			this._threeJsObjects.splice(this._threeJsObjects.length - 1, 1);
			// Remove it from the base component's list.
			for (let i = 0, l = this._component.getThreeJsObjects().length; i < l; i++) {
				if (this._component.getThreeJsObjects()[i] === objectToRemove) {
					this._component.getThreeJsObjects().splice(i, 1);
					break;
				}
			}
		}
		// Add any new objects that are needed.
		if (this._threeJsObjects.length < numThreeJsObjects) {
			// Update the current last geometry to have full vertices.
			if (this._threeJsObjects.length > 0) {
				this._setupThreeJsGeometry(this._threeJsObjects[this._threeJsObjects.length - 1].geometry, LineMesh._verticesPerGeometry);
			}
			// Add the new objects.
			for (let i = this._threeJsObjects.length; i < numThreeJsObjects; i++) {
				const objectToAdd = _internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this._component, this._threeJsMaterial, [], false);
				this._threeJsObjects.push(objectToAdd);
				this._component.getThreeJsObjects().push(objectToAdd);
				const numVerticesInGeometry = Math.min(numVertices - i * LineMesh._verticesPerGeometry, LineMesh._verticesPerGeometry);
				this._setupThreeJsGeometry(objectToAdd.geometry, numVerticesInGeometry);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPosition(objectToAdd, this._position);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(objectToAdd, this._orientation);
				_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(objectToAdd, this._scale);
				objectToAdd.frustumCulled = false;
			}
		}
		// There were no new objects needed, so just adjust the vertices of the last mesh.
		else if (numThreeJsObjects > 0) {
			// If we've got a different number of vertices, we need to update the Three.js geometry.
			const geometry = this._threeJsObjects[numThreeJsObjects - 1].geometry;
			const numVerticesInLastGeometry = numVertices - (numThreeJsObjects - 1) * LineMesh._verticesPerGeometry;
			if (geometry.getAttribute('position').array.length !== numVerticesInLastGeometry * LineMesh._floatsPerVertex) {
				this._setupThreeJsGeometry(geometry, numVerticesInLastGeometry);
			}
		}
	}

	/**
	 * A helper function to setup the Three.js geometry when a new object is created.
	 * @param {THREE.BufferGeometry} geometry
	 * @param {number} numVertices - The number of vertices to create.
	 * @private
	 */
	_setupThreeJsGeometry(geometry, numVertices) {
		// Setup the interleaved vertex buffer.
		const vertices = new Float32Array(numVertices * LineMesh._floatsPerVertex);
		const buffer = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBuffer(vertices, LineMesh._floatsPerVertex);
		geometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 0, false));
		geometry.setAttribute('positionPrev', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 3, false));
		geometry.setAttribute('positionNext', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 3, 6, false));
		geometry.setAttribute('color', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 4, 9, false));
		geometry.setAttribute('width', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 13, false));
		geometry.setAttribute('dashOffset', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(buffer, 1, 14, false));

		// Setup the index buffer.
		const meshIndices = new Uint16Array(numVertices * 6 / 4);
		for (let j = 0; j < numVertices / 4; j++) {
			meshIndices[j * 6 + 0] = j * 4;
			meshIndices[j * 6 + 1] = j * 4 + 2;
			meshIndices[j * 6 + 2] = j * 4 + 3;
			meshIndices[j * 6 + 3] = j * 4;
			meshIndices[j * 6 + 4] = j * 4 + 3;
			meshIndices[j * 6 + 5] = j * 4 + 1;
		}
		geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(meshIndices, 1));
	}
}

LineMesh._floatsPerVertex = 3 + 3 + 3 + 4 + 1 + 1;
LineMesh._verticesPerGeometry = 65536;


/***/ }),

/***/ "../pioneer/engine/src/utils/material_utils.js":
/*!*****************************************************!*\
  !*** ../pioneer/engine/src/utils/material_utils.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaterialUtils": function() { return /* binding */ MaterialUtils; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** Material utilities. */
class MaterialUtils {
	/**
	 * Sets the light source uniforms. lightPosition is in camera-space.
	 * @param {THREE.ShaderMaterial[]} materials
	 * @param {Entity} entity
	 * @param {CameraComponent} camera
	 */
	static setLightSourceUniforms(materials, entity, camera) {
		const scene = entity.getScene();
		const lightSourceColor = _internal__WEBPACK_IMPORTED_MODULE_0__.Color.pool.get();
		let lightSourceCount = 0;
		for (let i = 0, l = scene.getNumLightSources(); i < Math.min(l, 5); i++) {
			// Set the lightPosition and lightColor uniform.
			const lightSource = scene.getLightSource(i);
			if (lightSource !== null && lightSource !== entity.getComponentByType('lightSource')) {
				// Position
				const lightSourcePosition = lightSource.getEntity().getCameraSpacePosition(camera);
				// Flux
				// const lightSourcePositionRelEntity = Vector3.pool.get();
				// lightSource.getEntity().getPositionRelativeToEntity(lightSourcePositionRelEntity, Vector3.Zero, entity);
				// const flux = 4.0 * Math.pow(2.51188643151, 46.4205043102 - lightSource.getAbsoluteMagnitude()) / lightSourcePositionRelEntity.magnitudeSqr();
				// Vector3.pool.release(lightSourcePositionRelEntity);
				const flux = 1.0; // Note: The above accurately calculates the flux, but farther planets are too dark. Just setting it to one for now.
				// Color
				lightSourceColor.mult(lightSource.getColor(), flux);
				// Radius. Make the radius for the camera light infinite so that it doesn't cast any shadows.
				const lightRadius = lightSource.getEntity().getComponentByType('camera') === null
					? lightSource.getEntity().getOcclusionRadius()
					: -1.0;
				for (let j = 0, m = materials.length; j < m; j++) {
					if (materials[j].uniforms['lightPositions'] !== undefined) {
						materials[j].uniforms['lightPositions'].value[lightSourceCount].set(lightSourcePosition.x, lightSourcePosition.y, lightSourcePosition.z);
						materials[j].uniforms['lightColors'].value[lightSourceCount].set(lightSourceColor.r, lightSourceColor.g, lightSourceColor.b);
						materials[j].uniforms['lightRadii'].value[lightSourceCount] = lightRadius;
					}
				}
				lightSourceCount += 1;
			}
		}
		for (let j = 0, m = materials.length; j < m; j++) {
			if (materials[j].uniforms['numLights'] !== undefined) {
				materials[j].uniforms['numLights'].value = lightSourceCount;
			}
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Color.pool.release(lightSourceColor);
	}

	/**
	 * Sets the materials' uniforms from the camera, entity, and light source.
	 * @param {THREE.ShaderMaterial[]} materials
	 * @param {CameraComponent} camera
	 * @param {Entity} entity
	 * @param {EntityRef[]} shadowEntities
	 * @param {AtmosphereComponent} atmosphere
	 * @param {boolean} isSpheroid
	 */
	static setUniforms(materials, camera, entity, shadowEntities, atmosphere, isSpheroid) {
		// Get the time.
		const time = entity.getScene().getEngine().getTime();

		// Get the ambient color.
		const ambientLightColor = entity.getScene().getAmbientLightColor();

		// Set the lightPosition and lightColor uniform.
		MaterialUtils.setLightSourceUniforms(materials, entity, camera);

		for (let i = 0, l = materials.length; i < l; i++) {
			/** @type {THREE.ShaderMaterial} */
			const material = materials[i];
			const uniforms = material.uniforms;

			if (material instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.RawShaderMaterial) {
				if (uniforms['time'] !== undefined) {
					// Wrap it to the nearest hour, since the full time can't fit into a GLSL float variable.
					uniforms['time'].value = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(time, 0.0, 3600.0);
				}
			}
			else { // Regular ShaderMaterial from the MaterialUtils.
				// Set the entity position uniform.
				const position = entity.getCameraSpacePosition(camera);
				uniforms['entityPos'].value.set(position.x, position.y, position.z);

				// Set the uniforms that don't depend on a light source.
				uniforms['ambientLightColor'].value.setRGB(ambientLightColor.r, ambientLightColor.g, ambientLightColor.b);

				// For each shadow entity, apply the params.
				if (shadowEntities !== undefined && shadowEntities.length > 0) {
					let validShadowEntities = 0;
					for (let j = 0; j < shadowEntities.length; j++) {
						const shadowEntity = shadowEntities[j].get();
						if (shadowEntity !== null) {
							const position = shadowEntity.getCameraSpacePosition(camera);
							uniforms['shadowEntityPositions'].value[validShadowEntities].set(position.x, position.y, position.z);
							uniforms['shadowEntityRadii'].value[validShadowEntities] = shadowEntity.getOcclusionRadius();

							const atmosphereComponent = /** @type {AtmosphereComponent} */(shadowEntity.get('atmosphere'));
							if (atmosphereComponent !== null) {
								const sunsetColor = atmosphereComponent.getSunsetColor();
								uniforms['shadowEntitySunsetColors'].value[validShadowEntities].set(sunsetColor.r, sunsetColor.g, sunsetColor.b);
								uniforms['shadowEntitySunsetIntensity'].value[validShadowEntities] = atmosphereComponent.getSunsetIntensity();
							}
							else {
								uniforms['shadowEntitySunsetIntensity'].value[validShadowEntities] = 0.0;
							}
							validShadowEntities += 1;
						}
						else {
							uniforms['shadowEntityRadii'].value[validShadowEntities] = 0;
							uniforms['shadowEntitySunsetIntensity'].value[validShadowEntities] = 0.0;
						}
					}

					uniforms['numShadowEntities'].value = validShadowEntities;
				}

				if (materials[i].defines['shadowRings']) {
					const ringsComponent = /** @type {RingsComponent} */(entity.get('rings'));
					if (ringsComponent !== null) {
						const normal = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
						entity.getOrientation().getAxis(normal, 2);
						uniforms['shadowRingsInnerRadius'].value = ringsComponent.getInnerRadius();
						uniforms['shadowRingsOuterRadius'].value = ringsComponent.getOuterRadius();
						uniforms['shadowRingsTexture'].value = ringsComponent.getTopTexture();
						uniforms['shadowRingsNormal'].value.set(normal.x, normal.y, normal.z);
						_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(normal);
					}
				}
			}

			// Atmospheres
			if (atmosphere !== null && atmosphere.getLoadState() === 'loaded' && !atmosphere.isExcludedFromCamera(camera) && uniforms['atmospherePosition'] !== undefined) {
				const spheroid = atmosphere.getSpheroid();
				const atmospherePosition = atmosphere.getEntity().getCameraSpacePosition(camera);
				const atmosphereOrientation = atmosphere.getEntity().getOrientation();
				const atmosphereColor = atmosphere.getColor();
				const atmosphereSunsetColor = atmosphere.getSunsetColor();
				uniforms['atmospherePosition'].value.set(atmospherePosition.x, atmospherePosition.y, atmospherePosition.z);
				uniforms['atmosphereOrientation'].value.set(atmosphereOrientation.x, atmosphereOrientation.y, atmosphereOrientation.z, atmosphereOrientation.w);
				if (spheroid !== null) {
					uniforms['atmosphereEquatorialRadius'].value = spheroid.getEquatorialRadius();
					uniforms['atmospherePolarRadius'].value = spheroid.getPolarRadius();
				}
				else {
					uniforms['atmosphereEquatorialRadius'].value = 0;
					uniforms['atmospherePolarRadius'].value = 0;
				}
				uniforms['atmosphereDensity'].value = atmosphere.getDensity();
				uniforms['atmosphereScaleHeight'].value = atmosphere.getScaleHeight();
				uniforms['atmosphereEmissivity'].value = atmosphere.getEmissivity();
				uniforms['atmosphereColor'].value.set(atmosphereColor.r, atmosphereColor.g, atmosphereColor.b);
				uniforms['atmosphereSunsetColor'].value.set(atmosphereSunsetColor.r, atmosphereSunsetColor.g, atmosphereSunsetColor.b);
				uniforms['atmosphereSunsetIntensity'].value = atmosphere.getSunsetIntensity();
				uniforms['atmosphereGroundIsSpheroid'].value = isSpheroid ? 1 : 0;
				if (material.defines['atmosphere'] === undefined) {
					material.defines['atmosphere'] = true;
					material.needsUpdate = true;
				}
			}
			else if (material.defines['atmosphere'] === true) {
				delete material.defines['atmosphere'];
				material.needsUpdate = true;
			}
		}
	}
}

/**
 * Returns a specular/phong material.
 * @returns {THREE.ShaderMaterial}
 */
MaterialUtils.get = _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtilsPhong.get;

/**
 * Returns a PBR material.
 * @returns {THREE.ShaderMaterial}
 */
MaterialUtils.getPBR = _internal__WEBPACK_IMPORTED_MODULE_0__.MaterialUtilsStandard.get;


/***/ }),

/***/ "../pioneer/engine/src/utils/material_utils_phong.js":
/*!***********************************************************!*\
  !*** ../pioneer/engine/src/utils/material_utils_phong.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaterialUtilsPhong": function() { return /* binding */ MaterialUtilsPhong; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** Material utilities. */
class MaterialUtilsPhong {
	/** Gets a Phong ShaderMaterial.
	 * @returns {THREE.ShaderMaterial}
	 */
	static get() {
		if (MaterialUtilsPhong._material === null) {
			MaterialUtilsPhong._material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ShaderMaterial({
				uniforms: {
					// External lighting and camera.
					entityPos: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),

					// Lights
					ambientLightColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color()),
					lightPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0)]),
					lightColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)]),
					lightRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
					numLights: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

					// Shading.
					color: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color(1, 1, 1)),
					specularColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color(1, 1, 1)),
					specularIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					specularHardness: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(50.0),

					// Textures.
					colorTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					normalTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					specularTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					nightTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					decalTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),

					normalScale: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2()),

					// Shadow Entities
					numShadowEntities: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					shadowEntityPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()]),
					shadowEntityRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
					shadowEntitySunsetIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
					shadowEntitySunsetColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()]),

					// Shadow Rings
					shadowRingsInnerRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					shadowRingsOuterRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					shadowRingsTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					shadowRingsNormal: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),

					// Atmosphere
					atmospherePosition: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)),
					atmosphereOrientation: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector4(1, 0, 0, 0)),
					atmosphereEquatorialRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1),
					atmospherePolarRadius: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1),
					atmosphereDensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					atmosphereScaleHeight: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1),
					atmosphereEmissivity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					atmosphereColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)),
					atmosphereSunBrightness: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1),
					atmosphereSunsetColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)),
					atmosphereSunsetIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					atmosphereGroundIsSpheroid: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

					..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
				},
				vertexShader: `
					#ifdef normalMap
						attribute vec4 tangent;
						varying vec4 viewTangent;
					#endif
					#ifdef normalUVs
						attribute vec2 normalUV;
						varying vec2 vNormalUV;
					#endif
					#ifdef specularUVs
						attribute vec2 specularUV;
						varying vec2 vSpecularUV;
					#endif
					#ifdef nightUVs
						attribute vec2 nightUV;
						varying vec2 vNightUV;
					#endif
					#ifdef decalUVs
						attribute vec2 decalUV;
						varying vec2 vDecalUV;
					#endif
					varying vec2 vColorUV;
					varying vec3 cameraSpacePosition;
					varying vec3 cameraSpaceNormal;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

					void main() {
						#ifdef normalMap
							viewTangent = vec4((modelMatrix * vec4(tangent.xyz, 0.0)).xyz, tangent.w);
						#endif
						vColorUV = uv;
						#ifdef normalUVs
							vNormalUV = normalUV;
						#endif
						#ifdef specularUVs
							vSpecularUV = specularUV;
						#endif
						#ifdef nightUVs
							vNightUV = nightUV;
						#endif
						#ifdef decalUVs
							vDecalUV = decalUV;
						#endif
						cameraSpacePosition = (modelMatrix * vec4(position, 1.)).xyz;
						cameraSpaceNormal = (modelMatrix * vec4(normal, 0.)).xyz;
						gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.);

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
					}`,
				fragmentShader: `
					precision highp float;

					#ifndef saturate
						#define saturate(a) clamp(a, 0.0, 1.0)
					#endif
					uniform mat3 normalMatrix;

					// External lighting and camera.
					uniform vec3 entityPos;

					// Lights
					uniform vec3 ambientLightColor;
					uniform vec3 lightPositions[5];
					uniform vec3 lightColors[5];
					uniform float lightRadii[5];
					uniform int numLights;

					// Shading.
					uniform vec3 color;
					uniform vec3 specularColor;
					uniform float specularIntensity;
					uniform float specularHardness;

					// Shadow Entities.
					#ifdef shadowEntities
						uniform int numShadowEntities;
						uniform vec3 shadowEntityPositions[5];
						uniform float shadowEntityRadii[5];
						uniform float shadowEntitySunsetIntensity[5];
						uniform vec3 shadowEntitySunsetColors[5];
					#endif

					#ifdef shadowRings
						uniform float shadowRingsInnerRadius;
						uniform float shadowRingsOuterRadius;
						uniform sampler2D shadowRingsTexture;
						uniform vec3 shadowRingsNormal;
					#endif

					// Textures.
					uniform sampler2D colorTexture;
					#ifdef normalMap
						uniform sampler2D normalTexture;
					#endif
					#ifdef specularMap
						uniform sampler2D specularTexture;
					#endif
					#ifdef nightMap
						uniform sampler2D nightTexture;
					#endif
					#ifdef decalMap
						uniform sampler2D decalTexture;
					#endif

					// Modifications on the textures.
					#ifdef normalMap
						uniform vec2 normalScale;
					#endif

					// The varying attributes.
					#ifdef normalMap
						varying vec4 viewTangent;
					#endif
					#ifdef normalUVs
						varying vec2 vNormalUV;
					#endif
					#ifdef specularUVs
						varying vec2 vSpecularUV;
					#endif
					#ifdef nightUVs
						varying vec2 vNightUV;
					#endif
					#ifdef decalUVs
						varying vec2 vDecalUV;
					#endif
					varying vec2 vColorUV;
					varying vec3 cameraSpacePosition;
					varying vec3 cameraSpaceNormal;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

					#ifdef normalMap
						vec3 getNormalFromMap() {
							vec3 normal = normalize(cameraSpaceNormal);
							vec3 tangent = normalize(viewTangent.xyz);
							vec3 bitangent = normalize(cross(normal, tangent));
							if (viewTangent.w < 0.0) {
								bitangent *= -1.0;
							}
							mat3 transform = mat3(tangent, bitangent, normal);
							#ifdef normalUVs
								vec2 uv = vNormalUV;
							#else
								vec2 uv = vColorUV;
							#endif
							vec3 normalFromMap = texture2D(normalTexture, uv).rgb * 2.0 - 1.0;
							normalFromMap.xy *= vec2(1, -1);
							normalFromMap.xy *= normalScale;
							return normalize(transform * normalFromMap);
						}
					#endif

					#ifdef colorTextureEnvironment
						vec4 getColorFromEnvironmentMap(sampler2D environmentTexture, vec3 positionDir, vec3 normal) {
							vec3 r = reflect(positionDir, normal);
							float m = 2. * sqrt(r.x * r.x + r.y * r.y + (r.z + 1.) * (r.z + 1.));
							vec2 uv = r.xy / m + .5;
							return vec4(texture2D(environmentTexture, uv).rgb, 1.);
						}
					#endif

					#ifdef shadowEntities
						vec3 applyRayleighScattering(vec3 color, float amount) {
							float value = (color.r + color.g + color.b);
							if (value > 0.0) {
								float rFactor = 1.0; // 6.3^-4 / 6.3^-4
								float gFactor = 1.602; // 5.6^-4 / 6.3^-4
								float bFactor = 3.228; // 4.7^-4 / 6.3^-4
								color.r *= pow(rFactor, -amount);
								color.g *= pow(gFactor, -amount);
								color.b *= pow(bFactor, -amount);
							}
							return color;
						}

						vec3 getLightColorFromShadowEntities(vec3 lightColor, vec3 lightDir, vec3 lightPosition, float lightRadius, vec3 normal) {
							vec3 color = lightColor;
							for (int i = 0; i < 5; i++) {
								if (i >= numShadowEntities || lightRadius < 0.0) {
									break;
								}
								vec3 origin = cameraSpacePosition - shadowEntityPositions[i];
								vec3 axis = normalize(shadowEntityPositions[i] - lightPosition);
								float sd = dot(origin, axis);
								if (sd > 0.0) {
									float e = length(origin - sd * axis);
									float ld = dot(cameraSpacePosition - lightPosition, axis);
									float lr = lightRadius;
									float sr = shadowEntityRadii[i];
									float e0 = (ld * sr - sd * lr) / (ld - sd);
									float e1 = (ld * sr + sd * lr) / (ld - sd);
									float lightLevel = 0.0;
									if (e1 < 0.0 || sd < 0.0) { // light in front of shadow entity
										lightLevel = 1.0;
									}
									else if (e0 < e1) {
										e0 /= max(1.0, shadowEntitySunsetIntensity[i] * 2.0);
										lightLevel = (e - e0) / (e1 - e0);
									}
									else {
										lightLevel = e < e0 ? 0.0 : 1.0; // 0 radius light.
									}
									color = saturate(lightLevel) * applyRayleighScattering(color, saturate(1.5 - lightLevel) * saturate(shadowEntitySunsetIntensity[i]));
								}
							}
							return color;
						}
					#endif

					#ifdef shadowRings
						vec3 getLightColorFromShadowRings(vec3 lightColor, vec3 lightDir) {
							vec3 position = cameraSpacePosition - entityPos;
							float d = dot(position, shadowRingsNormal) / dot(lightDir, shadowRingsNormal);
							highp vec3 pointOnDisc = -d * lightDir + position;
							float lengthOnDisc = length(pointOnDisc - dot(pointOnDisc, shadowRingsNormal) * shadowRingsNormal);
							float u = (lengthOnDisc - shadowRingsInnerRadius) / (shadowRingsOuterRadius - shadowRingsInnerRadius);
							float shadow = 1.0 - texture2D(shadowRingsTexture, vec2(u, 0.0), 0.0).a;
							if (shadowRingsInnerRadius <= lengthOnDisc && lengthOnDisc <= shadowRingsOuterRadius && d > 0.0) {
								return lightColor * saturate(shadow);
							}
							else {
								return lightColor;
							}
						}
					#endif

					// ATMOSPHERE

					#ifdef atmosphere
						uniform vec3 atmospherePosition;
						uniform vec4 atmosphereOrientation;
						uniform float atmosphereEquatorialRadius;
						uniform float atmospherePolarRadius;
						uniform float atmosphereDensity;
						uniform float atmosphereScaleHeight;
						uniform vec3 atmosphereColor;
						uniform float atmosphereEmissivity;
						uniform float atmosphereSunBrightness;
						uniform vec3 atmosphereSunsetColor;
						uniform float atmosphereSunsetIntensity;
						uniform float atmosphereGroundIsSpheroid;

						const int atmosphereNumIterations = 5;

						// Inverse rotate a vector by a quaternion.
						vec3 quatRotInv(vec4 q, vec3 v) {
							float tx = q.w * v.x - q.y * v.z + q.z * v.y;
							float ty = q.w * v.y - q.z * v.x + q.x * v.z;
							float tz = q.w * v.z - q.x * v.y + q.y * v.x;
							float tw = q.x * v.x + q.y * v.y + q.z * v.z;
							float x = tx * q.w + tw * q.x + ty * q.z - tz * q.y;
							float y = ty * q.w + tw * q.y + tz * q.x - tx * q.z;
							float z = tz * q.w + tw * q.z + tx * q.y - ty * q.x;
							return vec3(x, y, z);
						}

						// Given an origin and direction, computes the sampling start and end as distance from the origin in the direction.
						void getStartEndSamples(out float start, out float end, vec3 origin, vec3 direction, float maxDistance, float groundRadius, float atmosphereScaleHeight) {
							// Get the along the ray perpendicular to the sphere.
							float perpD = -dot(origin, direction);
							vec3 perp = origin + direction * perpD;

							// Figure out the sample distance.
							float atmosphereRadius = groundRadius + atmosphereScaleHeight * 6.0;
							float chordHalfLength = sqrt(max(0.0, atmosphereRadius * atmosphereRadius - dot(perp, perp)));

							// Figure out starting and ending sample points.
							start = max(0.0, perpD - chordHalfLength);
							end = min(maxDistance, perpD + chordHalfLength);
						}

						// Gets the density of the atmosphere at a given position.
						float getDensity(vec3 position, float radius, float density, float atmosphereScaleHeight) {
							return density * exp((radius - length(position)) / atmosphereScaleHeight);
						}

						// Returns 0 if the ray does not intersect and 1.0 if the ray very intersects (with a gradient inbetween).
						float getDayLevel(vec3 origin, vec3 direction, float radius, float scaleHeight) {
							float blendHeight = scaleHeight * radius / 200.0;
							float perpD = -dot(origin, direction);
							float depth = radius - sqrt(dot(origin, origin) - sign(perpD) * perpD * perpD);
							if (depth < 0.0) { // day
								return 1.0 - max(0.0, 0.25 * depth / blendHeight + 0.25);
							}
							else { // night
								return 1.0 - min(1.0, 0.75 * depth / blendHeight + 0.25);
							}
						}

						// Adjusts the color if one of the RGB values is greater than 1.0.
						vec3 adjustOverbrightness(vec3 color) {
							float maxColor = max(color.r, max(color.g, color.b));
							if (maxColor > 1.0) {
								float f = (maxColor - 1.0) / maxColor;
								color.r = min(1.0, pow(color.r / maxColor, 1.0 / maxColor));
								color.g = min(1.0, pow(color.g / maxColor, 1.0 / maxColor));
								color.b = min(1.0, pow(color.b / maxColor, 1.0 / maxColor));
							}
							return color;
						}

						float easeInOut(float x, float sharpness) {
							float b = sharpness;
							if (x < 0.5) {
								return max(0.0, (pow(b, 2.0 * x) - 1.0) / (2.0 * (b - 1.0)));
							}
							else {
								return min(1.0, 1.0 - (pow(b, 2.0 * (1.0 - x)) - 1.0) / (2.0 * (b - 1.0)));
							}
						}

						// Calculates a glow around the light direction.
						float glow(float spread, float amount, float lightDotCamera) {
							return amount * spread / (1.0 + spread - lightDotCamera);
						}

						struct AtmosphereInfo {
							float spheroidRatio;
							highp vec3 position;
							highp vec3 cameraPosition;
							highp vec3 cameraToPosition;
							float cameraToPositionDist;
							highp vec3 cameraToPositionUnit;
							float start;
							float end;
							float totalDensity;
						};

						// Get atmosphere info that is independent of any light.
						AtmosphereInfo getAtmosphereInfo() {

							AtmosphereInfo atmosphereInfo;

							// Get position and camera in the atmosphere frame.
							atmosphereInfo.position = quatRotInv(atmosphereOrientation, cameraSpacePosition - atmospherePosition);
							atmosphereInfo.cameraPosition = quatRotInv(atmosphereOrientation, -atmospherePosition);

							// Convert everything into a sphere frame.
							atmosphereInfo.spheroidRatio = atmosphereEquatorialRadius / atmospherePolarRadius;
							atmosphereInfo.position.z *= atmosphereInfo.spheroidRatio;
							atmosphereInfo.cameraPosition.z *= atmosphereInfo.spheroidRatio;

							// Make sure the position is right on the ground.
							atmosphereInfo.position = normalize(atmosphereInfo.position / 1.0e8) * atmosphereEquatorialRadius;

							// Get some shortcut vectors.
							atmosphereInfo.cameraToPosition = atmosphereInfo.position - atmosphereInfo.cameraPosition;
							atmosphereInfo.cameraToPositionDist = length(atmosphereInfo.cameraToPosition / 1.0e8) * 1.0e8;
							atmosphereInfo.cameraToPositionUnit = atmosphereInfo.cameraToPosition / atmosphereInfo.cameraToPositionDist;

							// Get the start and end of the sampling from the camera to the position.
							getStartEndSamples(atmosphereInfo.start, atmosphereInfo.end, atmosphereInfo.cameraPosition, atmosphereInfo.cameraToPositionUnit, atmosphereInfo.cameraToPositionDist, atmosphereEquatorialRadius, atmosphereScaleHeight);
							float step = 1.0 / float(atmosphereNumIterations - 1);
							float stepDist = step * (atmosphereInfo.end - atmosphereInfo.start);

							// Do the sampling.
							atmosphereInfo.totalDensity = 0.0;
							float segmentStart = atmosphereInfo.start;
							for (int j = 0; j < atmosphereNumIterations; j++) {
								// Get the distance that this segment covers.
								float segDist = stepDist;
								if (j == 0 || j == atmosphereNumIterations - 1) {
									segDist *= 0.5;
								}

								// Get the segment start that we're looking at.
								vec3 p = atmosphereInfo.cameraPosition + segmentStart * atmosphereInfo.cameraToPositionUnit;

								// Get the density at that segment start. It'll be the density for the whole segment.
								float densityAtP = getDensity(p, atmosphereEquatorialRadius, atmosphereDensity, atmosphereScaleHeight);

								// Add it to the total density.
								atmosphereInfo.totalDensity += densityAtP * segDist;

								// Next step.
								segmentStart += stepDist;
							}

							return atmosphereInfo;
						}

						vec4 getAtmosphereEmissiveColor(AtmosphereInfo atmosphereInfo, vec3 color, float emissivity) {

							// Scale the total density with the emissivity.
							atmosphereInfo.totalDensity *= emissivity;

							// Apply the total density to the transparency of the atmosphere.
							vec4 outColor = vec4(0.0);
							outColor.a = clamp(pow(3.0 * atmosphereInfo.totalDensity, 0.3), 0.0, 1.0);

							// Multiply it all together with the source light color.
							outColor.rgb = emissivity * color * clamp(pow(15.0 * atmosphereInfo.totalDensity / (atmosphereDensity * atmosphereEquatorialRadius), 0.2), 0.75, 1.0);

							// Make it more opaque when lower down.
							outColor.a *= 1.0 + 0.5 * getDensity(atmosphereInfo.cameraPosition, atmosphereEquatorialRadius, 1.0, atmosphereScaleHeight);

							// Clamp it to make it clean.
							outColor.a = clamp(outColor.a, 0.0, 1.0);

							// Return the color.
							return outColor;
						}

						// Adjust the incoming light for the atmosphere.
						vec4 getAtmosphereColor(AtmosphereInfo atmosphereInfo, vec3 incomingLight, vec3 lightPosition) {

							// The color starts out in full brightness (as if emissivity was 1.0).
							vec4 outColor = getAtmosphereEmissiveColor(atmosphereInfo, incomingLight * atmosphereColor, 1.0);

							// Get the light position in the sphere entity-space.
							lightPosition = quatRotInv(atmosphereOrientation, lightPosition);
							lightPosition.z *= atmosphereInfo.spheroidRatio;
							highp vec3 lightToPosition = atmosphereInfo.position - lightPosition;
							highp vec3 lightToPositionUnit = normalize(lightToPosition / 1.0e8);

							// Get the day level, from 0 to 1, and apply it to the alpha.
							float ambientLightIntensity = min(1.0, length(ambientLightColor));
							vec3 dayRefUp = normalize(atmosphereInfo.cameraPosition + atmosphereInfo.end * atmosphereInfo.cameraToPositionUnit);
							float dayLevel = -dot(lightToPositionUnit, dayRefUp);
							float lightIntensity = mix(dayLevel, 0.0, ambientLightIntensity);
							outColor.a *= easeInOut(0.25 * 700.0 * atmosphereDensity + 1.0 * lightIntensity, 2.0);

							// Add broader sun glare.
							float lightDotCamera = max(0.0, -dot(lightToPositionUnit, atmosphereInfo.cameraToPositionUnit));
							outColor.rgb *= incomingLight * (1.0 + atmosphereSunBrightness * outColor.a * glow(0.04, 0.125, lightDotCamera));

							// Apply the sunset.
							float sunsetAmount = mix(atmosphereSunsetIntensity * easeInOut(0.5 * (1.0 - abs(dayLevel)), 4.0), 0.0, ambientLightIntensity);
							outColor.rgb *= mix(vec3(1.0), atmosphereSunsetColor, clamp(sunsetAmount, 0.0, 1.0));

							// Adjust for values that are greater than one.
							outColor.rgb = adjustOverbrightness(outColor.rgb);

							return outColor;
						}
					#endif

					void main(void) {
						// Get the camera direction to the position.
						vec3 positionDir = normalize(cameraSpacePosition);

						// Calculate the normal.
						#ifdef normalMap
							vec3 normal = getNormalFromMap();
						#else
							vec3 normal = normalize(cameraSpaceNormal);
						#endif

						// The diffuse light.
						vec3 diffuseLight = ambientLightColor;
						vec3 specularLight = vec3(0, 0, 0);

						// Atmosphere emissive shading.
						#ifdef atmosphere
							AtmosphereInfo atmosphereInfo = getAtmosphereInfo();
							vec4 atmosphereColor = getAtmosphereEmissiveColor(atmosphereInfo, atmosphereColor, atmosphereEmissivity);
						#endif

						// For each light,
						for (int i = 0; i < 5; i++) {
							if (i >= numLights) {
								break;
							}

							// Get lighting angles.
							vec3 lightDir = normalize(cameraSpacePosition - lightPositions[i]);
							float lightCosAngle = -dot(lightDir, normal);

							// Make the shadows a bit sharper, depending on atmospheres.
							float sharpness = 3.0;
							#ifdef atmosphere
								sharpness /= 1.0 + 700.0 * atmosphereDensity;
							#endif
							lightCosAngle = 2.0 * (1.0 + exp(-sharpness)) / (1.0 + exp(-sharpness * lightCosAngle)) - 1.0;

							// Get the incoming light after shadows.
							vec3 incomingLight = lightColors[i];
							#if !defined(colorMapEmmissive) | !defined(nightMapEmmissive) | !defined(decalMapEmmissive)
								#ifdef shadowEntities
									incomingLight = getLightColorFromShadowEntities(incomingLight, lightDir, lightPositions[i], lightRadii[i], normal);
								#endif
								#ifdef shadowRings
									incomingLight = getLightColorFromShadowRings(incomingLight, lightDir);
								#endif
							#endif

							// Diffuse shading.
							diffuseLight += incomingLight * saturate(lightCosAngle);

							// Specular shading.
							vec3 reflectedLightDir = reflect(lightDir, normal);
							vec3 halfVector = normalize(-lightDir - positionDir);
							float phongHighlight = 0.25 * pow(saturate(-dot(reflectedLightDir, positionDir)), specularHardness / 2.0);
							float blinnHighlight = 4.0 * pow(saturate(dot(halfVector, normal)), specularHardness);
							float specularAngle = phongHighlight + pow(1.0 - saturate(-dot(positionDir, normal)), specularHardness / 12.0) * blinnHighlight;
							specularLight += saturate(lightCosAngle * 20.0) * specularAngle * incomingLight;

							// Atmosphere shading.
							#ifdef atmosphere
								if (length(lightPositions[i]) > 0.0) { // don't use a camera light
									atmosphereColor += getAtmosphereColor(atmosphereInfo, incomingLight, lightPositions[i]);
								}
							#endif
						}
						diffuseLight = saturate(diffuseLight);

						// If there's ambience, remove the direct light components.
						specularLight *= vec3(1, 1, 1) - ambientLightColor;

						// Main Color map.
						vec4 colorPixel = vec4(1, 0, 1, 1);
						#ifdef colorTextureEnvironment
							colorPixel = getColorFromEnvironmentMap(colorTexture, positionDir, normal);
						#else
							colorPixel = texture2D(colorTexture, vColorUV) * vec4(color, 1);
						#endif
						#ifdef baseColor
							colorPixel = vec4(color, 1);
						#endif

						// Apply diffuse shading.
						#ifndef colorMapEmmissive
							colorPixel *= vec4(diffuseLight, 1.0);
						#endif
						gl_FragColor = colorPixel;

						// Specular Map
						vec3 specularPixel = specularColor * specularIntensity;
						#ifdef specularMap
							#ifdef specularUVs
								vec2 specularUV = vSpecularUV;
							#else
								vec2 specularUV = vColorUV;
							#endif
							specularPixel = specularColor * texture2D(specularTexture, specularUV).r;
						#endif

						// Apply specular Shading
						gl_FragColor.rgb += specularLight * specularPixel;

						// Night-Side Map
						#ifdef nightMap
							float ambientLightIntensity = min(1.0, length(ambientLightColor));
							#ifdef nightUVs
								vec2 nightUV = vNightUV;
							#else
								vec2 nightUV = vColorUV;
							#endif
							vec4 nightPixel = texture2D(nightTexture, nightUV);
							#ifndef nightMapEmmissive
								nightPixel *= vec4(diffuseLight, 1.0);
							#endif
							gl_FragColor = mix(gl_FragColor, nightPixel, 1.0 - min(1.0, length(ambientLightColor + diffuseLight)));//(1.0 - ambientLightIntensity) * saturate(0.5 - length(diffuseLight)));
						#endif

						// Decal Map
						#ifdef decalMap
							#ifdef decalUVs
								vec2 decalUV = vDecalUV;
							#else
								vec2 decalUV = vColorUV;
							#endif
							vec4 decalPixel = texture2D(decalTexture, decalUV);
							#ifndef decalMapEmmissive
								decalPixel *= vec4(diffuseLight, 1.0);
							#endif
							gl_FragColor.rgb = mix(gl_FragColor.rgb, decalPixel.rgb, decalPixel.a);
						#endif

						// Atmosphere
						#ifdef atmosphere
							gl_FragColor.rgb = mix(gl_FragColor.rgb, atmosphereColor.rgb, clamp(atmosphereColor.a, 0.0, 1.0));
						#endif

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
					}`
			});
		}
		const newMaterial = MaterialUtilsPhong._material.clone();
		for (let i = 0; i < newMaterial.uniforms['shadowEntityPositions'].value.length; i++) {
			newMaterial.uniforms['shadowEntityPositions'].value[i] = MaterialUtilsPhong._material.uniforms['shadowEntityPositions'].value[i].clone();
		}
		for (let i = 0; i < newMaterial.uniforms['shadowEntitySunsetColors'].value.length; i++) {
			newMaterial.uniforms['shadowEntitySunsetColors'].value[i] = MaterialUtilsPhong._material.uniforms['shadowEntitySunsetColors'].value[i].clone();
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupLogDepthBuffering(newMaterial);
		newMaterial.extensions.derivatives = true;
		newMaterial.needsUpdate = true;
		return newMaterial;
	}
}

/**
 * @type {THREE.ShaderMaterial}
*/
MaterialUtilsPhong._material = null;


/***/ }),

/***/ "../pioneer/engine/src/utils/material_utils_standard.js":
/*!**************************************************************!*\
  !*** ../pioneer/engine/src/utils/material_utils_standard.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MaterialUtilsStandard": function() { return /* binding */ MaterialUtilsStandard; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


class MaterialUtilsStandard {
	/** Gets a PBR ShaderMaterial.
	 * @returns {THREE.ShaderMaterial}
	 */
	static get() {
		if (MaterialUtilsStandard._material === null) {
			MaterialUtilsStandard._material = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.ShaderMaterial({
				uniforms: {
					// Lights
					ambientLightColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color()),
					lightPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(1, 0, 0)]),
					lightColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(0, 0, 0)]),
					lightRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
					numLights: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					environmentIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1.0),
					gammaCorrectionFactor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1.0),

					// External lighting and camera.
					entityPos: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()),

					// Shading.
					color: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color(1, 1, 1)),
					metalness: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0.0),
					roughness: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0.0),
					emissiveColor: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color(0, 0, 0)),
					alphaMultiplier: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(1.0),

					// Textures
					colorTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					roughnessTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					metalnessTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					normalTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					emissiveTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),

					// Shadow Entities
					numShadowEntities: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),
					shadowEntityPositions: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()]),
					shadowEntityRadii: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
					shadowEntitySunsetIntensity: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([0, 0, 0, 0, 0]),
					shadowEntitySunsetColors: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform([new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3(), new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3()]),

					// Environmental cubemap
					envTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					maxMipLevel: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

					// Dynamic environment map
					dynEnvTexture: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(null),
					dynEnvFaceSize: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(0),

					normalScale: new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Uniform(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector2()),

					..._internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.ThreeUniforms
				},
				vertexShader: `
					#ifdef normalMap
						attribute vec4 tangent;
						varying vec4 localTangent;
						varying vec3 localNormal;
					#else
						varying vec3 modelNormal;
					#endif
					#if defined(normalMap) || defined(colorMap) || defined(roughnessMap) || defined(metalnessMap) || defined(emissiveMap)
						varying vec2 localUV;
					#endif
					varying vec3 cameraSpacePosition;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.VertexHead}

					void main() {
						#ifdef normalMap
							localTangent = tangent;
							localNormal = normal;
						#else
							modelNormal = normalize((modelMatrix * vec4(normal, 0.)).xyz);
						#endif
						#if defined(normalMap) || defined(colorMap) || defined(roughnessMap) || defined(metalnessMap) || defined(emissiveMap)
							localUV = uv;
						#endif
						cameraSpacePosition = (modelMatrix * vec4(position, 1.)).xyz;
						vec4 viewPosition = modelViewMatrix * vec4(position, 1.);
						gl_Position = projectionMatrix * viewPosition;

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Vertex}
					}`,
				fragmentShader: `
					precision highp float;

					#define DEFAULT_SPECULAR_COEFFICIENT 0.04
					#define EPSILON 1e-6
					#define PI 3.14159265359
					#define RECIPROCAL_PI 0.31830988618
					#define RECIPROCAL_PI2 0.15915494
					#ifndef saturate
						#define saturate(a) clamp( a, 0.0, 1.0 )
					#endif

					float pow2( float x ) { return x*x; }

					uniform mat4 modelMatrix;

					// Lights
					uniform vec3 ambientLightColor;
					uniform vec3 lightPositions[5];
					uniform vec3 lightColors[5];
					uniform float lightRadii[5];
					uniform int numLights;
					uniform float environmentIntensity;
					uniform float gammaCorrectionFactor;

					// External lighting and camera.
					uniform vec3 entityPos;

					// Textures.
					uniform sampler2D colorTexture;
					uniform sampler2D roughnessTexture;
					uniform sampler2D metalnessTexture;
					#ifdef normalMap
						uniform sampler2D normalTexture;
					#endif
					#ifdef emissiveMap
						uniform sampler2D emissiveTexture;
					#endif
					#ifdef dynEnvMap
						uniform sampler2D dynEnvTexture;
						uniform float dynEnvFaceSize;
					#elif defined( envMap )
						#ifdef envIsCube
							uniform samplerCube envTexture;
						#else
							uniform sampler2D envTexture;
						#endif
					#endif

					#ifdef normalMap
						uniform vec2 normalScale;
					#endif

					// Shadow Entities.
					#ifdef shadowEntities
						uniform int numShadowEntities;
						uniform vec3 shadowEntityPositions[5];
						uniform float shadowEntityRadii[5];
						uniform float shadowEntitySunsetIntensity[5];
						uniform vec3 shadowEntitySunsetColors[5];
					#endif

					// Scalars
					uniform vec3 color;
					uniform float roughness;
					uniform float metalness;
					uniform vec3 emissiveColor;
					uniform float alphaMultiplier;

					// The varying attributes.
					#ifdef normalMap
						varying vec4 localTangent;
						varying vec3 localNormal;
					#else
						varying vec3 modelNormal;
					#endif
					#if defined(normalMap) || defined(colorMap) || defined(roughnessMap) || defined(metalnessMap) || defined(emissiveMap)
						varying vec2 localUV;
					#endif
					varying vec3 cameraSpacePosition;

					${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.FragmentHead}

					struct PhysicalMaterial {
						vec3 diffuseColor;
						vec3 specularColor;
						float specularRoughness;
					};
					struct IncidentLight {
						vec3 color;
						vec3 direction;
					};

					struct ReflectedLight {
						vec3 directDiffuse;
						vec3 directSpecular;
						vec3 indirectDiffuse;
						vec3 indirectSpecular;
					};

					struct GeometricContext {
						vec3 normal;
						vec3 viewDir;
					};

					#ifdef normalMap
						vec3 getNormalFromMap() {
							vec3 normal = normalize(localNormal);
							vec3 tangent = normalize(localTangent.xyz);
							vec3 bitangent = normalize(cross(normal, tangent));
							if (localTangent.w < 0.0) {
								bitangent *= -1.0;
							}
							mat3 transform = mat3(tangent, bitangent, normal);
							vec3 normalFromMap = texture2D(normalTexture, localUV).rgb * 2.0 - 1.0;
							normalFromMap.xy *= vec2(1, -1);
							normalFromMap.xy *= normalScale;
							return normalize(transform * normalFromMap);
						}
					#endif

					#ifdef shadowEntities
						vec3 applyRayleighScattering(vec3 color, float amount) {
							float value = (color.r + color.g + color.b);
							if (value > 0.0) {
								float rFactor = 1.0; // 6.3^-4 / 6.3^-4
								float gFactor = 1.602; // 5.6^-4 / 6.3^-4
								float bFactor = 3.228; // 4.7^-4 / 6.3^-4
								color.r *= pow(rFactor, -amount);
								color.g *= pow(gFactor, -amount);
								color.b *= pow(bFactor, -amount);
								color = value * color / (color.r + color.g + color.b);
							}
							return color;
						}

						vec3 getLightColorFromShadowEntities(vec3 lightColor, vec3 lightDir, vec3 lightPosition, float lightRadius, vec3 normal) {
							vec3 color = lightColor;
							for (int i = 0; i < 5; i++) {
								if (i >= numShadowEntities || lightRadius < 0.0) {
									break;
								}
								vec3 origin = cameraSpacePosition - shadowEntityPositions[i];
								vec3 axis = normalize(shadowEntityPositions[i] - lightPosition);
								float sd = dot(origin, axis);
								if (sd > 0.0) {
									float e = length(origin - sd * axis);
									float ld = dot(cameraSpacePosition - lightPosition, axis);
									float lr = lightRadius;
									float sr = shadowEntityRadii[i];
									float e0 = (ld * sr - sd * lr) / (ld - sd);
									float e1 = (ld * sr + sd * lr) / (ld - sd);
									float lightLevel = 0.0;
									if (e1 < 0.0 || sd < 0.0) { // light in front of shadow entity
										lightLevel = 1.0;
									}
									else if (e0 < e1) {
										e0 -= (e1 - e0) * saturate(shadowEntitySunsetIntensity[i] / 3.0);
										lightLevel = pow(saturate((e - e0) / (e1 - e0)), 0.5); // soft light
									}
									else {
										lightLevel = e < e0 ? 0.0 : 1.0; // 0 radius light.
									}
									color = lightLevel * mix(color, shadowEntitySunsetColors[i], (1.0 - lightLevel) * saturate(shadowEntitySunsetIntensity[i]));
								}
							}
							return color;
						}
					#endif

					vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
						return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
					}

					// These use optimizations found in https://cdn2.unrealengine.com/Resources/files/2013SiggraphPresentationsNotes-26915738.pdf.

					// The Smith-method geometry function. Calculates the ratio of incident light that is blocked by the microfacets to never reach the viewer.
					// alpha is the roughness^2
					// dotNL is the normal · the light vector.
					// dotNV is the normal · the view vector.
					float G_GGX_SmithCorrelated( float alpha, float dotNL, float dotNV ) {
						float a2 = pow2( alpha );
						// Get the light direction part of the geometry function.
						float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
						// Get the view direction part of the geometry function.
						float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
						// It would normally be be gv * gl, but this is using an optimization by Heitz (2014),
						// including the BRDF denominator, simplifying the results.
						return 0.5 / max( gv + gl, EPSILON );
					}

					// The Trowbridge-Reitz normal distribution function. Calculates the relative surface area microfacets exactly aligned to the halfway vector, how "smooth" the surface is.
					// alpha is the roughness^2.
					// dotNH is the normal · the halfway vector.
					float D_GGX( float alpha, float dotNH ) {
						float a2 = pow2( alpha );
						float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
						return RECIPROCAL_PI * a2 / pow2( denom );
					}

					// The Schlick approximation for the Fresnel equation.
					// Since metallic and non-metallic surfaces have different equations, this function combines the two by approximation.
					// specularColor is the specular color at normal incidence.
					// dotLH is the light direction · the halfway vector.
					vec3 F_Schlick( vec3 specularColor, float dotLH ) {
						float fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );
						return ( 1.0 - specularColor ) * fresnel + specularColor;
					}

					// The specular part of the main BRDF function that describes the weighting function for the sum of every incoming light.
					// It uses the Cook-Torrance model.
					vec3 BRDF_Specular_GGX( IncidentLight incidentLight, GeometricContext geometry, vec3 specularColor, float roughness ) {
						float alpha = pow2( roughness );
						vec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );
						float dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );
						float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
						float dotNH = saturate( dot( geometry.normal, halfDir ) );
						float dotLH = saturate( dot( incidentLight.direction, halfDir ) );
						vec3 F = F_Schlick( specularColor, dotLH );
						float G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );
						float D = D_GGX( alpha, dotNH );
						return F * ( G * D );
					}

					// The diffuse part of the main BRDF function.
					vec3 BRDF_Diffuse_Lambert( vec3 diffuseColor ) {
						return RECIPROCAL_PI * diffuseColor;
					}

					float BlinnExponentToGGXRoughness( float blinnExponent ) {
						return sqrt( 2.0 / ( blinnExponent + 2.0 ) );
					}

					float GGXRoughnessToBlinnExponent( float ggxRoughness ) {
						return ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );
					}

					vec2 integrateSpecularBRDF( float dotNV, float roughness ) {
						const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
						const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
						vec4 r = roughness * c0 + c1;
						float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
						return vec2( -1.04, 1.04 ) * a004 + r.zw;
					}

					vec3 BRDF_Specular_GGX_Environment( GeometricContext geometry, vec3 specularColor, float roughness ) {
						float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
						vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
						return specularColor * brdf.x + brdf.y;
					}

					void BRDF_Specular_Multiscattering_Environment( GeometricContext geometry, vec3 specularColor, float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
						float dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );
						vec3 F = F_Schlick( specularColor, dotNV );
						vec2 brdf = integrateSpecularBRDF( dotNV, roughness );
						vec3 FssEss = F * brdf.x + brdf.y;
						float Ess = brdf.x + brdf.y;
						float Ems = 1.0 - Ess;
						vec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
						singleScatter += FssEss;
						multiScatter += Fms * Ems;
					}

					float opacity = 1.0;

					uniform float reflectivity;
					uniform int maxMipLevel;

					// Returns the radiance: the incoming light * the cos(light angle to the normal)
					vec3 getIncomingLight( IncidentLight directLight, GeometricContext geometry) {
						float dotNL = saturate( dot( geometry.normal, directLight.direction ) );
						return (dotNL * directLight.color);
					}

					float getSpecularMIPLevel( float blinnShininessExponent, int maxMIPLevel ) {
						float maxMIPLevelScalar = float( maxMIPLevel );
						float desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );
						return clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );
					}

					#ifdef envIsCubeUV
						// These defines must match with PMREMGenerator
						#define cubeUV_maxMipLevel 8.0
						#define cubeUV_minMipLevel 4.0
						#define cubeUV_maxTileSize 256.0
						#define cubeUV_minTileSize 16.0
						// These shader functions convert between the UV coordinates of a single face of
						// a cubemap, the 0-5 integer index of a cube face, and the direction vector for
						// sampling a textureCube (not generally normalized ).
						float getFace( vec3 direction ) {
							vec3 absDirection = abs( direction );
							float face = - 1.0;
							if ( absDirection.x > absDirection.z ) {
								if ( absDirection.x > absDirection.y )
									face = direction.x > 0.0 ? 0.0 : 3.0;
								else
									face = direction.y > 0.0 ? 1.0 : 4.0;
							} else {
								if ( absDirection.z > absDirection.y )
									face = direction.z > 0.0 ? 2.0 : 5.0;
								else
									face = direction.y > 0.0 ? 1.0 : 4.0;
							}
							return face;
						}
						// RH coordinate system; PMREM face-indexing convention
						vec2 getUV( vec3 direction, float face ) {
							vec2 uv;
							if ( face == 0.0 ) {
								uv = vec2( direction.z, direction.y ) / abs( direction.x ); // pos x
							} else if ( face == 1.0 ) {
								uv = vec2( - direction.x, - direction.z ) / abs( direction.y ); // pos y
							} else if ( face == 2.0 ) {
								uv = vec2( - direction.x, direction.y ) / abs( direction.z ); // pos z
							} else if ( face == 3.0 ) {
								uv = vec2( - direction.z, direction.y ) / abs( direction.x ); // neg x
							} else if ( face == 4.0 ) {
								uv = vec2( - direction.x, direction.z ) / abs( direction.y ); // neg y
							} else {
								uv = vec2( direction.x, direction.y ) / abs( direction.z ); // neg z
							}
							return 0.5 * ( uv + 1.0 );
						}
						vec3 bilinearCubeUV( sampler2D environmentMap, vec3 direction, float mipInt ) {
							float face = getFace( direction );
							float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
							mipInt = max( mipInt, cubeUV_minMipLevel );
							float faceSize = exp2( mipInt );
							float texelSize = 1.0 / ( 3.0 * cubeUV_maxTileSize );
							vec2 uv = getUV( direction, face ) * ( faceSize - 1.0 );
							vec2 f = fract( uv );
							uv += 0.5 - f;
							if ( face > 2.0 ) {
								uv.y += faceSize;
								face -= 3.0;
							}
							uv.x += face * faceSize;
							if ( mipInt < cubeUV_maxMipLevel ) {
								uv.y += 2.0 * cubeUV_maxTileSize;
							}
							uv.y += filterInt * 2.0 * cubeUV_minTileSize;
							uv.x += 3.0 * max( 0.0, cubeUV_maxTileSize - 2.0 * faceSize );
							uv *= texelSize;
							vec3 tl = texture2D( environmentMap, uv ).rgb;
							uv.x += texelSize;
							vec3 tr = texture2D( environmentMap, uv ).rgb;
							uv.y += texelSize;
							vec3 br = texture2D( environmentMap, uv ).rgb;
							uv.x -= texelSize;
							vec3 bl = texture2D( environmentMap, uv ).rgb;
							vec3 tm = mix( tl, tr, f.x );
							vec3 bm = mix( bl, br, f.x );
							return mix( tm, bm, f.y );
						}
						#define r0 1.0
						#define v0 0.339
						#define m0 - 2.0
						#define r1 0.8
						#define v1 0.276
						#define m1 - 1.0
						#define r4 0.4
						#define v4 0.046
						#define m4 2.0
						#define r5 0.305
						#define v5 0.016
						#define m5 3.0
						#define r6 0.21
						#define v6 0.0038
						#define m6 4.0
						float roughnessToMip( float roughness ) {
							float mip = 0.0;
							if ( roughness >= r1 ) {
								mip = ( r0 - roughness ) * ( m1 - m0 ) / ( r0 - r1 ) + m0;
							} else if ( roughness >= r4 ) {
								mip = ( r1 - roughness ) * ( m4 - m1 ) / ( r1 - r4 ) + m1;
							} else if ( roughness >= r5 ) {
								mip = ( r4 - roughness ) * ( m5 - m4 ) / ( r4 - r5 ) + m4;
							} else if ( roughness >= r6 ) {
								mip = ( r5 - roughness ) * ( m6 - m5 ) / ( r5 - r6 ) + m5;
							} else {
								mip = - 2.0 * log2( 1.16 * roughness ); // 1.16 = 1.79^0.25
							}
							return mip;
						}
						vec4 textureCubeUV( sampler2D environmentMap, vec3 sampleDir, float roughness ) {
							float mip = clamp( roughnessToMip( roughness ), m0, cubeUV_maxMipLevel );
							float mipF = fract( mip );
							float mipInt = floor( mip );
							vec3 color0 = bilinearCubeUV( environmentMap, sampleDir, mipInt );
							if ( mipF == 0.0 ) {
								return vec4( color0, 1.0 );
							} else {
								vec3 color1 = bilinearCubeUV( environmentMap, sampleDir, mipInt + 1.0 );
								return vec4( mix( color0, color1, mipF ), 1.0 );
							}
						}
					#endif

					#ifdef dynEnvMap
						// Converts an XY in cylindrical space to a face (z) with coordinates within that face (xy).
						vec3 xyzToUvFace(vec3 xyz, float pixelSize) {
							// Figure out which basis we're using.
							vec3 basis[3];
							float face;
							if (xyz.x * xyz.x >= xyz.y * xyz.y && xyz.x * xyz.x >= xyz.z * xyz.z) {
								if (xyz.x >= 0.0) {
									basis[0] = vec3(0, 1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(1, 0, 0);
									face = 0.0;
								}
								else {
									basis[0] = vec3(0, -1, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(-1, 0, 0);
									face = 2.0;
								}
							}
							else if (xyz.y * xyz.y >= xyz.x * xyz.x && xyz.y * xyz.y >= xyz.z * xyz.z) {
								if (xyz.y >= 0.0) {
									basis[0] = vec3(-1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, 1, 0);
									face = 1.0;
								}
								else {
									basis[0] = vec3(1, 0, 0); basis[1] = vec3(0, 0, 1); basis[2] = vec3(0, -1, 0);
									face = 3.0;
								}
							}
							else {
								if (xyz.z >= 0.0) {
									basis[0] = vec3(0, 1, 0); basis[1] = vec3(-1, 0, 0); basis[2] = vec3(0, 0, 1);
									face = 4.0;
								}
								else {
									basis[0] = vec3(0, 1, 0); basis[1] = vec3(1, 0, 0); basis[2] = vec3(0, 0, -1);
									face = 5.0;
								}
							}

							// Convert into the uv basis from the xyz basis.
							float z = basis[2].x * xyz.x + basis[2].y * xyz.y + basis[2].z * xyz.z;
							if (z < 0.0) {
								z = 1.0;
							}
							vec2 uv = vec2(
								(basis[0].x * xyz.x + basis[0].y * xyz.y + basis[0].z * xyz.z) / z,
								(basis[1].x * xyz.x + basis[1].y * xyz.y + basis[1].z * xyz.z) / z);

							// Convert from -1 to +1, to 0 to 1.
							uv = 0.5 * (uv + vec2(1.0));

							// Convert to pixel-space.
							uv *= pixelSize;

							// Shrink to ignore 1 pixel borders.
							uv.x = (pixelSize - 2.0) / pixelSize * uv.x + 1.0;
							uv.y = (pixelSize - 2.0) / pixelSize * uv.y + 1.0;

							// Convert back to unit-space.
							uv /= pixelSize;

							return vec3(uv, face);
						}

						// Gets the dynamic environmental lighting given the outward direction.
						vec3 getEnvLight(vec3 direction, float roughness) {
							// Get the mip levels.
							float mipLevel = pow(roughness, 0.25) * (log2(dynEnvFaceSize) - 2.0);
							float mipLevel0 = floor(mipLevel);
							float mipLevel1 = floor(mipLevel) + 1.0;
							float mipLevelU = mipLevel - mipLevel0;
							float mipSizeX0 = pow(2.0, -mipLevel0);
							float mipOffsetY0 = 1.0 - pow(2.0, -mipLevel0);
							float mipSizeX1 = pow(2.0, -mipLevel1);
							float mipOffsetY1 = 1.0 - pow(2.0, -mipLevel1);
							// Get UV within a mip of cube faces.
							vec3 uvFace0 = xyzToUvFace(direction, dynEnvFaceSize * mipSizeX0);
							vec3 uvFace1 = xyzToUvFace(direction, dynEnvFaceSize * mipSizeX1);
							vec2 faceOffset = vec2(mod(uvFace0.z, 3.0) / 3.0, floor(uvFace0.z / 3.0) / 2.0);
							vec2 uvInMip0 = vec2(faceOffset.x + uvFace0.x / 3.0, faceOffset.y + uvFace0.y / 2.0);
							vec2 uvInMip1 = vec2(faceOffset.x + uvFace1.x / 3.0, faceOffset.y + uvFace1.y / 2.0);
							// Get the UVs within the textures.
							vec2 uv0 = vec2(uvInMip0.x * mipSizeX0 * 0.75, 0.5 * uvInMip0.y * mipSizeX0 + mipOffsetY0);
							vec2 uv1 = vec2(uvInMip1.x * mipSizeX1 * 0.75, 0.5 * uvInMip1.y * mipSizeX1 + mipOffsetY1);
							vec3 color0 = texture2D(dynEnvTexture, uv0).rgb;
							vec3 color1 = texture2D(dynEnvTexture, uv1).rgb;
							return mix(color0, color1, mipLevelU) * environmentIntensity * ((PI - 1.0) * roughness + 1.0);
						}
					#endif

					vec3 getLightProbeIndirectRadiance( GeometricContext geometry, float blinnShininessExponent, int maxMIPLevel ) {
						vec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );
						#if defined( envMap )
							reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
							float specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );
							vec3 queryReflectVec = vec3( reflectVec.x, reflectVec.yz );
							#ifdef envIsCube
								#ifdef TEXTURE_LOD_EXT
									vec4 envMapColor = textureCubeLodEXT( envTexture, queryReflectVec, specularMIPLevel );
								#else
									vec4 envMapColor = textureCube( envTexture, queryReflectVec, specularMIPLevel );
								#endif
							#elif defined( envIsCubeUV )
								vec4 envMapColor = textureCubeUV( envTexture, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));
							#else
								vec2 sampleUV;
								sampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
								sampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;
								#ifdef TEXTURE_LOD_EXT
									vec4 envMapColor = texture2DLodEXT( envTexture, sampleUV, specularMIPLevel );
								#else
									vec4 envMapColor = texture2D( envTexture, sampleUV, specularMIPLevel );
								#endif
							#endif
							return envMapColor.rgb * environmentIntensity;
						#else
							return vec3(0, 0, 0);
						#endif
					}

					// Given the directLight, accumulates onto the reflectedLight the irradiance as the BRDF function.
					void RE_Direct_Physical( IncidentLight directLight, GeometricContext geometry, PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
						vec3 irradiance = getIncomingLight( directLight, geometry );
						irradiance *= PI;
						float clearCoatDHR = 0.0;
						reflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );
						reflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
					}

					void RE_IndirectDiffuse_Physical( vec3 irradiance, GeometricContext geometry, PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
						reflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );
					}

					void RE_IndirectSpecular_Physical( vec3 radiance, vec3 irradiance, vec3 clearCoatRadiance, GeometricContext geometry, PhysicalMaterial material, inout ReflectedLight reflectedLight) {
						float clearCoatDHR = 0.0;
						float clearCoatInv = 1.0 - clearCoatDHR;
						reflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );
					}

					#define RE_Direct RE_Direct_Physical
					#define Material_BlinnShininessExponent( material ) GGXRoughnessToBlinnExponent( material.specularRoughness )
					#define RE_IndirectDiffuse RE_IndirectDiffuse_Physical
					#define RE_IndirectSpecular RE_IndirectSpecular_Physical

					void main(void) {
						vec4 diffuseColor = vec4( color, 1.0 );
						ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );

						#ifdef colorMap
							vec4 texelColor = texture2D(colorTexture, localUV);
							diffuseColor *= texelColor;
							opacity = texelColor.a;
						#endif

						// PBR variables
						float roughnessFactor;
						float metalnessFactor;

						roughnessFactor = roughness;
						#ifdef roughnessMap
							roughnessFactor *= texture2D( roughnessTexture, localUV ).g;
						#endif

						metalnessFactor = metalness;
						#ifdef metalnessMap
							metalnessFactor *= texture2D( metalnessTexture, localUV ).b;
						#endif

						PhysicalMaterial material;
						material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
						material.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );
						material.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );

						GeometricContext geometry;
						geometry.viewDir = -normalize(cameraSpacePosition);
						#ifdef normalMap
							geometry.normal = normalize((modelMatrix * vec4(getNormalFromMap(), 0.)).xyz);
						#else
							geometry.normal = modelNormal;
						#endif

						// Env Light
						vec3 irradiance = ambientLightColor;
						#ifdef dynEnvMap
							irradiance += getEnvLight(geometry.normal, 1.0);
						#endif
						vec3 radiance = ambientLightColor / 2.0;
						#ifdef dynEnvMap
							radiance += getEnvLight(reflect(-geometry.viewDir, geometry.normal), material.specularRoughness);
						#endif

						// Add emissivity.
						vec3 totalEmissiveRadiance = emissiveColor;
						#ifdef emissiveMap
							totalEmissiveRadiance *= texture2D(emissiveTexture, localUV).rgb;
						#endif

						// Add direct radiance.
						vec3 totalDirectIrradiance = ambientLightColor / 2.0;
						#ifdef dynEnvMap
							totalDirectIrradiance += getEnvLight(reflect(-geometry.viewDir, geometry.normal), material.specularRoughness);
						#endif

						// For each light,
						for (int i = 0; i < 5; i++) {
							if (i >= numLights) {
								break;
							}

							IncidentLight directLight;
							directLight.color = lightColors[i];
							directLight.direction = -normalize(cameraSpacePosition - lightPositions[i]);
							#ifdef shadowEntities
								directLight.color = getLightColorFromShadowEntities(directLight.color, directLight.direction, lightPositions[i], lightRadii[i], geometry.normal);
							#endif

							RE_Direct(directLight, geometry, material, reflectedLight);

							radiance += getLightProbeIndirectRadiance(geometry, Material_BlinnShininessExponent(material), maxMipLevel);
							RE_IndirectDiffuse(irradiance, geometry, material, reflectedLight);
							RE_IndirectSpecular(radiance, irradiance, vec3(0.0), geometry, material, reflectedLight);

							// Modify env light by total incoming light.
							totalDirectIrradiance += getIncomingLight(directLight, geometry);
						}

						// Multiply in the direct irradiance.
						reflectedLight.indirectSpecular *= totalDirectIrradiance;

						// If there's ambience, remove the direct light components.
						reflectedLight.directDiffuse *= vec3(1, 1, 1) - ambientLightColor;
						reflectedLight.directSpecular *= vec3(1, 1, 1) - ambientLightColor;

						// Add the reflected light to the outgoing light.
						vec3 outgoingLight = totalEmissiveRadiance + reflectedLight.directDiffuse + reflectedLight.directSpecular + reflectedLight.indirectDiffuse + reflectedLight.indirectSpecular;

						// Set the frag color based on the total outgoing light.
						gl_FragColor = vec4( outgoingLight, opacity );

						// Gamma correction
						gl_FragColor = vec4( pow( abs(gl_FragColor.rgb), vec3( 1.0 / gammaCorrectionFactor ) ), gl_FragColor.a );

						// Convert to sRGB.
						gl_FragColor = LinearTosRGB(gl_FragColor);

						// Multiply the alphaMultiplier.
						gl_FragColor.a *= alphaMultiplier;

						${_internal__WEBPACK_IMPORTED_MODULE_0__.ShaderChunkLogDepth.Fragment}
					}`
			});
		}
		const newMaterial = MaterialUtilsStandard._material.clone();
		for (let i = 0; i < newMaterial.uniforms['shadowEntityPositions'].value.length; i++) {
			newMaterial.uniforms['shadowEntityPositions'].value[i] = MaterialUtilsStandard._material.uniforms['shadowEntityPositions'].value[i].clone();
		}
		for (let i = 0; i < newMaterial.uniforms['shadowEntitySunsetColors'].value.length; i++) {
			newMaterial.uniforms['shadowEntitySunsetColors'].value[i] = MaterialUtilsStandard._material.uniforms['shadowEntitySunsetColors'].value[i].clone();
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setupLogDepthBuffering(newMaterial);
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasGLExtension('EXT_shader_texture_lod')) {
			newMaterial.extensions.shaderTextureLOD = true;
		}
		newMaterial.extensions.derivatives = true;
		newMaterial.needsUpdate = true;
		return newMaterial;
	}
}

/** @type {THREE.ShaderMaterial} */
MaterialUtilsStandard._material = null;


/***/ }),

/***/ "../pioneer/engine/src/utils/math_utils.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/math_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "MathUtils": function() { return /* binding */ MathUtils; }
/* harmony export */ });
/** @module pioneer */

/**
 * A class of math routines to augment the built-in Math class.
 * @hideconstructor
 */
class MathUtils {
	/**
	 * Returns PI.
	 * @returns {number}
	 */
	static get pi() {
		return 3.141592653589793;
	}

	/**
	 * Returns PI * 2.
	 * @returns {number}
	 */
	static get twoPi() {
		return 6.283185307179586;
	}

	/**
	 * Returns PI / 2.
	 * @returns {number}
	 */
	static get halfPi() {
		return 1.5707963267948966;
	}

	/**
	 * Returns the nearest angle between a0 and a1.
	 * @param {number} a0
	 * @param {number} a1
	 * @returns {number}
	 */
	static angle(a0, a1) {
		a0 = this.wrap(a0, 0, 2 * Math.PI);
		a1 = this.wrap(a1, 0, 2 * Math.PI);
		if (a1 - a0 > Math.PI) {
			return a0 - a1 + 2 * Math.PI;
		}
		if (a0 - a1 > Math.PI) {
			return a1 - a0 + 2 * Math.PI;
		}
		return Math.abs(a1 - a0);
	}

	/**
	 * Clamps a between a0 and a1.
	 * @param {number} a - the value to clamp
	 * @param {number} a0 - the minimum
	 * @param {number} a1 - the maximum
	 * @returns {number}
	 */
	static clamp(a, a0, a1) {
		return Math.min(Math.max(a0, a), a1);
	}

	/**
	 * Clamps a between 0 and 1.
	 * @param {number} a - the value to clamp
	 * @returns {number}
	 */
	static clamp01(a) {
		return Math.min(Math.max(0, a), 1);
	}

	/**
	 * Returns the point a between a0 and a1 as if they were a cycle.
	 * @param {number} a - the value to wrap
	 * @param {number} a0 - the start of the cycle
	 * @param {number} a1 - the end of the cycle
	 * @returns {number}
	 */
	static wrap(a, a0, a1) {
		let phase = (a - a0) % (a1 - a0) + a0;
		if (phase < a0) {
			phase += a1 - a0;
		}
		return phase;
	}

	/**
	 * Linearly interpolates between a0 and a1.
	 * @param {number} a0 - the value when u = 0
	 * @param {number} a1 - the value when u = 1
	 * @param {number} u - the lerp factor
	 * @returns {number}
	 */
	static lerp(a0, a1, u) {
		return (1.0 - u) * a0 + u * a1;
	}

	/**
	 * Linearly interpolates between two angles in radians a0 and a1.
	 * @param {number} a0 - the value when u = 0
	 * @param {number} a1 - the value when u = 1
	 * @param {number} u - the lerp factor
	 * @returns {number}
	 */
	static lerpAngle(a0, a1, u) {
		a0 = this.wrap(a0, -Math.PI, +Math.PI);
		a1 = this.wrap(a1, -Math.PI, +Math.PI);
		if (a1 - a0 > Math.PI) {
			a0 += 2 * Math.PI;
		}
		if (a0 - a1 > Math.PI) {
			a1 += 2 * Math.PI;
		}
		return this.wrap(this.lerp(a0, a1, u), -Math.PI, +Math.PI);
	}

	/**
	 * Converts radians to degrees.
	 * @param {number} a - the value in radians
	 * @returns {number}
	 */
	static radToDeg(a) {
		return a * 57.29577951308232;
	}

	/**
	 * Converts degrees to radians.
	 * @param {number} a - the value in degrees
	 * @returns {number}
	 */
	static degToRad(a) {
		return a * 0.01745329251994329;
	}

	/**
	 * Returns the next higher power of two, or a if it is a power of 2.
	 * @param {number} a - the value to use
	 * @returns {number}
	 */
	static ceilPow2(a) {
		return Math.pow(2, Math.ceil(Math.log(a) / Math.log(2)));
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/orbital_elements.js":
/*!*******************************************************!*\
  !*** ../pioneer/engine/src/utils/orbital_elements.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitalElements": function() { return /* binding */ OrbitalElements; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


class OrbitalElements {
	constructor() {
		/**
		 * The epoch.
		 * @type {number}
		 */
		this.epoch = 0;

		/**
		 * The eccentricity.
		 * @type {number}
		 */
		this.eccentricity = 0;

		/**
		 * The semi-major axis.
		 * @type {number}
		 */
		this.semiMajorAxis = 0;

		/**
		 * The mean angular motion.
		 * @type {number}
		 */
		this.meanAngularMotion = 0;

		/**
		 * The mean anomaly at the epoch.
		 * @type {number}
		 */
		this.meanAnomalyAtEpoch = 0;

		/**
		 * The orbit's oriention.
		 * The x-axis is along the eccentricity vector (periapsis) and the z-axis is along the angular momentum vector.
		 * @type {Quaternion}
		 */
		this.orbitOrientation = new _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
	}

	/**
	 * Copies an other orbital elements to this.
	 * @param {OrbitalElements} other
	 */
	copy(other) {
		this.epoch = other.epoch;
		this.eccentricity = other.eccentricity;
		this.semiMajorAxis = other.semiMajorAxis;
		this.meanAnomalyAtEpoch = other.meanAnomalyAtEpoch;
		this.meanAngularMotion = other.meanAngularMotion;
		this.orbitOrientation.copy(other.orbitOrientation);
	}

	/**
	 * Projects a position and velocity based on the orbital elements.
	 * @param {Vector3} outPosition
	 * @param {Vector3} outVelocity
	 * @param {number} meanAnomaly
	 */
	projectFromMeanAnomaly(outPosition, outVelocity, meanAnomaly) {
		if (this.eccentricity < 1.0) {
			// Get the eccentric anomaly.
			const eccentricAnomaly = this.getEccentricAnomalyFromMeanAnomaly(meanAnomaly);

			// Set the position and rotate it by the orbit orientation.
			const radius = this.semiMajorAxis * (1.0 - this.eccentricity * Math.cos(eccentricAnomaly));
			const velocityFactor = this.meanAngularMotion * this.semiMajorAxis * this.semiMajorAxis / radius;
			outPosition.x = this.semiMajorAxis * (Math.cos(eccentricAnomaly) - this.eccentricity);
			outPosition.y = this.semiMajorAxis * Math.sqrt(1.0 - this.eccentricity * this.eccentricity) * Math.sin(eccentricAnomaly);
			outVelocity.x = -velocityFactor * Math.sin(eccentricAnomaly);
			outVelocity.y = velocityFactor * Math.sqrt(1.0 - this.eccentricity * this.eccentricity) * Math.cos(eccentricAnomaly);
		}
		else {
			// Get the hyperbolic anomaly.
			const hyperbolicAnomaly = this.getEccentricAnomalyFromMeanAnomaly(meanAnomaly);

			// Set the position and rotate it by the orbit orientation.
			const radius = -this.semiMajorAxis * (1.0 - this.eccentricity * Math.cosh(hyperbolicAnomaly));
			const velocityFactor = this.meanAngularMotion * this.semiMajorAxis * this.semiMajorAxis / radius;
			outPosition.x = this.semiMajorAxis * (this.eccentricity - Math.cosh(hyperbolicAnomaly));
			outPosition.y = this.semiMajorAxis * Math.sqrt(this.eccentricity * this.eccentricity - 1.0) * Math.sinh(hyperbolicAnomaly);
			outVelocity.x = -velocityFactor * Math.sinh(hyperbolicAnomaly);
			outVelocity.y = velocityFactor * Math.sqrt(this.eccentricity * this.eccentricity - 1.0) * Math.cosh(hyperbolicAnomaly);
		}
		outPosition.z = 0.0;
		outVelocity.z = 0.0;

		// Rotate the vectors by the orbit orientation.
		outPosition.rotate(this.orbitOrientation, outPosition);
		outVelocity.rotate(this.orbitOrientation, outVelocity);
	}

	/**
	 * Projects a position and velocity based on the orbital elements.
	 * @param {Vector3} outPosition
	 * @param {Vector3} outVelocity
	 * @param {number} time
	 */
	project(outPosition, outVelocity, time) {
		// Get the mean anomaly for the time.
		let meanAnomaly = this.meanAnomalyAtEpoch + this.meanAngularMotion * (time - this.epoch);
		if (this.eccentricity < 1.0) {
			meanAnomaly = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(meanAnomaly, -_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi, +_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi);
		}
		this.projectFromMeanAnomaly(outPosition, outVelocity, meanAnomaly);
	}

	/**
	 * Gets the true anomaly given a position.
	 * @param {Vector3} position
	 * @returns {number}
	 */
	getTrueAnomalyFromPosition(position) {
		const positionInPlane = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		positionInPlane.rotateInverse(this.orbitOrientation, position);
		const trueAnomaly = Math.atan2(positionInPlane.y, positionInPlane.x);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionInPlane);
		return trueAnomaly;
	}

	/**
	 * Gets the mean anomaly from the true anomaly.
	 * @param {number} trueAnomaly
	 * @returns {number}
	 */
	getMeanAnomalyFromTrueAnomaly(trueAnomaly) {
		// The eccentric anomaly, mean anomaly, and mean angular motion from the true anomaly, for either ellipses or hyperbolas.
		let eccentricAnomaly = 0.0;
		let meanAnomaly = 0.0;
		if (this.eccentricity < 1.0) {
			eccentricAnomaly = 2.0 * Math.atan(Math.tan(trueAnomaly / 2.0) * Math.sqrt((1 - this.eccentricity) / (1 + this.eccentricity)));
			meanAnomaly = eccentricAnomaly - this.eccentricity * Math.sin(eccentricAnomaly);
		}
		else {
			eccentricAnomaly = 2.0 * Math.atanh(Math.tan(trueAnomaly / 2.0) * Math.sqrt((this.eccentricity - 1) / (1 + this.eccentricity)));
			meanAnomaly = this.eccentricity * Math.sinh(eccentricAnomaly) - eccentricAnomaly;
		}
		return meanAnomaly;
	}

	/**
	 * Gets the eccentric/hyperbolic anomaly from the mean anomaly.
	 * @param {number} meanAnomaly
	 * @returns {number}
	 */
	getEccentricAnomalyFromMeanAnomaly(meanAnomaly) {
		if (this.eccentricity < 1.0) {
			// Use Newton's method to find the eccentric anomaly.
			let eccentricAnomaly = meanAnomaly;
			if (this.eccentricity >= 0.8) {
				eccentricAnomaly = Math.sign(meanAnomaly) * _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.pi; // use a more optimal start point for near parabolic orbits
			}
			for (let i = 0; i < 20; i++) {
				const difference = (eccentricAnomaly - this.eccentricity * Math.sin(eccentricAnomaly) - meanAnomaly) / (this.eccentricity * Math.cos(eccentricAnomaly) - 1.0);
				eccentricAnomaly += difference;
				if (Math.abs(difference) < 0.00174532925) { // .1 degrees
					break;
				}
			}
			return eccentricAnomaly;
		}
		else {
			// Use Newton's method to find the hyperbolic anomaly.
			let hyperbolicAnomaly = Math.log(2.0 * Math.abs(meanAnomaly) / Math.E + 1.8);
			if (this.eccentricity <= 1.2) {
				hyperbolicAnomaly = Math.log(2.0 * Math.abs(meanAnomaly) / Math.E + 1.8); // use a more optimal start point for near parabolic orbits
			}
			if (meanAnomaly < 0.0) {
				hyperbolicAnomaly *= -1;
			}
			for (let i = 0; i < 20; i++) {
				const difference = (hyperbolicAnomaly - this.eccentricity * Math.sinh(hyperbolicAnomaly) + meanAnomaly) / (this.eccentricity * Math.cosh(hyperbolicAnomaly) - 1.0);
				hyperbolicAnomaly += difference;
				if (Math.abs(difference) < 0.00174532925) { // .1 degrees
					break;
				}
			}
			return hyperbolicAnomaly;
		}
	}

	/**
	 * Gets the mean anomaly from the eccentric or hyperbolic anomaly.
	 * @param {number} eccentricAnomaly
	 * @returns {number}
	 */
	getMeanAnomalyFromEccentricAnomaly(eccentricAnomaly) {
		if (this.eccentricity < 1.0) {
			const meanAnomaly = eccentricAnomaly - this.eccentricity * Math.sin(eccentricAnomaly);
			return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(meanAnomaly, -Math.PI, +Math.PI);
		}
		else {
			return this.eccentricity * Math.sinh(eccentricAnomaly) - eccentricAnomaly;
		}
	}

	/**
	 * Gets the true anomaly from the eccentric or hyperbolic anomaly.
	 * @param {number} eccentricAnomaly
	 * @returns {number}
	 */
	getTrueAnomalyFromEccentricAnomaly(eccentricAnomaly) {
		if (this.eccentricity < 1.0) {
			return 2.0 * Math.atan(Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)) * Math.tan(eccentricAnomaly / 2.0));
		}
		else {
			return 2.0 * Math.atan(Math.sqrt((1 + this.eccentricity) / (this.eccentricity - 1)) * Math.tanh(eccentricAnomaly / 2.0));
		}
	}

	/**
	 * Gets the eccentric/hyperbolic anomaly from the true anomaly.
	 * @param {number} trueAnomaly
	 * @returns {number}
	 */
	getEccentricAnomalyFromTrueAnomaly(trueAnomaly) {
		// The eccentric anomaly, mean anomaly, and mean angular motion from the true anomaly, for either ellipses or hyperbolas.
		if (this.eccentricity < 1.0) {
			const eccentricAnomaly = 2.0 * Math.atan2(Math.tan(trueAnomaly / 2.0), Math.sqrt((1 + this.eccentricity) / (1 - this.eccentricity)));
			return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(eccentricAnomaly, -Math.PI, +Math.PI);
		}
		else {
			return 2.0 * Math.atanh(Math.sqrt((this.eccentricity - 1.0) / (this.eccentricity + 1.0)) * Math.tan(trueAnomaly / 2.0));
		}
	}

	/**
	 * Gets the inclination in radians.
	 * @returns {number}
	 */
	getInclination() {
		const h = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		// Get the angular momentum.
		this.orbitOrientation.getAxis(h, 2);
		// Get the inclination as angle between angular momentum and z-axis.
		const inclination = h.angle(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(h);
		return inclination;
	}

	/**
	 * Gets the longitude of the ascending node in radians.
	 * @returns {number}
	 */
	getLongitudeOfAscendingNode() {
		const h = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		// Get the angular momentum.
		this.orbitOrientation.getAxis(h, 2);
		// Get the longitude of ascending node as perpendicular to the angular momentum projected onto the x-y plane.
		const longitudeOfAscendingNode = Math.atan2(h.x, -h.y);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(h);
		return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(longitudeOfAscendingNode, 0, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi);
	}

	/**
	 * Gets the argument of the periapsis in radians.
	 * @returns {number}
	 */
	getArgumentOfPeriapsis() {
		const h = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const e = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		// Get the angular momentum.
		this.orbitOrientation.getAxis(h, 2);
		// Get the ascending node.
		h.set(-h.y, h.x, 0);
		// Get the eccentricity vector.
		this.orbitOrientation.getAxis(e, 0);
		const argumentOfPeriapsis = h.angle(e);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(e);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(h);
		return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(argumentOfPeriapsis, 0, _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi);
	}

	/**
	 * Gets the period in seconds.
	 * @returns {number}
	 */
	getPeriod() {
		return _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi / this.meanAngularMotion;
	}

	/**
	 * Gets the periapsis.
	 * @returns {number}
	 */
	getPeriapsis() {
		return this.semiMajorAxis * (1 - this.eccentricity);
	}

	/**
	 * Gets the apoapsis.
	 * @returns {number}
	 */
	getApoapsis() {
		return this.semiMajorAxis * (1 + this.eccentricity);
	}

	/**
	 * Given an inclination, longitude of ascending node, and argument of periapsis, all in radians,
	 *   get the orbit orientation as a quaternion.
	 * @param {number} inclination
	 * @param {number} longitudeOfAscendingNode
	 * @param {number} argumentOfPeriapsis
	 */
	setOrbitOrientationFromElements(inclination, longitudeOfAscendingNode, argumentOfPeriapsis) {
		const n = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const h = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const periapsisRotation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		n.set(Math.cos(longitudeOfAscendingNode), Math.sin(longitudeOfAscendingNode), 0);
		h.set(Math.sin(longitudeOfAscendingNode) * Math.sin(inclination), -Math.cos(longitudeOfAscendingNode) * Math.sin(inclination), Math.cos(inclination));
		this.orbitOrientation.setFromAxes(n, undefined, h);
		periapsisRotation.setFromAxisAngle(h, argumentOfPeriapsis);
		this.orbitOrientation.mult(periapsisRotation, this.orbitOrientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(periapsisRotation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(h);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(n);
	}

	/**
	 * Sets orbital elements from a position, velocity, time, and a gravitational constant GM.
	 * @param {Vector3} position
	 * @param {Vector3} velocity
	 * @param {number} time
	 * @param {number} gm
	 */
	setFromPositionAndVelocity(position, velocity, time, gm) {
		const gmInv = 1 / gm;

		// Set the epoch.
		this.epoch = time;

		// Get the specific angular momentum.
		const specificAngularMomentum = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		specificAngularMomentum.cross(position, velocity);

		// Get the eccentricity vector and eccentricity.
		const eccentricityVec = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const positionNormalized = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		positionNormalized.normalize(position);
		eccentricityVec.cross(velocity, specificAngularMomentum);
		eccentricityVec.mult(eccentricityVec, gmInv);
		eccentricityVec.sub(eccentricityVec, positionNormalized);
		this.eccentricity = eccentricityVec.magnitude();

		// The semi-major axis.
		const semiLatusRectum = specificAngularMomentum.dot(specificAngularMomentum) * gmInv;
		this.semiMajorAxis = semiLatusRectum / (1 - this.eccentricity * this.eccentricity);
		if (this.eccentricity > 1) {
			this.semiMajorAxis *= -1;
		}

		// The true anomaly.
		let trueAnomaly = Math.acos(_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(eccentricityVec.dot(positionNormalized) / this.eccentricity, -1, 1));
		if (position.dot(velocity) < 0) {
			trueAnomaly *= -1;
		}
		if (trueAnomaly < -Math.PI) {
			trueAnomaly += _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
		}
		if (trueAnomaly >= Math.PI) {
			trueAnomaly -= _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
		}

		// The orbit orientation quaternion.
		eccentricityVec.normalize(eccentricityVec);
		specificAngularMomentum.normalize(specificAngularMomentum);
		this.orbitOrientation.setFromAxes(eccentricityVec, undefined, specificAngularMomentum);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionNormalized);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(specificAngularMomentum);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(eccentricityVec);

		// The eccentric anomaly, mean anomaly, and mean angular motion from the true anomaly, for either ellipses or hyperbolas.
		const eccentricAnomaly = this.getEccentricAnomalyFromTrueAnomaly(trueAnomaly);
		this.meanAnomalyAtEpoch = this.getMeanAnomalyFromEccentricAnomaly(eccentricAnomaly);
		this.meanAngularMotion = Math.sqrt(gm / (this.semiMajorAxis * this.semiMajorAxis * this.semiMajorAxis));
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/pool.js":
/*!*******************************************!*\
  !*** ../pioneer/engine/src/utils/pool.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Pool": function() { return /* binding */ Pool; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A pool for generic objects. Great for minimizing garbage collection. For every get call you must call release.
 * @template Type
 * @extends FastIterable<Type>
 */
class Pool extends _internal__WEBPACK_IMPORTED_MODULE_0__.FastIterable {
	/**
	 * @typedef PoolData
	 * @property {number} _poolIndex - The index in the pool.
	 * @property {boolean} _poolUsed - If true, the item is in the pool.
	 */

	/**
	 * @typedef {PoolData & Type} PoolItem
	 */

	/**
	 * The constructor.
	 * @param {new () => Type} type - The class that will be instantiated when a new object needs to be allocated. It must be default constructable.
	 */
	constructor(type) {
		super();

		/**
		 * The class type for when new objects are needed.
		 * @type {new () => Type}
		 * @private
		 */
		this._type = type;

		/**
		 * List of objects, free and used.
		 * @type {Array<PoolItem>}
		 * @private
		 */
		this._objects = [];

		/**
		 * List of which objects are free in the objects list. It acts like a stack of indices into the objects list.
		 * @type {number[]}
		 * @private
		 */
		this._free = [];

		/**
		 * Since the free list only grows, this says how long the array is.
		 * @type {number}
		 * @private
		 */
		this._freeLength = 0;

		/**
		 * A constructor function that is called when a new object needs to be created.
		 * @type {function():Type}
		 * @private
		 */
		this._constructorFunction = () => {
			return new this._type();
		};

		/**
		 * A destructor function that is called when an object needs to be destroyed.
		 * @type {() => void}
		 * @private
		 */
		this._destructorFunction = () => {
		};
	}

	/**
	 * Sets a constructor function that is called when a new object needs to be created.
	 * @param {() => Type} constructorFunction
	 */
	setConstructorFunction(constructorFunction) {
		this._constructorFunction = constructorFunction;
	}

	/**
	 * Sets a destructor function that is called when an object needs to be destroyed.
	 * @param {() => void} destructorFunction
	 */
	setDestructorFunction(destructorFunction) {
		this._destructorFunction = destructorFunction;
	}

	/**
	 * Gets an object from the pool.
	 * @returns {Type}
	 */
	get() {
		/** @type {PoolItem} */
		let objectToGet = null;
		if (this._freeLength > 0) {
			objectToGet = this._objects[this._free[this._freeLength - 1]];
			this._freeLength -= 1;
		}
		else {
			// @ts-ignore - Ignoring conversion from Type to PoolItem.
			const poolIndex = this._objects.push(this._constructorFunction()) - 1;
			this._objects[poolIndex]._poolIndex = poolIndex;
			objectToGet = this._objects[poolIndex];
		}
		objectToGet._poolUsed = true;
		// @ts-ignore - Ignoring conversion from PoolItem to Type.
		return objectToGet;
	}

	/**
	 * Releases an object back into the pool.
	 * @param {Type} o - The object to release.
	 */
	release(o) {
		/** @type {PoolItem} */
		// @ts-ignore - Ignoring conversion from Type to PoolItem.
		const poolItem = o;
		if (poolItem._poolIndex !== undefined) {
			if (this._freeLength >= this._free.length) {
				this._free.push(poolItem._poolIndex);
			}
			else {
				this._free[this._freeLength] = poolItem._poolIndex;
			}
			this._freeLength += 1;
			poolItem._poolUsed = false;
		}
	}

	/**
	 * Cleans up memory, removing all unused objects. If the threshold is a number and is greater or equal than the number of used / total,
	 * it will be cleaned.
	 * @param {number} [threshold]
	 */
	clean(threshold) {
		if (threshold === undefined || threshold >= (this._objects.length - this._freeLength) / this._objects.length) {
			for (let freeI = 0; freeI < this._freeLength; freeI++) {
				const indexToRemove = this._free[freeI];
				// @ts-ignore - Ignoring conversion from PoolItem to Type.
				this._destructorFunction(this._objects[indexToRemove]);
				this._objects.splice(indexToRemove, 1);
				for (let i = indexToRemove, l = this._objects.length; i < l; i++) {
					this._objects[i]._poolIndex -= 1;
				}
				for (let i = freeI + 1, l = this._freeLength; i < l; i++) {
					if (this._free[i] > indexToRemove) {
						this._free[i] -= 1;
					}
				}
			}
			this._free = [];
			this._freeLength = 0;
		}
	}

	/**
	 * Returns the whole pool as an array.
	 * @returns {Type[]}
	 */
	getAsArray() {
		// @ts-ignore - Ignoring conversion from PoolItem to Type.
		return this._objects;
	}

	/**
	 * Returns true if the object is in the pool and used.
	 * @param {any} o
	 * @returns {boolean}
	 */
	isUsed(o) {
		return o._poolUsed;
	}

	/**
	 * Returns true if there are any objects used. This is good for debugging to see if there are any get calls without release calls.
	 * @returns {boolean}
	 */
	areAnyUsed() {
		return this._freeLength < this._objects.length;
	}

	/**
	 * Gets the value of the given index.
	 * @param {number} index
	 * @returns {Type}
	 * @override
	 */
	getAt(index) {
		return this._objects[index];
	}

	/**
	 * Gets the number of values.
	 * @returns {number}
	 * @override
	 */
	get size() {
		return this._objects.length;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/quaternion.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/quaternion.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Quaternion": function() { return /* binding */ Quaternion; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A mathematical quaternion */
class Quaternion extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<Quaternion>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * NaN quaternion
	 * @returns {Quaternion}
	 */
	static get NaN() {
		return _nan;
	}

	/**
	 * Returns the identity quaternion.
	 * @returns {Quaternion}
	 */
	static get Identity() {
		return _identity;
	}

	/**
	 * Returns a quaternion from the angle-axis rotation.
	 * @param {Vector3} axis - must be normalized
	 * @param {number} angle - in radians
	 * @returns {Quaternion}
	 */
	static fromAxisAngle(axis, angle) {
		const q = new Quaternion();
		q.setFromAxisAngle(axis, angle);
		return q;
	}

	/**
	 * Returns a quaternion representing a rotate frame from the given at least two axes, the other being undefined. The given axes must be orthonormal.
	 * @param {Vector3|undefined} xAxis
	 * @param {Vector3|undefined} yAxis
	 * @param {Vector3|undefined} zAxis
	 * @returns {Quaternion}
	 */
	static fromAxes(xAxis, yAxis, zAxis) {
		const q = new Quaternion();
		q.setFromAxes(xAxis, yAxis, zAxis);
		return q;
	}

	/**
	 * Returns a quaternion from Euler angles.
	 * @param {number} pitch - the angle around the +x axis to rotate
	 * @param {number} roll - the angle around the +y axis to rotate
	 * @param {number} yaw - the angle around the +z axis to rotate
	 * @returns {Quaternion}
	 */
	static fromEuler(pitch, roll, yaw) {
		const q = new Quaternion();
		q.setFromEuler(pitch, roll, yaw);
		return q;
	}

	/**
	 * Returns a quaternion rotation that would rotate the fromVector to the toVector. The two vectors must be normalized.
	 * @param {Vector3} fromVector
	 * @param {Vector3} toVector
	 * @returns {Quaternion}
	 */
	static fromVectorFromTo(fromVector, toVector) {
		const q = new Quaternion();
		q.setFromVectorFromTo(fromVector, toVector);
		return q;
	}

	/**
	 * Returns a quaternion rotation with the given z axis, and arbitrary x and y axes.
	 * @param {Vector3} axis - the axis to set
	 * @param {number} which - the index of the axis in the quaternion: 0 for x, 1 for y, 2 for z
	 * @returns {Quaternion}
	 */
	static fromFromAxis(axis, which) {
		const q = new Quaternion();
		q.setFromAxis(axis, which);
		return q;
	}

	/**
	 * Constructor. Defaults to identity.
	 * @param {number} w
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 */
	constructor(w = 1, x = 0, y = 0, z = 0) {
		super();

		/**
		 * @type {number}
		 * @private
		 */
		this._w = w;
		/**
		 * @type {number}
		 * @private
		 */
		this._x = x;
		/**
		 * @type {number}
		 * @private
		 */
		this._y = y;
		/**
		 * @type {number}
		 * @private
		 */
		this._z = z;
	}

	/**
	 * Gets the w component.
	 * @returns {number}
	 */
	get w() {
		return this._w;
	}

	/**
	 * Sets the w component.
	 * @param {number} w
	 */
	set w(w) {
		this.throwIfFrozen();
		this._w = w;
	}

	/**
	 * Gets the x component.
	 * @returns {number}
	 */
	get x() {
		return this._x;
	}

	/**
	 * Sets the x component.
	 * @param {number} x
	 */
	set x(x) {
		this.throwIfFrozen();
		this._x = x;
	}

	/**
	 * Gets the y component.
	 * @returns {number}
	 */
	get y() {
		return this._y;
	}

	/**
	 * Sets the y component.
	 * @param {number} y
	 */
	set y(y) {
		this.throwIfFrozen();
		this._y = y;
	}

	/**
	 * Gets the z component.
	 * @returns {number}
	 */
	get z() {
		return this._z;
	}

	/**
	 * Sets the z component.
	 * @param {number} z
	 */
	set z(z) {
		this.throwIfFrozen();
		this._z = z;
	}

	/**
	 * Gets the rotation angle.
	 * @returns {number}
	 */
	getAngle() {
		return Math.acos(this._w) * 2.0;
	}

	/**
	 * Sets this to a.
	 * @param {Quaternion} a - the source quaternion
	 */
	copy(a) {
		this.throwIfFrozen();
		this._w = a._w;
		this._x = a._x;
		this._y = a._y;
		this._z = a._z;
	}

	/**
	 * Sets this to a as a ThreeJs quaternion.
	 * @param {THREE.Quaternion} a
	 */
	copyFromThreeJs(a) {
		this.throwIfFrozen();
		this._w = a.w;
		this._x = a.x;
		this._y = a.y;
		this._z = a.z;
	}

	/**
	 * Sets this to the parameters.
	 * @param {number} w
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 */
	set(w, x, y, z) {
		this.throwIfFrozen();
		this._w = w;
		this._x = x;
		this._y = y;
		this._z = z;
	}

	/**
	 * Sets this to the angle-axis rotation.
	 * @param {Vector3} axis - must be normalized
	 * @param {number} angle - in radians
	 */
	setFromAxisAngle(axis, angle) {
		this.throwIfFrozen();
		const sinHalfAngle = Math.sin(angle / 2.0);
		this._w = Math.cos(angle / 2.0);
		this._x = sinHalfAngle * axis.x;
		this._y = sinHalfAngle * axis.y;
		this._z = sinHalfAngle * axis.z;
	}

	/**
	 * Sets this to a quaternion representing a rotate frame from the given at least two axes, the other being undefined. The given axes must be orthonormal.
	 * @param {Vector3|undefined} xAxis
	 * @param {Vector3|undefined} yAxis
	 * @param {Vector3|undefined} zAxis
	 */
	setFromAxes(xAxis, yAxis, zAxis) {
		this.throwIfFrozen();
		let missingAxis;
		if (xAxis === undefined) {
			xAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			missingAxis = xAxis;
			xAxis.cross(yAxis, zAxis);
		}
		else if (yAxis === undefined) {
			yAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			missingAxis = yAxis;
			yAxis.cross(zAxis, xAxis);
		}
		else if (zAxis === undefined) {
			zAxis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			missingAxis = zAxis;
			zAxis.cross(xAxis, yAxis);
		}
		const tr = xAxis.x + yAxis.y + zAxis.z;
		if (tr > 0) {
			const S = Math.sqrt(tr + 1.0) * 2; // S = 4 * this._w
			this._w = 0.25 * S;
			this._x = (yAxis.z - zAxis.y) / S;
			this._y = (zAxis.x - xAxis.z) / S;
			this._z = (xAxis.y - yAxis.x) / S;
		}
		else if ((xAxis.x > yAxis.y) && (xAxis.x > zAxis.z)) {
			const S = Math.sqrt(1.0 + xAxis.x - yAxis.y - zAxis.z) * 2; // S = 4 * this._x
			this._w = (yAxis.z - zAxis.y) / S;
			this._x = 0.25 * S;
			this._y = (yAxis.x + xAxis.y) / S;
			this._z = (zAxis.x + xAxis.z) / S;
		}
		else if (yAxis.y > zAxis.z) {
			const S = Math.sqrt(1.0 + yAxis.y - zAxis.z - xAxis.x) * 2; // S = 4 * this._y
			this._w = (zAxis.x - xAxis.z) / S;
			this._x = (yAxis.x + xAxis.y) / S;
			this._y = 0.25 * S;
			this._z = (zAxis.y + yAxis.z) / S;
		}
		else {
			const S = Math.sqrt(1.0 + zAxis.z - xAxis.x - yAxis.y) * 2; // S = 4 * this._z
			this._w = (xAxis.y - yAxis.x) / S;
			this._x = (zAxis.x + xAxis.z) / S;
			this._y = (zAxis.y + yAxis.z) / S;
			this._z = 0.25 * S;
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(missingAxis);
	}

	/**
	 * Sets this to the euler angles. Use right-hand rule for rotation directions.
	 * @param {number} pitch - the angle around the +x axis to rotate
	 * @param {number} roll - the angle around the +y axis to rotate
	 * @param {number} yaw - the angle around the +z axis to rotate
	 */
	setFromEuler(pitch, roll, yaw) {
		this.throwIfFrozen();
		const halfX = pitch * 0.5;
		const halfY = roll * 0.5;
		const halfZ = yaw * 0.5;
		const cosHalfX = Math.cos(halfX);
		const sinHalfX = Math.sin(halfX);
		const cosHalfY = Math.cos(halfY);
		const sinHalfY = Math.sin(halfY);
		const cosHalfZ = Math.cos(halfZ);
		const sinHalfZ = Math.sin(halfZ);
		this._w = cosHalfX * cosHalfY * cosHalfZ + sinHalfX * sinHalfY * sinHalfZ;
		this._x = sinHalfX * cosHalfY * cosHalfZ - cosHalfX * sinHalfY * sinHalfZ;
		this._y = cosHalfX * sinHalfY * cosHalfZ + sinHalfX * cosHalfY * sinHalfZ;
		this._z = cosHalfX * cosHalfY * sinHalfZ - sinHalfX * sinHalfY * cosHalfZ;
	}

	/**
	 * Sets this to the quaternion rotation that would rotate the fromVector to the toVector. The two vectors must be normalized.
	 * @param {Vector3} fromVector
	 * @param {Vector3} toVector
	 */
	setFromVectorFromTo(fromVector, toVector) {
		const axis = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const dot = fromVector.dot(toVector);
		if (dot >= 1.0) {
			this.set(1, 0, 0, 0);
		}
		else if (dot <= -1.0) {
			this.set(0, 1, 0, 0);
		}
		else {
			axis.cross(fromVector, toVector);
			axis.normalize(axis);
			const angle = Math.acos(dot);
			this.setFromAxisAngle(axis, angle);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(axis);
	}

	/**
	 * Sets this to a quaternion rotation with the given z axis, and arbitrary x and y axes.
	 * @param {Vector3} axis - the axis to set
	 * @param {number} which - the index of the axis in the quaternion: 0 for x, 1 for y, 2 for z
	 */
	setFromAxis(axis, which) {
		const axis0 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const axis1 = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		axis0.normalize(axis);
		axis1.cross(axis0, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis);
		if (axis1.isZero()) {
			axis1.cross(axis0, _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis);
		}
		axis1.normalize(axis1);
		if (which === 0) {
			this.setFromAxes(axis0, axis1, undefined);
		}
		else if (which === 1) {
			this.setFromAxes(undefined, axis0, axis1);
		}
		else if (which === 2) {
			this.setFromAxes(axis1, undefined, axis0);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(axis0);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(axis1);
	}

	/**
	 * Returns a nicely formed string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		return '[' + this._w + ', ' + this._x + ', ' + this._y + ', ' + this._z + ']';
	}

	/**
	 * Returns true if the quaternion is NaN (just checks w component).
	 * @returns {boolean}
	 */
	isNaN() {
		return (!(this._w <= 0) && !(this._w > 0));
	}

	/**
	 * Returns the magnitude of the quaternion. It should be 1 if you're using it right.
	 * @returns {number}
	 */
	magnitude() {
		return Math.sqrt(this._w * this._w + this._x * this._x + this._y * this._y + this._z * this._z);
	}

	/**
	 * Sets this to a with a magnitude of 1.0.
	 * @param {Quaternion} a
	 */
	normalize(a) {
		this.throwIfFrozen();
		const magnitude = a.magnitude();
		if (magnitude > 0) {
			this._w = a._w / magnitude;
			this._x = a._x / magnitude;
			this._y = a._y / magnitude;
			this._z = a._z / magnitude;
		}
	}

	/**
	 * Sets this to the inverse of quaternion a.
	 * @param {Quaternion} a
	 */
	inverse(a) {
		this.throwIfFrozen();
		this._w = a._w;
		this._x = -a._x;
		this._y = -a._y;
		this._z = -a._z;
	}

	/**
	 * Sets this to quaternion a * quaternion b.
	 * @param {Quaternion} a
	 * @param {Quaternion} b
	 */
	mult(a, b) {
		this.throwIfFrozen();
		const r = Quaternion.pool.get();
		r._w = a._w * b._w - a._x * b._x - a._y * b._y - a._z * b._z;
		r._x = a._w * b._x + a._x * b._w + a._y * b._z - a._z * b._y;
		r._y = a._w * b._y - a._x * b._z + a._y * b._w + a._z * b._x;
		r._z = a._w * b._z + a._x * b._y - a._y * b._x + a._z * b._w;
		this.copy(r);
		Quaternion.pool.release(r);
	}

	/**
	 * Sets this to (the inverse of quaternion a) * quaternion b.
	 * @param {Quaternion} a
	 * @param {Quaternion} b
	 */
	multInverseL(a, b) {
		this.throwIfFrozen();
		const r = Quaternion.pool.get();
		r._w = a._w * b._w + a._x * b._x + a._y * b._y + a._z * b._z;
		r._x = a._w * b._x - a._x * b._w - a._y * b._z + a._z * b._y;
		r._y = a._w * b._y + a._x * b._z - a._y * b._w - a._z * b._x;
		r._z = a._w * b._z - a._x * b._y + a._y * b._x - a._z * b._w;
		this.copy(r);
		Quaternion.pool.release(r);
	}

	/**
	 * Sets this to quaternion a * (the inverse of quaternion b).
	 * @param {Quaternion} a
	 * @param {Quaternion} b
	 */
	multInverseR(a, b) {
		this.throwIfFrozen();
		const r = Quaternion.pool.get();
		r._w = +a._w * b._w + a._x * b._x + a._y * b._y + a._z * b._z;
		r._x = -a._w * b._x + a._x * b._w - a._y * b._z + a._z * b._y;
		r._y = -a._w * b._y + a._x * b._z + a._y * b._w - a._z * b._x;
		r._z = -a._w * b._z - a._x * b._y + a._y * b._x + a._z * b._w;
		this.copy(r);
		Quaternion.pool.release(r);
	}

	/**
	 * Sets this to quaternion a, with its rotation angle multiplied by b.
	 * @param {Quaternion} a
	 * @param {number} b
	 */
	scaleAngle(a, b) {
		this.throwIfFrozen();
		const halfAngle = Math.acos(a._w);
		const sinHalfAngle = Math.sin(halfAngle);
		if (sinHalfAngle === 0) {
			this.copy(a);
			return;
		}
		const sinHalfAngleB = Math.sin(halfAngle * b);
		this._w = Math.cos(halfAngle * b);
		this._x = a._x / sinHalfAngle * sinHalfAngleB;
		this._y = a._y / sinHalfAngle * sinHalfAngleB;
		this._z = a._z / sinHalfAngle * sinHalfAngleB;
	}

	/**
	 * Returns the angle in radians between this and quaternion a.
	 * @param {Quaternion} a
	 * @returns {number}
	 */
	angle(a) {
		return Math.acos(this._w * a._w + this._x * a._x + this._y * a._y + this._z * a._z) * 2.0;
	}

	/**
	 * Sets this to be spherically interpolated between a and b by the factor u. The parameter u is not clamped.
	 * @param {Quaternion} a - the quaternion when u = 0
	 * @param {Quaternion} b - the quaternion when u = 1
	 * @param {number} u - the lerp parameter
	 */
	slerp(a, b, u) {
		this.throwIfFrozen();
		let dot = a._w * b._w + a._x * b._x + a._y * b._y + a._z * b._z;
		let f = 1;
		if (dot < 0.0) {
			f = -1;
			dot = -dot;
		}
		if (dot <= 0.9995) {
			const angle = Math.acos(dot);
			const A = f * Math.sin((1.0 - u) * angle) / Math.sin(angle);
			const B = Math.sin(u * angle) / Math.sin(angle);
			this._w = A * a._w + B * b._w;
			this._x = A * a._x + B * b._x;
			this._y = A * a._y + B * b._y;
			this._z = A * a._z + B * b._z;
		}
		else { // too small, so lerp
			const A = f * (1.0 - u);
			const B = u;
			this._w = A * a._w + B * b._w;
			this._x = A * a._x + B * b._x;
			this._y = A * a._y + B * b._y;
			this._z = A * a._z + B * b._z;
			this.normalize(this);
		}
	}

	/**
	 * Sets Vector3 outAxis to an axis (x = 0, y = 1, z = 2) of the quaternion. If the axis is undefined, it returns the axis of rotation.
	 * @param {Vector3} outAxis
	 * @param {number} axis
	 */
	getAxis(outAxis, axis) {
		if (axis === undefined) {
			outAxis.set(this._x, this._y, this._z);
			outAxis.normalize(outAxis);
		}
		else if (axis === 0) {
			outAxis.x = this._w * this._w + this._x * this._x - this._y * this._y - this._z * this._z;
			outAxis.y = 2.0 * this._w * this._z + 2.0 * this._x * this._y;
			outAxis.z = 2.0 * this._x * this._z - 2.0 * this._w * this._y;
		}
		else if (axis === 1) {
			outAxis.x = 2.0 * this._y * this._x - 2.0 * this._w * this._z;
			outAxis.y = this._w * this._w - this._x * this._x + this._y * this._y - this._z * this._z;
			outAxis.z = 2.0 * this._x * this._w + 2.0 * this._y * this._z;
		}
		else if (axis === 2) {
			outAxis.x = 2.0 * this._y * this._w + 2.0 * this._z * this._x;
			outAxis.y = 2.0 * this._z * this._y - 2.0 * this._w * this._x;
			outAxis.z = this._w * this._w - this._x * this._x - this._y * this._y + this._z * this._z;
		}
	}
}

/**
 * @type {Pool<Quaternion>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(Quaternion);

const _identity = new Quaternion();
_identity.freeze();

const _nan = new Quaternion(Number.NaN, Number.NaN, Number.NaN, Number.NaN);
_nan.freeze();


/***/ }),

/***/ "../pioneer/engine/src/utils/reader.js":
/*!*********************************************!*\
  !*** ../pioneer/engine/src/utils/reader.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Reader": function() { return /* binding */ Reader; }
/* harmony export */ });
/** @module pioneer */

/**
 * A binary data reader.
 */
class Reader {
	/**
	 * Constructor.
	 * @param {ArrayBuffer | SharedArrayBuffer} data
	 */
	constructor(data) {
		this._dataView = new DataView(data);
		this._offset = 0;
	}

	/**
	 * Returns true if the offset is at the end of the data.
	 * @returns {boolean}
	 */
	isAtEnd() {
		return this._offset >= this._dataView.byteLength;
	}

	/**
	 * Reads an 8-bit unsigned integer.
	 * @returns {number}
	 */
	readByte() {
		const result = this._dataView.getUint8(this._offset);
		this._offset += 1;
		return result;
	}

	/**
	 * Reads a 32-bit floating-point number.
	 * @returns {number}
	 */
	readFloat32() {
		const result = this._dataView.getFloat32(this._offset, true);
		this._offset += 4;
		return result;
	}

	/**
	 * Reads a 64-bit floating-point number.
	 * @returns {number}
	 */
	readFloat64() {
		const result = this._dataView.getFloat64(this._offset, true);
		this._offset += 8;
		return result;
	}

	/**
	* Reads a 8-bit unsigned integer.
	* @returns {number}
	*/
	readUInt8() {
		const result = this._dataView.getUint8(this._offset);
		this._offset += 1;
		return result;
	}

	/**
	* Reads a 16-bit unsigned integer.
	* @returns {number}
	*/
	readUInt16() {
		const result = this._dataView.getUint16(this._offset, true);
		this._offset += 2;
		return result;
	}

	/**
	* Reads a 32-bit unsigned integer.
	* @returns {number}
	*/
	readUInt32() {
		const result = this._dataView.getUint32(this._offset, true);
		this._offset += 4;
		return result;
	}

	/**
	* Reads a 64-bit unsigned integer.
	* @returns {number}
	*/
	readUInt64() {
		const result = Number(this._dataView.getBigUint64(this._offset, true));
		this._offset += 8;
		return Number.isSafeInteger(result) ? result : NaN;
	}

	/**
	* Reads a 8-bit integer.
	* @returns {number}
	*/
	readInt8() {
		const result = this._dataView.getInt8(this._offset);
		this._offset += 1;
		return result;
	}

	/**
	 * Reads a 16-bit integer.
	 * @returns {number}
	 */
	readInt16() {
		const result = this._dataView.getInt16(this._offset, true);
		this._offset += 2;
		return result;
	}

	/**
	 * Reads a 32-bit integer.
	 * @returns {number}
	 */
	readInt32() {
		const result = this._dataView.getInt32(this._offset, true);
		this._offset += 4;
		return result;
	}

	/**
	 * Reads a 64-bit integer.
	 * @returns {number}
	 */
	readInt64() {
		const result = Number(this._dataView.getBigInt64(this._offset, true));
		this._offset += 8;
		return Number.isSafeInteger(result) ? result : NaN;
	}

	/**
	 * Reads a single line of text, ending with '\n'.
	 * @returns {string}
	 */
	readLine() {
		const byteArray = [];
		while (true) {
			const byte = this.readByte();
			const byteAsString = String.fromCharCode(byte);
			if (byteAsString === '\r') {
				continue;
			}
			if (byteAsString === '\n') {
				break;
			}
			byteArray.push(byte);
		}
		if (typeof TextEncoder !== 'undefined') {
			const utf8Decoder = new TextDecoder();
			const array = new Uint8Array(byteArray);
			return utf8Decoder.decode(array);
		}
		else {
			return this._utf8ArrayToStr(byteArray);
		}
	}

	/**
	 * Reads a null terminated UTF-8 string or a given number of bytes as a string.
	 * @param {number} [numBytes]
	 * @returns {string}
	 */
	readString(numBytes) {
		const byteArray = [];
		while (true) {
			const byte = this.readByte();
			if (numBytes === undefined && byte === 0) {
				break;
			}
			byteArray.push(byte);
			if (numBytes !== undefined && byteArray.length === numBytes) {
				break;
			}
		}
		if (typeof TextEncoder !== 'undefined') {
			const utf8Decoder = new TextDecoder();
			const array = new Uint8Array(byteArray);
			return utf8Decoder.decode(array);
		}
		else {
			return this._utf8ArrayToStr(byteArray);
		}
	}

	/**
	 * Converts a UTF-8 array to a string. Taken, verified, and formatted from https://stackoverflow.com/a/59339612.
	 * @param {number[]} byteArray
	 * @returns {string}
	 */
	_utf8ArrayToStr(byteArray) {
		let c0 = 0;
		let c1 = 0;
		let c2 = 0;
		let c3 = 0;
		let out = '';
		let i = 0;
		const len = byteArray.length;
		while (i < len) {
			c0 = byteArray[i];
			i += 1;
			switch (c0 >> 4) {
				case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
					// 0xxxxxxx
					out += String.fromCharCode(c0);
					break;
				case 12: case 13:
					// 110xxxxx 10xxxxxx
					c1 = byteArray[i] | 0;
					i += 1;
					out += String.fromCharCode(((c0 & 0x1F) << 6) | (c1 & 0x3F));
					break;
				case 14:
					// 1110xxxx 10xxxxxx 10xxxxxx
					c1 = byteArray[i] | 0;
					i += 1;
					c2 = byteArray[i] | 0;
					i += 1;
					out += String.fromCharCode(((c0 & 0x0F) << 12)
						| ((c1 & 0x3F) << 6)
						| ((c2 & 0x3F) << 0));
					break;
				case 15:
					// 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
					c1 = byteArray[i] | 0;
					i += 1;
					c2 = byteArray[i] | 0;
					i += 1;
					c3 = byteArray[i] | 0;
					i += 1;
					out += String.fromCharCode(((c0 & 0x07) << 18)
						| ((c1 & 0x3F) << 12)
						| ((c2 & 0x3F) << 6)
						| ((c3 & 0x3F) << 0));
					break;
			}
		}

		return out;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/rect.js":
/*!*******************************************!*\
  !*** ../pioneer/engine/src/utils/rect.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Rect": function() { return /* binding */ Rect; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A class for handling an axis-aligned rectangle. */
class Rect extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<Rect>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * Constructor.
	 * @param {number} x - origin x
	 * @param {number} y - origin y
	 * @param {number} w - size x
	 * @param {number} h - size y
	 */
	constructor(x = 0, y = 0, w = 0, h = 0) {
		super();

		/**
		 * origin
		 * @type {Vector2}
		 * @private
		 */
		this._origin = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(x, y);

		/**
		 * size
		 * @type {Vector2}
		 * @private
		 */
		this._size = new _internal__WEBPACK_IMPORTED_MODULE_0__.Vector2(w, h);
	}

	/**
	 * Freezes the object.
	 * @override
	 */
	freeze() {
		this._origin.freeze();
		this._size.freeze();
	}

	/**
	 * Thaws (unfreezes) the object.
	 * @override
	 */
	thaw() {
		this._origin.thaw();
		this._size.thaw();
	}

	/**
	 * Gets the origin.
	 * @returns {Vector2}
	 */
	get origin() {
		return this._origin;
	}

	/**
	 * Gets the size.
	 * @returns {Vector2}
	 */
	get size() {
		return this._size;
	}

	/**
	 * Returns a nicely formed string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		return '[Origin: (' + this._origin.x + ', ' + this._origin.y + '), Size: (' + this._size.x + ', ' + this._size.y + ')]';
	}

	/**
	 * Sets this to a.
	 * @param {Rect} a
	 */
	copy(a) {
		this._origin.copy(a._origin);
		this._size.copy(a._size);
	}

	/**
	 * Sets this to the parameters.
	* @param {number} x - origin x
	* @param {number} y - origin y
	* @param {number} w - size x
	* @param {number} h - size y */
	set(x, y, w, h) {
		this._origin.set(x, y);
		this._size.set(w, h);
	}

	/**
	 * Returns true if the position is within this.
	 * @param {Vector2} position
	 * @returns {boolean}
	 */
	contains(position) {
		return this._origin.x <= position.x && position.x < this._origin.x + this._size.x && this._origin.y <= position.y && position.y < this._origin.y + this._size.y;
	}

	/**
	 * Returns true if the rect intersects with this.
	 * @param {Rect} rect
	 * @returns {boolean}
	 */
	intersects(rect) {
		return this._origin.x + this._size.x > rect._origin.x && rect._origin.x + rect._size.x > this._origin.x
			&& this._origin.y + this._size.y > rect._origin.y && rect._origin.y + rect._size.y > this._origin.y;
	}
}

/**
 * @type {Pool<Rect>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(Rect);


/***/ }),

/***/ "../pioneer/engine/src/utils/shader_fix.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/shader_fix.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShaderFix": function() { return /* binding */ ShaderFix; }
/* harmony export */ });
/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ "../pioneer/engine/node_modules/three/build/three.module.js");
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */



class ShaderFix {
	/**
	 * Fixes up shader code.
	 * Also converts shader code from GLSL 1 to 3, if WebGL is being used.
	 * @param {THREE.RawShaderMaterial} rawShaderMaterial
	 * */
	static fix(rawShaderMaterial) {
		const webGL2 = _internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.isWebGL2();
		const fragDepth = _internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasFragDepth();
		let prependVertex = '';
		let prependFragment = '';
		if (webGL2) {
			prependVertex += `
				#define attribute in
				#define varying out
				#define texture2D texture
				precision highp float;
				precision highp int;
				#define L_EXT_frag_depth true
				`;
			prependFragment += `
				#define varying in
				out highp vec4 pc_fragColor;
				#define gl_FragColor pc_fragColor
				#define gl_FragDepthEXT gl_FragDepth
				#define texture2D texture
				#define textureCube texture
				#define texture2DProj textureProj
				#define texture2DLodEXT textureLod
				#define texture2DProjLodEXT textureProjLod
				#define textureCubeLodEXT textureLod
				#define texture2DGradEXT textureGrad
				#define texture2DProjGradEXT textureProjGrad
				#define textureCubeGradEXT textureGrad
				#define L_EXT_frag_depth true
				precision highp float;
				precision highp int;
				`;
			rawShaderMaterial.glslVersion = three__WEBPACK_IMPORTED_MODULE_1__.GLSL3;
		}
		else {
			if (fragDepth) {
				prependVertex += `
					#extension GL_EXT_frag_depth : enable
					#define L_EXT_frag_depth true
					`;
				prependFragment += `
					#extension GL_EXT_frag_depth : enable
					#define L_EXT_frag_depth true
					`;
			}
			prependVertex += `
				precision highp float;
				precision highp int;
				`;
			prependFragment += `
				precision highp float;
				precision highp int;
				`;
			rawShaderMaterial.glslVersion = three__WEBPACK_IMPORTED_MODULE_1__.GLSL1;
		}
		rawShaderMaterial.vertexShader = prependVertex + rawShaderMaterial.vertexShader;
		rawShaderMaterial.fragmentShader = prependFragment + rawShaderMaterial.fragmentShader;
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/sort.js":
/*!*******************************************!*\
  !*** ../pioneer/engine/src/utils/sort.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Sort": function() { return /* binding */ Sort; }
/* harmony export */ });
/** @module pioneer */

class Sort {
	/**
	 * Gets the least index whose value is greater than or equal to the value.
	 * 1.5 on [0, 1, 2, 3] will return 2, 5.5 will return 4, and -4 will return 0.
	 * O(log n).
	 * @template ArrayType
	 * @template ValueType
	 * @param {ValueType} value
	 * @param {ArrayType[]} array
	 * @param {CompareFunction<ArrayType, ValueType>} [isLess]
	 * @returns {number}
	 */
	static getIndex(value, array, isLess) {
		let low = 0;
		let high = array.length;
		if (isLess === undefined) {
			while (low < high) {
				const mid = (low + high) >>> 1;
				// @ts-ignore
				if (array[mid] < value) {
					low = mid + 1;
				}
				else {
					high = mid;
				}
			}
		}
		else {
			while (low < high) {
				const mid = (low + high) >>> 1;
				if (isLess(array[mid], value)) {
					low = mid + 1;
				}
				else {
					high = mid;
				}
			}
		}
		return low;
	}

	/**
	 * Adds the value into a sorted array.
	 * @template ArrayType
	 * @param {ArrayType} value
	 * @param {ArrayType[]} array
	 * @param {CompareFunction<ArrayType, ArrayType>} [isLess]
	 * @param {CompareFunction<ArrayType, ArrayType>} [isEqual]
	 */
	static add(value, array, isLess, isEqual) {
		let index = this.getIndex(value, array, isLess);
		if (isEqual === undefined) {
			while (index < array.length && array[index] === value) {
				index += 1;
			}
		}
		else {
			while (index < array.length && isEqual(array[index], value)) {
				index += 1;
			}
		}
		array.splice(index, 0, value);
	}

	/**
	 * Removes the value from a sorted array. Returns true if the value was found.
	 * @template ArrayType
	 * @template ValueType
	 * @param {ValueType} value
	 * @param {ArrayType[]} array
	 * @param {CompareFunction<ArrayType, ValueType>} [isLess]
	 * @param {CompareFunction<ArrayType, ValueType>} [isEqual]
	 */
	static remove(value, array, isLess, isEqual) {
		const index = this.getIndex(value, array, isLess);
		let isFound = false;
		if (index < array.length) {
			// @ts-ignore
			if (isEqual === undefined && array[index] === value) {
				isFound = true;
			}
			else if (isEqual !== undefined && isEqual(array[index], value)) {
				isFound = true;
			}
		}
		if (isFound) {
			array.splice(index, 1);
		}
		return isFound;
	}
}

/**
 * An compare function that uses two types.
 * @template LHSType
 * @template RHSType
 * @callback CompareFunction
 * @param {LHSType} a
 * @param {RHSType} b
 * @returns {boolean}
 */


/***/ }),

/***/ "../pioneer/engine/src/utils/sprite_particles.js":
/*!*******************************************************!*\
  !*** ../pioneer/engine/src/utils/sprite_particles.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SpriteParticles": function() { return /* binding */ SpriteParticles; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A basic sprite particle system with position, color, and scale attributes.
 */
class SpriteParticles {
	/**
	 * The constructor.
	 * @param {BaseComponent} component
	 */
	constructor(component) {
		/**
		 * The component that contains this.
		 * @type {BaseComponent}
		 * @private
		 */
		this._component = component;

		/**
		 * Whether or not the particles are relative to the orientation of the entity.
		 * @type {boolean}
		 * @private
		 */
		this._relativeToEntityOrientation = true;

		/**
		 * The positions of the particles.
		 * @type {Float32Array}
		 * @private
		 */
		this._offsetArray = new Float32Array(0);

		/**
		 * The colors of the particles.
		 * @type {Float32Array}
		 * @private
		 */
		this._colorArray = new Float32Array(0);

		/**
		 * The scales of the particles.
		 * @type {Float32Array}
		 * @private
		 */
		this._scaleArray = new Float32Array(0);

		/**
		 * The ThreeJs instanced geometry.
		 * @type {THREE.InstancedBufferGeometry}
		 * @private
		 */
		this._threeJsGeometry = null;

		/**
		 * The ThreeJs material.
		 * @type {THREE.RawShaderMaterial}
		 * @private
		 */
		this._threeJsMaterial = null;

		/**
		 * The ThreeJs object.
		 * @type {THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>}
		 * @private
		 */
		this._threeJsObject = null;

		// Setup the Three.js geometry.
		this._threeJsGeometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferGeometry();
		this._threeJsGeometry.setAttribute('position', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Float32Array([-1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1]), 3));
		this._threeJsGeometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Uint16Array([0, 1, 2, 2, 3, 0]), 1));
		this._threeJsGeometry.setAttribute('offset', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(this._offsetArray, 3));
		this._threeJsGeometry.setAttribute('color', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(this._colorArray, 4));
		this._threeJsGeometry.setAttribute('scale', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(this._scaleArray, 1));

		// Setup the Three.js material.
		this._threeJsMaterial = this._component.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('sprite_particles');

		// Setup the Three.js object.
		this._threeJsObject = /** @type {THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>} */ (_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObjectGivenGeometry(component, this._threeJsMaterial, this._threeJsGeometry));
	}

	/**
	 * Gets the Three.js object.
	 * @returns {THREE.Mesh<THREE.InstancedBufferGeometry, THREE.ShaderMaterial>}
	 */
	getThreeJsObject() {
		return this._threeJsObject;
	}

	/**
	 * Gets the Three.js object.
	 * @returns {THREE.ShaderMaterial}
	 */
	getThreeJsMaterial() {
		return this._threeJsMaterial;
	}

	/**
	 * Sets the positions of the particles.
	 * @param {Float32Array} particleOffsets
	 */
	setParticleOffsets(particleOffsets) {
		this._setAttribute('offset', particleOffsets, 3);
	}

	/**
	 * Sets the colors of the particles.
	 * @param {Float32Array} particleColors
	 */
	setParticleColors(particleColors) {
		this._setAttribute('color', particleColors, 4);
	}

	/**
	 * Sets the scales of the particles.
	 * @param {Float32Array} particleScales
	 */
	setParticleScales(particleScales) {
		this._setAttribute('scale', particleScales, 1);
	}

	/**
	 * Gets whether or not the particles are relative to the orientation of the entity. Defaults to true.
	 * @returns {boolean}
	 */
	getRelativeToEntityOrientation() {
		return this._relativeToEntityOrientation;
	}

	/**
	 * Sets whether or not the particles are relative to the orientation of the entity.
	 * @param {boolean} relativeToEntityOrientation
	 */
	setRelativeToEntityOrientation(relativeToEntityOrientation) {
		this._relativeToEntityOrientation = relativeToEntityOrientation;
	}

	/**
	 * Prepares the sprite particles for rendering.
	 * @param {CameraComponent} camera
	 */
	prepareForRender(camera) {
		// Set the position of the ThreeJs object.
		_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this._threeJsObject, this._component.getEntity(), camera);

		// Set the orientation of the ThreeJs object if it is relative to the entity orientation.
		if (this._relativeToEntityOrientation) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this._threeJsObject, this._component.getEntity());
		}
	}

	/**
	 * Sets the values of an attribute, and adjusts the number of particles if needed.
	 * @param {string} name
	 * @param {Float32Array} array
	 * @param {number} itemSize
	 * @private
	 */
	_setAttribute(name, array, itemSize) {
		let attribute = this._threeJsGeometry.getAttribute(name);
		if (attribute instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute) {
			if (attribute.count !== array.length / itemSize) {
				this._offsetArray = new Float32Array(array.length / itemSize * 3);
				this._colorArray = new Float32Array(array.length / itemSize * 4);
				this._scaleArray = new Float32Array(array.length / itemSize * 1);
				this._threeJsGeometry.instanceCount = array.length / itemSize;
				this._threeJsGeometry.setAttribute('offset', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(this._offsetArray, 3));
				this._threeJsGeometry.setAttribute('color', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(this._colorArray, 4));
				this._threeJsGeometry.setAttribute('scale', new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute(this._scaleArray, 1));
			}
		}
		attribute = this._threeJsGeometry.getAttribute(name);
		if (attribute instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InstancedBufferAttribute) {
			attribute.copyArray(array);
			attribute.needsUpdate = true;
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/texture_lod.js":
/*!**************************************************!*\
  !*** ../pioneer/engine/src/utils/texture_lod.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TextureLOD": function() { return /* binding */ TextureLOD; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A texture that downloads different resolution textures depending on the level of detail requested.
 * Each texture URL is can use the $SIZE and $FACE replacement strings to specify the different images loaded depending on the LOD and face.
 */
class TextureLOD {
	/**
	 * Constructor.
	 * @param {BaseComponent} component - the component container
	 */
	constructor(component) {
		/**
		 * The Pioneer engine.
		 * @type {Engine}
		 * @private
		 */
		this._engine = component.getEntity().getScene().getEngine();

		/**
		 * The component container.
		 * @type {BaseComponent}
		 * @private
		 */
		this._component = component;

		/**
		 * The uniform to be set to the texture.
		 * @type {THREE.IUniform}
		 * @private
		 */
		this._uniform = null;

		/**
		 * The url to be used.
		 * @type {string}
		 * @private
		 */
		this._url = '';

		/**
		 * The array of sizes of textures.
		 * @type {number[]}
		 * @private
		 */
		this._sizes = [];

		/**
		 * The current size of the texture.
		 * @type {number}
		 * @private
		 */
		this._currentSize = 0;

		/**
		 * If not undefined, forces the texture to be this size.
		 * @type {number}
		 * @private
		 */
		this._forcedSize = undefined;

		/**
		 * The flag that if true, uses compressed textures.
		 * @type {boolean}
		 * @private
		 */
		this._useCompressed = false;

		/**
		 * A promise that resolves when the texture is loaded. Every new texture load creates a new promise.
		 * @type {Promise<void>}
		 * @private
		 */
		this._loadedPromise = Promise.resolve();

		/**
		 * A flag that tells whether this is currently loading a texture.
		 * @type {boolean}
		 * @private
		 */
		this._loading = false;
	}

	/**
	 * Gets the url currently being used.
	 * @returns {string}
	 */
	getUrl() {
		return this._url;
	}

	/**
	 * Sets the url to be used. If can have a $SIZE in the URL to act as replacements for different sizes.
	 * @param {string} url
	 */
	setUrl(url) {
		this._url = url;
		this._currentSize = 0;
	}

	/**
	 * Gets the uniform to be used.
	 * @returns {THREE.IUniform}
	 */
	getUniform() {
		return this._uniform;
	}

	/**
	 * Sets the uniform to be used, or null for no uniform.
	 * @param {THREE.IUniform} uniform
	 */
	setUniform(uniform) {
		this._uniform = uniform;
		this._currentSize = 0;
	}

	/**
	 * Gets the sizes to be loaded.
	 * @returns {number[]}
	 */
	getSizes() {
		return this._sizes.slice();
	}

	/**
	 * Sets the sizes of the textures to be loaded.
	 * @param {number[]} sizes
	 */
	setSizes(sizes) {
		this._sizes = sizes.slice();
		this._currentSize = 0;
	}

	/**
	 * Gets the size of the current texture.
	 * @returns {number}
	 */
	getCurrentSize() {
		return this._currentSize;
	}

	/**
	 * Gets the forced texture size, if defined.
	 * @returns {number}
	 */
	getForcedSize() {
		return this._forcedSize;
	}

	/**
	 * Sets the forced texture size, if defined.
	 * @param {number} size
	 */
	setForcedSize(size) {
		this._forcedSize = size;
	}

	/**
	 * Gets the flag that if true, uses compressed textures.
	 * @returns {boolean}
	 */
	getUseCompression() {
		return this._useCompression;
	}

	/**
	 * Sets the flag that if true, uses compressed textures.
	 * @param {boolean} useCompression
	 */
	setUseCompression(useCompression) {
		this._useCompression = useCompression;
		this._currentSize = 0;
	}

	/**
	 * Returns a promise that resolves when the texture for the current target size is loaded.
	 * @returns {Promise<void>}
	 */
	getLoadedPromise() {
		return this._loadedPromise;
	}

	/**
	 * Starts the downloading of a texture at the current target level.
	 */
	update() {
		// Still loading a texture.
		if (this._loading || this._uniform === null) {
			return;
		}
		// No textures to check or load.
		if (this._url === '' || this._sizes.length === 0 || (this._component.getLoadState() === 'unloaded' && this._forcedSize === undefined)) {
			// Unload any existing texture.
			if (this._uniform.value !== null) {
				this._uniform.value.dispose();
				this._uniform.value = null;
				this._currentSize = 0;
			}
			return;
		}
		// Figure out which texture should be loaded.
		let targetSize = this._sizes[0];
		if (this._forcedSize !== undefined) {
			targetSize = this._forcedSize;
		}
		else {
			targetSize = this._component.getEntity().getGreatestPixelSpaceExtentsRadius();
		}
		// Get the index of the least size greater than or equal to the target size.
		let sizeIndex = 0;
		for (let i = 0, l = this._sizes.length; i < l; i++) {
			const size = this._sizes[i];
			if (i === l - 1) { // End of list, so choose the highest one.
				sizeIndex = i;
			}
			const maxTextureSize = this._engine.getConfig().getValue('maxTextureSize');
			if (size >= targetSize // If we've past the target or the maxTextureSize config (without a forced size), choose the this one.
				|| (typeof maxTextureSize === 'number' && size >= maxTextureSize && this._forcedSize === undefined)) {
				sizeIndex = i;
				break;
			}
		}
		// If the current size is different than the requested size, load up the new size.
		if (this._currentSize !== this._sizes[sizeIndex]) {
			this._currentSize = this._sizes[sizeIndex];
			this._loadTexture(this._currentSize);
		}
	}

	/**
	 * Loads the texture at the given size.
	 * This is separate from the update function to avoid garbage generation from the this-bound anonymous function after the download.
	 * @param {number} size - The size of the texture to load.
	 * @private
	 */
	_loadTexture(size) {
		const url = this._url.replace('$SIZE', size.toString());
		this._loading = true;
		const textureLoader = this._useCompression ? this._engine.getTextureLoaderCompressed() : this._engine.getTextureLoader();
		this._loadedPromise = textureLoader.loadIntoUniform(this._uniform, url, true).then(() => {
			this._loading = false;
		}).catch((error) => {
			throw Error(error);
		});
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/three_js_helper.js":
/*!******************************************************!*\
  !*** ../pioneer/engine/src/utils/three_js_helper.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ThreeJsHelper": function() { return /* binding */ ThreeJsHelper; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A set of helper functions for Three.js objects and materials.
 * `attributes` takes an array of {name: string, dimensions: number} objects.
 */
class ThreeJsHelper {
	// CREATE & DESTROY

	/**
	 * Creates a Three.js Mesh object with BufferGeometry (with given attributes) and a default pink ShaderMaterial, and adds it to the scene.
	 * @param {Object[]} attributes
	 * @param {string} attributes[].name
	 * @param {number} attributes[].dimensions
	 * @param {boolean} interleavedAttributes
	 * @returns {THREE.BufferGeometry}
	 */
	static createGeometry(attributes, interleavedAttributes) {
		// Create the Three.js goemetry.
		const geometry = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferGeometry();

		// Setup the attributes.
		if (interleavedAttributes) {
			// Get stride.
			let stride = 0;
			for (let i = 0; i < attributes.length; i++) {
				stride += attributes[i].dimensions;
			}
			// Create the buffers.
			const interleavedBuffer = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBuffer(new Float32Array(0), stride);
			let offset = 0;
			for (let i = 0; i < attributes.length; i++) {
				geometry.setAttribute(attributes[i].name, new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.InterleavedBufferAttribute(interleavedBuffer, attributes[i].dimensions, offset));
				offset += attributes[i].dimensions;
			}
		}
		else {
			for (let i = 0; i < attributes.length; i++) {
				geometry.setAttribute(attributes[i].name, new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Float32Array(0), attributes[i].dimensions));
			}
		}
		geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(new Uint16Array(0), 1));

		// Return the geometry.
		return geometry;
	}

	/**
	 * Sets up the Three.js objec, assuming it's the root of its hierarchy.
	 * @param {BaseComponent} component
	 * @param {THREE.Object3D} object
	 */
	static setupObject(component, object) {
		// Set the name of the object.
		object.name = component + '.' + Math.floor(Math.random() * 10000);

		// This turns off recalculating the world matrix every single frame.
		object.matrixAutoUpdate = false;

		// Set the object to never be culled by Three.js.
		object.frustumCulled = false;

		// Set the object to be initially invisible.
		object.visible = false;

		// Add it to the scene.
		component.getEntity().getScene().getThreeJsScene().add(object);
	}

	/**
	 * Creates a Three.js Mesh object with BufferGeometry (with given attributes) and a default pink ShaderMaterial, and adds it to the scene.
	 * @param {BaseComponent} component
	 * @param {THREE.ShaderMaterial | THREE.ShaderMaterial[]} material
	 * @param {THREE.BufferGeometry} geometry
	 * @returns {THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial | THREE.ShaderMaterial[]>}
	 */
	static createMeshObjectGivenGeometry(component, material, geometry) {
		// Create the Three.js object.
		const object = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh(geometry, material);

		// Setup the mesh.
		this.setupObject(component, object);

		// Return the mesh.
		return object;
	}

	/**
	 * Creates a Three.js Mesh object with BufferGeometry (with given attributes) and a default pink ShaderMaterial, and adds it to the scene.
	 * @param {BaseComponent} component
	 * @param {THREE.ShaderMaterial | THREE.ShaderMaterial[]} material
	 * @param {{ name: string, dimensions: number }[]} attributes
	 * @param {boolean} interleavedAttributes
	 * @returns {THREE.Mesh<THREE.BufferGeometry, THREE.ShaderMaterial | THREE.ShaderMaterial[]>}
	 */
	static createMeshObject(component, material, attributes, interleavedAttributes) {
		// Create the Three.js goemetry.
		const geometry = this.createGeometry(attributes, interleavedAttributes);

		// Create the object with no material.
		const object = this.createMeshObjectGivenGeometry(component, material, geometry);

		// Return the mesh.
		return object;
	}

	/**
	 * Destroys a Three.js geometry.
	 * @param {THREE.BufferGeometry} geometry
	 */
	static destroyGeometry(geometry) {
		geometry.dispose();
	}

	/**
	 * Disposes of geometry and removes the object from the Three.js scene. Also applies to children. Does not affect materials.
	 * @param {THREE.Object3D} object
	 */
	static destroyObject(object) {
		while (object.children.length > 0) {
			this.destroyObject(object.children[object.children.length - 1]);
		}
		if (object.parent !== null) {
			object.parent.remove(object);
		}
		if (object instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Mesh) {
			this.destroyGeometry(object.geometry);
		}
	}

	/**
	 * Destroys a Three.js material. Disposes of it and any textures.
	 * @param {THREE.ShaderMaterial} material
	 */
	static destroyMaterial(material) {
		const uniforms = material.uniforms;
		for (const uniform in uniforms) {
			if (Object.prototype.hasOwnProperty.call(uniforms, uniform) && uniforms[uniform].value !== null && uniforms[uniform].value.dispose !== undefined) {
				uniforms[uniform].value.dispose();
			}
		}
		material.dispose();
	}

	/**
	 * Destroys all Three.js objects, geometries, materials, and textures in the component.
	 * @param {BaseComponent} component
	 */
	static destroyAllObjectsAndMaterials(component) {
		const objects = component.getThreeJsObjects();
		const materials = component.getThreeJsMaterials();
		for (let i = 0; i < objects.length; i++) {
			this.destroyObject(objects[i]);
		}
		for (let i = 0; i < materials.length; i++) {
			this.destroyMaterial(materials[i]);
		}
	}

	// POSITION & ORIENTATION

	/**
	 * Sets the object's position.
	 * @param {THREE.Object3D | THREE.Object3D[]} objects
	 * @param {Vector3} position
	 */
	static setPosition(objects, position) {
		if (!objects) {
			return;
		}
		if (Array.isArray(objects)) {
			for (let i = 0, l = objects.length; i < l; i++) {
				objects[i].position.set(position.x, position.y, position.z);
			}
		}
		else {
			objects.position.set(position.x, position.y, position.z);
		}
	}

	/**
	 * Sets the object's position to be the entity's camera-space position, along with an optional offset.
	 * @param {THREE.Object3D | THREE.Object3D[]} objects
	 * @param {Entity} entity
	 * @param {CameraComponent} camera
	 * @param {Vector3} [offset]
	 * @param {boolean} [offsetIsInEntityFrame]
	 */
	static setPositionToEntity(objects, entity, camera, offset, offsetIsInEntityFrame) {
		if (!objects) {
			return;
		}
		const cameraSpacePosition = entity.getCameraSpacePosition(camera);
		this._tempThreeJsVector3.set(cameraSpacePosition.x, cameraSpacePosition.y, cameraSpacePosition.z);
		if (offset) {
			const newOffset = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			if (offsetIsInEntityFrame) {
				newOffset.rotate(entity.getOrientation(), offset);
			}
			else {
				newOffset.copy(offset);
			}
			this._tempThreeJsVector3.x += newOffset.x;
			this._tempThreeJsVector3.y += newOffset.y;
			this._tempThreeJsVector3.z += newOffset.z;
			_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newOffset);
		}
		if (Array.isArray(objects)) {
			for (let i = 0, l = objects.length; i < l; i++) {
				objects[i].position.copy(this._tempThreeJsVector3);
			}
		}
		else {
			objects.position.copy(this._tempThreeJsVector3);
		}
	}

	/**
	 * Sets the object's scale.
	 * @param {THREE.Object3D | THREE.Object3D[]} objects
	 * @param {number|Vector3} scale
	 */
	static setScale(objects, scale) {
		if (!objects) {
			return;
		}
		if (Array.isArray(objects)) {
			for (let i = 0, l = objects.length; i < l; i++) {
				if (typeof scale === 'number') {
					objects[i].scale.set(scale, scale, scale);
				}
				else {
					objects[i].scale.set(scale.x, scale.y, scale.z);
				}
			}
		}
		else {
			if (typeof scale === 'number') {
				objects.scale.set(scale, scale, scale);
			}
			else {
				objects.scale.set(scale.x, scale.y, scale.z);
			}
		}
	}

	/**
	 * Sets the object's orientation.
	 * @param {THREE.Object3D | THREE.Object3D[]} objects
	 * @param {Quaternion} orientation
	 */
	static setOrientation(objects, orientation) {
		if (!objects) {
			return;
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
		if (Array.isArray(objects)) {
			for (let i = 0, l = objects.length; i < l; i++) {
				objects[i].setRotationFromQuaternion(_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion);
			}
		}
		else {
			objects.setRotationFromQuaternion(_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion);
		}
	}

	/**
	 * Sets the object to have its axes so that its z-axis faces the camera, and x-axis is aligned with the camera's right.
	 * @param {THREE.Object3D | THREE.Object3D[]} objects
	 * @param {Entity} entity
	 * @param {CameraComponent} camera
	 */
	static setOrientationToBillboard(objects, entity, camera) {
		if (!objects) {
			return;
		}
		const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const forward = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const right = _internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		forward.normalize(entity.getCameraSpacePosition(camera));
		camera.getEntity().getOrientation().getAxis(right, 0);
		right.setNormalTo(forward, right);
		orientation.setFromAxes(right, undefined, forward);
		_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
		if (Array.isArray(objects)) {
			for (let i = 0, l = objects.length; i < l; i++) {
				objects[i].setRotationFromQuaternion(_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion);
			}
		}
		else {
			objects.setRotationFromQuaternion(_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion);
		}
		_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(forward);
		_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(right);
	}

	/**
	 * Sets the object's orientation to be the same as the entity, with optional addition rotation applied first.
	 * @param {THREE.Object3D | THREE.Object3D[]} objects
	 * @param {Entity} entity
	 * @param {Quaternion} [rotation]
	 */
	static setOrientationToEntity(objects, entity, rotation) {
		if (!objects) {
			return;
		}
		const entityOrientation = entity.getOrientation();
		if (rotation === undefined) {
			_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion.set(entityOrientation.x, entityOrientation.y, entityOrientation.z, entityOrientation.w);
		}
		else {
			const orientation = _internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			orientation.mult(entityOrientation, rotation);
			_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion.set(orientation.x, orientation.y, orientation.z, orientation.w);
			_internal__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
		}
		if (Array.isArray(objects)) {
			for (let i = 0, l = objects.length; i < l; i++) {
				objects[i].setRotationFromQuaternion(_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion);
			}
		}
		else {
			objects.setRotationFromQuaternion(_internal__WEBPACK_IMPORTED_MODULE_0__.BaseComponent._tempThreeJsQuaternion);
		}
	}

	// OTHER OBJECT PROPERTIES

	/**
	 * Sets whether or not to use the component in the dynamic environment map. Defaults to false if it isn't used.
	 * @param {THREE.Object3D} object
	 * @param {boolean} enable
	 */
	static useInDynEnvMap(object, enable) {
		if (enable) {
			object.layers.enable(1);
		}
		else {
			object.layers.disable(1);
		}
	}

	// GEOMETRY

	/**
	 * Sets the vertices of the given attribute.
	 * @param {THREE.BufferGeometry} geometry
	 * @param {string} name
	 * @param {Float32Array} vertices
	 */
	static setVertices(geometry, name, vertices) {
		const attribute = geometry.getAttribute(name);
		if (attribute instanceof _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute) {
			if (attribute.array.length === vertices.length) {
				attribute.copyArray(vertices);
				attribute.needsUpdate = true;
			}
			else {
				geometry.setAttribute(name, new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(vertices, geometry.getAttribute(name).itemSize));
			}
		}
	}

	/**
	 * Sets the vertices of the given attribute.
	 * @param {THREE.BufferGeometry} geometry
	 * @param {Uint16Array} indices
	 */
	static setIndices(geometry, indices) {
		const attribute = geometry.getIndex();
		if (attribute.array.length === indices.length) {
			attribute.copyArray(indices);
			attribute.needsUpdate = true;
		}
		else {
			geometry.setIndex(new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.BufferAttribute(indices, 1));
		}
	}

	/**
	 * Sets the tangent attribute computed from the normal and uv attributes.
	 * @param {THREE.BufferGeometry} geometry
	 */
	static computeTangents(geometry) {
		geometry.computeTangents();
	}

	/**
	 * Sets the render order of the objects.
	 * @param {THREE.Object3D} object
	 * @param {number} renderOrder
	 */
	static setRenderOrder(object, renderOrder) {
		if (!object) {
			return;
		}
		object.renderOrder = renderOrder;
	}

	// MATERIALS & TEXTURES

	/**
	 * Sets up log-depth buffering for the material.
	 * They should already have the proper defines in their vertex and fragment code.
	 * @param {THREE.ShaderMaterial} material
	 */
	static setupLogDepthBuffering(material) {
		if (_internal__WEBPACK_IMPORTED_MODULE_0__.Capabilities.hasFragDepth()) {
			material.defines['L_EXT_frag_depth'] = true;
			material.extensions.fragDepth = true;
		}
		else {
			delete material.defines['L_EXT_frag_depth'];
		}
		material.needsUpdate = true;
	}

	/**
	 * Loads a texture.
	 * @param {BaseComponent} component
	 * @param {string} url
	 * @param {boolean} useMipMaps
	 * @param {boolean} useCompression
	 * @returns {Promise<THREE.Texture>}
	 */
	static loadTexture(component, url, useMipMaps, useCompression) {
		const engine = component.getEntity().getScene().getEngine();
		const textureLoader = useCompression ? engine.getTextureLoaderCompressed() : engine.getTextureLoader();
		return textureLoader.loadTexture(url, useMipMaps);
	}

	/**
	 * Loads a texture from a canvas element. The canvas needs to be power of 2.
	 * @param {HTMLCanvasElement} canvas
	 * @returns {THREE.Texture}
	 */
	static loadTextureFromCanvas(canvas) {
		const texture = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CanvasTexture(canvas);
		texture.magFilter = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NearestFilter;
		texture.minFilter = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NearestFilter;
		texture.flipY = false;
		texture.needsUpdate = true;
		return texture;
	}

	/**
	 * Loads a texture.
	 * @param {BaseComponent} component
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} uniformName
	 * @param {string} url
	 * @param {boolean} useMipMaps
	 * @param {boolean} useCompression
	 * @returns {Promise<void>}
	 */
	static async loadTextureIntoUniform(component, material, uniformName, url, useMipMaps, useCompression) {
		if (!material) {
			return;
		}
		const engine = component.getEntity().getScene().getEngine();
		const textureLoader = useCompression ? engine.getTextureLoaderCompressed() : engine.getTextureLoader();
		const texture = await textureLoader.loadTexture(url, useMipMaps);
		const materials = component.getThreeJsMaterials();
		if (materials.includes(material)) { // Check if the material is still loaded.
			const uniform = material.uniforms[uniformName];
			if (uniform === undefined) {
				throw new Error(`Material in ${component} doesn't have uniform name '${uniformName}'.`);
			}
			if (uniform.value !== null) {
				uniform.value.dispose();
			}
			uniform.value = texture;
		}
		else {
			texture.dispose();
		}
	}

	/**
	 * Sets whether or not the material is an overlay. If true, it will be rendered on top of the scene with no scene occlusion.
	 * @param {THREE.ShaderMaterial} material
	 * @param {boolean} overlay
	 */
	static setOverlay(material, overlay) {
		if (!material) {
			return;
		}
		material.depthFunc = (overlay ? _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AlwaysDepth : _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.LessEqualDepth);
	}

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {boolean} enabled
	 */
	static setTransparent(material, enabled) {
		if (!material) {
			return;
		}
		material.transparent = enabled;
		material.depthWrite = !enabled;
	}

	/**
	 * Sets blending mode. Defaults to 'normal'.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} blending - one of 'normal', 'additive', 'subtractive', 'multliply', 'custom', or 'none'
	 */
	static setBlending(material, blending) {
		if (!material) {
			return;
		}
		switch (blending) {
			case 'normal':
				material.blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NormalBlending;
				break;
			case 'additive':
				material.blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.AdditiveBlending;
				break;
			case 'subtractive':
				material.blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.SubtractiveBlending;
				break;
			case 'multiply':
				material.blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.MultiplyBlending;
				break;
			case 'custom':
				material.blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.CustomBlending;
				break;
			default:
				material.blending = _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.NoBlending;
				break;
		}
		material.needsUpdate = true;
	}

	/**
	 * Sets the define on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {boolean} enabled
	 */
	static setDefine(material, name, enabled) {
		if (enabled && !material.defines[name]) {
			material.defines[name] = true;
			material.needsUpdate = true;
		}
		else if (!enabled && material.defines[name] === true) {
			delete material.defines[name];
			material.needsUpdate = true;
		}
	}

	// UNIFORMS

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {number} value
	 */
	static setUniformNumber(material, name, value) {
		if (!material) {
			return;
		}
		material.uniforms[name].value = value;
	}

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {Vector2} value
	 */
	static setUniformVector2(material, name, value) {
		if (!material) {
			return;
		}
		material.uniforms[name].value.set(value.x, value.y);
	}

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {Vector3} value
	 */
	static setUniformVector3(material, name, value) {
		if (!material) {
			return;
		}
		material.uniforms[name].value.set(value.x, value.y, value.z);
	}

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {Color} value
	 */
	static setUniformColorRGB(material, name, value) {
		if (!material) {
			return;
		}
		material.uniforms[name].value.set(value.r, value.g, value.b);
	}

	/**
	 * Sets the uniform on the material.
	 * The alphaMultipier is multiplied onto the alpha component (defaults to 1).
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {Color} value
	 * @param {number} [alphaMultiplier=1]
	 */
	static setUniformColorRGBA(material, name, value, alphaMultiplier = 1) {
		if (!material) {
			return;
		}
		material.uniforms[name].value.set(value.r, value.g, value.b, value.a * alphaMultiplier);
	}

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} name
	 * @param {Quaternion} value
	 */
	static setUniformQuaternion(material, name, value) {
		if (!material) {
			return;
		}
		material.uniforms[name].value.set(value.x, value.y, value.z, value.w);
	}

	/**
	 * Sets the uniform on the material.
	 * @param {THREE.ShaderMaterial} material
	 * @param {string} uniformName
	 * @param {THREE.Texture} value
	 */
	static setUniformTexture(material, uniformName, value) {
		if (!material) {
			return;
		}
		if (material.uniforms[uniformName].value !== null) {
			material.uniforms[uniformName].value.dispose();
		}
		material.uniforms[uniformName].value = value;
	}
}

/**
 * A temporary Three.js Vector3.
 * @type {THREE.Vector3}
 */
ThreeJsHelper._tempThreeJsVector3 = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Vector3();


/***/ }),

/***/ "../pioneer/engine/src/utils/tile.js":
/*!*******************************************!*\
  !*** ../pioneer/engine/src/utils/tile.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Tile": function() { return /* binding */ Tile; }
/* harmony export */ });
/** @module pioneer */

/**
 * A generic multi-level tile class that supports loading, unloading, activating, and deactivating of tiles of a subclass.
 * @template {Tile<TileType>} TileType
 * @private
 */
class Tile {
	/**
	 * Constructor.
	 * @param {TileType | null} parent
	 */
	constructor(parent) {
		/**
		 * The parent tile.
		 * @type {TileType | null}
		 * @private
		 */
		this._parent = parent;

		/**
		 * The child tiles.
		 * @type {TileType[]}
		 * @private
		 */
		this._children = [];

		/**
		 * True if the tile has been activated.
		 * @type {boolean}
		 * @private
		 */
		this._active = false;

		/**
		 * True if the tile has been loaded.
		 * @type {boolean}
		 * @private
		 */
		this._loaded = false;

		/**
		 * True if the tile has been destroyed.
		 * @type {boolean}
		 * @private
		 */
		this._destroyed = false;

		/**
		 * True if this is in a transition (loading, splitting, joining, etc).
		 * @type {boolean}
		 * @private
		 */
		this._transitioning = false;
	}

	/**
	 * Gets the parent tile.
	 * @returns {TileType | null}
	 */
	getParent() {
		return this._parent;
	}

	/**
	 * Forces a tile to load. Useful for the root node that needs to start the process.
	 * @returns {Promise<void>}
	 */
	async forceLoad() {
		this._transitioning = true;
		if (!this._destroyed) {
			await this.load();
		}
		this._loaded = true;
		if (!this._destroyed) {
			await this.activate();
		}
		this._active = true;
		this._transitioning = false;
	}

	/**
	 * Checks the tile to see if needs to be split or join. Returns true if it is transitioning.
	 * @returns {boolean}
	 */
	check() {
		if (!this._destroyed && !this._transitioning) {
			if (this._children.length === 0 && this.checkSplit()) {
				this._split();
			}
			else if (this._children.length > 0 && this.checkJoin()) {
				this._join();
			}
		}

		return this._transitioning;
	}

	/**
	 * Gets the children.
	 * @returns {TileType[]}
	 */
	get children() {
		return this._children;
	}

	/**
	 * Returns a new Tile or null if the tile could not be created.
	 * @param {TileType} _parent
	 * @param {number} _row - 0 or 1
	 * @param {number} _col - 0 or 1
	 * @returns {TileType}
	 */
	createNewTile(_parent, _row, _col) {
		return null;
	}

	/**
	 * Returns true if this tile should be split.
	 * @abstract
	 * @returns {boolean}
	 */
	checkSplit() {
		return false;
	}

	/**
	 * Returns true if this tile should join its children.
	 * @abstract
	 * @returns {boolean}
	 */
	checkJoin() {
		return false;
	}

	/**
	 * Asynchronously loads the tile so that it may be used.
	 * @abstract
	 * @returns {Promise<void | void[]>}
	 */
	async load() {
	}

	/**
	 * Asynchronously unloads the tile.
	 * @abstract
	 * @returns {Promise<void>}
	 */
	async unload() {
	}

	/**
	 * Asynchronously activates the tile.
	 * @abstract
	 * @returns {Promise<void>}
	 */
	async activate() {
	}

	/**
	 * Asynchronously deactivates the tile.
	 * @abstract
	 * @returns {Promise<void>}
	 */
	async deactivate() {
	}

	/**
	 * Destroys the tile and all of its children.
	 */
	destroy() {
		this._destroyed = true;
		for (let i = 0; i < this._children.length; i++) {
			this._children[i].destroy();
		}
		if (!this._transitioning) {
			if (this._active) {
				this.deactivate().then(() => {
					this.unload();
				}).catch((error) => {
					throw error;
				});
			}
			else if (this._loaded) {
				this.unload();
			}
		}
	}

	/**
	 * Splits a tile all the way down and only loads the leaf tiles.
	 * @private
	 */
	_split() {
		/** @type {Array<Promise<void>>} */
		const loadedPromises = [];
		/** @type {TileType[]} */
		const newTiles = [];

		// Create and load all of the tiles.
		this._splitAndLoad(loadedPromises, newTiles);

		// Wait till all of the tiles are loaded, then activate them.
		Promise.all(loadedPromises).then(() => {
			/** @type {Array<Promise<void>>} */
			const activatedPromises = [];
			for (let i = 0; i < newTiles.length; i++) {
				if (newTiles[i]._loaded && !newTiles[i]._destroyed) {
					activatedPromises.push(newTiles[i].activate().then(async () => {
						if (this._destroyed) {
							return this.deactivate().then(() => {
								this.unload();
							}).catch((error) => {
								throw error;
							});
						}
						newTiles[i]._active = true;
						newTiles[i]._transitioning = false;
					}).catch((error) => {
						throw error;
					}));
				}
				else {
					newTiles[i]._transitioning = false;
				}
			}
			if (this._active) {
				activatedPromises.push(this.deactivate().then(() => {
					this._active = false;
				}).catch((error) => {
					throw error;
				}));
			}
			return activatedPromises;
		// Wait till all of the tiles are activated and this is deactivated, then unload this.
		}).then(() => {
			if (this._loaded) {
				this.unload().then(() => {
					this._loaded = false;
					this._transitioning = false;
				}).catch((error) => {
					throw error;
				});
			}
			else {
				this._transitioning = false;
			}
		}).catch((error) => {
			throw error;
		});
	}

	/**
	 * Joins a tile, deactivating, unloading, and removing all children.
	 * @private
	 */
	_join() {
		// First mark all of the descendant tiles as transitioning,
		// and if any were already transitioning, we don't do the join.
		if (this._checkIfDescendantsAreTransitioning()) {
			return;
		}

		// Make this and all descendant tiles transitioning.
		/** @type {TileType[]} */
		const tilesToUnload = [];
		this._transitioning = true;
		this._markDescendantsAsTransitioning(tilesToUnload);

		this.load().then(async () => {
			if (this._destroyed) {
				return this.unload();
			}
			this._loaded = true;
		}).then(() => {
			const promises = [];
			for (let i = 0; i < tilesToUnload.length; i++) {
				promises.push(tilesToUnload[i].deactivate().then(() => {
					tilesToUnload[i]._active = false;
				}).catch((error) => {
					throw error;
				}));
			}
			if (!this._destroyed) {
				promises.push(this.activate().then(async () => {
					if (this._destroyed) {
						return this.deactivate().then(() => {
							this.unload();
						}).catch((error) => {
							throw error;
						});
					}
					this._active = true;
				}).catch((error) => {
					throw error;
				}));
			}
			return Promise.all(promises);
		}).then(() => {
			const promises = [];
			for (let i = 0; i < tilesToUnload.length; i++) {
				promises.push(tilesToUnload[i].unload().then(() => {
					tilesToUnload[i]._loaded = false;
				}).catch((error) => {
					throw error;
				}));
			}
			return Promise.all(promises);
		}).then(() => {
			this._children = [];
			this._transitioning = false;
		}).catch((error) => {
			throw error;
		});
	}

	/**
	 * Creates and loads all of the required tiles.
	 * @param {Array<Promise<void>>} loadedPromises - the list of tiles that were loaded
	 * @param {TileType[]} newTiles - the list of tiles that were created (and possibly loaded)
	 * @private
	 */
	_splitAndLoad(loadedPromises, newTiles) {
		// Create and load all of the tiles.
		this._transitioning = true;
		for (let row = 0; row < 2; row++) {
			for (let col = 0; col < 2; col++) {
				// Construct the tile.
				// @ts-ignore - because it can't convert 'this' to 'TileType'.
				const tile = this.createNewTile(this, row, col);
				if (tile !== null) {
					this._children.push(tile);
					// Check to see if this tile needs to be split as well.
					if (tile.checkSplit()) {
						tile._splitAndLoad(loadedPromises, newTiles);
					}
					// Otherwise, load the tile.
					else {
						tile._transitioning = true;
						loadedPromises.push(tile.load().then(async () => {
							if (tile._destroyed) {
								return tile.unload();
							}
							tile._loaded = true;
						}).catch((error) => {
							throw error;
						}));
					}
					newTiles.push(tile);
				}
			}
		}
	}

	/**
	 * Returns true if any descendant tiles are transitioning. Used by join to ensure that all joined tiles are not already transitioning.
	 * @returns {boolean}
	 * @private
	 */
	_checkIfDescendantsAreTransitioning() {
		for (let i = 0; i < this._children.length; i++) {
			const tile = this._children[i];
			if (tile._transitioning) {
				return true;
			}
			else {
				if (tile._checkIfDescendantsAreTransitioning()) {
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Marks all descendant tiles as transitioning. Assumes the _checkIfDescendantsAreTransitioning function has already been called.
	 * Used by join to ensure that nothing happens to the descendants during the join process.
	 * Also stores the active tiles for later deactivating and unloading.
	 * @param {TileType[]} tilesToUnload
	 * @private
	 */
	_markDescendantsAsTransitioning(tilesToUnload) {
		for (let i = 0; i < this._children.length; i++) {
			const tile = this._children[i];
			tile._transitioning = true;
			if (tile._active) {
				tilesToUnload.push(tile);
			}
			tile._markDescendantsAsTransitioning(tilesToUnload);
		}
	}
}


/***/ }),

/***/ "../pioneer/engine/src/utils/time_utils.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/time_utils.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TimeUtils": function() { return /* binding */ TimeUtils; }
/* harmony export */ });
/** @module pioneer */

/**
 * A class of time routines.
 * @hideconstructor
 */
class TimeUtils {
	/**
	 * Returns the ET time right now.
	 * @returns {number}
	 */
	static now() {
		return TimeUtils.unixToEt(Date.now() / 1000.0);
	}

	/**
	 * Converts an ET time to a Unix time.
	 * @param {number} et - the ET time to convert
	 * @returns {number}
	 */
	static etToUnix(et) {
		let leapSecondsOffset = 0;
		for (let i = 0; i < _leapSeconds.length; i++) {
			if (et + 946727957.816 + leapSecondsOffset >= _leapSeconds[i] + 1) {
				leapSecondsOffset -= 1;
			}
		}
		return et + 946727957.816 + leapSecondsOffset;
	}

	/**
	 * Converts a Unix time to an ET time.
	 * @param {number} unix - the Unix time to convert
	 * @returns {number}
	 */
	static unixToEt(unix) {
		let leapSecondsOffset = 0;
		for (let i = 0; i < _leapSeconds.length; i++) {
			if (unix >= _leapSeconds[i] + 1) {
				leapSecondsOffset += 1;
			}
		}
		return unix - 946727957.816 + leapSecondsOffset;
	}

	/**
	 * Returns the leap seconds array, which is the list of Unix times in seconds right before the leap second.
	 * @returns {number[]}
	 */
	static get leapSeconds() {
		return _leapSeconds;
	}
}

/**
 * The array of leap seconds, which is the list of Unix times in seconds right before the leap second.
 * @type {number[]}
 */
const _leapSeconds = [
	Date.UTC(1972, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1972, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1973, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1974, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1975, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1976, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1977, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1978, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1979, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1981, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1982, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1983, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1985, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1987, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1989, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1990, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1992, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1993, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1994, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1995, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(1997, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(1998, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(2005, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(2008, 12 - 1, 31, 23, 59, 59) / 1000.0,
	Date.UTC(2012, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(2015, 6 - 1, 30, 23, 59, 59) / 1000.0,
	Date.UTC(2016, 12 - 1, 31, 23, 59, 59) / 1000.0
];


/***/ }),

/***/ "../pioneer/engine/src/utils/vector2.js":
/*!**********************************************!*\
  !*** ../pioneer/engine/src/utils/vector2.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector2": function() { return /* binding */ Vector2; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A 2-dimensional vector */
class Vector2 extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<Vector2>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * NaN vector
	 * @returns {Vector2}
	 */
	static get NaN() {
		return _nan;
	}

	/**
	 * Zero vector
	 * @returns {Vector2}
	 */
	static get Zero() {
		return _zero;
	}

	/**
	 * Unit x-axis vector
	 * @returns {Vector2}
	 */
	static get XAxis() {
		return _xAxis;
	}

	/**
	 * Unit y-axis vector
	 * @returns {Vector2}
	 */
	static get YAxis() {
		return _yAxis;
	}

	/**
	 * Constructor.
	 * @param {number} x
	 * @param {number} y
	 */
	constructor(x = 0, y = 0) {
		super();

		/**
		 * @type {number}
		 * @private
		 */
		this._x = x;
		/**
		 * @type {number}
		 * @private
		 */
		this._y = y;
	}

	/**
	 * Gets the x component.
	 * @returns {number}
	 */
	get x() {
		return this._x;
	}

	/**
	 * Sets the x component.
	 * @param {number} x
	 */
	set x(x) {
		this.throwIfFrozen();
		this._x = x;
	}

	/**
	 * Gets the y component.
	 * @returns {number}
	 */
	get y() {
		return this._y;
	}

	/**
	 * Sets the y component.
	 * @param {number} y
	 */
	set y(y) {
		this.throwIfFrozen();
		this._y = y;
	}

	/**
	 * Returns a nicely formed string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		return '[' + this._x + ', ' + this._y + ']';
	}

	/**
	 * Returns true if this equals a.
	 * @param {Vector2} a
	 * @returns {boolean}
	 */
	equals(a) {
		return this._x === a._x && this._y === a._y;
	}

	/**
	 * Returns true if all components are zero.
	 * @returns {boolean}
	 */
	isZero() {
		return this._x === 0 && this._y === 0;
	}

	/**
	 * Returns true if any component of the vector is NaN.
	 * @returns {boolean}
	 */
	isNaN() {
		return (!(this._x <= 0) && !(this._x > 0)) || (!(this._y <= 0) && !(this._y > 0));
	}

	/**
	 * Sets this to a.
	 * @param {Vector2} a
	 */
	copy(a) {
		this.throwIfFrozen();
		this._x = a._x;
		this._y = a._y;
	}

	/**
	 * Sets this to a as a ThreeJs vector.
	 * @param {THREE.Vector2} a
	 */
	copyFromThreeJs(a) {
		this.throwIfFrozen();
		this._x = a.x;
		this._y = a.y;
	}

	/**
	 * Sets this to the parameters.
	 * @param {number} x
	 * @param {number} y
	 */
	set(x, y) {
		this.throwIfFrozen();
		this._x = x;
		this._y = y;
	}

	/**
	 * Sets this to the negative of a.
	 * @param {Vector2} a
	 */
	neg(a) {
		this.throwIfFrozen();
		this._x = -a._x;
		this._y = -a._y;
	}

	/**
	 * Sets this to a + b.
	 * @param {Vector2} a
	 * @param {Vector2} b
	 */
	add(a, b) {
		this.throwIfFrozen();
		this._x = a._x + b._x;
		this._y = a._y + b._y;
	}

	/**
	 * Sets this to a - b.
	 * @param {Vector2} a
	 * @param {Vector2} b
	 */
	sub(a, b) {
		this.throwIfFrozen();
		this._x = a._x - b._x;
		this._y = a._y - b._y;
	}

	/**
	 * Sets this to a * b, where b is a number.
	 * @param {Vector2} a
	 * @param {number} b
	 */
	mult(a, b) {
		this.throwIfFrozen();
		this._x = a._x * b;
		this._y = a._y * b;
	}

	/**
	 * Sets this to a + b * c, where c is a number.
	 * @param {Vector2} a
	 * @param {Vector2} b
	 * @param {number} c
	 */
	addMult(a, b, c) {
		this.throwIfFrozen();
		this._x = a._x + b._x * c;
		this._y = a._y + b._y * c;
	}

	/**
	 * Sets this to a / b, where b is a number.
	 * @param {Vector2} a
	 * @param {number} b
	 */
	div(a, b) {
		this.throwIfFrozen();
		this._x = a._x / b;
		this._y = a._y / b;
	}

	/**
	 * Sets this to a * b, component-wise multiplication.
	 * @param {Vector2} a
	 * @param {Vector2} b
	 */
	scale(a, b) {
		this.throwIfFrozen();
		this._x = a._x * b._x;
		this._y = a._y * b._y;
	}

	/**
	 * Sets this to a / b, component-wise division.
	 * @param {Vector2} a
	 * @param {Vector2} b
	 */
	scaleInv(a, b) {
		this.throwIfFrozen();
		this._x = a._x / b._x;
		this._y = a._y / b._y;
	}

	/**
	 * Returns the dot product of this and a.
	 * @param {Vector2} a
	 * @returns {number}
	 */
	dot(a) {
		return this._x * a._x + this._y * a._y;
	}

	/**
	 * Returns a 2D cross product, which can be used for signed angles between vectors.
	 * @param {Vector2} a
	 */
	cross(a) {
		return this._x * a._y - this._y * a._x;
	}

	/**
	 * Returns the squared length of this vector.
	 * @returns {number}
	 */
	magnitudeSqr() {
		return this._x * this._x + this._y * this._y;
	}

	/**
	 * Returns the length of this vector.
	 * @returns {number}
	 */
	magnitude() {
		return Math.sqrt(this.magnitudeSqr());
	}

	/**
	 * Sets this to a with a magnitude of 1.0.
	 * @param {Vector2} a
	 */
	normalize(a) {
		this.throwIfFrozen();
		const magnitude = a.magnitude();
		if (magnitude > 0) {
			this._x = a._x / magnitude;
			this._y = a._y / magnitude;
		}
	}

	/**
	 * Sets this to a with a given magnitude.
	 * @param {Vector2} a
	 * @param {number} magnitude
	 */
	setMagnitude(a, magnitude) {
		this.throwIfFrozen();
		this.normalize(a);
		this._x *= magnitude;
		this._y *= magnitude;
	}

	/**
	 * Returns the distance between this and a.
	 * @param {Vector2} a
	 * @returns {number}
	 */
	distance(a) {
		const x = this._x - a._x;
		const y = this._y - a._y;
		return Math.sqrt(x * x + y * y);
	}

	/**
	 * Returns the angle in radians between this and a. If this or a are zero, returns NaN.
	 * @param {Vector2} a
	 * @returns {number}
	 */
	angle(a) {
		const magnitudes = this.magnitude() * a.magnitude();
		if (magnitudes > 0) {
			return Math.acos(_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(this.dot(a) / magnitudes, -1.0, 1.0));
		}
		else {
			return Number.NaN;
		}
	}

	/**
	 * Sets this to a, clamped between min and max, component-wise.
	 * @param {Vector2} a
	 * @param {Vector2} min
	 * @param {Vector2} max
	 */
	clamp(a, min, max) {
		this.throwIfFrozen();
		this._x = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(a._x, min._x, max._x);
		this._y = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(a._y, min._y, max._y);
	}

	/**
	 * Sets this to the lerp between a and b, where u is the lerp parameter, and it may be clamped between a and b.
	 * @param {Vector2} a - the value when u = 0
	 * @param {Vector2} b - the value when u = 1
	 * @param {number} u - the lerp factor
	 */
	lerp(a, b, u) {
		this.throwIfFrozen();
		this._x = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._x, b._x, u);
		this._y = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._y, b._y, u);
	}
}

/**
 * @type {Pool<Vector2>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(Vector2);

const _zero = new Vector2();
_zero.freeze();

const _xAxis = new Vector2(1, 0);
_xAxis.freeze();

const _yAxis = new Vector2(0, 1);
_yAxis.freeze();

const _nan = new Vector2(Number.NaN, Number.NaN);
_nan.freeze();


/***/ }),

/***/ "../pioneer/engine/src/utils/vector3.js":
/*!**********************************************!*\
  !*** ../pioneer/engine/src/utils/vector3.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Vector3": function() { return /* binding */ Vector3; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/** A 3-dimensional vector */
class Vector3 extends _internal__WEBPACK_IMPORTED_MODULE_0__.Freezable {
	/**
	 * Pool for temporary variables.
	 * @returns {Pool<Vector3>}
	 */
	static get pool() {
		return _pool;
	}

	/**
	 * NaN vector
	 * @returns {Vector3}
	 */
	static get NaN() {
		return _nan;
	}

	/**
	 * Zero vector
	 * @returns {Vector3}
	 */
	static get Zero() {
		return _zero;
	}

	/**
	 * Unit x-axis vector
	 * @returns {Vector3}
	 */
	static get XAxis() {
		return _xAxis;
	}

	/**
	 * Unit y-axis vector
	 * @returns {Vector3}
	 */
	static get YAxis() {
		return _yAxis;
	}

	/**
	 * Unit z-axis vector
	 * @returns {Vector3}
	 */
	static get ZAxis() {
		return _zAxis;
	}

	/**
	 * Unit negative x-axis vector
	 * @returns {Vector3}
	 */
	static get XAxisNeg() {
		return _xAxisNeg;
	}

	/**
	 * Unit negative y-axis vector
	 * @returns {Vector3}
	 */
	static get YAxisNeg() {
		return _yAxisNeg;
	}

	/**
	 * Unit negative z-axis vector
	 * @returns {Vector3}
	 */
	static get ZAxisNeg() {
		return _zAxisNeg;
	}

	/**
	 * Returns the xyz equivalent of azimuth (rotation from x-axis about z-axis), elevation (from x-y plane), and range.
	 * @param {AER} aer
	 * @returns {Vector3}
	 */
	static fromAER(aer) {
		const v = new Vector3();
		v.setFromAER(aer);
		return v;
	}

	/**
	 * Constructor.
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 */
	constructor(x = 0, y = 0, z = 0) {
		super();

		/**
		 * @type {number}
		 * @private
		 */
		this._x = x;
		/**
		 * @type {number}
		 * @private
		 */
		this._y = y;
		/**
		 * @type {number}
		 * @private
		 */
		this._z = z;
	}

	/**
	 * Gets the x component.
	 * @returns {number}
	 */
	get x() {
		return this._x;
	}

	/**
	 * Sets the x component.
	 * @param {number} x
	 */
	set x(x) {
		this.throwIfFrozen();
		this._x = x;
	}

	/**
	 * Gets the y component.
	 * @returns {number}
	 */
	get y() {
		return this._y;
	}

	/**
	 * Sets the y component.
	 * @param {number} y
	 */
	set y(y) {
		this.throwIfFrozen();
		this._y = y;
	}

	/**
	 * Gets the z component.
	 * @returns {number}
	 */
	get z() {
		return this._z;
	}

	/**
	 * Sets the z component.
	 * @param {number} z
	 */
	set z(z) {
		this.throwIfFrozen();
		this._z = z;
	}

	/**
	 * Returns a nicely formed string.
	 * @override
	 * @returns {string}
	 */
	toString() {
		return '[' + this._x + ', ' + this._y + ', ' + this._z + ']';
	}

	/**
	 * Returns true if this equals a.
	 * @param {Vector3} a
	 * @returns {boolean}
	 */
	equals(a) {
		return this._x === a._x && this._y === a._y && this._z === a._z;
	}

	/**
	 * Returns true if all components are zero.
	 * @returns {boolean}
	 */
	isZero() {
		return this._x === 0 && this._y === 0 && this._z === 0;
	}

	/**
	 * Returns true if any component in the vector is NaN.
	 * @returns {boolean}
	 */
	isNaN() {
		return (!(this._x <= 0) && !(this._x > 0)) || (!(this._y <= 0) && !(this._y > 0)) || (!(this._z <= 0) && !(this._z > 0));
	}

	/**
	 * Sets this to a.
	 * @param {Vector3} a
	 */
	copy(a) {
		this.throwIfFrozen();
		this._x = a._x;
		this._y = a._y;
		this._z = a._z;
	}

	/**
	 * Sets this to a as a ThreeJs vector.
	 * @param {THREE.Vector3} a
	 */
	copyFromThreeJs(a) {
		this.throwIfFrozen();
		this._x = a.x;
		this._y = a.y;
		this._z = a.z;
	}

	/**
	 * Sets this to the parameters.
	 * @param {number} x
	 * @param {number} y
	 * @param {number} z
	 */
	set(x, y, z) {
		this.throwIfFrozen();
		this._x = x;
		this._y = y;
		this._z = z;
	}

	/**
	 * Sets this to the xyz equivalent of azimuth (rotation from x-axis about z-axis), elevation (from x-y plane), and range.
	 * @param {AER} aer
	 */
	setFromAER(aer) {
		this.throwIfFrozen();
		const cosElevation = Math.cos(aer.elevation);
		this._x = aer.range * cosElevation * Math.cos(aer.azimuth);
		this._y = aer.range * cosElevation * Math.sin(aer.azimuth);
		this._z = aer.range * Math.sin(aer.elevation);
	}

	/**
	 * Sets this to the negative of a.
	 * @param {Vector3} a
	 */
	neg(a) {
		this.throwIfFrozen();
		this._x = -a._x;
		this._y = -a._y;
		this._z = -a._z;
	}

	/**
	 * Sets this to a + b.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 */
	add(a, b) {
		this.throwIfFrozen();
		this._x = a._x + b._x;
		this._y = a._y + b._y;
		this._z = a._z + b._z;
	}

	/**
	 * Sets this to a - b.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 */
	sub(a, b) {
		this.throwIfFrozen();
		this._x = a._x - b._x;
		this._y = a._y - b._y;
		this._z = a._z - b._z;
	}

	/**
	 * Sets this to a * b, where b is a number.
	 * @param {Vector3} a
	 * @param {number} b
	 */
	mult(a, b) {
		this.throwIfFrozen();
		this._x = a._x * b;
		this._y = a._y * b;
		this._z = a._z * b;
	}

	/**
	 * Sets this to a + b * c, where c is a number.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 * @param {number} c
	 */
	addMult(a, b, c) {
		this.throwIfFrozen();
		this._x = a._x + b._x * c;
		this._y = a._y + b._y * c;
		this._z = a._z + b._z * c;
	}

	/**
	 * Sets this to a / b, where b is a number.
	 * @param {Vector3} a
	 * @param {number} b
	 */
	div(a, b) {
		this.throwIfFrozen();
		this._x = a._x / b;
		this._y = a._y / b;
		this._z = a._z / b;
	}

	/**
	 * Sets this to a * b, component-wise multiplication.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 */
	scale(a, b) {
		this.throwIfFrozen();
		this._x = a._x * b._x;
		this._y = a._y * b._y;
		this._z = a._z * b._z;
	}

	/**
	 * Sets this to a / b, component-wise division.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 */
	scaleInv(a, b) {
		this.throwIfFrozen();
		this._x = a._x / b._x;
		this._y = a._y / b._y;
		this._z = a._z / b._z;
	}

	/**
	 * Returns the dot product of this and a.
	 * @param {Vector3} a
	 * @returns {number}
	 */
	dot(a) {
		return this._x * a._x + this._y * a._y + this._z * a._z;
	}

	/**
	 * Sets this to the cross product of a and b.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 */
	cross(a, b) {
		this.throwIfFrozen();
		const x = a._y * b._z - a._z * b._y;
		const y = a._z * b._x - a._x * b._z;
		const z = a._x * b._y - a._y * b._x;
		this._x = x;
		this._y = y;
		this._z = z;
	}

	/**
	 * Returns the squared length of this vector.
	 * @returns {number}
	 */
	magnitudeSqr() {
		return this._x * this._x + this._y * this._y + this._z * this._z;
	}

	/**
	 * Returns the length of this vector.
	 * @returns {number}
	 */
	magnitude() {
		return Math.sqrt(this.magnitudeSqr());
	}

	/**
	 * Returns the length of just the x and y components. Useful in calculations involving spheres.
	 * @returns {number}
	 */
	magnitudeXY() {
		return Math.sqrt(this._x * this._x + this._y * this._y);
	}

	/**
	 * Sets this to a with a magnitude of 1.0.
	 * @param {Vector3} a
	 */
	normalize(a) {
		this.throwIfFrozen();
		const magnitude = a.magnitude();
		if (magnitude > 0) {
			this._x = a._x / magnitude;
			this._y = a._y / magnitude;
			this._z = a._z / magnitude;
		}
		else {
			this.copy(a);
		}
	}

	/**
	 * Sets this to a with a given magnitude.
	 * @param {Vector3} a
	 * @param {number} magnitude
	 */
	setMagnitude(a, magnitude) {
		this.throwIfFrozen();
		this.normalize(a);
		this._x *= magnitude;
		this._y *= magnitude;
		this._z *= magnitude;
	}

	/**
	 * Returns the distance between this and a.
	 * @param {Vector3} a
	 * @returns {number}
	 */
	distance(a) {
		const x = this._x - a._x;
		const y = this._y - a._y;
		const z = this._z - a._z;
		return Math.sqrt(x * x + y * y + z * z);
	}

	/**
	 * Returns the angle in radians between this and a. If this or a are zero, returns NaN.
	 * @param {Vector3} a
	 * @returns {number}
	 */
	angle(a) {
		const magnitudes = this.magnitude() * a.magnitude();
		if (magnitudes > 0) {
			return Math.acos(_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(this.dot(a) / magnitudes, -1.0, 1.0));
		}
		else {
			return Number.NaN;
		}
	}

	/**
	 * Returns the angle in radians from this to a if they were projected on the plane formed by axis. It can be plus or minus, based on the right-hand rule rotation around axis.
	 * @param {Vector3} a
	 * @param {Vector3} axis
	 * @returns {number}
	 */
	angleAroundAxis(a, axis) {
		const thisP = Vector3.pool.get();
		const aP = Vector3.pool.get();

		// Project the vectors.
		thisP.addMult(this, axis, -this.dot(axis));
		aP.addMult(a, axis, -a.dot(axis));

		// Get the angle.
		let angle = thisP.angle(aP);

		// Determine the sign of the angle.
		thisP.cross(thisP, aP);
		if (thisP.dot(axis) < 0) {
			angle *= -1;
		}

		Vector3.pool.release(thisP);
		Vector3.pool.release(aP);
		return angle;
	}

	/**
	 * Sets this to a, clamped between min and max, component-wise.
	 * @param {Vector3} a
	 * @param {Vector3} min
	 * @param {Vector3} max
	 */
	clamp(a, min, max) {
		this.throwIfFrozen();
		this._x = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(a._x, min._x, max._x);
		this._y = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(a._y, min._y, max._y);
		this._z = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(a._z, min._z, max._z);
	}

	/**
	 * Sets this to the lerp between a and b, where u is the lerp parameter, and it may be clamped between a and b.
	 * @param {Vector3} a - the value when u = 0
	 * @param {Vector3} b - the value when u = 1
	 * @param {number} u - the lerp factor
	 */
	lerp(a, b, u) {
		this.throwIfFrozen();
		this._x = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._x, b._x, u);
		this._y = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._y, b._y, u);
		this._z = _internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(a._z, b._z, u);
	}

	/**
	 * Sets this to the slerp between a and b, where u is the lerp parameter, and it may be clamped between a and b.
	 * @param {Vector3} a - the value when u = 0
	 * @param {Vector3} b - the value when u = 1
	 * @param {number} u - the lerp factor
	 */
	slerp(a, b, u) {
		this.throwIfFrozen();
		const aMag = a.magnitude();
		const bMag = b.magnitude();
		if (aMag > 0.0 && bMag > 0.0) {
			const angle = Math.acos(_internal__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(a.dot(b) / (aMag * bMag), -1, +1));
			if (Math.abs(angle) > 0.01745327777) { // If less than one degree, just lerp
				const sinAngleInv = 1 / Math.sin(angle);
				const aFactor = Math.sin((1 - u) * angle) * sinAngleInv;
				const bFactor = Math.sin(u * angle) * sinAngleInv;
				this.set(a.x * aFactor / aMag + b.x * bFactor / bMag, a.y * aFactor / aMag + b.y * bFactor / bMag, a.z * aFactor / aMag + b.z * bFactor / bMag);
				this.mult(this, (1 - u) * aMag + u * bMag);
			}
			else {
				this.lerp(a, b, u);
			}
		}
		else {
			this.lerp(a, b, u);
		}
	}

	/**
	 * Sets this to the result of the vector b rotated by the quaternion a.
	 * @param {Quaternion} a
	 * @param {Vector3} b
	 */
	rotate(a, b) {
		this.throwIfFrozen();
		const tx = a.w * b._x + a.y * b._z - a.z * b._y;
		const ty = a.w * b._y + a.z * b._x - a.x * b._z;
		const tz = a.w * b._z + a.x * b._y - a.y * b._x;
		const tw = -a.x * b._x - a.y * b._y - a.z * b._z;
		this._x = tx * a.w - tw * a.x - ty * a.z + tz * a.y;
		this._y = ty * a.w - tw * a.y - tz * a.x + tx * a.z;
		this._z = tz * a.w - tw * a.z - tx * a.y + ty * a.x;
	}

	/**
	 * Sets this to the result of the vector b rotated by the inverse of quaternion a.
	 * @param {Quaternion} a
	 * @param {Vector3} b
	 */
	rotateInverse(a, b) {
		this.throwIfFrozen();
		const tx = a.w * b._x - a.y * b._z + a.z * b._y;
		const ty = a.w * b._y - a.z * b._x + a.x * b._z;
		const tz = a.w * b._z - a.x * b._y + a.y * b._x;
		const tw = a.x * b._x + a.y * b._y + a.z * b._z;
		this._x = tx * a.w + tw * a.x + ty * a.z - tz * a.y;
		this._y = ty * a.w + tw * a.y + tz * a.x - tx * a.z;
		this._z = tz * a.w + tw * a.z + tx * a.y - ty * a.x;
	}

	/**
	 * Sets this to a vector normal to a, in the plane of 'a cross b', such that 'this dot b' is positive.
	 * @param {Vector3} a
	 * @param {Vector3} b
	 */
	setNormalTo(a, b) {
		const x = b._x * (a._y * a._y + a._z * a._z) - a._x * (a._y * b._y + a._z * b._z);
		const y = b._y * (a._z * a._z + a._x * a._x) - a._y * (a._z * b._z + a._x * b._x);
		const z = b._z * (a._x * a._x + a._y * a._y) - a._z * (a._x * b._x + a._y * b._y);
		this._x = x;
		this._y = y;
		this._z = z;
		this.normalize(this);
	}
}

/**
 * @type {Pool<Vector3>}
 */
const _pool = new _internal__WEBPACK_IMPORTED_MODULE_0__.Pool(Vector3);

const _zero = new Vector3();
_zero.freeze();

const _xAxis = new Vector3(1, 0, 0);
_xAxis.freeze();

const _yAxis = new Vector3(0, 1, 0);
_yAxis.freeze();

const _zAxis = new Vector3(0, 0, 1);
_zAxis.freeze();

const _xAxisNeg = new Vector3(-1, 0, 0);
_xAxis.freeze();

const _yAxisNeg = new Vector3(0, -1, 0);
_yAxis.freeze();

const _zAxisNeg = new Vector3(0, 0, -1);
_zAxis.freeze();

const _nan = new Vector3(Number.NaN, Number.NaN, Number.NaN);
_nan.freeze();


/***/ }),

/***/ "../pioneer/engine/src/utils/wait_until.js":
/*!*************************************************!*\
  !*** ../pioneer/engine/src/utils/wait_until.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "waitUntil": function() { return /* binding */ waitUntil; }
/* harmony export */ });
/** @module pioneer */

/**
 * Waits until the testFunc returns true.
 * @param {() => boolean} testFunc - The testing function. Returning true stops the wait.
 * @param {number} testInterval - The interval in seconds to wait between tests.
 * @param {number} timeout - The time at which point the promise rejects.
 */
async function waitUntil(testFunc, testInterval, timeout) {
	return new Promise((resolve, reject) => {
		let timeSoFar = 0;
		const intervalCheck = setInterval(() => {
			// Do the test.
			if (testFunc()) {
				clearInterval(intervalCheck);
				resolve();
			}
			// Increase the time we've waited.
			timeSoFar += testInterval;
			// If we've hit the timeout, reject.
			if (timeSoFar >= timeout) {
				clearInterval(intervalCheck);
				reject(new Error());
			}
		}, testInterval * 1000.0);
	});
}


/***/ }),

/***/ "../pioneer/engine/src/version.js":
/*!****************************************!*\
  !*** ../pioneer/engine/src/version.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Version": function() { return /* binding */ Version; }
/* harmony export */ });
const Version = '51.0.1';


/***/ }),

/***/ "../pioneer/engine/src/viewport.js":
/*!*****************************************!*\
  !*** ../pioneer/engine/src/viewport.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Viewport": function() { return /* binding */ Viewport; }
/* harmony export */ });
/* harmony import */ var _internal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal */ "../pioneer/engine/src/internal.js");
/** @module pioneer */


/**
 * A viewport is where a scene will be rendered through a camera.
 * When it is created, it creates a div element that can be styled, and which is contained in the viewports div.
 * @extends {CollectionItem<Engine>}
 */
class Viewport extends _internal__WEBPACK_IMPORTED_MODULE_0__.CollectionItem {
	/**
	 * Constructs the viewport. Only called by the engine.
	 * @param {string} type - The type of the viewport (always 'viewport').
	 * @param {string} name - The name of the viewport.
	 * @param {Engine} engine - The engine.
	 */
	constructor(type, name, engine) {
		super(type, name, engine);

		/**
		 * Flag whether the viewport is enabled or not.
		 * @type {boolean}
		 * @private
		 */
		this._enabled = true;

		/**
		 * The camera being used to render.
		 * @type {CameraComponent}
		 * @private
		 */
		this._camera = null;

		/**
		 * The div that this viewport uses for its bounds.
		 * @type {HTMLDivElement}
		 * @private
		 */
		this._div = document.createElement('div');

		/**
		 * The bounds of the viewport. Calculated from the div.
		 * @type {Rect}
		 * @private
		 */
		this._bounds = new _internal__WEBPACK_IMPORTED_MODULE_0__.Rect(0, 0, 0, 0);
		this._bounds.freeze();

		/**
		 * The color of the viewport background.
		 * @type {Color}
		 * @private
		 */
		this._backgroundColor = new _internal__WEBPACK_IMPORTED_MODULE_0__.Color(0, 0, 0, 1);
		this._backgroundColor.freeze();

		/**
		 * A THREE.Color helper so that a new THREE.Color doesn't need to be generated every frame.
		 * @type {THREE.Color}
		 * @private
		 */
		this._threeJsBackgroundColor = new _internal__WEBPACK_IMPORTED_MODULE_0__.THREE.Color();

		// Configure and add the div.
		this._div.style.position = 'absolute';
		this._div.style.overflow = 'hidden';
		this._div.id = name ?? '';
		this._div.classList.add('viewport');
		if (!this._enabled) {
			this._div.style.display = 'none';
		}
		this.getEngine().getViewportDiv().appendChild(this._div);

		// Make sure the pixel bounds are valid on startup.
		const rootDiv = this.getEngine().getRootDiv();
		this._bounds.thaw();
		this._bounds.set(this._div.offsetLeft - rootDiv.offsetLeft, this._div.offsetTop - rootDiv.offsetTop, this._div.offsetWidth, this._div.offsetHeight);
		this._bounds.freeze();

		// Make this the active viewport if there is none yet.
		const input = this.getEngine().getInput();
		if (input.getActiveViewport() === null) {
			input.__setActiveViewport(this);
		}
	}

	/**
	 * Gets the engine.
	 * @returns {Engine}
	 */
	getEngine() {
		return this.__getCollectionParent();
	}

	/**
	 * Gets the div. This can be used to style the viewport.
	 * @returns {HTMLDivElement}
	 */
	getDiv() {
		return this._div;
	}

	/**
	 * Gets the pixel bounds within which this viewport renders, relative to the root div.
	 * @returns {Rect}
	 */
	getBounds() {
		return this._bounds;
	}

	/**
	 * Gets the background color.
	 * @returns {Color}
	 */
	getBackgroundColor() {
		return this._backgroundColor;
	}

	/**
	 * Sets the background color.
	 * @param {Color} backgroundColor - The color for the background.
	 */
	setBackgroundColor(backgroundColor) {
		this._backgroundColor.thaw();
		this._backgroundColor = backgroundColor;
		this._backgroundColor.freeze();
		this._threeJsBackgroundColor.setRGB(this._backgroundColor.r, this._backgroundColor.g, this._backgroundColor.b);
	}

	/**
	 * Returns the camera that will be used by this viewport.
	 * @returns {CameraComponent}
	 */
	getCamera() {
		return this._camera;
	}

	/**
	 * Sets the camera that will be used by this viewport.
	 * @param {CameraComponent} camera
	 */
	setCamera(camera) {
		this._camera = camera;
		if (this._camera !== null) {
			this._camera.__setViewport(this);
		}
	}

	/**
	 * Returns true if the viewport is enabled.
	 * @returns {boolean}
	 */
	isEnabled() {
		return this._enabled;
	}

	/**
	 * Sets whether the viewport is enabled or not.
	 * @param {boolean} enabled
	 */
	setEnabled(enabled) {
		this._enabled = enabled;
		if (!this._enabled) {
			this._div.style.display = 'none';
		}
		else {
			this._div.style.display = 'block';
		}
	}

	/**
	 * Gets a normal-space position from a pixel-space position. Sets the z coordinate to +1, which is equivalent to the near point of the camera.
	 * @param {Vector3} outNormalSpacePosition
	 * @param {Vector2} pixelSpacePosition
	 */
	getNormalSpacePositionFromPixelSpacePosition(outNormalSpacePosition, pixelSpacePosition) {
		outNormalSpacePosition.x = 2.0 * (pixelSpacePosition.x - this._bounds.origin.x) / this._bounds.size.x - 1.0;
		outNormalSpacePosition.y = 1.0 - 2.0 * (pixelSpacePosition.y - this._bounds.origin.y) / this._bounds.size.y;
		outNormalSpacePosition.z = +1;
	}

	/**
	 * Gets a pixel-space position from a normal-space position. Ignores the z coordinate.
	 * @param {Vector2} outPixelSpacePosition
	 * @param {Vector3} normalSpacePosition
	 */
	getPixelSpacePositionFromNormalSpacePosition(outPixelSpacePosition, normalSpacePosition) {
		if (-1.0 < normalSpacePosition.z && normalSpacePosition.z < 1.0) {
			outPixelSpacePosition.x = this._bounds.size.x * (normalSpacePosition.x + 1.0) / 2.0 + this._bounds.origin.x;
			outPixelSpacePosition.y = this._bounds.size.y * (1.0 - normalSpacePosition.y) / 2.0 + this._bounds.origin.y;
		}
		else {
			outPixelSpacePosition.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector2[NaN]);
		}
	}

	/**
	 * Gets the pixel-space radius from a normal-space radius.
	 * @param {number} normalSpaceRadius
	 * @returns {number}
	 */
	getPixelSpaceRadiusFromNormalSpaceRadius(normalSpaceRadius) {
		return normalSpaceRadius * Math.max(this._bounds.size.x, this._bounds.size.y);
	}

	/**
	 * Gets the normal-space radius from a pixel-space radius.
	 * @param {number} pixelSpaceRadius
	 * @returns {number}
	 */
	getNormalSpaceRadiusFromPixelSpaceRadius(pixelSpaceRadius) {
		return pixelSpaceRadius / Math.max(this._bounds.size.x, this._bounds.size.y);
	}

	/**
	 * Gets the direction in camera-space of the cursor position, or NaN if the cursor is not over the viewport.
	 * @param {Vector3} outDirection
	 */
	getDirectionOfCursor(outDirection) {
		const camera = this.getCamera();
		if (camera === null) {
			outDirection.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			return;
		}
		// Get the picked position in normal space.
		const input = this.getEngine().getInput();
		this.getNormalSpacePositionFromPixelSpacePosition(outDirection, input.getCursorPosition());
		if (outDirection.x < -1 || outDirection.x > +1
			|| outDirection.y < -1 || outDirection.y > +1
			|| outDirection.z < -1 || outDirection.z > +1) {
			outDirection.copy(_internal__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			return;
		}

		// Get the picked position in camera space.
		camera.getCameraSpacePositionFromNormalSpacePosition(outDirection, outDirection);

		// Turn it into a ray of length 1, going from the camera.
		outDirection.normalize(outDirection);
	}

	/**
	 * Removes the div from the viewports div.
	 * @override
	 * @internal
	 */
	__destroy() {
		super.__destroy();

		// Clean up the div.
		this._div.parentNode.removeChild(this._div);
	}

	/**
	 * Prepares the camera-dependent variables and those of its connected entities.
	 * @internal
	 */
	__updateViewportVariables() {
		if (this._enabled) {
			// Update the bounds.
			this._bounds.thaw();
			this._bounds.set(this._div.offsetLeft, this._div.offsetTop, this._div.offsetWidth, this._div.offsetHeight);
			this._bounds.freeze();

			// Update the camera variables for the camera.
			if (this._camera !== null) {
				this._camera.__updateCameraVariablesForConnectedScene();
			}
		}
	}

	/**
	 * Renders the camera in the viewport. Called by Engine.
	 * @internal
	 */
	__render() {
		if (!this._enabled) {
			return;
		}

		const renderer = this.getEngine().__getThreeJsRenderer();

		const positionFromBottomLeft = this.getEngine().getRootDiv().offsetHeight - this._div.offsetTop - this._div.offsetHeight;
		renderer.setViewport(this._bounds.origin.x, positionFromBottomLeft, this._bounds.size.x, this._bounds.size.y);
		renderer.setScissor(this._bounds.origin.x, positionFromBottomLeft, this._bounds.size.x, this._bounds.size.y);

		this._threeJsBackgroundColor.setRGB(this._backgroundColor.r, this._backgroundColor.g, this._backgroundColor.b);
		renderer.setClearColor(this._threeJsBackgroundColor, this._backgroundColor.a);

		// Render the camera (which renders its scene).
		if (this._camera !== null) {
			this._camera.__prepareForRender();

			this._camera.__render();
		}
		else {
			this.getEngine().__getThreeJsRenderer().clear();
		}
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/animation.js":
/*!*******************************************!*\
  !*** ../pioneer/scripts/src/animation.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Animation": function() { return /* binding */ Animation; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * Helpful utilities for scenes.
 * @hideconstructor
 */
class Animation {

	/**
	 * Makes an animation that makes visible and invisible a subobjects at different times.
	 * Each keyframe is a [time, visible] pair.
	 * @param {Pioneer.ModelComponent} model
	 * @param {string} subobject
	 * @param {boolean} visibilityAtNegInf
	 * @param {[number, boolean][]} keyframes
	 * @returns {Pioneer.CoverageController}
	 */
	static makeSubobjectVisibleAnimation(model, subobject, visibilityAtNegInf, keyframes) {
		// Sort the keyframes by time, just in case they aren't.
		keyframes.sort((a, b) => a[0] - b[0]);

		// Get the coverage controller or create one if it doesn't already exist.
		const entity = model.getEntity();
		const coverageController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CoverageController);
		coverageController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY));
		coverageController.setUpdateFunction((entity) => {
			const time = entity.getScene().getEngine().getTime();
			const index = pioneer__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, keyframes, (a, time) => a[0] < time);
			if (index === 0) { // At first keyframe time or before.
				model.setHiddenObject(subobject, !visibilityAtNegInf);
			}
			else {
				model.setHiddenObject(subobject, !keyframes[index - 1][1]);
			}
		});

		return coverageController;
	}

	/**
	 * Makes an animation that rotates an entity's joints at different times.
	 * Each keyframe is a [time, rotation] pair.
	 * @param {Pioneer.ModelComponent} model
	 * @param {string} joint
	 * @param {'x' | 'y' | 'z'} axis
	 * @param {[number, number][]} keyframes
	 */
	static makeJointRotationAnimation(model, joint, axis, keyframes) {
		// Sort the keyframes by time, just in case they aren't.
		keyframes.sort((a, b) => a[0] - b[0]);

		// Get the coverage controller or create one if it doesn't already exist.
		const entity = model.getEntity();
		const coverageController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CoverageController);
		coverageController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY));
		coverageController.setUpdateFunction((entity) => {
			const obj = model.getThreeJsObjectByName(joint);
			if (obj !== null) {
				const time = entity.getScene().getEngine().getTime();
				const index = pioneer__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, keyframes, (a, time) => a[0] < time);
				if (index === 0) { // At first keyframe time or before.
					obj.rotation[axis] = keyframes[0][1];
				}
				else if (index === keyframes.length) { // After last keyframe time.
					obj.rotation[axis] = keyframes[keyframes.length - 1][1];
				}
				else {
					const prevKeyframe = keyframes[index - 1];
					const nextKeyframe = keyframes[index];
					const u = (time - prevKeyframe[0]) / (nextKeyframe[0] - prevKeyframe[0]);
					obj.rotation[axis] = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(prevKeyframe[1], nextKeyframe[1], u);
				}
			}
		});

		return coverageController;
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/cameras.js":
/*!*****************************************!*\
  !*** ../pioneer/scripts/src/cameras.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cameras": function() { return /* binding */ Cameras; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * @callback TransitionFunction
 * @param {Pioneer.Entity} entity
 * @param {Pioneer.Vector3} initialPosition
 * @param {Pioneer.Vector3} finalPosition
 * @param {Pioneer.Quaternion} initialOrientation
 * @param {Pioneer.Quaternion} finalOrientation
 * @param {number} u
 */

/**
 * Helpful functions for viewports and cameras.
 * @hideconstructor
 */
class Cameras {
	/**
	 * Creates a full size (100% width and height) viewport and a camera.
	 * @param {Pioneer.Scene} scene - the scene in which to create the camera
	 * @param {string} [viewportName = 'main'] - the name of the viewport
	 * @param {string} [cameraEntityName = 'camera'] - the name of the camera entity
	 */
	static createFullSizeViewportAndCamera(scene, viewportName = 'main', cameraEntityName = 'camera') {
		const viewport = scene.getEngine().addViewport(viewportName);
		viewport.getDiv().style.width = '100%';
		viewport.getDiv().style.height = '100%';
		const cameraEntity = scene.addEntity(cameraEntityName);
		const camera = cameraEntity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CameraComponent);
		viewport.setCamera(camera);
	}

	/** Makes the camera align to the focus entity.
	 * @param {Pioneer.Entity} cameraEntity - the camera entity
	 * @param {Pioneer.Entity} focusEntity - the entity around which the camera entity will orbit
	 * @param {Object} options - the options used to setup the camera
	 * @param {boolean} [options.up = true] - If true, the camera's up will be aligned with the entity.
	 * @param {boolean} [options.orbiter = false] - If true, the camera's up will be the away from the focus entity's parent, and if false, it will be the z-axis (usually the north pole).
	 */
	static focusOnEntity(cameraEntity, focusEntity, { up = true, orbiter = false }) {
		const alignController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.AlignController);
		alignController.setPrimaryAlignType('point');
		alignController.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis);
		alignController.setPrimaryTargetEntity(focusEntity.getName());
		if (up) {
			if (orbiter) {
				alignController.setSecondaryAlignType('position');
				alignController.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
				alignController.setSecondaryTargetEntity(focusEntity.getName());
			}
			else {
				alignController.setSecondaryAlignType('align');
				alignController.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
				alignController.setSecondaryTargetEntity(focusEntity.getName());
				alignController.setSecondaryTargetAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
			}
		}
	}

	/**
	 * Makes the camera look at an entity.
	 * @param {Pioneer.Entity} cameraEntity - the camera entity
	 * @param {Pioneer.Entity} focusEntity - the entity that the camera entity will look at
	 * @param {Object} options - the options used to setup the camera
	 * @param {number} [options.duration = 0.5] - seconds to do the transition
	 * @param {Pioneer.Vector3} [options.finalUp] - the final up vector, defaults to undefined, which means no up alignment
	 * @param {Pioneer.Entity} [options.finalUpRelativeEntity] - the final up vector is relative to this entity, defaults to the focus entity
	 * @param {boolean} [options.finalUpPosition] - true if the final up vector is the position of the finalUpRelativeEntity relative to its parent
	 */
	static async lookAtEntity(cameraEntity, focusEntity, { duration = 0.5, finalUp = undefined, finalUpRelativeEntity = undefined, finalUpPosition = false }) {
		// If the camera isn't yet anywhere, there's nowhere to look.
		if (cameraEntity.getPosition().isNaN()) {
			return;
		}

		// Get the final forward vector.
		const forward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		focusEntity.getPositionRelativeToEntity(forward, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, cameraEntity);
		forward.normalize(forward);

		// Remove any other orientation modifying controllers.
		for (let i = 0; i < cameraEntity.getNumControllers(); i++) {
			if (cameraEntity.getController(i).hasModifiedState('orientation')) {
				cameraEntity.removeController(i);
				i--;
			}
		}

		// Add and setup the align controller.
		const alignController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.AlignController);
		alignController.setPrimaryAlignType('point');
		alignController.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxis);
		alignController.setPrimaryTargetEntity(focusEntity.getName());
		if (finalUp !== undefined) {
			if (finalUpRelativeEntity === undefined) {
				finalUpRelativeEntity = focusEntity;
			}
			if (finalUpPosition) {
				alignController.setSecondaryAlignType('position');
				alignController.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
				alignController.setSecondaryTargetEntity(finalUpRelativeEntity.getName());
			}
			else {
				alignController.setSecondaryAlignType('align');
				alignController.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis);
				alignController.setSecondaryTargetEntity(finalUpRelativeEntity.getName());
				alignController.setSecondaryTargetAxis(finalUp);
			}
		}

		// Add and setup the transition controller.
		const transitionController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.TransitionController);
		transitionController.setTransitionTime(duration);
		await transitionController.getEndPromise();
	}

	/**
	 * Makes the camera go to an object.
	 * @param {Pioneer.Entity} cameraEntity - the camera entity
	 * @param {Pioneer.Entity} focusEntity - the entity that the camera will orbit around, starting on the sunny side
	 * @param {Object} options - the options used to setup the camera
	 * @param {boolean} [options.up = true] - align the entity to either the north pole of the entity or if it is an orbiter, the position of the orbiter.
	 * @param {boolean} [options.orbiter = false] - if true, the camera's up will be the away from the focus entity's parent.
	 * @param {boolean} [options.fixedToParent = false] - if true, the camera will be fixed to the parent and will not drift if the parent rotates.
	 * @param {number} [options.duration = 0.5] - seconds to do the transition
	 * @param {number} [options.distance] - how far away from the focus entity the camera should be (default is 5 times focusEntity's radius)
	 * @param {boolean} [options.zoom = true] - if true, sets a zoom controller
	 * @param {Pioneer.Vector3} [options.destination] - the location relative to the focus entity to transition to; if undefined it goes to the nearest spot from the camera's current position; this overrides distance
	 * @param {Pioneer.Vector3} [options.destinationUp] - the up direction that the camera will transition to; if undefined it will use the current up of the camera projected into the forward plane
	 * @param {boolean} [options.destinationInFocusFrame = false] - if true, the destination and destinationUp are in the orientation frame of the focus entity
	 * @param {TransitionFunction} [options.transitionFunction] - a manual transition function to use
	 * @returns {Promise<void>}
	 */
	static async goToEntity(cameraEntity, focusEntity, { up = true, orbiter = false, fixedToParent = false, duration = 1.0, distance = undefined, zoom = true, destination = undefined, destinationUp = undefined, destinationInFocusFrame = false, transitionFunction = undefined }) {
		if (!distance) {
			distance = focusEntity.getExtentsRadius() * 5.0;
		}

		// If the camera isn't yet anywhere, set it to a nice location.
		if (cameraEntity.getPosition().isNaN() || cameraEntity.getOrientation().isNaN()) {
			cameraEntity.setParent(focusEntity);
			if (destination === undefined) {
				cameraEntity.setPosition(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, -distance, 0));
			}
			else {
				cameraEntity.setPosition(destination);
			}
			cameraEntity.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
			duration = 0;
		}

		// Get the destination position for the end of the transition if there was none set.
		if (destination === undefined) {
			destination = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			cameraEntity.getPositionRelativeToEntity(destination, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, focusEntity);
			destination.normalize(destination);
			destination.mult(destination, distance);
			if (destination.isNaN()) {
				destination.set(0, -distance, 0);
			}
		}

		// Set the destination position for the end of the transition.
		cameraEntity.clearControllers();
		const fixedController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.FixedController);
		fixedController.setPosition(destination);

		// Set the destination orientation for the end of the transition.
		if (destinationUp !== undefined) {
			const destinationForward = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			const destUp = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
			destinationForward.neg(destination);
			destinationForward.normalize(destinationForward);
			destUp.setNormalTo(destinationForward, destinationUp);
			const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
			orientation.setFromAxes(undefined, destinationForward, destUp);
			fixedController.setOrientation(orientation);
		}

		if (destinationInFocusFrame) {
			const rotateByEntityOrientationController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.RotateByEntityOrientationController);
			if (destinationUp === undefined) {
				rotateByEntityOrientationController.setRotatingOrientation(false);
			}
		}

		this.focusOnEntity(cameraEntity, focusEntity, { up, orbiter });

		// Setup the transition.
		const transitionController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.TransitionController);
		transitionController.setTransitionTime(duration);
		transitionController.setParent(focusEntity.getName());
		if (transitionFunction) {
			transitionController.setTransitionFunction(transitionFunction);
		}
		await transitionController.getEndPromise();

		cameraEntity.clearControllers();
		const orbitController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitController);
		if (up) {
			if (orbiter) {
				orbitController.setYawAxisType('position');
			}
			else {
				orbitController.setYawAxisType('z-axis');
			}
		}
		else {
			cameraEntity.addController('roll');
		}

		if (fixedToParent) {
			cameraEntity.addController('fixedToParent');
		}

		if (zoom) {
			cameraEntity.addController('zoom');
		}

		this.focusOnEntity(cameraEntity, focusEntity, { up, orbiter });
	}

	/**
	 * Adds pick controller that calls the callback with the XYZ (ECEF) and the LatLonAlt of the location picked on the entity.
	 * @param {Pioneer.Entity} cameraEntity
	 * @param {Pioneer.Entity} pickedEntity
	 * @param {(xyz: Pioneer.Vector3, lla: Pioneer.LatLonAlt) => void} callback
	 */
	static pickOnEntity(cameraEntity, pickedEntity, callback) {
		const pickController = cameraEntity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.PickController);
		pickController.setPickedEntity(pickedEntity);
		pickController.setCallback((position) => {
			const spheroidComponent = pickedEntity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent);
			if (spheroidComponent !== null) {
				const positionInSpheroidFrame = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				positionInSpheroidFrame.rotateInverse(pickedEntity.getOrientation(), position);
				const lla = pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
				spheroidComponent.llaFromXYZ(lla, positionInSpheroidFrame);
				callback(positionInSpheroidFrame, lla);
				pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
				pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionInSpheroidFrame);
			}
		});
	}

	/**
	 * Gets the distance that the camera entity should be so that all of the entities are in view.
	 * @param {Pioneer.Entity} cameraEntity - the camera entity
	 * @param {Pioneer.Quaternion} cameraOrientation - the orientation that the camera will have, assuming it will be centered on the focus entity
	 * @param {Pioneer.Entity} focusEntity - the entity that the child will be a child of and pointed at
	 * @param {Pioneer.Entity[]} entities - the list of entities to keep in view
	 * @returns {number}
	 */
	static getDistanceToFitEntities(cameraEntity, cameraOrientation, focusEntity, entities) {
		const cameraComponent = cameraEntity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CameraComponent);
		if (cameraComponent === null) {
			return NaN;
		}

		let distance = 0;
		const positionOfEntity = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const sinHalfHorizontalFov = Math.sin(cameraComponent.getHorizontalFieldOfView() / 2.0);
		const sinHalfVerticalFov = Math.sin(cameraComponent.getVerticalFieldOfView() / 2.0);
		const tanHalfHorizontalFov = Math.tan(cameraComponent.getHorizontalFieldOfView() / 2.0);
		const tanHalfVerticalFov = Math.tan(cameraComponent.getVerticalFieldOfView() / 2.0);

		for (let i = 0; i < entities.length; i++) {
			const entity = entities[i];
			let ringsRadius = 0;
			const ringsComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.RingsComponent);
			if (ringsComponent !== null) {
				ringsRadius = ringsComponent.getOuterRadius();
			}

			// Get the position of the entity in the camera's rotated frame.
			entity.getPositionRelativeToEntity(positionOfEntity, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, focusEntity);
			positionOfEntity.rotateInverse(cameraOrientation, positionOfEntity);

			// Get the distances for the horizontal and vertical fovs.
			distance = Math.max(distance, Math.abs(positionOfEntity.x) / tanHalfHorizontalFov + Math.max(entity.getExtentsRadius(), ringsRadius) / sinHalfHorizontalFov - positionOfEntity.y);
			distance = Math.max(distance, Math.abs(positionOfEntity.z) / tanHalfVerticalFov + Math.max(entity.getExtentsRadius(), ringsRadius) / sinHalfVerticalFov - positionOfEntity.y);
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(positionOfEntity);
		return distance;
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/components/annulus_component.js":
/*!**************************************************************!*\
  !*** ../pioneer/scripts/src/components/annulus_component.js ***!
  \**************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AnnulusComponent": function() { return /* binding */ AnnulusComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * A component that renders a colored disc in the x-y plane with an inner and outer radius.
 */
class AnnulusComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The inner-radius of the circular-shaped plane.
		 * @type {number}
		 * @private
		 */
		this._sizeInner = 1;

		/**
		 * The outer-radius of the circular-shaped plane.
		 * @type {number}
		 * @private
		 */
		this._sizeOuter = 1;

		/**
		 * A flag the determines whether or not the plane ignores the distance when determining visibility.
		 * @type {boolean}
		 * @private
		 */
		this._ignoreDistance = false;

		/**
		 * The calculated transition slope at which the plane will fade out. This is calculated based on the value provided to setMinDistance.
		 * @type {number}
		 * @private
		 */
		this._minDistanceM = 0.0;

		/**
		 * The calculated transition offset at which the plane will fade out. This is calculated based on the value provided to setMinDistance.
		 * @type {number}
		 * @private
		 */
		this._minDistanceB = 0.0;

		/**
		 * The calculated transition slope at which the plane will fade out. This is calculated based on the value provided to setMaxDistance.
		 * @type {number}
		 * @private
		 */
		this._maxDistanceM = 0.0;

		/**
		 * The calculated transition offset at which the plane will fade out. This is calculated based on the value provided to setMaxDistance.
		 * @type {number}
		 * @private
		 */
		this._maxDistanceB = 0.0;

		/**
		 * The color of the annulus.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The alpha multiplier determined by fading.
		 * @type {number}
		 * @private
		 */
		this._alphaMultiplier = 1.0;

		/**
		 * The number of points on the circle.
		 * @type {number}
		 * @private
		 */
		this._numPointsOnCircle = 200;

		/**
		 * True if the mesh needs to be updated.
		 * @type {boolean}
		 * @private
		 */
		this._meshDirty = true;

		this.__setRadius(this._sizeOuter);
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the size of the inner radius. Defaults to 1.
	 * @returns {number}
	 */
	getInnerRadius() {
		return this._sizeInner;
	}

	/**
	 * Sets the size of the inner radius.
	 * @param {number} size
	 */
	setInnerRadius(size) {
		this._sizeInner = size;
		this._meshDirty = true;
	}

	/**
	 * Gets the size of the outer radius.
	 * @returns {number}
	 */
	getOuterRadius() {
		return this._sizeOuter;
	}

	/**
	 * Sets the size of the outer radius
	 * @param {number} size
	 */
	setOuterRadius(size) {
		this._sizeOuter = size;
		this._meshDirty = true;
		this.__setRadius(size);
	}

	/**
	 * Sets the component to either consider the distance (false) or ignore the distance (true).
	 * @param {boolean} ignoreDistance
	 */
	setIgnoreDistance(ignoreDistance) {
		this._ignoreDistance = ignoreDistance;
		this._alphaMultiplier = 1.0;
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
	}

	/**
	 * Sets the minimum distance at which the component should be fully visible.
	 * @param {number} distance
	 */
	setMinDistance(distance) {
		this._minDistanceM = 1.0 / (distance - distance / 1.1);
		this._minDistanceB = -1.0 * this._minDistanceM * distance / 1.1;
	}

	/**
	 * Sets the maximum distance at which the component should be fully visible.
	 * @param {number} distance
	 */
	setMaxDistance(distance) {
		this._maxDistanceM = -1.0 / (distance * 1.1 - distance);
		this._maxDistanceB = -1.0 * this._maxDistanceM * distance * 1.1;
	}

	/**
	 * Gets the color of the annulus. Defaults to white.
	 * @returns {Pioneer.Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the annulus. The alpha value should be provided at the component's maximum visibility.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		// Set the orientation to the entity's orientation.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());

		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);

		if (this._meshDirty) {
			this._updateMesh();
		}

		if (!this._ignoreDistance) {
			const cameraSpacePosition = this.getEntity().getCameraSpacePosition(camera);
			const distanceToObject = cameraSpacePosition.magnitude();
			const minimumDistanceTransition = this._minDistanceM * distanceToObject + this._minDistanceB;
			const maximumDistanceTransition = this._maxDistanceM * distanceToObject + this._maxDistanceB;
			this._alphaMultiplier = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(Math.min(minimumDistanceTransition, maximumDistanceTransition));
			pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
		}
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		// Create the material.
		const material = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('basic_alpha');
		this.getThreeJsMaterials().push(material);
		// Set the properties.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(material, 'color', this._color, this._alphaMultiplier);
		// Create the mesh object.
		const object = pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [{ name: 'position', dimensions: 3 }], false);
		this.getThreeJsObjects().push(object);
		// Return it as loaded.
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyObject(this.getThreeJsObjects()[0]);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyMaterial(this.getThreeJsMaterials()[0]);
	}

	/**
	 * Updates the mesh.
	 * @private
	 */
	_updateMesh() {
		const positions = new Float32Array(this._numPointsOnCircle * 4 * 3);
		const indices = new Uint16Array(this._numPointsOnCircle * 6);

		// Make the concentric circles.
		let positionsIndex = 0;
		let indicesIndex = 0;
		const position0 = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const position1 = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		const circleSize = this._sizeOuter;
		const circleInnerRatio = this._sizeInner / this._sizeOuter;

		for (let j = 0; j < this._numPointsOnCircle; j++) {
			const angle1 = j / this._numPointsOnCircle * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
			const angle2 = ((j + 1) % this._numPointsOnCircle) / this._numPointsOnCircle * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;

			position0.set(circleSize * Math.cos(angle1), circleSize * Math.sin(angle1), 0);
			position1.set(circleSize * Math.cos(angle2), circleSize * Math.sin(angle2), 0);

			positions[positionsIndex + 0] = position0.x * circleInnerRatio;	// XYZ set for origin (inner)
			positions[positionsIndex + 1] = position0.y * circleInnerRatio;
			positions[positionsIndex + 2] = position0.z * circleInnerRatio;

			positions[positionsIndex + 3] = position0.x;
			positions[positionsIndex + 4] = position0.y;
			positions[positionsIndex + 5] = position0.z; // CW Edge (left)

			positions[positionsIndex + 6] = position1.x;
			positions[positionsIndex + 7] = position1.y;
			positions[positionsIndex + 8] = position1.z; // CCW Edge (right)

			positions[positionsIndex + 9] = position1.x * circleInnerRatio;
			positions[positionsIndex + 10] = position1.y * circleInnerRatio;
			positions[positionsIndex + 11] = position1.z * circleInnerRatio; // CCW Edge (Inner)

			indices[indicesIndex + 0] = positionsIndex / 3 + 0;
			indices[indicesIndex + 1] = positionsIndex / 3 + 1;
			indices[indicesIndex + 2] = positionsIndex / 3 + 2;
			indices[indicesIndex + 3] = positionsIndex / 3 + 2;
			indices[indicesIndex + 4] = positionsIndex / 3 + 3;
			indices[indicesIndex + 5] = positionsIndex / 3 + 0;

			positionsIndex += 12;
			indicesIndex += 6;
		}
		const geometry = /** @type {Pioneer.THREE.Mesh} */(this.getThreeJsObjects()[0]).geometry;
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(geometry, 'position', positions);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(geometry, indices);
		this._meshDirty = false;
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/components/celestial_grid_component.js":
/*!*********************************************************************!*\
  !*** ../pioneer/scripts/src/components/celestial_grid_component.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "CelestialGridComponent": function() { return /* binding */ CelestialGridComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * The Celestial Grid component.
 * */
class CelestialGridComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The number of degrees per line.
		 * @type {number}
		 * @private
		 */
		this._degreesPerLine = 10;

		/**
		 * The color of the grid.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The LineMesh object used to do the drawing.
		 * @type {Pioneer.LineMesh}
		 * @private
		 */
		this._lineMesh = null;

		/**
		 * True if the mesh needs to be updated.
		 * @type {boolean}
		 * @private
		 */
		this._meshDirty = true;
	}

	/**
	 * Sets the radius of the grid.
	 * @param {number} radius
	 */
	setRadius(radius) {
		this.__setRadius(radius);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(this.getThreeJsObjects(), this.getRadius());
	}

	/**
	 * Gets the color of the grid. Defaults to white.
	 * @returns {Pioneer.Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the grid.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		this._meshDirty = true;
	}

	/**
	 * Gets the number of degrees per line. Defaults to 10.
	 * @returns {number}
	 */
	getDegreesPerLine() {
		return this._degreesPerLine;
	}

	/**
	 * Sets the number of degrees per line.
	 * @param {number} degreesPerLine
	 */
	setDegreesPerLine(degreesPerLine) {
		this._degreesPerLine = degreesPerLine;
		this._meshDirty = true;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		if (this._meshDirty) {
			this._updateMesh();
		}

		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), camera);

		// Call the line mesh prepare for render.
		this._lineMesh.prepareForRender(camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		this._lineMesh = new pioneer__WEBPACK_IMPORTED_MODULE_0__.LineMesh(this);
		this._updateMesh();

		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}

	/**
	 * Updates the mesh positions and colors.
	 * @private
	 */
	_updateMesh() {
		const positions = [];
		for (let lon0 = 0; lon0 < 360; lon0 += this._degreesPerLine) {
			const lon1 = Math.min(lon0 + this._degreesPerLine, 360);
			const lon0Rad = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(lon0);
			const lon1Rad = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(lon1);
			for (let lat0 = -90; lat0 < 90; lat0 += this._degreesPerLine) {
				const lat1 = Math.min(lat0 + this._degreesPerLine, 90);
				const lat0Rad = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(lat0);
				const lat1Rad = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(lat1);
				// Make a horizontal line.
				if (-90 < lat0 && lat0 < 90) {
					positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(lon0Rad) * Math.cos(lat0Rad), Math.cos(lon0Rad) * Math.cos(lat0Rad), Math.sin(lat0Rad)));
					positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(lon1Rad) * Math.cos(lat0Rad), Math.cos(lon1Rad) * Math.cos(lat0Rad), Math.sin(lat0Rad)));
				}
				// Make a vertical line.
				positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(lon0Rad) * Math.cos(lat0Rad), Math.cos(lon0Rad) * Math.cos(lat0Rad), Math.sin(lat0Rad)));
				positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.sin(lon0Rad) * Math.cos(lat1Rad), Math.cos(lon0Rad) * Math.cos(lat1Rad), Math.sin(lat1Rad)));
			}
		}
		const colors = [];
		for (let i = 0, l = positions.length; i < l; i++) {
			colors.push(this._color);
		}
		const widths = [];
		for (let i = 0, l = positions.length; i < l; i++) {
			widths.push(2);
		}
		this._lineMesh.setPositions(positions);
		this._lineMesh.setColors(colors);
		this._lineMesh.setWidths(widths);

		// Set the Three.js object orientation to the identity.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);

		// Set the Three.js object scale to be the radius of the component.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setScale(this.getThreeJsObjects(), this.getRadius());

		this._meshDirty = false;
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/components/constellations_component.js":
/*!*********************************************************************!*\
  !*** ../pioneer/scripts/src/components/constellations_component.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ConstellationsComponent": function() { return /* binding */ ConstellationsComponent; }
/* harmony export */ });
/* harmony import */ var _scene_helpers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scene_helpers */ "../pioneer/scripts/src/scene_helpers.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



/**
 * Constellations.
 */
class ConstellationsComponent extends pioneer__WEBPACK_IMPORTED_MODULE_1__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The url used for the database.
		 * @type {string}
		 * @private
		 */
		this._url = '';

		/**
		 * The database. They match the ordering of the labelEntities.
		 * @type {DatabaseEntry[]}
		 */
		this._database = [];

		/**
		 * The number of vertices in each line mesh.
		 * @type {number[]}
		 * @private
		 */
		this._numVertices = [];

		/**
		 * The label entities.
		 * @type {Pioneer.Entity[]}
		 * @private
		 */
		this._labelEntities = [];

		/**
		 * The color of the lines.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color();

		/**
		 * The width of the lines.
		 * @type {number}
		 * @private
		 */
		this._lineWidth = 2;

		/**
		 * The glow width for the lines.
		 * @type {number}
		 * @private
		 */
		this._glowWidth = 0;

		/**
		 * The index of the constellation to be highlighted.
		 * @type {number | undefined}
		 * @private
		 */
		this._highlightedIndex = undefined;

		/**
		 * The color of the highlight.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._highlightColor = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color();

		/**
		 * The width of of the highlight lines.
		 * @type {number}
		 * @private
		 */
		this._highlightWidth = 0;

		/**
		 * The line meshes.
		 * @type {Pioneer.LineMesh[]}
		 * @private
		 */
		this._lineMeshes = [];

		// Set the radius to infinite, since it extends to all of the stars in the constellations.
		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Sets the color of the lines.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.copy(color);

		// Set the color for every line mesh.
		for (let i = 0; i < this._lineMeshes.length; i++) {
			const colors = [];
			for (let j = 0; j < this._numVertices[i]; j++) {
				colors.push(this._color);
			}
			this._lineMeshes[i].setColors(colors);
		}
	}

	/**
	 * Sets the width of the lines.
	 * @param {number} lineWidth
	 */
	setLineWidth(lineWidth) {
		this._lineWidth = lineWidth;

		// Set the width of the line meshes.
		for (let i = 0; i < this._lineMeshes.length; i++) {
			this._lineMeshes[i].setWidths(lineWidth);
		}
	}

	/**
	 * Sets the glow for the lines.
	 * @param {number} glowWidth
	 */
	setGlowWidth(glowWidth) {
		this._glowWidth = glowWidth;
		for (let i = 0, l = this._lineMeshes.length; i < l; i++) {
			this._lineMeshes[i].setGlowWidth(this._glowWidth);
		}
	}

	/**
	 * Sets the database.
	 * @param {string} url
	 */
	setUrl(url) {
		this._url = url;
		this.resetResources();
	}

	/**
	 * Generates and returns a list of the constellation names. Each label entity is named "constellation_label_<name>".
	 * @returns {string[]}
	 */
	getNames() {
		const names = [];
		for (let i = 0, l = this._database.length; i < l; i++) {
			names.push(this._database[i].name);
		}
		return names;
	}

	/**
	 * Sets the contellation at the index to be highlighted. Use undefined for the index to clear the highlighting.
	 * @param {number | undefined} hightlightedIndex
	 * @param {Pioneer.Color} highlightColor
	 * @param {number} highlightWidth
	 */
	setHighlight(hightlightedIndex, highlightColor, highlightWidth) {
		// Unhighlight the previous lineMesh.
		if (this._lineMeshes.length > 0 && this._highlightedIndex !== undefined) {
			const colors = [];
			for (let i = 0, l = this._numVertices[this._highlightedIndex]; i < l; i++) {
				colors.push(this._color);
			}
			this._lineMeshes[this._highlightedIndex].setColors(colors);
			this._lineMeshes[this._highlightedIndex].setWidths(this._lineWidth);
		}

		// Set the highlight vars.
		this._highlightedIndex = hightlightedIndex;
		this._highlightColor.copy(highlightColor);
		this._highlightWidth = highlightWidth;

		// Highlight the new lineMesh.
		if (this._lineMeshes.length > 0 && this._highlightedIndex !== undefined) {
			const colors = [];
			for (let i = 0, l = this._numVertices[this._highlightedIndex]; i < l; i++) {
				colors.push(this._highlightColor);
			}
			this._lineMeshes[this._highlightedIndex].setColors(colors);
			this._lineMeshes[this._highlightedIndex].setWidths(this._highlightWidth);
		}
	}

	/**
	 * Gets the index of the constellation nearest to the pixel-space position. If there is none, returns undefined
	 * @param {Pioneer.Vector2} pixelSpacePosition
	 * @param {Pioneer.CameraComponent} camera
	 */
	getNearestConstellationIndex(pixelSpacePosition, camera) {
		/** @type {number | undefined} */
		let nearestIndex;
		let nearestDistance = Number.POSITIVE_INFINITY;
		for (let i = 0, l = this._labelEntities.length; i < l; i++) {
			const dist = pixelSpacePosition.distance(this._labelEntities[i].getPixelSpacePosition(camera));
			if (dist < nearestDistance) {
				nearestDistance = dist;
				nearestIndex = i;
			}
		}
		return nearestIndex;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_1__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), camera);

		// Call the line meshes prepare for render.
		for (let i = 0; i < this._lineMeshes.length; i++) {
			this._lineMeshes[i].prepareForRender(camera);
		}
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		this._labelEntities = [];
		this._lineMeshes = [];
		this._numVertices = [];

		const result = await this.getEntity().getScene().getEngine().getDownloader().download(this._url, true);
		if (result.status === 'completed' && result.content instanceof ArrayBuffer) {
			const reader = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Reader(result.content);

			while (!reader.isAtEnd()) {
				const entry = /** @type {DatabaseEntry} */({
					name: '',
					stars: [],
					segments: [],
					color: []
				});

				entry.name = reader.readString(reader.readByte());

				entry.color = [
					reader.readByte(),
					reader.readByte(),
					reader.readByte(),
					reader.readByte()
				];

				const starCount = reader.readByte();
				for (let i = 0; i < starCount; i++) {
					entry.stars.push([
						reader.readFloat32(),
						reader.readFloat32(),
						reader.readFloat32()
					]);
				}

				const segmentCount = reader.readByte() * 2;
				for (let i = 0; i < segmentCount; i++) {
					entry.segments.push(reader.readByte());
				}

				this._database.push(entry);
			}
		}

		// Create the lines.
		for (let i = 0; i < this._database.length; i++) {
			const stars = this._database[i].stars;
			const segments = this._database[i].segments;
			const positions = [];
			const colors = [];
			const widths = [];

			for (let j = 0; j < segments.length; j++) {
				const starIndex = segments[j];
				positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(stars[starIndex][2], -stars[starIndex][0], stars[starIndex][1]));
				colors.push(i === this._highlightedIndex ? this._highlightColor : this._color);
				widths.push(i === this._highlightedIndex ? this._highlightWidth : this._lineWidth);
			}
			const lineMesh = new pioneer__WEBPACK_IMPORTED_MODULE_1__.LineMesh(this);
			lineMesh.setPositions(positions);
			lineMesh.setColors(colors);
			lineMesh.setWidths(widths);
			lineMesh.setGlowWidth(this._glowWidth);
			this._lineMeshes.push(lineMesh);
			this._numVertices.push(segments.length);
		}
		pioneer__WEBPACK_IMPORTED_MODULE_1__.ThreeJsHelper.setOrientation(this.getThreeJsObjects(), _scene_helpers__WEBPACK_IMPORTED_MODULE_0__.SceneHelpers.getEclipJ2000ToJ2000Rotation());

		// Create the labels as child entities with div components.
		for (let i = 0; i < this._database.length; i++) {
			const stars = this._database[i].stars;
			// Calculate the min and max bounds for the center.
			const minBounds = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY);
			const maxBounds = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY);
			const distance = Math.sqrt(stars[0][0] * stars[0][0] + stars[0][1] * stars[0][1] + stars[0][2] * stars[0][2]);
			for (let j = 0; j < stars.length; j++) {
				const star = stars[j];
				const position = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
				position.set(star[2], -star[0], star[1]);
				position.rotate(_scene_helpers__WEBPACK_IMPORTED_MODULE_0__.SceneHelpers.getEclipJ2000ToJ2000Rotation(), position);
				position.normalize(position);
				position.mult(position, distance);
				if (minBounds.x > position.x) {
					minBounds.x = position.x;
				}
				if (maxBounds.x < position.x) {
					maxBounds.x = position.x;
				}
				if (minBounds.y > position.y) {
					minBounds.y = position.y;
				}
				if (maxBounds.y < position.y) {
					maxBounds.y = position.y;
				}
				if (minBounds.z > position.z) {
					minBounds.z = position.z;
				}
				if (maxBounds.z < position.z) {
					maxBounds.z = position.z;
				}
			}
			// Get the center point of the constellation.
			const center = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3();
			center.add(minBounds, maxBounds);
			center.mult(center, 0.5);
			// Create a new entity that's a child of this entity at the center.
			const labelEntity = this.getEntity().getScene().addEntity('constellation_label_' + this._database[i].name);
			labelEntity.setParent(this.getEntity());
			labelEntity.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity);
			labelEntity.setPosition(center);
			// Add a div component to that entity with the name of the constellation.
			const divComponent = labelEntity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
			divComponent.setAlignment(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector2(0.5, 0.5));
			const div = divComponent.getDiv();
			div.classList.add('pioneer-constellation-label');
			div.innerHTML = this._database[i].name;
			// Add it to the list of label entities.
			this._labelEntities.push(labelEntity);
		}
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		// Clean up the label entities.
		for (let i = 0; i < this._labelEntities.length; i++) {
			this.getEntity().getScene().removeEntity(this._labelEntities[i]);
		}
		// Clean up the objects and materials created by the line meshes.
		pioneer__WEBPACK_IMPORTED_MODULE_1__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		// Make the line meshes null.
		this._lineMeshes = [];
		// Clear the database.
		this._database = [];
	}
}

/**
 * @typedef {object} DatabaseEntry
 * @property {string} name - the name of the constellation
 * @property {number[][]} stars - the list of star positions, each entry being a 3-array XYZ in J2000Eclipse coordinates.
 * @property {number[]} segments - the list of segments, each pair being a line, and each indexing an entry in the stars list.
 * @property {number[]} color - a 3-array of RGB values from 0 to 255.
 */


/***/ }),

/***/ "../pioneer/scripts/src/components/disc_grid_component.js":
/*!****************************************************************!*\
  !*** ../pioneer/scripts/src/components/disc_grid_component.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DiscGridComponent": function() { return /* binding */ DiscGridComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * A grid in the shape of a disc.
 */
class DiscGridComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The size of the grid.
		 * @type {number}
		 * @private
		 */
		this._size = 1;

		/**
		 * The color of the grid.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The width of the lines in pixels.
		 * @type {number}
		 * @private
		 */
		this._lineWidth = 1;

		/**
		 * The number of radial points to render.
		 * @type {number}
		 * @private
		 */
		this._numCircles = 10;

		/**
		 * The number of circular points to render.
		 * @type {number}
		 * @private
		 */
		this._numSpokes = 20;

		/**
		 * The power that each concentric circle radius is raised to.
		 * @type {number}
		 * @private
		 */
		this._radialPower = 1;

		/**
		 * A flag the determines whether or not the grid ignores the distance when determining visibility.
		 * @type {boolean}
		 * @private
		 */
		this._ignoreDistance = false;

		/**
		 * The LineMesh object used to do the drawing.
		 * @type {Pioneer.LineMesh}
		 * @private
		 */
		this._lineMesh = null;

		/**
		 * True if the mesh needs to be updated.
		 * @type {boolean}
		 * @private
		 */
		this._meshDirty = true;

		// Set the initial size.
		this.__setRadius(this._size);

		// It uses the entity's orientation.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the size of the grid. Defaults to 1.
	 * @returns {number}
	 */
	getSize() {
		return this._size;
	}

	/**
	 * Sets the size of the grid.
	 * @param {number} size
	 */
	setSize(size) {
		this._size = size;
		this.__setRadius(this._size);
		if (this._lineMesh !== null) {
			this._lineMesh.setScale(this._size);
		}
	}

	/**
	 * Gets the color of the grid. Defaults to white.
	 * @returns {Pioneer.Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the grid.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		this._meshDirty = true;
	}

	/**
	 * Gets the width of the lines in pixels.
	 * @returns {number}
	 */
	getLineWidth() {
		return this._lineWidth;
	}

	/**
	 * Sets the width of the lines in pixels. Defaults to 1.
	 * @param {number} lineWidth
	 */
	setLineWidth(lineWidth) {
		this._lineWidth = lineWidth;
		if (this._lineMesh !== null) {
			this._lineMesh.setWidths(this._lineWidth);
		}
	}

	/**
	 * Gets the number of concentric circles to place. Defaults to 10.
	 * @returns {number}
	 */
	getNumCircles() {
		return this._numCircles;
	}

	/**
	 * Sets the number of concentric circles to place.
	 * @param {number} numCircles
	 */
	setNumCircles(numCircles) {
		this._numCircles = numCircles;
		this._meshDirty = true;
	}

	/**
	 * Gets the number of spokes to place. Defaults to 50.
	 * @returns {number}
	 */
	getNumSpokes() {
		return this._numSpokes;
	}

	/**
	 * Sets the number of spokes to place.
	 * @param {number} numSpokes
	 */
	setNumSpokes(numSpokes) {
		this._numSpokes = numSpokes;
		this._meshDirty = true;
	}

	/**
	 * Gets the power that each concentric circle is raised to compared to the next inner circle. Defaults to 1.
	 * @returns {number}
	 */
	getRadialPower() {
		return this._radialPower;
	}

	/**
	 * Sets the power that each concentric circle is raised to compared to the next inner circle.
	 * @param {number} radialPower
	 */
	setRadialPower(radialPower) {
		this._radialPower = radialPower;
		this._meshDirty = true;
	}

	/**
	 * Ignores the distance when determining whether it should show the grid or not. Defaults to false.
	 * @param {boolean} ignoreDistance
	 */
	setIgnoreDistance(ignoreDistance) {
		this._ignoreDistance = ignoreDistance;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		if (this._meshDirty) {
			this._updateMesh();
		}

		if (!this._ignoreDistance) {
			const normalizedSizeOfEntity = this.getEntity().getNormalSpaceExtentsRadius(camera);
			const alphaMultiplier = (0.02 - normalizedSizeOfEntity) / 0.02;
			this._lineMesh.setAlphaMultiplier(alphaMultiplier);
		}

		this._lineMesh.prepareForRender(camera);

		// Set the orientation to the entity's orientation.
		for (let i = 0, l = this.getThreeJsObjects().length; i < l; i++) {
			pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[i], this.getEntity());

			// Set the Three.js object position the entity's camera-space position.
			pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[i], this.getEntity(), camera);
		}
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		// Create the line mesh.
		this._lineMesh = new pioneer__WEBPACK_IMPORTED_MODULE_0__.LineMesh(this);

		// Update the vertices.
		this._updateMesh();

		// Set the scale.
		this._lineMesh.setScale(this._size);

		// Resolve immediately.
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}

	/**
	 * Updates the mesh.
	 * @private
	 */
	_updateMesh() {
		// Make the concentric circles.
		const positions = [];
		for (let i = 1; i <= this._numCircles; i++) {
			const circleSize = this._radialPower !== 1 ? Math.pow(this._radialPower, i - this._numCircles) : (i / this._numCircles);
			const numOfPointsOnCircle = 50;
			for (let j = 0; j < numOfPointsOnCircle; j++) {
				const angle1 = j / numOfPointsOnCircle * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
				const angle2 = ((j + 1) % numOfPointsOnCircle) / numOfPointsOnCircle * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
				positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(circleSize * Math.cos(angle1), circleSize * Math.sin(angle1), 0));
				positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(circleSize * Math.cos(angle2), circleSize * Math.sin(angle2), 0));
			}
		}
		for (let i = 0; i < this._numSpokes; i++) {
			const angle1 = i / this._numSpokes * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
			positions.push(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero);
			positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(Math.cos(angle1), Math.sin(angle1), 0));
		}
		const colors = [];
		for (let i = 0, l = positions.length; i < l; i++) {
			colors.push(this._color);
		}
		this._lineMesh.setPositions(positions);
		this._lineMesh.setColors(colors);
		this._lineMesh.setWidths(this._lineWidth);
		this._meshDirty = false;
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/components/orbit_line_component.js":
/*!*****************************************************************!*\
  !*** ../pioneer/scripts/src/components/orbit_line_component.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "OrbitLineComponent": function() { return /* binding */ OrbitLineComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * The Orbit Line component.
 * */
class OrbitLineComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The color of the line.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The alpha fade on the far side of the orbit.
		 * @type {number}
		 * @private
		 */
		this._farSideAlphaFade = 1;

		/**
		 * The width of the line.
		 * @type {number}
		 * @private
		 */
		this._lineWidth = 5;

		/**
		 * The glow width for the lines.
		 * @type {number}
		 * @private
		 */
		this._glowWidth = 0;

		/**
		 * The LineMesh object used to do the drawing.
		 * @type {Pioneer.LineMesh}
		 * @private
		 */
		this._lineMesh = null;

		/**
		 * The positions for the line mesh.
		 * @type {Pioneer.Vector3[]}
		 * @private
		 */
		this._positions = [];

		/**
		 * The colors for the line mesh.
		 * @type {Pioneer.Color[]}
		 * @private
		 */
		this._colors = [];

		/**
		 * The widths for the line mesh.
		 * @type {number[]}
		 * @private
		 */
		this._widths = [];

		/**
		 * An array that determines the pixel-space radii at which it has 0 and 1 alpha.
		 * @type {[number, number]}
		 * @private
		 */
		this._pixelSpaceRadiiAlphaFade = [5, 1];

		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Gets the color of the grid. Defaults to white.
	 * @returns {Pioneer.Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the grid. Defaults to white.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		if (this._lineMesh !== null) {
			for (let i = 0, l = this._colors.length; i < l; i++) {
				this._colors[i].copy(this._color);
			}
			this._lineMesh.setColors(this._colors);
		}
	}

	/**
	 * Gets the alpha fade on the far side of the orbit.
	 * @returns {number}
	 */
	getFarSideAlphaFade() {
		return this._farSideAlphaFade;
	}

	/**
	 * Sets the alpha fade on the far side of the orbit. Defaults to 1.
	 * @param {number} alphaFade
	 */
	setFarSideAlphaFade(alphaFade) {
		this._farSideAlphaFade = alphaFade;
	}

	/**
	 * Gets the width of the line.
	 * @returns {number}
	 */
	getLineWidth() {
		return this._lineWidth;
	}

	/**
	 * Sets the width of the line. Defaults to 5.
	 * @param {number} lineWidth
	 */
	setLineWidth(lineWidth) {
		this._lineWidth = lineWidth;
		if (this._lineMesh !== null) {
			for (let i = 0, l = this._widths.length; i < l; i++) {
				this._widths[i] = this._lineWidth;
			}
			this._lineMesh.setWidths(this._widths);
		}
	}

	/**
	 * Sets the glow for the lines.
	 * @param {number} glowWidth
	 */
	setGlowWidth(glowWidth) {
		this._glowWidth = glowWidth;
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformNumber(this.getThreeJsMaterials()[0], 'glowWidth', this._glowWidth);
	}

	/**
	 * Sets values that determine the pixel-space radii at which it has 0 and 1 alpha. Defaults to 5, 1.
	 * @param {number} radiusFor0Alpha
	 * @param {number} radiusFor1Alpha
	 */
	setPixelSpaceRadiiAlphaFade(radiusFor0Alpha, radiusFor1Alpha) {
		this._pixelSpaceRadiiAlphaFade[0] = radiusFor0Alpha;
		this._pixelSpaceRadiiAlphaFade[1] = radiusFor1Alpha;
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {

		// Update the mesh.
		this._updateMesh();

		// Update the pixel-space radius alpha fade.
		const pixelSpaceRadius = this.getEntity().getPixelSpaceExtentsRadius(camera);
		if (!isNaN(pixelSpaceRadius)) {
			const fadeU = (pixelSpaceRadius - this._pixelSpaceRadiiAlphaFade[0]) / (this._pixelSpaceRadiiAlphaFade[1] - this._pixelSpaceRadiiAlphaFade[0]);
			this._lineMesh.setAlphaMultiplier(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(0, 1, pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(fadeU)));
		}
		else {
			this._lineMesh.setAlphaMultiplier(1);
		}

		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), camera);

		// Call the line mesh prepare for render.
		this._lineMesh.prepareForRender(camera);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		this._lineMesh = new pioneer__WEBPACK_IMPORTED_MODULE_0__.LineMesh(this);

		// Setup the arrays for the line mesh.
		for (let i = 0, l = 360 * 2; i < l; i++) {
			this._positions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3());
			this._colors.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color());
			this._colors[i].copy(this._color);
			this._widths.push(this._lineWidth);
		}

		// Set the widths and colors for the line mesh.
		this._lineMesh.setColors(this._colors);
		this._lineMesh.setWidths(this._widths);
		this._lineMesh.setGlowWidth(this._glowWidth);

		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		// Clean up the arrays for the line mesh.
		this._positions = [];
		this._colors = [];
		this._widths = [];

		// Clean up the objects and line mesh.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
		this._lineMesh = null;
	}

	/**
	 * Updates the mesh positions and colors.
	 * @private
	 */
	_updateMesh() {
		// Find the GM from the last covered dynamo orb controller.
		const entity = this.getEntity();
		const currentTime = entity.getScene().getEngine().getTime();
		let gm = 0;
		for (let i = entity.getNumControllers() - 1; i >= 0; i--) {
			const controller = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.DynamoController, i);
			if (controller !== null && controller.getCoverage().contains(currentTime)) {
				if (controller.getPointType() === 'orb') {
					gm = controller.getHeaderValue('gravitationalParameter1') + controller.getHeaderValue('gravitationalParameter2');
					break;
				}
			}
		}

		// Get the orbital elements from the current position and velocity.
		orbitalElements.setFromPositionAndVelocity(entity.getPosition(), entity.getVelocity(), currentTime, gm);

		// Get the true and eccentric anomaly of the current position, used for the alpha fade.
		const entityPosition = entity.getPosition();
		const trueAnomalyAtCurrentTime = orbitalElements.getTrueAnomalyFromPosition(entityPosition);
		const eccentricAnomalyAtCurrentTime = orbitalElements.getEccentricAnomalyFromTrueAnomaly(trueAnomalyAtCurrentTime);

		// Calculate the new positions and colors.
		let lastMeanAnomalyNaN = false;
		for (let angle = 0; angle < 360; angle += 1) {
			// The indices for the vertices.
			const index0 = angle * 2;
			const index1 = (angle * 2 - 1 + this._positions.length) % this._positions.length;

			// Calculate the position given the angle, which is the true anomaly.
			let eccentricAnomaly = orbitalElements.getEccentricAnomalyFromTrueAnomaly(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(angle - 180));
			const eccentricAnomalyNext = orbitalElements.getEccentricAnomalyFromTrueAnomaly(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(angle + 1 - 180));
			if ((eccentricAnomaly < eccentricAnomalyAtCurrentTime && eccentricAnomalyAtCurrentTime < eccentricAnomalyNext)
				|| (eccentricAnomalyNext < eccentricAnomalyAtCurrentTime && eccentricAnomalyAtCurrentTime < eccentricAnomaly)) {
				eccentricAnomaly = eccentricAnomalyAtCurrentTime;
			}
			const meanAnomaly = orbitalElements.getMeanAnomalyFromEccentricAnomaly(eccentricAnomaly);
			const time = orbitalElements.epoch + (meanAnomaly - orbitalElements.meanAnomalyAtEpoch) / orbitalElements.meanAngularMotion;
			const position = this._positions[index0];
			orbitalElements.project(position, velocity, time);
			position.sub(position, entityPosition);
			this._positions[index1].copy(position);

			// If the mean anomaly is NaN, disconnect the segments around it.
			if (isNaN(meanAnomaly)) {
				lastMeanAnomalyNaN = true;
				const index2 = (index0 + 1) % this._positions.length;
				const index3 = (index1 - 1 + this._positions.length) % this._positions.length;
				this._positions[index0].set(0, 0, 0);
				this._positions[index1].set(0, 0, 0);
				this._positions[index2].set(0, 0, 0);
				this._positions[index3].set(0, 0, 0);
				this._colors[index0].a = 0;
				this._colors[index1].a = 0;
				this._colors[index2].a = 0;
				this._colors[index3].a = 0;
				continue;
			}

			// Get the alpha fade based on the current true anomaly of the entity.
			let alphaFadeU = 0.0;
			alphaFadeU = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.angle(eccentricAnomaly, eccentricAnomalyAtCurrentTime) / Math.PI;
			alphaFadeU = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp01(alphaFadeU);
			const alphaFade = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(1.0, this._farSideAlphaFade, alphaFadeU);
			this._colors[index0].mult(this._color, alphaFade);
			if (!lastMeanAnomalyNaN) {
				this._colors[index1].mult(this._color, alphaFade);
			}

			// It got here, so mark the last mean anomaly as valid.
			lastMeanAnomalyNaN = false;
		}

		// If we're at the end of the loop and the eccentricity is para/hyperbolic, disconnect the loop.
		if (orbitalElements.eccentricity >= 1) {
			this._positions[this._positions.length - 2].copy(this._positions[this._positions.length - 3]);
			this._positions[this._positions.length - 1].copy(this._positions[this._positions.length - 3]);
			this._colors[this._colors.length - 2].a = 0;
			this._colors[this._colors.length - 1].a = 0;
		}

		// Set the line mesh positions.
		this._lineMesh.setPositions(this._positions);
		this._lineMesh.setColors(this._colors);
	}
}

const orbitalElements = new pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements();
const velocity = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();


/***/ }),

/***/ "../pioneer/scripts/src/components/shadow_cone_component.js":
/*!******************************************************************!*\
  !*** ../pioneer/scripts/src/components/shadow_cone_component.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ShadowConeComponent": function() { return /* binding */ ShadowConeComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * The Shadow Cone component.
 * */
class ShadowConeComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The color of the grid.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The other entity to use as the source of the cone.
		 * @type {Pioneer.EntityRef}
		 * @private
		 */
		this._sourceEntity = new pioneer__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The shadow type to use the umbra or penumbra.
		 * @type {'umbra' | 'penumbra'}
		 * @private
		 */
		this._shadowType = 'umbra';

		/**
		 * The target entity for the shadow to extend to.
		 * @type {Pioneer.EntityRef}
		 * @private
		 */
		this._targetEntity = new pioneer__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());

		/**
		 * The distance interval over which the component is visible.
		 * @type {Pioneer.Interval}
		 * @private
		 */
		this._visibleDistanceInterval = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(0, Number.POSITIVE_INFINITY);
		this._visibleDistanceInterval.freeze();

		/**
		 * The alpha multiplier determined by fading.
		 * @type {number}
		 * @private
		 */
		this._alphaMultiplier = 1.0;

		/**
		 * The number of vertices on the circle.
		 * @type {number}
		 * @private
		 */
		this._numberOfCirclePoints = 20;

		this.__setRadius(Number.POSITIVE_INFINITY);
	}

	/**
	 * Gets the color of the grid. Defaults to white.
	 * @returns {Pioneer.Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the cone. Defaults to white.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
	}

	/**
	 * Gets the other entity to use as the source of the cone.
	 * @returns {string}
	 */
	getSourceEntity() {
		return this._sourceEntity.getName();
	}

	/**
	 * Sets the other entity to use as the source of the cone.
	 * @param {string} name
	 */
	setSourceEntity(name) {
		this._sourceEntity.setName(name);
	}

	/**
	 * Gets the target entity for the shadow to extend to.
	 * @returns {string}
	 */
	getTargetEntity() {
		return this._targetEntity.getName();
	}

	/**
	 * Sets the target entity for the shadow to extend to.
	 * @param {string} name
	 */
	setTargetEntity(name) {
		this._targetEntity.setName(name);
	}

	/**
	 * Gets the shadow type to use the umbra or penumbra. Defaults to 'umbra'.
	 * @returns {'umbra' | 'penumbra'}
	 */
	getShadowType() {
		return this._shadowType;
	}

	/**
	 * Sets the shadow type to use the umbra or penumbra. Defaults to 'umbra'.
	 * @param {'umbra' | 'penumbra'} shadowType
	 */
	setShadowType(shadowType) {
		this._shadowType = shadowType;
		this.resetResources();
	}

	/**
	 * Gets the distance interval over which the component is visible. Defaults to [0, infinity).
	 * @returns {Pioneer.Interval}
	 */
	getVisibleDistanceInterval() {
		return this._visibleDistanceInterval;
	}

	/**
	 * Sets the distance interval over which the component is visible. Defaults to [0, infinity).
	 * @param {Pioneer.Interval} distanceInterval
	 */
	setVisibleDistanceInterval(distanceInterval) {
		this._visibleDistanceInterval.thaw();
		this._visibleDistanceInterval.copy(distanceInterval);
		this._visibleDistanceInterval.freeze();
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {

		// Update the mesh to reflect the cone.
		this._updateMesh();

		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);

		// Make the cone fade if the camera is outside a visible distance interval.
		const cameraSpacePosition = this.getEntity().getCameraSpacePosition(camera);
		const distanceToObject = cameraSpacePosition.magnitude();
		const diffFadeDistance = (this._visibleDistanceInterval.max - this._visibleDistanceInterval.min) * 0.5;
		const minFadeDistance = Math.min(this._visibleDistanceInterval.min * 0.5, diffFadeDistance);
		const maxFadeDistance = Math.min(this._visibleDistanceInterval.max * 0.5, diffFadeDistance);
		if (distanceToObject < this._visibleDistanceInterval.min + minFadeDistance) {
			this._alphaMultiplier = Math.max(0, (distanceToObject - this._visibleDistanceInterval.min) / minFadeDistance);
		}
		else if (distanceToObject > this._visibleDistanceInterval.max - maxFadeDistance) {
			this._alphaMultiplier = Math.max(0, (this._visibleDistanceInterval.max - distanceToObject) / maxFadeDistance);
		}
		else {
			this._alphaMultiplier = 1.0;
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {

		// Create the material.
		const material = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('basic_alpha');
		this.getThreeJsMaterials().push(material);

		// Set the uniforms.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(material, 'color', this._color, this._alphaMultiplier);

		// Create the mesh object.
		const object = pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [{ name: 'position', dimensions: 3 }], false);
		this.getThreeJsObjects().push(object);

		// Create the mesh geometry.
		this._createMesh();

		// Return it as loaded.
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Creates the mesh.
	 * @private
	 */
	_createMesh() {

		// The arrays.
		const positions = new Float32Array(this._numberOfCirclePoints * 2 * 3);
		const indices = new Uint16Array(this._numberOfCirclePoints * 6);

		// Go around the circle and set the indices.
		for (let i = 0; i < this._numberOfCirclePoints; i++) {
			const iPlus1 = (i + 1) % this._numberOfCirclePoints;
			indices[i * 6 + 0] = i;
			indices[i * 6 + 1] = iPlus1;
			indices[i * 6 + 2] = iPlus1 + this._numberOfCirclePoints;
			indices[i * 6 + 3] = iPlus1 + this._numberOfCirclePoints;
			indices[i * 6 + 4] = i + this._numberOfCirclePoints;
			indices[i * 6 + 5] = i;
		}

		// Apply the positions and indices.
		const geometry = /** @type {Pioneer.THREE.Mesh} */(this.getThreeJsObjects()[0]).geometry;
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(geometry, 'position', positions);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(geometry, indices);
	}

	/**
	 * Updates the mesh positions and colors.
	 * @private
	 */
	_updateMesh() {

		// Get the source entity, and do nothing if not found.
		const sourceEntity = this._sourceEntity.get();
		if (sourceEntity === null) {
			return;
		}

		// Get the target entity (it may be null).
		const targetEntity = this._targetEntity.get();

		// Get the source and this radius.
		const sourceRadius = sourceEntity.getExtentsRadius();
		const thisRadius = this.getEntity().getExtentsRadius();

		// Get the distance and axis from the sourceEntity to this entity.
		const axis = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this.getEntity().getPositionRelativeToEntity(axis, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, sourceEntity);
		const distanceToSource = axis.magnitude();
		axis.normalize(axis);
		if (axis.isNaN()) {
			return;
		}

		// Get the distance between this entity and the target entity.
		let distanceToTarget = thisRadius * 10;
		if (targetEntity !== null) {
			const targetAxis = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			targetEntity.getPositionRelativeToEntity(targetAxis, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity());
			distanceToTarget = targetAxis.magnitude();
			pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(targetAxis);
		}

		// Get the attribute array to modify.
		const attribute = /** @type {Pioneer.THREE.Mesh} */(this.getThreeJsObjects()[0]).geometry.getAttribute('position');
		const array = attribute.array;

		// Calculate the different offsets and radii of the cone.
		let radius0;
		let radius1;
		let offset0;
		let offset1;
		if (this._shadowType === 'umbra') {
			const cosAngleOfTangent = (sourceRadius - thisRadius) / distanceToSource;
			const sinAngleOfTangent = Math.sqrt(1 - cosAngleOfTangent * cosAngleOfTangent);
			const offsetFocus = thisRadius / cosAngleOfTangent;
			const radiusFactor = cosAngleOfTangent / sinAngleOfTangent;
			offset0 = thisRadius * cosAngleOfTangent;
			offset1 = Math.min(distanceToTarget, offsetFocus);
			radius0 = radiusFactor * (offsetFocus - offset0);
			radius1 = radiusFactor * (offsetFocus - offset1);
		}
		else { // 'penumbra'
			const cosAngleOfTangent = (sourceRadius + thisRadius) / distanceToSource;
			const sinAngleOfTangent = Math.sqrt(1 - cosAngleOfTangent * cosAngleOfTangent);
			const offsetFocus = -thisRadius / cosAngleOfTangent;
			const radiusFactor = cosAngleOfTangent / sinAngleOfTangent;
			offset0 = -thisRadius * cosAngleOfTangent;
			offset1 = distanceToTarget;
			radius0 = -radiusFactor * (offsetFocus - offset0);
			radius1 = -radiusFactor * (offsetFocus - offset1);
		}

		// If this entity has a spheroid, it might cause clipping issues with the cone, so increase the radius0 by a small amount.
		if (this.getEntity().getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent) !== null) {
			radius0 *= 1.02;
		}

		// Go around the circle.
		for (let i = 0; i < this._numberOfCirclePoints; i++) {
			const angleI = i / this._numberOfCirclePoints * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
			const xI = Math.cos(angleI);
			const yI = Math.sin(angleI);

			// Set the position.
			array[i * 3 + 0] = radius0 * xI;
			array[i * 3 + 1] = radius0 * yI;
			array[i * 3 + 2] = offset0;
			array[(i + this._numberOfCirclePoints) * 3 + 0] = radius1 * xI;
			array[(i + this._numberOfCirclePoints) * 3 + 1] = radius1 * yI;
			array[(i + this._numberOfCirclePoints) * 3 + 2] = offset1;
		}

		// Mark that the attribute changed.
		attribute.needsUpdate = true;

		// Set the Three.js object orientation to have the z-axis be the axis.
		const orientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const rotation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		const forward = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		orientation.copyFromThreeJs(this.getThreeJsObjects()[0].quaternion);
		orientation.getAxis(forward, 2);
		rotation.setFromVectorFromTo(forward, axis);
		orientation.mult(rotation, orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientation(this.getThreeJsObjects()[0], orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(forward);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(axis);

	}
}


/***/ }),

/***/ "../pioneer/scripts/src/components/torus_component.js":
/*!************************************************************!*\
  !*** ../pioneer/scripts/src/components/torus_component.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "TorusComponent": function() { return /* binding */ TorusComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * A component that renders a colored torus aligned in the x-y plane with an inner and outer radius.
 */
class TorusComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The color.
		 * @type {Pioneer.Color}
		 * @private
		 */
		this._color = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 1);
		this._color.freeze();

		/**
		 * The inner radius.
		 * @type {number}
		 * @private
		 */
		this._innerRadius = 1;

		/**
		 * The outer radius.
		 * @type {number}
		 * @private
		 */
		this._outerRadius = 10;

		/**
		 * The distance interval over which the component is visible.
		 * @type {Pioneer.Interval}
		 * @private
		 */
		this._visibleDistanceInterval = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(0, Number.POSITIVE_INFINITY);
		this._visibleDistanceInterval.freeze();

		/**
		 * The alpha multiplier determined by fading.
		 * @type {number}
		 * @private
		 */
		this._alphaMultiplier = 1.0;

		this.__setRadius(this._outerRadius);
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Gets the color of the annulus. Defaults to white.
	 * @returns {Pioneer.Color}
	 */
	getColor() {
		return this._color;
	}

	/**
	 * Sets the color of the annulus. The alpha value should be provided at the component's maximum visibility.
	 * @param {Pioneer.Color} color
	 */
	setColor(color) {
		this._color.thaw();
		this._color.copy(color);
		this._color.freeze();
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
	}

	/**
	 * Gets the inner radius.
	 * @returns {number}
	 */
	getInnerRadius() {
		return this._innerRadius;
	}

	/**
	 * Sets the inner radius. Defaults to 1.
	 * @param {number} size
	 */
	setInnerRadius(size) {
		this._innerRadius = size;
		this.resetResources();
	}

	/**
	 * Gets the outer radius.
	 * @returns {number}
	 */
	getOuterRadius() {
		return this._outerRadius;
	}

	/**
	 * Sets the outer radius. Defaults to 10.
	 * @param {number} radius
	 */
	setOuterRadius(radius) {
		this._outerRadius = radius;
		this.__setRadius(this._outerRadius);
		this.resetResources();
	}

	/**
	 * Gets the distance interval over which the component is visible.
	 * @returns {Pioneer.Interval}
	 */
	getVisibleDistanceInterval() {
		return this._visibleDistanceInterval;
	}

	/**
	 * Sets the distance interval over which the component is visible. Defaults to [0, infinity).
	 * @param {Pioneer.Interval} distanceInterval
	 */
	setVisibleDistanceInterval(distanceInterval) {
		this._visibleDistanceInterval.thaw();
		this._visibleDistanceInterval.copy(distanceInterval);
		this._visibleDistanceInterval.freeze();
	}

	/**
	 * Prepare the component for rendering.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @package
	 */
	__prepareForRender(camera) {
		// Set the orientation to the entity's orientation.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects()[0], this.getEntity());

		// Set the Three.js object position the entity's camera-space position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects()[0], this.getEntity(), camera);

		// Make the torus fade if the camera is outside a visible distance interval.
		const cameraSpacePosition = this.getEntity().getCameraSpacePosition(camera);
		const distanceToObject = cameraSpacePosition.magnitude();
		const diffFadeDistance = (this._visibleDistanceInterval.max - this._visibleDistanceInterval.min) * 0.5;
		const minFadeDistance = Math.min(this._visibleDistanceInterval.min * 0.5, diffFadeDistance);
		const maxFadeDistance = Math.min(this._visibleDistanceInterval.max * 0.5, diffFadeDistance);
		if (distanceToObject < this._visibleDistanceInterval.min + minFadeDistance) {
			this._alphaMultiplier = Math.max(0, (distanceToObject - this._visibleDistanceInterval.min) / minFadeDistance);
		}
		else if (distanceToObject > this._visibleDistanceInterval.max - maxFadeDistance) {
			this._alphaMultiplier = Math.max(0, (this._visibleDistanceInterval.max - distanceToObject) / maxFadeDistance);
		}
		else {
			this._alphaMultiplier = 1.0;
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(this.getThreeJsMaterials()[0], 'color', this._color, this._alphaMultiplier);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void>}
	 * @override
	 * @protected
	 */
	__loadResources() {
		// Create the material.
		const material = this.getEntity().getScene().getEngine().getMaterialManager().getPreloaded('basic_alpha');
		this.getThreeJsMaterials().push(material);

		// Set the uniforms.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setUniformColorRGBA(material, 'color', this._color, this._alphaMultiplier);

		// Create the mesh object.
		const object = pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this, material, [{ name: 'position', dimensions: 3 }], false);
		this.getThreeJsObjects().push(object);

		// Create the mesh geometry.
		this._createMesh();

		// Return it as loaded.
		return Promise.resolve();
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyAllObjectsAndMaterials(this);
	}

	/**
	 * Creates the mesh.
	 * @private
	 */
	_createMesh() {
		// Constants to use for a good number of segments.
		const numberOfCirclePoints = 100;
		const numberOfTorusPoints = 20;

		// The arrays.
		const positions = new Float32Array(numberOfCirclePoints * numberOfTorusPoints * 3);
		const indices = new Uint16Array(numberOfCirclePoints * numberOfTorusPoints * 6);

		// Saved variables for quicker calculations.
		const middleRadius = (this._outerRadius + this._innerRadius) / 2;
		const diffRadius = (this._outerRadius - this._innerRadius) / 2;

		// Go around the main circle.
		for (let i = 0; i < numberOfCirclePoints; i++) {
			const angleI = i / numberOfCirclePoints * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
			const xI = Math.cos(angleI);
			const yI = Math.sin(angleI);

			// Go around a circle segment of the main circle.
			for (let j = 0; j < numberOfTorusPoints; j++) {
				const angleJ = j / numberOfTorusPoints * pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi;
				const rJ = Math.cos(angleJ);
				const zJ = Math.sin(angleJ);

				// Set the position.
				const positionsIndex = (i * numberOfTorusPoints + j) * 3;
				positions[positionsIndex + 0] = xI * (middleRadius + diffRadius * rJ);
				positions[positionsIndex + 1] = yI * (middleRadius + diffRadius * rJ);
				positions[positionsIndex + 2] = diffRadius * zJ;

				// Set the indices of the quad.
				const indicesIndex = (i * numberOfTorusPoints + j) * 6;
				const iPlus1 = (i + 1) % numberOfCirclePoints;
				const jPlus1 = (j + 1) % numberOfTorusPoints;
				indices[indicesIndex + 0] = i * numberOfTorusPoints + j;
				indices[indicesIndex + 1] = iPlus1 * numberOfTorusPoints + j;
				indices[indicesIndex + 2] = i * numberOfTorusPoints + jPlus1;
				indices[indicesIndex + 3] = iPlus1 * numberOfTorusPoints + jPlus1;
				indices[indicesIndex + 4] = i * numberOfTorusPoints + jPlus1;
				indices[indicesIndex + 5] = iPlus1 * numberOfTorusPoints + j;
			}
		}

		// Apply the positions and indices.
		const geometry = /** @type {Pioneer.THREE.Mesh} */(this.getThreeJsObjects()[0]).geometry;
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(geometry, 'position', positions);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(geometry, indices);
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/components/wmts.js":
/*!*************************************************!*\
  !*** ../pioneer/scripts/src/components/wmts.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Capabilities": function() { return /* binding */ Capabilities; },
/* harmony export */   "Layer": function() { return /* binding */ Layer; },
/* harmony export */   "TileMatrixSet": function() { return /* binding */ TileMatrixSet; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var proj4__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! proj4 */ "../pioneer/scripts/node_modules/proj4/lib/index.js");
/** @module pioneer-scripts */



/**
 * The capabilities XML file.
 * @private
 */
class Capabilities {
	/**
	 * The constructor.
	 * @param {string} endPoint
	 * @param {Pioneer.Engine} engine
	 */
	constructor(endPoint, engine) {
		/**
		 * The end point for the WMTS protocol.
		 * @type {string}
		 * @private
		 */
		this._endPoint = endPoint;

		/**
		 * The XML content of the capabilities.
		 * @type {Document}
		 * @private
		 */
		this._capabilitiesXML = null;

		/**
		 * The list of layers as a map from titles to identifiers.
		 * @type {Map<string, string>}
		 * @private
		 */
		this._layers = new Map();

		/**
		 * A promise that resolves when the capabilities is ready to be used.
		 * @type {Promise<void>}
		 * @private
		 */
		this._readyPromise = null;

		// Get the capabilities.
		this._readyPromise = engine.getDownloader().download(this._endPoint + '/1.0.0/WMTSCapabilities.xml', false).then((download) => {
			if (typeof download.content === 'string') {
				this._capabilitiesXML = new DOMParser().parseFromString(download.content, 'application/xml');
			}

			// Populate the layers.
			if (this._capabilitiesXML !== null) {
				const layerElems = this._capabilitiesXML.querySelectorAll('Contents > Layer');
				for (const layerElem of layerElems) {
					const title = layerElem.querySelector('*|Title').textContent;
					const identifier = layerElem.querySelector('*|Identifier').textContent;
					this._layers.set(title, identifier);
				}
			}
		});
	}

	/**
	 * Gets the promise that resolves when it is ready to be used.
	 * @returns {Promise<void>}
	 */
	get readyPromise() {
		return this._readyPromise;
	}

	/**
	 * Gets the end point.
	 * @returns {string}
	 */
	get endPoint() {
		return this._endPoint;
	}

	/**
	 * Gets the list of layers as a map from titles to identifiers.
	 * @returns {Map<string, string>}
	 */
	get layers() {
		return this._layers;
	}

	/**
	 * Gets a layer from its identifier. Returns null if the identifier is invalid.
	 * @param {string} identifier
	 * @returns {Layer}
	 */
	getLayer(identifier) {
		let layer = null;
		if (this._capabilitiesXML !== null) {
			const layerElems = this._capabilitiesXML.querySelectorAll('Contents > Layer');
			for (const layerElem of layerElems) {
				const layerIdentifier = layerElem.querySelector('*|Identifier').textContent;
				if (identifier === layerIdentifier) {
					layer = new Layer(layerElem, this._endPoint + '/1.0.0');
				}
			}
		}
		return layer;
	}

	/**
	 * Gets a tile matrix set from its identifier. Returns null if the identifier is invalid.
	 * @param {string} identifier
	 * @returns {TileMatrixSet}
	 */
	getTileMatrixSet(identifier) {
		let tileMatrixSet = null;
		if (this._capabilitiesXML !== null) {
			const tileMatrixSetElems = this._capabilitiesXML.querySelectorAll('Contents > TileMatrixSet');
			for (const tileMatrixSetElem of tileMatrixSetElems) {
				const tileMatrixSetIdentifier = tileMatrixSetElem.querySelector('*|Identifier').textContent;
				if (identifier === tileMatrixSetIdentifier) {
					tileMatrixSet = new TileMatrixSet(tileMatrixSetElem);
				}
			}
		}
		return tileMatrixSet;
	}
}

/**
 * A capabilities layer.
 * @internal
 */
class Layer {
	/**
	 * Constructor.
	 * @param {Element} elem
	 * @param {string} baseUrl
	 */
	constructor(elem, baseUrl) {
		/**
		 * The base URL
		 * @type {string}
		 * @private
		 */
		this._baseUrl = baseUrl;

		/**
		 * The title.
		 * @type {string}
		 * @private
		 */
		this._title = elem.querySelector('*|Title').textContent;

		/**
		 * The WMTS layer identifier.
		 * @type {string}
		 * @private
		 */
		this._identifier = elem.querySelector('*|Identifier').textContent;

		/**
		 * The mapping of styles from title to identifier.
		 * @type {Map<string, string>}
		 * @private
		 */
		this._styles = new Map();

		/**
		 * The style that is the default.
		 * @type {string}
		 * @private
		 */
		this._defaultStyle = '';

		/**
		 * The bounding box of the layer.
		 * @type {Pioneer.Rect}
		 * @private
		 */
		this._boundingBox = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Rect();

		/**
		 * The possible extra dimensions of the layer, along with its default.
		 * @type {Map<string, string>}
		 * @private
		 */
		this._dimensions = new Map();

		/**
		 * The tile matrix sets.
		 * @type {Set<string>}
		 * @private
		 */
		this._tileMatrixSets = new Set();

		/**
		 * The WMTS layer url.
		 * @type {string}
		 * @private
		 */
		this._url = '';

		// Get the styles.
		const styleElems = elem.querySelectorAll('Style');
		for (const styleElem of styleElems) {
			const title = styleElem.querySelector('*|Title').textContent;
			const identifier = styleElem.querySelector('*|Identifier').textContent;
			this._styles.set(title, identifier);

			if (styleElem.getAttribute('isDefault') === 'true') {
				this._defaultStyle = identifier;
			}
		}

		// Get the bounding box and crs.
		let boundingBoxElem = elem.querySelector('*|BoundingBox');
		if (boundingBoxElem === null) {
			boundingBoxElem = elem.querySelector('*|WGS84BoundingBox');
		}
		if (boundingBoxElem === null) {
			throw new Error('Layer "' + this._identifier + '" missing a BoundingBox or a WGS84BoundingBox tag.');
		}
		const lowerCornerArray = boundingBoxElem.querySelector('*|LowerCorner').textContent.split(' ');
		const upperCornerArray = boundingBoxElem.querySelector('*|UpperCorner').textContent.split(' ');
		this._boundingBox.origin.set(Number.parseFloat(lowerCornerArray[0]), Number.parseFloat(lowerCornerArray[1]));
		this._boundingBox.size.set(Number.parseFloat(upperCornerArray[0]) - this._boundingBox.origin.x, Number.parseFloat(upperCornerArray[1]) - this._boundingBox.origin.y);

		// Get the extra dimensions of the layer.
		const dimensionElems = elem.querySelectorAll('Dimension');
		for (const dimensionElem of dimensionElems) {
			const identifier = dimensionElem.querySelector('*|Identifier').textContent;
			const defaultValue = dimensionElem.querySelector('Default').textContent;
			this._dimensions.set(identifier, defaultValue);
		}

		// Get the tile matrix sets.
		const tileMatrixSetLinkElems = elem.querySelectorAll('TileMatrixSetLink');
		for (const tileMatrixSetLinkElem of tileMatrixSetLinkElems) {
			const tileMatrixSet = tileMatrixSetLinkElem.querySelector('TileMatrixSet').textContent;
			this._tileMatrixSets.add(tileMatrixSet);
		}

		// Get the url.
		const resourceURLElem = elem.querySelector('ResourceURL');
		this._url = resourceURLElem.getAttribute('template');
		// If it is relative, prepend the base url.
		if (!/^(?:[a-z]+:)?\/\//i.test(this._url)) {
			this._url = this._baseUrl + this._url;
		}
	}

	/**
	 * Gets the title.
	 * @returns {string}
	 */
	get title() {
		return this._title;
	}

	/**
	 * Gets the identifiers.
	 * @returns {string}
	 */
	get identifier() {
		return this._identifier;
	}

	/**
	 * Gets the mapping of style titles to identifiers.
	 * @returns {Map<string, string>}
	 */
	get styles() {
		return this._styles;
	}

	/**
	 * Gets the default style.
	 * @returns {string}
	 */
	get defaultStyle() {
		return this._defaultStyle;
	}

	/**
	 * Gets the bounding box.
	 * @returns {Pioneer.Rect}
	 */
	get boundingBox() {
		return this._boundingBox;
	}

	/**
	 * Gets the dimension options as a mapping of the identifier to its default.
	 * @return {Map<string, string>}
	 */
	get dimensions() {
		return this._dimensions;
	}

	/**
	 * Gets the tile matrix sets associated with this layer.
	 * @return {Set<string>}
	 */
	get tileMatrixSets() {
		return this._tileMatrixSets;
	}

	/**
	 * Gets the url template for the layer.
	 * @returns {string}
	 */
	get url() {
		return this._url;
	}
}

/**
 * A tile matrix set.
 * @internal
 */
class TileMatrixSet {
	/**
	 * Constructor.
	 * @param {Element} elem
	 */
	constructor(elem) {
		/**
		 * The WMTS layer identifier.
		 * @type {string}
		 * @private
		 */
		this._identifier = elem.querySelector('*|Identifier').textContent;

		/**
		 * The CRS of the tile matrix set.
		 * @type {string}
		 * @private
		 */
		this._crs = elem.querySelector('*|SupportedCRS').textContent;

		/**
		 * The bounding box of the tile matrix set.
		 * @type {Pioneer.Rect}
		 * @private
		 */
		this._boundingBox = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Rect();

		/**
		 * The number of levels that the matrix has.
		 * @type {Pioneer.Vector2[]}
		 * @private
		 */
		this._numTiles = [];

		/**
		 * A promise that resolves when it is ready to be used.
		 * @type {Promise<void>}
		 * @private
		 */
		this._readyPromise = null;

		// Check if it has proper power-of-two levels and set the number of tiles for each tile matrix.
		let scalePrev;
		let level = 0;
		for (const node of elem.querySelectorAll('TileMatrix')) {
			const scaleElem = node.querySelector('ScaleDenominator');
			if (!scaleElem) {
				throw new Error('ScaleDenominator tag not found for TileMatrix ' + level + '.');
			}
			const scale = parseFloat(scaleElem.innerHTML);
			if (scalePrev !== undefined && Math.abs(scale * 2 - scalePrev) / scale > 0.01) {
				throw new Error('ScaleDenominator for TileMatrix ' + level + ' must be half of the next higher level, but is not.');
			}
			scalePrev = scale;
			this._numTiles[level] = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(
				parseFloat(node.querySelector('MatrixWidth').innerHTML),
				parseFloat(node.querySelector('MatrixHeight').innerHTML));
			level += 1;
		}

		// Get the number of levels from the iteration above
		this._numLevels = level;

		// Calculate the bounding box.
		// It uses the ScaleDenominator, TileWidth/Height, and MatrixWidth/Height of level 0
		// to calculate the bounding box size. Since the calculation yields a number in
		// km / matrix and we need it in CRS units, we have to get the CRS unitsPerMeter value
		// in order to get the bounding box size in CRS units.
		const tileMatrix0Elem = elem.querySelector('TileMatrix');
		const scaleDenominator = Number.parseFloat(tileMatrix0Elem.querySelector('ScaleDenominator').textContent);
		const pixelsPerTile = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(Number.parseFloat(tileMatrix0Elem.querySelector('TileWidth').textContent), Number.parseFloat(tileMatrix0Elem.querySelector('TileHeight').textContent));
		const kmPerPixel = scaleDenominator * 0.28e-6;
		const kmPerTile = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(kmPerPixel * pixelsPerTile.x, kmPerPixel * pixelsPerTile.y);
		const kmPerMatrix = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(kmPerTile.x * this._numTiles[0].x, kmPerTile.y * this._numTiles[0].y);
		// Get the bounding box origin.
		const topLeftCornerArray = tileMatrix0Elem.querySelector('TopLeftCorner').textContent.split(' ');
		this._boundingBox.origin.set(Number.parseFloat(topLeftCornerArray[0]), Number.parseFloat(topLeftCornerArray[1]));
		// Get the CRS to convert km/matrix to CRS units/matrix.
		this._readyPromise = TileMatrixSet.setCRS(this._crs).then((crs) => {
			this._crs = crs;
			let unitsPerKm = 1e3;
			const proj = proj4__WEBPACK_IMPORTED_MODULE_1__["default"].defs(this._crs);
			if (proj.to_meter) {
				unitsPerKm = 1000 / proj.to_meter;
			}
			else if (proj.units === 'degrees') {
				unitsPerKm = 0.00898315284;
			}
			else if (proj.units === 'feet' || proj.units === 'us feet') {
				unitsPerKm = 3280.83333335;
			}

			// Set the size, rounding off extra digits to prevent slight overflows.
			this._boundingBox.size.x = Math.round(kmPerMatrix.x * unitsPerKm * 1e6) / 1e6;
			this._boundingBox.size.y = Math.round(kmPerMatrix.y * unitsPerKm * 1e6) / 1e6;
			this._boundingBox.origin.y = this._boundingBox.origin.y - this._boundingBox.size.y;
		});
	}

	/**
	 * Gets a promise that resolves when it is ready to be used.
	 * @returns {Promise<void>}
	 */
	get readyPromise() {
		return this._readyPromise;
	}

	/**
	 * Gets the identifier.
	 * @returns {string}
	 */
	get identifier() {
		return this._identifier;
	}

	/**
	 * Gets the bounding box in CRS coordinates.
	 * @returns {Pioneer.Rect}
	 */
	get boundingBox() {
		return this._boundingBox;
	}

	/**
	 * Gets the number of levels.
	 * @returns {number}
	 */
	get numLevels() {
		return this._numLevels;
	}

	/**
	 * Gets the number of tiles in each direction at the given level.
	 * @param {number} level
	 * @returns {Pioneer.Vector2}
	 */
	getNumTiles(level) {
		return this._numTiles[level];
	}

	/**
	 * Converts CRS units to an XYZ.
	 * @param {Pioneer.Vector3} outXYZ
	 * @param {Pioneer.Vector2} crsUnits
	 * @param {Pioneer.SpheroidComponent} spheroid
	 */
	crsUnitsToXYZ(outXYZ, crsUnits, spheroid) {
		const lla = pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		// Clamp the x and y to the bounding box so that we don't get crazy values.
		const x = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(crsUnits.x, this._boundingBox.origin.x, this._boundingBox.origin.x + this._boundingBox.size.x);
		const y = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(crsUnits.y, this._boundingBox.origin.y, this._boundingBox.origin.y + this._boundingBox.size.y);
		// Convert it to regular geodetic latitude and longitude.
		const ll = (0,proj4__WEBPACK_IMPORTED_MODULE_1__["default"])(this._crs, 'WGS84', [x, y]);
		lla.set(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(ll[1]), pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(ll[0]), 0);
		// Convert it to xyz.
		spheroid.xyzFromLLA(outXYZ, lla);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
	}

	/**
	 * Defines a projection in proj4 from the crs. Returns the string to be used on subsequent proj4 calls.
	 * @param {string} crs
	 * @returns {Promise<string>}
	 */
	static async setCRS(crs) {
		if (crs.startsWith('urn:ogc:def:crs:')) {
			crs = crs.substring('urn:ogc:def:crs:'.length);
		}
		// Try to get it locally first.
		let proj4Text = crsToWKT.get(crs);
		if (proj4Text === undefined && crs.startsWith('EPSG::')) {
			const url = 'https://epsg.io/' + crs.substring('EPSG::'.length) + '.proj4';
			const result = await fetch(url);
			proj4Text = await result.text();
		}
		proj4__WEBPACK_IMPORTED_MODULE_1__["default"].defs(crs, proj4Text);
		return crs;
	}
}

const crsToWKT = /** @type {Map<string, string | any>} */(new Map());
// Some common ones to start us off.
crsToWKT.set('EPSG::104903', 'GEOGCS["GCS_Moon_2000",DATUM["D_Moon_2000",SPHEROID["Moon_2000_IAU_IAG",1737400.0,0.0]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]');
crsToWKT.set('EPSG::104905', 'GEOGCS["GCS_Mars_2000",DATUM["D_Mars_2000",SPHEROID["Mars_2000_IAU_IAG",3396190.0,169.8944472236118]],PRIMEM["Reference_Meridian",0.0],UNIT["Degree",0.0174532925199433]]');
crsToWKT.set('EPSG::4326', '+proj=longlat +ellps=WGS84 +datum=WGS84 +no_defs');
crsToWKT.set('EPSG::3857', '+proj=merc +a=6378137 +b=6378137 +lat_ts=0.0 +lon_0=0.0 +x_0=0.0 +y_0=0 +k=1.0 +units=m +nadgrids=@null +wktext +no_defs');
crsToWKT.set('OGC:1.3:84', proj4__WEBPACK_IMPORTED_MODULE_1__["default"].defs('WGS84'));
crsToWKT.set('OGC:1.3:CRS84', proj4__WEBPACK_IMPORTED_MODULE_1__["default"].defs('WGS84'));
crsToWKT.set('OGC:2:84', proj4__WEBPACK_IMPORTED_MODULE_1__["default"].defs('WGS84'));




/***/ }),

/***/ "../pioneer/scripts/src/components/wmts_component.js":
/*!***********************************************************!*\
  !*** ../pioneer/scripts/src/components/wmts_component.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "WMTSComponent": function() { return /* binding */ WMTSComponent; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _wmts__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wmts */ "../pioneer/scripts/src/components/wmts.js");
/** @module pioneer-scripts */



/**
 * @callback TransitionsCompleteCallback
 * @returns {void}
 */

/**
 * The WMTS component.
 * */
class WMTSComponent extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseComponent {
	/**
	 * Constructor.
	 * @param {string} type - the type of the component
	 * @param {string} name - the name of the component
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The WMTS Capabilities
		 * @type {Capabilities}
		 * @private
		 */
		this._capabilities = null;

		/**
		 * The WMTS end point.
		 * @type {string}
		 * @private
		 */
		this._endPoint = '';

		/**
		 * The WMTS layer identifier
		 * @type {string}
		 * @private
		 */
		this._layerIdentifier = '';

		/**
		 * The WMTS tile matrix set identifier
		 * @type {string}
		 * @private
		 */
		this._tileMatrixSetIdentifier = '';

		/**
		 * The style identifier.
		 * @type {string}
		 * @private
		 */
		this._style = '';

		/**
		 * Dimension values used to get the right tile.
		 * @type {Map<string, string>}
		 * @private
		 */
		this._dimensionValues = new Map();

		/**
		 * The minimum level to which the tiles must split.
		 * @type {number}
		 * @private
		 */
		this._minLevel = Number.NEGATIVE_INFINITY;

		/**
		 * The maximum level to which the tiles can split.
		 * @type {number}
		 * @private
		 */
		this._maxLevel = Number.POSITIVE_INFINITY;

		/**
		 * A factor that determines when to split the tiles. Higher means more splits.
		 * @type {number}
		 * @private
		 */
		this._splitJoinThresholdFactor = 512;

		/**
		 * The layer.
		 * @type {Layer}
		 * @private
		 */
		this._layer = null;

		/**
		 * The tile matrix set.
		 * @type {TileMatrixSet}
		 * @private
		 */
		this._tileMatrixSet = null;

		/**
		 * The url to be used by the tiles for the images.
		 * @type {string}
		 * @private
		 */
		this._tileUrl = '';

		/**
		 * The entities used for shadows. Derived from the shadow entity names.
		 * @type {Pioneer.EntityRef[]}
		 * @private
		 */
		this._shadowEntities = [];

		/**
		 * The downloader for easier future access.
		 * @private
		 */
		this._engine = this.getEntity().getScene().getEngine();

		/**
		 * The positions of all active cameras.
		 * @type {Pioneer.Vector3[]}
		 * @private
		 */
		this._cameraPositions = [];

		/**
		 * The root tile.
		 * @type {WMTSTile}
		 * @private
		 */
		this._rootTile = null;

		/**
		 * The pixel size of each tile. Starts out as undefined and then on the first image load is set.
		 * @type {number}
		 * @private
		 */
		this._tilePixelSize = undefined;

		/**
		 * A promise that resolves when all tiles are no longer transitioning.
		 * @type {Promise<void>}
		 * @private
		 */
		this._tilesLoadedPromise = null;

		/**
		 * The callback that gets called when all tiles are no longer transitioning.
		 * @type {TransitionsCompleteCallback}
		 * @private
		 */
		this._transitionsCompleteCallback = null;

		/**
		 * A counter that ensures that we don't do too many splits or joins in a single frame.
		 * @type {number}
		 * @private
		 */
		this._loadsThisFrame = 0;

		/**
		 * A reference to the atmosphere component.
		 * @type {Pioneer.ComponentRef<Pioneer.AtmosphereComponent>}
		 * @private
		 */
		this._atmosphereComponentRef = new pioneer__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._atmosphereComponentRef.setByType(this.getEntity().getName(), 'atmosphere');

		/**
		 * A reference to the spheroid component.
		 * @type {Pioneer.ComponentRef<Pioneer.SpheroidComponent>}
		 * @private
		 */
		this._spheroidComponentRef = new pioneer__WEBPACK_IMPORTED_MODULE_0__.ComponentRef(this.getEntity().getScene());
		this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid');
		this._spheroidComponentRef.setRefChangedCallback(this._spheroidRefChangedCallback.bind(this));

		// Bind the callbacks to this.
		this._spheroidChangedCallback = this._spheroidChangedCallback.bind(this);

		// Lets the base component to check for valid orientation when determining whether this is visible.
		this.__setUsesEntityOrientation(true);
	}

	/**
	 * Sets the end point for the WMTS protocol.
	 * @param {string} endPoint
	 */
	async setEndPoint(endPoint) {
		this._endPoint = endPoint;
		this.resetResources();
	}

	/**
	 * Sets the layer identifier.
	 * @param {string} identifier
	 */
	setLayer(identifier) {
		this._layerIdentifier = identifier;
		this.resetResources();
	}

	/**
	 * Sets the tile matrix set identifier.
	 * @param {string} identifier
	 */
	setTileMatrixSet(identifier) {
		this._tileMatrixSetIdentifier = identifier;
		this.resetResources();
	}

	/**
	 * Sets the style of the layer.
	 * @param {string} identifier
	 */
	setStyle(identifier) {
		this._style = identifier;
		this.resetResources();
	}

	/**
	 * Sets the value of a dimension in the layer.
	 * @param {string} dimension
	 * @param {string} value
	 */
	setDimensionValue(dimension, value) {
		this._dimensionValues.set(dimension, value);
		this.resetResources();
	}

	/**
	 * Gets the list of layers as a map from titles to identifiers.
	 * @returns {Map<string, string>}
	 */
	getLayers() {
		if (this._capabilities !== null) {
			return this._capabilities.layers;
		}
		else {
			return new Map();
		}
	}

	/**
	 * Gets the minimum level to which the tiles must split.
	 * @returns {number}
	 */
	getMinLevel() {
		return this._minLevel;
	}

	/**
	 * Sets the minimum level to which the tiles must split. Defaults to negative infinity.
	 * @param {number} minLevel
	 */
	setMinLevel(minLevel) {
		this._minLevel = minLevel;
	}

	/**
	 * Gets the maximum level to which the tiles can split.
	 * @returns {number}
	 */
	getMaxLevel() {
		return this._maxLevel;
	}

	/**
	 * Sets the maximum level to which the tiles can split. Defaults to positive infinity.
	 * @param {number} maxLevel
	 */
	setMaxLevel(maxLevel) {
		this._maxLevel = maxLevel;
	}

	/**
	 * Returns a promise when no more tiles are loading.
	 * @returns {Promise<void>}
	 */
	getTilesLoadedPromise() {
		return this._tilesLoadedPromise || Promise.resolve();
	}

	/**
	 * Sets the reference to use for the spheroid component, by name or the type index.
	 * @param {string | number} nameOrTypeIndex
	 */
	setSpheroidReference(nameOrTypeIndex) {
		if (typeof nameOrTypeIndex === 'string') {
			this._spheroidComponentRef.setByName(this.getEntity().getName(), nameOrTypeIndex);
		}
		else {
			this._spheroidComponentRef.setByType(this.getEntity().getName(), 'spheroid', nameOrTypeIndex);
		}
	}

	/**
	 * Gets the layer.
	 * @returns {Layer}
	 * @internal
	 */
	__getLayer() {
		return this._layer;
	}

	/**
	 * Gets the tile matrix set.
	 * @returns {TileMatrixSet}
	 * @internal
	 */
	__getTileMatrixSet() {
		return this._tileMatrixSet;
	}

	/**
	 * Gets the url to be used by the tiles.
	 * @returns {string}
	 * @internal
	 */
	__getTileUrl() {
		return this._tileUrl;
	}

	/**
	 * Gets the layer bounds or null if there is no layer.
	 * @returns {Pioneer.Rect}
	 * @internal
	 */
	__getLayerBounds() {
		if (this._layer !== null) {
			return this._layer.boundingBox;
		}
		else {
			return null;
		}
	}

	/**
	 * Gets the max level.
	 * @returns {number}
	 * @internal
	 */
	__getMaxLevel() {
		return this._maxLevel;
	}

	/**
	 * Gets the min level.
	 * @returns {number}
	 * @internal
	 */
	__getMinLevel() {
		return this._minLevel;
	}

	/**
	 * Gets the split-join factor.
	 * @returns {number}
	 * @internal
	 */
	__getSplitJoinFactor() {
		return this._splitJoinThresholdFactor;
	}

	/**
	 * Gets the pixel size of each tile. Starts out as undefined and then on the first image load is set.
	 * @returns {number}
	 */
	__getTilePixelSize() {
		return this._tilePixelSize;
	}

	/**
	 * Sets the pixel size of each tile. Starts out as undefined and then on the first image load is set.
	 * @param {number} tilePixelSize
	 */
	__setTilePixelSize(tilePixelSize) {
		this._tilePixelSize = tilePixelSize;
	}

	/**
	 * Gets the number of loads this frame.
	 * @returns {number}
	 */
	__getLoadsThisFrame() {
		return this._loadsThisFrame;
	}

	/**
	 * Increments the number of loads this frame.
	 * @internal
	 */
	__incLoadsThisFrame() {
		this._loadsThisFrame += 1;
	}

	/**
	 * Gets the current camera positions.
	 * @returns {Pioneer.Vector3[]}
	 * @internal
	 */
	__getCameraPositions() {
		return this._cameraPositions;
	}

	/**
	 * Gets the spheroid component this is using. Used by Tile.
	 * @returns {Pioneer.SpheroidComponent}
	 * @internal
	 */
	__getSpheroidComponent() {
		return this._spheroidComponentRef.get();
	}

	/**
	 * Cleans up the component.
	 * @override
	 * @internal
	 */
	__destroy() {
		// Remove the spheroid changed callback.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			spheroidComponent.removeChangedCallback(this._spheroidChangedCallback);
		}

		super.__destroy();
	}

	/**
	 * Updates the component.
	 * @override
	 * @internal
	 */
	__update() {
		// Update the references.
		this._spheroidComponentRef.update();

		// If there's no root tile, do nothing else.
		if (this._rootTile === null) {
			return;
		}

		// Get the positions of all cameras.
		while (this._cameraPositions.length > this._engine.getNumViewports()) {
			this._cameraPositions.pop();
		}
		while (this._cameraPositions.length < this._engine.getNumViewports()) {
			this._cameraPositions.push(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3());
		}
		const cameraPosition = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		for (let i = 0, l = this._engine.getNumViewports(); i < l; i++) {
			cameraPosition.neg(this.getEntity().getCameraSpacePosition(this._engine.getViewport(i).getCamera()));
			this._cameraPositions[i].rotateInverse(this.getEntity().getOrientation(), cameraPosition);
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(cameraPosition);

		this._loadsThisFrame = 0;

		// Do the update on all of the tiles recursively.
		// If any tile is still transitioning, set transitioning to true.
		const transitioning = this._rootTile.update();

		// If there is no current promise (there were no tiles) and now there are,
		// Create the loaded promise and record its resolve callback.
		if (this._tilesLoadedPromise === null && transitioning) {
			this._tilesLoadedPromise = new Promise((resolve) => {
				this._transitionsCompleteCallback = resolve;
			});
		}

		// If the loaded promise callback exists and we're no longer transitioning,
		// Clear the loaded promise and callback and call the callback (the resolve function of the promise).
		if (this._tilesLoadedPromise !== null && !transitioning) {
			const callback = this._transitionsCompleteCallback;
			this._tilesLoadedPromise = null;
			this._transitionsCompleteCallback = null;
			callback();
		}
	}

	/**
	 * Prepares the component for render.
	 * @param {Pioneer.CameraComponent} camera
	 * @override
	 * @internal
	 */
	__prepareForRender(camera) {
		// Set the orientation to the entity's orientation.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setOrientationToEntity(this.getThreeJsObjects(), this.getEntity());

		// Set the position to the entity's camera position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setPositionToEntity(this.getThreeJsObjects(), this.getEntity(), camera);

		// Get the atmosphere.
		const atmosphere = this._atmosphereComponentRef.get();

		// Setup the regular uniforms.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.setUniforms(this.getThreeJsMaterials(), camera, this.getEntity(), this._shadowEntities, atmosphere, true);
	}

	/**
	 * Loads the resources needed by the component.
	 * @returns {Promise<void | void[]>}
	 * @override
	 * @protected
	 */
	async __loadResources() {
		if (this._endPoint !== '') {
			// Load the capabilities end point XML.
			this._capabilities = new _wmts__WEBPACK_IMPORTED_MODULE_1__.Capabilities(this._endPoint, this._engine);
			await this._capabilities.readyPromise;

			// If no layer is specified and there is only one choice, choose that one.
			let layerIdentifier = this._layerIdentifier;
			if (layerIdentifier === '') {
				const layers = this._capabilities.layers;
				if (layers.size === 1) {
					for (const [, identifier] of layers) {
						layerIdentifier = identifier;
					}
				}
			}
			// If there's still no layer specified, nothing to do.
			if (layerIdentifier === '') {
				return;
			}
			// Load the layer.
			this._layer = this._capabilities.getLayer(layerIdentifier);
			if (this._layer === null) {
				throw new Error('Invalid layer: "' + layerIdentifier + '".');
			}

			// If no tile matrix set is specified and there is only one choice, choose that one.
			let tileMatrixSetIdentifier = this._tileMatrixSetIdentifier;
			if (tileMatrixSetIdentifier === '') {
				const tileMatrixSets = this._layer.tileMatrixSets;
				if (tileMatrixSets.size === 1) {
					for (const identifier of tileMatrixSets) {
						tileMatrixSetIdentifier = identifier;
					}
				}
			}
			// Load the tile matrix set.
			this._tileMatrixSet = this._capabilities.getTileMatrixSet(tileMatrixSetIdentifier);
			if (this._tileMatrixSet === null) {
				throw new Error('Invalid tile matrix set: "' + tileMatrixSetIdentifier + '".');
			}
			await this._tileMatrixSet.readyPromise;

			// Get the root tile bounds.
			const rootTileBounds = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Rect();
			rootTileBounds.copy(this._tileMatrixSet.boundingBox);
			// Make sure the level -1 tile matrix can be 2x2 when split.
			if (this._tileMatrixSet.getNumTiles(0).x === 1) {
				rootTileBounds.size.x *= 2.0;
			}
			if (this._tileMatrixSet.getNumTiles(0).y === 1) {
				rootTileBounds.origin.y -= rootTileBounds.size.y;
				rootTileBounds.size.y *= 2.0;
			}

			// If no style is specified, get the default one.
			let style = this._style;
			if (style === '') {
				style = this._layer.defaultStyle;
			}
			// Add default dimension values.
			for (const [identifier, defaultValue] of this._layer.dimensions) {
				if (!this._dimensionValues.has(identifier)) {
					this._dimensionValues.set(identifier, defaultValue);
				}
			}

			// The tile url to be used by the tiles.
			this._tileUrl = this._layer.url;
			this._tileUrl = this._tileUrl.replace('{TileMatrixSet}', this._tileMatrixSet.identifier);
			this._tileUrl = this._tileUrl.replace('{Style}', style);
			this._dimensionValues.forEach((value, dimension) => {
				this._tileUrl = this._tileUrl.replace('{' + dimension + '}', value);
			});

			this._rootTile = new WMTSTile(this, null, -1, 0, 0, rootTileBounds);
		}
	}

	/**
	 * Unloads any resources used by the component.
	 * @override
	 * @protected
	 */
	__unloadResources() {
		this._capabilities = null;
		this._layer = null;
		this._tileMatrixSet = null;
		this._tileUrl = '';
		this._rootTile.destroy();
		this._rootTile = null;
	}

	/**
	 * Callback called when the spheroid reference is found or lost.
	 * @param {Pioneer.SpheroidComponent} oldRef
	 * @param {Pioneer.SpheroidComponent} newRef
	 * @private
	 */
	_spheroidRefChangedCallback(oldRef, newRef) {
		if (oldRef !== null) {
			oldRef.removeChangedCallback(this._spheroidChangedCallback);
		}
		if (newRef !== null) {
			newRef.addChangedCallback(this._spheroidChangedCallback);
		}
		this._spheroidChangedCallback();
	}

	/**
	 * Callback to be called when the spheroid component changed.
	 * @private
	 */
	_spheroidChangedCallback() {
		// Set the radii uniforms.
		const spheroidComponent = this._spheroidComponentRef.get();
		if (spheroidComponent !== null) {
			this.__setRadius(Math.max(spheroidComponent.getEquatorialRadius(), spheroidComponent.getPolarRadius()));
		}
		else {
			this.__setRadius(0);
		}
		this.resetResources();
	}
}

/**
 * A single tile with mesh, material, and bounds.
 * @extends Pioneer.Tile<WMTSTile>
 * @private
 */
class WMTSTile extends pioneer__WEBPACK_IMPORTED_MODULE_0__.Tile {
	/**
	 * Constructor.
	 * @param {WMTSComponent} component
	 * @param {WMTSTile} parent
	 * @param {number} level
	 * @param {number} row
	 * @param {number} col
	 * @param {Pioneer.Rect} tileBounds
	 */
	constructor(component, parent, level, row, col, tileBounds) {
		super(parent);

		/**
		 * The WMTS component.
		 * @type {WMTSComponent}
		 * @private
		 */
		this._component = component;

		/**
		 * The TileMatrix level starting from -1.
		 * @type {number}
		 * @private
		 */
		this._level = level;

		/**
		 * The row in the TileMatrix of the tile.
		 * @type {number}
		 * @private
		 */
		this._row = row;

		/**
		 * The column in the TileMatrix of the tile.
		 * @type {number}
		 * @private
		 */
		this._col = col;

		/**
		 * The bounds of the tile in CRS coordinates.
		 * @type {Pioneer.Rect}
		 * @private
		 */
		this._tileBounds = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Rect();
		this._tileBounds.copy(tileBounds);

		/**
		 * The "center", the average between the origin and end of the tile bounds.
		 * @type {Pioneer.Vector3}
		 * @private
		 */
		this._center = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();

		/**
		 * The "radius", the distance from the center to one of the corners.
		 * @type {number}
		 * @private
		 */
		this._radius = 0;

		/**
		 * The material used by the tile, from a pool of materials.
		 * @type {Pioneer.THREE.ShaderMaterial}
		 * @private
		 */
		this._threeJsMaterial = null;

		/**
		 * The Three.js object of the tile.
		 * @type {Pioneer.THREE.Mesh<Pioneer.THREE.BufferGeometry, Pioneer.THREE.ShaderMaterial | Pioneer.THREE.ShaderMaterial[]>}
		 * @private
		 */
		this._threeJsObject = null;

		// Calculate the center and diagonal length of a box that includes
		// the start and end points and the average of the two.
		const spheroid = component.__getSpheroidComponent();
		const tileMatrixSet = this._component.__getTileMatrixSet();
		// Get the origin as XYZ.
		const originXYZ = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		tileMatrixSet.crsUnitsToXYZ(originXYZ, this._tileBounds.origin, spheroid);
		// Get the end as XYZ.
		const end = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		end.add(this._tileBounds.origin, this._tileBounds.size);
		const endXYZ = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		tileMatrixSet.crsUnitsToXYZ(endXYZ, end, spheroid);
		// Get the average of the start and end points.
		const tileBoundsCenter = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		tileBoundsCenter.addMult(this._tileBounds.origin, this._tileBounds.size, 0.5);
		tileMatrixSet.crsUnitsToXYZ(this._center, tileBoundsCenter, spheroid);
		// Get the min and max points.
		const min = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		const max = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		min.x = Math.min(originXYZ.x, endXYZ.x, this._center.x);
		min.y = Math.min(originXYZ.y, endXYZ.y, this._center.y);
		min.z = Math.min(originXYZ.z, endXYZ.z, this._center.z);
		max.x = Math.max(originXYZ.x, endXYZ.x, this._center.x);
		max.y = Math.max(originXYZ.y, endXYZ.y, this._center.y);
		max.z = Math.max(originXYZ.z, endXYZ.z, this._center.z);
		// Get the center of the box.
		this._center.add(min, max);
		this._center.mult(this._center, 0.5);
		// Get the radius.
		const diagonal = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		diagonal.sub(this._center, min);
		this._radius = diagonal.magnitude();
	}

	/**
	 * @param {WMTSTile} parent
	 * @param {number} row - 0 or 1
	 * @param {number} col - 0 or 1
	 * @returns {WMTSTile}
	 * @override
	 */
	createNewTile(parent, row, col) {
		// Get new tile params.
		const newLevel = parent._level + 1;
		const newRow = parent._row * 2 + row;
		const newCol = parent._col * 2 + col;

		// Check if it's within the tile bounds.
		const numTiles = parent._component.__getTileMatrixSet().getNumTiles(parent._level + 1);
		if (newRow >= numTiles.y || newCol >= numTiles.x) {
			return null;
		}

		// Calculate the new CRS tile bounds.
		const tileBounds = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Rect();
		tileBounds.origin.set(parent._tileBounds.origin.x + col * 0.5 * parent._tileBounds.size.x, parent._tileBounds.origin.y + (1 - row) * 0.5 * parent._tileBounds.size.y);
		tileBounds.size.set(0.5 * parent._tileBounds.size.x, 0.5 * parent._tileBounds.size.y);

		return new WMTSTile(parent._component, parent, newLevel, newRow, newCol, tileBounds);
	}

	/**
	 * Returns true if this tile should be split.
	 * @returns {boolean}
	 * @override
	 */
	checkSplit() {
		// Don't split if there are no more tiles in the tile matrix set.
		if (this._level >= this._component.__getTileMatrixSet().numLevels - 1) {
			return false;
		}
		// Don't split if the whole tile is not in the layer.
		if (!this._tileBounds.intersects(this._component.__getLayerBounds())) {
			return false;
		}
		// Don't split if we're at the maximum level of detail.
		if (this._level >= this._component.__getMaxLevel()) {
			return false;
		}
		// Don't split if we've already done a lot this frame.
		if (this._component.__getLoadsThisFrame() >= 1) {
			return false;
		}
		// Always split if we're below the minimum level of detail.
		if (this._level < this._component.__getMinLevel()) {
			return true;
		}
		// Always split if we're at the invisible root node.
		if (this._level === -1) {
			return true;
		}
		// Split if the nearest camera distance is less than the threshold.
		let tilePixelSize = this._component.__getTilePixelSize();
		if (tilePixelSize === undefined && this._threeJsMaterial !== null) {
			tilePixelSize = this._threeJsMaterial.uniforms['colorTexture'].value.image.width;
			if (tilePixelSize === 1) { // It is using a single pixel color, so don't go further.
				return false;
			}
			this._component.__setTilePixelSize(tilePixelSize);
		}
		return this._getNearestDistance() < this._component.__getSplitJoinFactor() * this._radius / tilePixelSize;
	}

	/**
	 * Returns true if this tile should join its children.
	 * @returns {boolean}
	 * @override
	 */
	checkJoin() {
		// If we're at the root node, never join.
		if (this._level === -1) {
			return false;
		}
		// Don't join if we've already done a lot this frame.
		if (this._component.__getLoadsThisFrame() >= 1) {
			return false;
		}
		// Always join is we're above the maximum level of detail.
		if (this._level > this._component.__getMaxLevel()) {
			return true;
		}
		// Never join if we're at or below the minimum level of detail.
		if (this._level <= this._component.__getMinLevel()) {
			return false;
		}
		// Check if the nearest camera distance is greater than the threshold.
		let tilePixelSize = this._component.__getTilePixelSize();
		if (tilePixelSize === undefined && this._threeJsMaterial !== null) {
			tilePixelSize = this._threeJsMaterial.uniforms['colorTexture'].value.image.width;
			this._component.__setTilePixelSize(tilePixelSize);
		}
		return this._getNearestDistance() > this._component.__getSplitJoinFactor() * this._radius * 4 / tilePixelSize;
	}

	/**
	 * Asynchronously loads the tile so that it may be used.
	 * @returns {Promise<void | void[]>}
	 * @override
	 */
	async load() {
		if (this._level === -1) {
			return Promise.resolve();
		}

		this._component.__incLoadsThisFrame();

		if (this._threeJsMaterial !== null) {
			throw new Error('Tile already has material.');
		}

		// Check if it's within the layer bounds.
		if (this._tileBounds.intersects(this._component.__getLayerBounds())) {
			// Get a material from the component's materials cache.
			this._threeJsMaterial = pioneer__WEBPACK_IMPORTED_MODULE_0__.MaterialUtils.get();
			this._component.getThreeJsMaterials().push(this._threeJsMaterial);
			// this._threeJsMaterial.wireframe = true;
			// this._threeJsMaterial.defines['baseColor'] = true;
			// this._threeJsMaterial.uniforms['color'].value.setRGB(0.25 + 0.75 * Math.random(), 0.25 + 0.75 * Math.random(), 0.25 + 0.75 * Math.random());

			let url = this._component.__getTileUrl();
			url = url.replace('{TileMatrix}', '' + this._level);
			url = url.replace('{TileRow}', '' + this._row);
			url = url.replace('{TileCol}', '' + this._col);
			try {
				// Download the texture.
				await pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTextureIntoUniform(this._component, this._threeJsMaterial, 'colorTexture', url, false, false);
			}
			catch (e) {
				await pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.loadTextureIntoUniform(this._component, this._threeJsMaterial, 'colorTexture', 'gray', false, false);
			}
		}
	}

	/**
	 * Asynchronously unloads the tile.
	 * @returns {Promise<void>}
	 * @override
	 */
	async unload() {
		if (this._level === -1) {
			return;
		}
		if (this._threeJsMaterial !== null) {
			// Remove up the material from the materials list.
			const materials = this._component.getThreeJsMaterials();
			for (let i = 0, l = materials.length; i < l; i++) {
				if (materials[i] === this._threeJsMaterial) {
					materials.splice(i, 1);
					break;
				}
			}
			if (this._threeJsMaterial.uniforms['colorTexture'].value) {
				this._threeJsMaterial.uniforms['colorTexture'].value.dispose();
			}
			// Dispose of the material.
			this._threeJsMaterial.dispose();
			this._threeJsMaterial = null;
		}
		this._threeJsMaterial = null;
	}

	/**
	 * Asynchronously activates the tile.
	 * @returns {Promise<void>}
	 * @override
	 */
	async activate() {
		if (this._level === -1) {
			return;
		}
		// Create the Three.js object.
		this._threeJsObject = pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.createMeshObject(this._component, this._threeJsMaterial, [
			{ name: 'position', dimensions: 3 },
			{ name: 'normal', dimensions: 3 },
			{ name: 'uv', dimensions: 2 }
		], false);
		this._component.getThreeJsObjects().push(this._threeJsObject);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.useInDynEnvMap(this._threeJsObject, true);

		// Create the vertices, normals, uvs, and indices arrays.
		const numVVerts = 21;
		const numUVerts = 21;
		const numVerts = numUVerts * numVVerts;
		const meshPositions = new Float32Array(numVerts * 3);
		const meshNormals = new Float32Array(numVerts * 3);
		const meshUVs = new Float32Array(numVerts * 2);
		const meshIndices = new Uint16Array(numUVerts * (numVVerts - 1) * 6);

		// Get the bounding box.
		const boundingBox = this._component.__getLayer().boundingBox;

		// Set the vertices, normals, uvs, and indices arrays.
		const crsUnits = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const clampedCRSUnits = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2();
		const xyz = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
		for (let y = 0; y < numVVerts; y++) {
			let yF = 1.0 - y / (numVVerts - 1);
			crsUnits.y = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this._tileBounds.origin.y, this._tileBounds.origin.y + this._tileBounds.size.y, yF);
			clampedCRSUnits.y = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(crsUnits.y, boundingBox.origin.y, boundingBox.origin.y + boundingBox.size.y);
			yF += (clampedCRSUnits.y - crsUnits.y) / this._tileBounds.size.y;
			for (let x = 0; x < numUVerts; x++) {
				let xF = x / (numUVerts - 1);
				crsUnits.x = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(this._tileBounds.origin.x, this._tileBounds.origin.x + this._tileBounds.size.x, xF);
				clampedCRSUnits.x = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.clamp(crsUnits.x, boundingBox.origin.x, boundingBox.origin.x + boundingBox.size.x);
				xF += (clampedCRSUnits.x - crsUnits.x) / this._tileBounds.size.x;
				// Set the latitude and longitude coordinate.
				this._component.__getTileMatrixSet().crsUnitsToXYZ(xyz, clampedCRSUnits, this._component.__getSpheroidComponent());

				const vertexI = y * numUVerts + x;
				meshPositions[vertexI * 3 + 0] = xyz.x;
				meshPositions[vertexI * 3 + 1] = xyz.y;
				meshPositions[vertexI * 3 + 2] = xyz.z;
				xyz.normalize(xyz);
				meshNormals[vertexI * 3 + 0] = xyz.x;
				meshNormals[vertexI * 3 + 1] = xyz.y;
				meshNormals[vertexI * 3 + 2] = xyz.z;
				meshUVs[vertexI * 2 + 0] = xF;
				meshUVs[vertexI * 2 + 1] = 1.0 - yF;

				const triangleI = y * numUVerts + x;
				if (x < numUVerts - 1 && y < numVVerts - 1) {
					meshIndices[triangleI * 6 + 0] = numUVerts * (y + 0) + (x + 0);
					meshIndices[triangleI * 6 + 1] = numUVerts * (y + 1) + (x + 0);
					meshIndices[triangleI * 6 + 2] = numUVerts * (y + 1) + (x + 1);
					meshIndices[triangleI * 6 + 3] = numUVerts * (y + 0) + (x + 0);
					meshIndices[triangleI * 6 + 4] = numUVerts * (y + 1) + (x + 1);
					meshIndices[triangleI * 6 + 5] = numUVerts * (y + 0) + (x + 1);
				}
			}
		}

		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'position', meshPositions);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'normal', meshNormals);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setVertices(this._threeJsObject.geometry, 'uv', meshUVs);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.setIndices(this._threeJsObject.geometry, meshIndices);
	}

	/**
	 * Asynchronously deactivates the tile.
	 * @returns {Promise<void>}
	 * @override
	 */
	async deactivate() {
		if (this._level === -1) {
			return;
		}
		// Remove the object from the objects list.
		const objects = this._component.getThreeJsObjects();
		for (let i = 0, l = objects.length; i < l; i++) {
			if (objects[i] === this._threeJsObject) {
				objects.splice(i, 1);
				break;
			}
		}
		// Destroy the object and its geometry.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.ThreeJsHelper.destroyObject(this._threeJsObject);
		this._threeJsObject = null;
	}

	/**
	 * Updates the tiles recursively. Returns true if the tile or any descendant is transitioning.
	 * @returns {boolean}
	 */
	update() {
		let transitioning = this.check();
		for (let i = 0, l = this.children.length; i < l; i++) {
			transitioning = this.children[i].update() || transitioning;
		}
		return transitioning;
	}

	_getNearestDistance() {
		// Calculate the nearest distance to see if we need to split or join this node.
		let nearestDistance = Number.POSITIVE_INFINITY;
		const diff = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		for (let i = 0, l = this._component.__getCameraPositions().length; i < l; i++) {
			const position = this._component.__getCameraPositions()[i];
			diff.sub(this._center, position);
			const distance = Math.max(0, diff.magnitude() - this._radius);
			if (nearestDistance > distance) {
				nearestDistance = distance;
			}
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(diff);
		return nearestDistance;
	}

	/**
	 * Converts the tile to a string.
	 * @returns {string}
	 * @override
	 */
	toString() {
		return this._level + '-' + this._row + '-' + this._col;
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/controllers/keyframe_pointing_controller.js":
/*!**************************************************************************!*\
  !*** ../pioneer/scripts/src/controllers/keyframe_pointing_controller.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyframePointingController": function() { return /* binding */ KeyframePointingController; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * A controller that points the entity's frame-space direction given by keyframes.
 */
class KeyframePointingController extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The keyframes.
		 * @type {[number, string][]}
		 * @private
		 */
		this._keyframes = [];

		/**
		 * The frame-space direction to use for the pointing.
		 * @type {Pioneer.Vector3}
		 * @private
		 */
		this._direction = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);

		this.addModifiedState('orientation');
	}

	/**
	 * Sets the keyframes. Each keyframe is a [time, value]. Possible keyframe values are any entity name or 'velocity',
	 * with an optional prefix of '-' to indicate the opposite direction.
	 * @param {[number, string][]} keyframes
	 */
	setKeyframes(keyframes) {
		// Remove any previous dependent states.
		for (let i = 0, l = this._keyframes.length; i < l; i++) {
			let value = this._keyframes[i][1];
			if (value.startsWith('-')) {
				value = value.substring(1);
			}
			if (value === 'velocity') {
				this.removeDependentState(this.getEntity().getName(), 'velocity');
			}
			else {
				this.removeDependentState(value, 'position');
			}
		}
		this._keyframes = [];
		for (let i = 0, l = keyframes.length; i < l; i++) {
			this._keyframes.push([keyframes[i][0], keyframes[i][1]]);
			// Add any new dependent states.
			let value = this._keyframes[i][1];
			if (value.startsWith('-')) {
				value = value.substring(1);
			}
			if (value === 'velocity') {
				this.addDependentState(this.getEntity().getName(), 'velocity');
			}
			else {
				this.addDependentState(value, 'position');
			}
		}
		this._keyframes.sort((a, b) => a[0] - b[0]);
	}

	/**
	 * Sets the frame-space direction to use for the pointing.
	 * @param {Pioneer.Vector3} direction
	 */
	setDirection(direction) {
		this._direction.copy(direction);
	}

	/**
	 * Updates given orientation for the given time.
	 * @param {Pioneer.Quaternion} orientation - The orientation to update.
	 * @param {number} time - The time to check.
	 * @override
	 */
	__updateOrientationAtTime(orientation, time) {
		if (orientation.isNaN()) {
			orientation.copy(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		this._getNewOrientation(orientation, time, orientation);
	}

	/**
	 * Updates the controller.
	 * @override
	 */
	__update() {
		if (this._keyframes.length === 0) {
			return;
		}
		const entity = this.getEntity();
		const time = entity.getScene().getEngine().getTime();
		if (entity.getOrientation().isNaN()) {
			entity.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		const newOrientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		this._getNewOrientation(newOrientation, time, entity.getOrientation());
		entity.setOrientation(newOrientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);
	}

	/**
	 * Gets a new orientation, given the time and an existing orientation.
	 * @param {Pioneer.Quaternion} newOrientation
	 * @param {number} time
	 * @param {Pioneer.Quaternion} oldOrientation
	 * @private
	 */
	_getNewOrientation(newOrientation, time, oldOrientation) {
		const index = pioneer__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._keyframes, (a, time) => a[0] < time);
		let prevIndex = 0;
		let nextIndex = 0;
		if (index === this._keyframes.length) { // After last keyframe time.
			prevIndex = this._keyframes.length - 1;
			nextIndex = this._keyframes.length - 1;
		}
		else if (index > 0) {
			prevIndex = index - 1;
			nextIndex = index;
		}
		const prevKeyframe = this._keyframes[prevIndex];
		const nextKeyframe = this._keyframes[nextIndex];
		const u = (nextKeyframe[0] > prevKeyframe[0])
			? (time - prevKeyframe[0]) / (nextKeyframe[0] - prevKeyframe[0])
			: 0;
		const prevDirection = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const nextDirection = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		this._getDirection(prevDirection, time, prevKeyframe[1]);
		this._getDirection(nextDirection, time, nextKeyframe[1]);
		nextDirection.slerp(prevDirection, nextDirection, u);
		nextDirection.normalize(nextDirection);
		prevDirection.rotate(oldOrientation, this._direction);
		const rotation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		rotation.setFromVectorFromTo(prevDirection, nextDirection);
		newOrientation.mult(rotation, oldOrientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(nextDirection);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(prevDirection);
	}

	/**
	 * Gets a dynamic direction using the type. It can be the name of another entity or 'velocity', and can be prefixed with '-'.
	 * @param {Pioneer.Vector3} outDirection
	 * @param {number} time
	 * @param {string} type
	 * @private
	 */
	_getDirection(outDirection, time, type) {
		const entity = this.getEntity();
		const isNeg = type.startsWith('-');
		if (isNeg) {
			type = type.substring(1);
		}
		if (type.startsWith('velocity')) {
			type = type.substring(8);
			if (type.startsWith(' rel ')) {
				type = type.substring(5);
				const relEntity = entity.getScene().getEntity(type);
				if (relEntity !== null) {
					entity.getVelocityRelativeToEntity(outDirection, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, relEntity, time);
				}
			}
			else {
				entity.getVelocityAtTime(outDirection, time);
			}
		}
		else {
			const otherEntity = entity.getScene().getEntity(type);
			if (otherEntity !== null) {
				otherEntity.getPositionRelativeToEntity(outDirection, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, entity, time);
			}
			else {
				outDirection.copy(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3[NaN]);
			}
		}
		outDirection.normalize(outDirection);
		if (isNeg) {
			outDirection.mult(outDirection, -1);
		}
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/controllers/keyframe_spin_controller.js":
/*!**********************************************************************!*\
  !*** ../pioneer/scripts/src/controllers/keyframe_spin_controller.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "KeyframeSpinController": function() { return /* binding */ KeyframeSpinController; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * A controller that spins an entity at keyframed rates along a given axis.
 */
class KeyframeSpinController extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The keyframes. The components are [time, rate, starting angle].
		 * @type {[number, number, number][]}
		 * @private
		 */
		this._keyframes = [];

		/**
		 * The frame-space axis to use for the spinning.
		 * @type {Pioneer.Vector3}
		 * @private
		 */
		this._axis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);

		/**
		 * The starting angle at keyframe 0.
		 * @type {number}
		 * @private
		 */
		this._startingAngle = 0;

		this.addModifiedState('orientation');
	}

	/**
	 * Sets the keyframes. Each keyframe is a [time, rate]. The rate uses the right-hand rotation along the specified axis.
	 * @param {[number, number][]} keyframes
	 */
	setKeyframes(keyframes) {
		this._keyframes = [];
		let lastAngle = 0;
		for (let i = 0, l = keyframes.length; i < l; i++) {
			if (i > 0) {
				// Get the accumulated angle over the previous duration, taking into account changing spin rates.
				lastAngle = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(lastAngle + (keyframes[i][0] - keyframes[i - 1][0]) * (keyframes[i - 1][1] + keyframes[i][1]) * 0.5, 0, 2 * Math.PI);
			}
			this._keyframes.push([keyframes[i][0], keyframes[i][1], lastAngle]);
		}
		this._keyframes.sort((a, b) => a[0] - b[0]);
	}

	/**
	 * Sets the frame-space axis to use for the spinning.
	 * @param {Pioneer.Vector3} axis
	 */
	setAxis(axis) {
		this._axis.copy(axis);
	}

	/**
	 * Sets the starting angle at keyframe 0.
	 * @param {number} angle
	 */
	setStartingAngle(angle) {
		this._startingAngle = angle;
	}

	/**
	 * Updates given orientation for the given time.
	 * @param {Pioneer.Quaternion} orientation - The orientation to update.
	 * @param {number} time - The time to check.
	 * @override
	 */
	__updateOrientationAtTime(orientation, time) {
		if (orientation.isNaN()) {
			orientation.copy(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		this._getNewOrientation(orientation, time, orientation);
	}

	/**
	 * Updates the controller.
	 * @override
	 */
	__update() {
		if (this._keyframes.length === 0) {
			return;
		}
		const entity = this.getEntity();
		const time = entity.getScene().getEngine().getTime();
		if (entity.getOrientation().isNaN()) {
			entity.setOrientation(pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.Identity);
		}
		const newOrientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		this._getNewOrientation(newOrientation, time, entity.getOrientation());
		entity.setOrientation(newOrientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(newOrientation);
	}

	/**
	 * Gets a new orientation, given the time and an existing orientation.
	 * @param {Pioneer.Quaternion} newOrientation
	 * @param {number} time
	 * @param {Pioneer.Quaternion} oldOrientation
	 * @private
	 */
	_getNewOrientation(newOrientation, time, oldOrientation) {
		const index = pioneer__WEBPACK_IMPORTED_MODULE_0__.Sort.getIndex(time, this._keyframes, (a, time) => a[0] < time);
		let prevIndex = 0;
		let nextIndex = 0;
		if (index === this._keyframes.length) { // After last keyframe time.
			prevIndex = this._keyframes.length - 1;
			nextIndex = this._keyframes.length - 1;
		}
		else if (index > 0) {
			prevIndex = index - 1;
			nextIndex = index;
		}
		const prevKeyframe = this._keyframes[prevIndex];
		const nextKeyframe = this._keyframes[nextIndex];
		const u = (nextKeyframe[0] > prevKeyframe[0])
			? (time - prevKeyframe[0]) / (nextKeyframe[0] - prevKeyframe[0])
			: 0;
		const angle = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.wrap(this._startingAngle + prevKeyframe[2] + (time - prevKeyframe[0]) * (prevKeyframe[1] + u * nextKeyframe[1]) / (1 + u), 0, 2 * Math.PI);
		const axis = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		axis.rotate(oldOrientation, this._axis);
		const rotation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		rotation.setFromAxisAngle(axis, angle);
		newOrientation.mult(rotation, oldOrientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(axis);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(rotation);
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/controllers/position_sum_controller.js":
/*!*********************************************************************!*\
  !*** ../pioneer/scripts/src/controllers/position_sum_controller.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "PositionSumController": function() { return /* binding */ PositionSumController; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/** A controller that adds a factor of different positions. */
class PositionSumController extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The list of entities and their factors.
		 * @type {Pioneer.FastMap<string, {ref: Pioneer.EntityRef, mult: number, add: number}>}
		 * @private
		 */
		this._entities = new pioneer__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		this.addModifiedState('position');
	}

	/**
	 * Adds an entity with mult and add factors.
	 * @param {string} entityName - The entity whose position to use.
	 * @param {number} mult - A multiply factor of the position.
	 * @param {number} add - An added offset in the direction of the position.
	 */
	addEntity(entityName, mult, add) {
		// Set the ref.
		const ref = new pioneer__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());
		ref.setName(entityName);

		// Add it to the list.
		this._entities.set(entityName, { ref, mult, add });

		// Mark that this is dependent on the position of the entity.
		this.addDependentState(entityName, 'position');
	}

	/**
	 * Removes an entity.
	 * @param {string} entityName
	 */
	removeEntity(entityName) {
		// Remove it from the list.
		this._entities.delete(entityName);

		// Mark that this is no longer dependent on the position of the entity.
		this.removeDependentState(entityName, 'position');
	}

	/**
	 * Sets the params of the entity, which has already been added.
	 * @param {string} entityName - The entity whose position to use.
	 * @param {number | undefined} mult - A multiply factor of the position.
	 * @param {number | undefined} add - An added offset in the direction of the position.
	 */
	setEntityParams(entityName, mult, add) {

		// Check if it already exists.
		if (!this._entities.has(entityName)) {
			throw new Error(`The entity ${entityName} has not been previously added to the controller.`);
		}

		// Update the params.
		const params = this._entities.get(entityName);
		if (mult !== undefined) {
			params.mult = mult;
		}
		if (add !== undefined) {
			params.add = add;
		}
	}

	/**
	 * Updates the position.
	 * @override
	 * @package
	 */
	__update() {
		const accumulatedPosition = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const position = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();

		// Go through each entity,
		accumulatedPosition.set(0, 0, 0);
		for (let i = 0, l = this._entities.size; i < l; i++) {
			const entry = this._entities.getAt(i).value;

			// Get the entity.
			const entity = entry.ref.get();
			if (entity === null) {
				continue;
			}

			// Get the position of the entity relative to the current parent.
			entity.getPositionRelativeToEntity(position, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity().getParent());

			// Accumulate the position with the factors.
			const magnitude = position.magnitude();
			accumulatedPosition.addMult(accumulatedPosition, position, entry.mult + (magnitude > 0 ? entry.add / magnitude : 0));
		}

		// Set the accumulated position.
		this.getEntity().setPosition(accumulatedPosition);

		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(accumulatedPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/controllers/zoom_fit_controller.js":
/*!*****************************************************************!*\
  !*** ../pioneer/scripts/src/controllers/zoom_fit_controller.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "ZoomFitController": function() { return /* binding */ ZoomFitController; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/** A controller that zooms the camera to fit a list of entities within view. */
class ZoomFitController extends pioneer__WEBPACK_IMPORTED_MODULE_0__.BaseController {
	/**
	 * Constructor.
	 * @param {string} type - the type of the controller
	 * @param {string} name - the name of the controller
	 * @param {Pioneer.Entity} entity - the parent entity
	 */
	constructor(type, name, entity) {
		super(type, name, entity);

		/**
		 * The list of entities and their factors.
		 * @type {Pioneer.FastMap<string, { ref: Pioneer.EntityRef }>}
		 * @private
		 */
		this._entities = new pioneer__WEBPACK_IMPORTED_MODULE_0__.FastMap();

		/**
		 * The flag that determines if the fit radius will take into account the point of view of the camera for a tighter fit.
		 * @type {boolean}
		 * @private
		 */
		this._tightFit = false;

		/**
		 * The flag that determines if the camera will zoom out only, or both in and out.
		 * @type {boolean}
		 * @private
		 */
		this._zoomOutOnly = false;

		/**
		 * The edge size as a fraction of the minimum of the viewport width and height.
		 * @type {number}
		 * @private
		 */
		this._edgeSize = 0;

		this.addModifiedState('position');
	}

	/**
	 * Adds an entity with mult and add factors.
	 * @param {string} entityName - The entity whose position to use.
	 */
	addEntity(entityName) {
		// Set the ref.
		const ref = new pioneer__WEBPACK_IMPORTED_MODULE_0__.EntityRef(this.getEntity().getScene());
		ref.setName(entityName);

		// Add it to the list.
		this._entities.set(entityName, { ref });

		// Mark that this is dependent on the position of the entity.
		this.addDependentState(entityName, 'position');
	}

	/**
	 * Removes an entity.
	 * @param {string} entityName
	 */
	removeEntity(entityName) {
		// Remove it from the list.
		this._entities.delete(entityName);

		// Mark that this is no longer dependent on the position of the entity.
		this.removeDependentState(entityName, 'position');
	}

	/**
	 * Sets the flag that determines if the fit radius will take into account the point of view of the camera for a tighter fit.
	 * @param {boolean} tightFit
	 */
	setTightFit(tightFit) {
		this._tightFit = tightFit;
	}

	/**
	 * Sets the flag that determines if the camera will zoom out only, or both in and out.
	 * @param {boolean} zoomOutOnly
	 */
	setZoomOutOnly(zoomOutOnly) {
		this._zoomOutOnly = zoomOutOnly;
	}

	/**
	 * Sets the edge size as a fraction of the minimum of the viewport width and height.
	 * @param {number} edgeSize
	 */
	setEdgeSize(edgeSize) {
		this._edgeSize = edgeSize;
	}

	/**
	 * Updates the position.
	 * @override
	 * @package
	 */
	__update() {
		// Get the sin and tan field of view variables for distance calculations.
		let tanHalfFov = 1;
		const camera = this.getEntity().getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CameraComponent);
		if (camera !== null) {
			const fieldOfView = Math.min(camera.getHorizontalFieldOfView(), camera.getVerticalFieldOfView());
			if (this._tightFit) {
				tanHalfFov = Math.tan(fieldOfView / 2.0);
			}
			tanHalfFov = Math.tan(fieldOfView / 2.0);
		}

		// Get the direction upon which we'll be zooming.
		// It will be the unit vector of the camera's position, or the camera's backward if the position vector is 0.
		const direction = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		direction.normalize(this.getEntity().getPosition());
		if (direction.magnitudeSqr() === 0) {
			this.getEntity().getOrientation().getAxis(direction, 1);
			direction.neg(direction);
		}
		if (direction.isNaN()) {
			direction.copy(pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.YAxisNeg);
		}

		// Get the edge factor that widens the view appropriately depending on the field of view.
		const factor = (1 + this._edgeSize / (0.5 - this._edgeSize)) / tanHalfFov;

		// Get the distance the camera should be at to see everything.
		let maxDistance = 0;
		const position = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		for (let i = 0, l = this._entities.size; i < l; i++) {
			const entry = this._entities.getAt(i).value;

			// Get the entity.
			const entity = entry.ref.get();
			if (entity === null) {
				continue;
			}

			// Get the position of the entity relative to the current parent.
			entity.getPositionRelativeToEntity(position, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, this.getEntity().getParent());

			// Get the extents radius of the entity.
			const radius = entity.getExtentsRadius();

			// Get the distance that we should be away from this entity.
			let distance = 0;
			if (this._tightFit) {
				// Get the position part along the direction.
				const distanceAlongDirection = position.dot(direction);

				// Get the position part along the plane normal to the direction.
				position.addMult(position, direction, -distanceAlongDirection);
				const distanceAlongPane = position.magnitude();

				// Get the distance to zoom back for this object.
				distance = distanceAlongDirection + factor * distanceAlongPane + radius * Math.sqrt(factor * factor + 1);
			}
			else {
				// It's not using the tight-fit flag, so we're just going to use the distances for the (dist + radius)
				//   and do the distance calculation after the loop.
				distance = position.magnitude() + radius;
			}

			// Max out the distance needed to see all of the entities.
			maxDistance = Math.max(maxDistance, distance);
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);

		// If it's not a tight fit, the maxDistance is just the max (dist + radius) all entities, so apply the equation to get the distance to zoom back.
		if (!this._tightFit) {
			maxDistance = maxDistance * Math.sqrt(factor * factor + 1);
		}

		// If we're either zooming out or we can zoom in,
		if (!this._zoomOutOnly || maxDistance > this.getEntity().getPosition().magnitude()) {
			// Add the distance along the backward vector to the position.
			direction.mult(direction, maxDistance);

			// Set the position.
			this.getEntity().setPosition(direction);
		}
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(direction);
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/date_time.js":
/*!*******************************************!*\
  !*** ../pioneer/scripts/src/date_time.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "DateTime": function() { return /* binding */ DateTime; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * A simple date and time class. Month starts at 1.
 * This is needed because the Date object (and moment.js) doesn't handle leap seconds.
 * Note that month starts at 1, not 0.
 */
class DateTime {
	/**
	 * Constructor.
	 * @param {number} [year=1]
	 * @param {number} [month=1]
	 * @param {number} [day=1]
	 * @param {number} [hour=0]
	 * @param {number} [minute=0]
	 * @param {number} [second=0]
	 * @param {number} [millisecond=0]
	 */
	constructor(year = 1, month = 1, day = 1, hour = 0, minute = 0, second = 0, millisecond = 0) {
		/**
		 * Year starting at 1 A.D.
		 * @type {number}
		 */
		this.year = year;

		/**
		 * Month starting at 1.
		 * @type {number}
		 */
		this.month = month;

		/**
		 * Day starting at 1.
		 * @type {number}
		 */
		this.day = day;

		/**
		 * The 24-hour.
		 * @type {number}
		 */
		this.hour = hour;

		/**
		 * The minute.
		 * @type {number}
		 */
		this.minute = minute;

		/**
		 * The second. Can go up to 60 for leap seconds.
		 * @type {number}
		 */
		this.second = second;

		/**
		 * The millisecond. Can be fractional.
		 * @type {number}
		 */
		this.millisecond = millisecond;
	}

	/**
	 * Copies a dateTime to this.
	 * @param {DateTime} dateTime
	 */
	copy(dateTime) {
		this.year = dateTime.year;
		this.month = dateTime.month;
		this.day = dateTime.day;
		this.hour = dateTime.hour;
		this.minute = dateTime.minute;
		this.second = dateTime.second;
		this.millisecond = dateTime.millisecond;
	}

	/**
	 * Sets this from an ET time.
	 * @param {number} et
	 */
	fromET(et) {
		const unixTime = pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.etToUnix(et);
		_date.setTime(unixTime * 1000.0);
		this.year = _date.getUTCFullYear();
		this.month = _date.getUTCMonth() + 1;
		this.day = _date.getUTCDate();
		this.hour = _date.getUTCHours();
		this.minute = _date.getUTCMinutes();
		this.second = _date.getUTCSeconds();
		this.millisecond = _date.getUTCMilliseconds();
		for (let i = 0, l = pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.leapSeconds.length; i < l; i++) {
			if (Math.floor(unixTime) === pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.leapSeconds[i] && unixTime === pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.etToUnix(et - 1)) {
				this.second += 1;
				break;
			}
		}
	}

	/**
	 * Gets an ET time from this.
	 * @returns {number}
	 */
	toET() {
		_date.setUTCFullYear(this.year);
		_date.setUTCMonth(this.month - 1);
		_date.setUTCDate(this.day);
		_date.setUTCHours(this.hour);
		_date.setUTCMinutes(this.minute);
		_date.setUTCSeconds(this.second);
		_date.setUTCMilliseconds(this.millisecond);
		const unixTime = _date.getTime() / 1000.0;
		let etTime = pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.unixToEt(unixTime);
		if (this.second === 60) {
			for (let i = 0, l = pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.leapSeconds.length; i < l; i++) {
				if (Math.floor(unixTime) === pioneer__WEBPACK_IMPORTED_MODULE_0__.TimeUtils.leapSeconds[i] + 1) {
					etTime -= 1;
					break;
				}
			}
		}
		return etTime;
	}

	/**
	 * Sets this from an ordinal date (day of year) and time.
	 * @param {number} year
	 * @param {number} doy
	 * @param {number} [hour=0]
	 * @param {number} [minute=0]
	 * @param {number} [second=0]
	 * @param {number} [millisecond=0]
	 */
	fromDOY(year, doy, hour = 0, minute = 0, second = 0, millisecond = 0) {
		let passedDays = 0;
		this.year = year;
		this.month = 1;
		this.hour = hour;
		this.minute = minute;
		this.second = second;
		this.millisecond = millisecond;
		let daysInMonth = this.getDaysInMonth();
		while (doy > passedDays + daysInMonth && this.month < 12) {
			passedDays += daysInMonth;
			this.month += 1;
			daysInMonth = this.getDaysInMonth();
		}
		this.day = doy - passedDays;
	}

	/**
	 * Gets the day of year for this.
	 * @returns {number}
	 */
	toDOY() {
		const originalMonth = this.month;
		let doy = 0;
		for (this.month = 1; this.month < originalMonth; this.month++) {
			doy += this.getDaysInMonth();
		}
		this.month = originalMonth;
		doy += this.day;
		return doy;
	}

	/**
	 * Returns true if this is a leap year.
	 * @returns {boolean}
	 */
	isLeapYear() {
		return ((this.year % 4 === 0) && (this.year % 100 !== 0)) || (this.year % 400 === 0);
	}

	/**
	 * Returns the number of days in the month for this.
	 * @returns {number}
	 */
	getDaysInMonth() {
		let daysInMonth = _daysInMonth[this.month - 1];
		if (this.month === 2 && this.isLeapYear()) {
			daysInMonth += 1;
		}
		return daysInMonth;
	}

	/**
	 * Parses text in the form of YYYY-MM-DD HH:MM:SS.ssssss, with the time and milliseconds optional.
	 * @param {string} text
	 */
	parse(text) {
		this.year = parseInt(text.substring(0, 4));
		if (text.length > 5) {
			this.month = parseInt(text.substring(5, 7));
		}
		else {
			this.month = 1;
		}
		if (text.length > 8) {
			this.day = parseInt(text.substring(8, 10));
		}
		else {
			this.day = 1;
		}
		if (text.length > 11) {
			this.hour = parseInt(text.substring(11, 13));
			this.minute = parseInt(text.substring(14, 16));
		}
		else {
			this.hour = 0;
			this.minute = 0;
		}
		if (text.length > 17) {
			this.second = parseInt(text.substring(17, 19));
		}
		else {
			this.second = 0;
		}
		if (text.length > 20) {
			this.millisecond = parseInt(text.substring(20)) * Math.pow(10, 23 - text.length);
		}
		else {
			this.millisecond = 0;
		}
	}

	/**
	 * Parses text in the form of YYYY-DDD HH:MM:SS.ssssss.
	 * @param {string} text
	 */
	parseDOY(text) {
		const year = parseInt(text.substring(0, 4));
		let doy = 1;
		if (text.length > 5) {
			doy = parseInt(text.substring(5, 8));
		}
		this.fromDOY(year, doy);
		if (text.length > 9) {
			this.hour = parseInt(text.substring(9, 11));
			this.minute = parseInt(text.substring(12, 14));
		}
		else {
			this.hour = 0;
			this.minute = 0;
		}
		if (text.length > 15) {
			this.second = parseInt(text.substring(15, 17));
		}
		else {
			this.second = 0;
		}
		if (text.length > 18) {
			this.millisecond = parseInt(text.substring(18)) * Math.pow(10, 21 - text.length);
		}
		else {
			this.millisecond = 0;
		}
	}

	/**
	 * Converts this to a string of the form YYYY-MM-DD HH:MM:SS.ssssss.
	 * @returns {string}
	 */
	toString() {
		return `${this.year.toString().padStart(4, '0')}-${this.month.toString().padStart(2, '0')}-${this.day.toString().padStart(2, '0')} ${this.hour.toString().padStart(2, '0')}:${this.minute.toString().padStart(2, '0')}:${this.second.toString().padStart(2, '0')}.${Math.floor(this.millisecond * 1e3).toString().padStart(6, '0')}`;
	}

	/**
	 * Converts this to a string of the form YYYY-DDD.
	 * @returns {string}
	 */
	toStringDOY() {
		return `${this.year.toString().padStart(4, '0')}-${this.toDOY().toString().padStart(3, '0')}`;
	}
};

/**
 * The number of days in a non-leap year month.
 * @type {number[]}
 * @private
 */
const _daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

/**
 * Temporary date that can be reused within functions.
 * @type {Date}
 * @private
 */
const _date = new Date();


/***/ }),

/***/ "../pioneer/scripts/src/entities/comets.js":
/*!*************************************************!*\
  !*** ../pioneer/scripts/src/entities/comets.js ***!
  \*************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var _entity_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity_utils */ "../pioneer/scripts/src/entities/entity_utils.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */




_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	'1i_oumuamua': {
		groups: ['comets'],
		occlusionRadius: 0.030,
		extentsRadius: 0.225,
		label: 'ʻOumuamua',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/1i_oumuamua/oumuamua.gltf'
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '1i_oumuamua/sun/orb'
		}, {
			type: 'spin',
			axis: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.57735026919, 0.57735026919, 0.57735026919),
			periodInHours: 8.10
		}]
	},
	'1p_halley': {
		groups: ['comets'],
		radius: 6.0,
		label: 'Halley (1P/Halley)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [6, 6, 6]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '1p_halley/sun/orb'
		}, {
			type: 'spin',
			periodInHours: 52,
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
			axisInFrameSpace: false
		}]
	},
	'103p_hartley_2': {
		groups: ['comets'],
		radius: 2.0,
		label: 'Hartley 2 (103P/Hartley)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/103p_hartley_2/hartley_2.gltf'
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '103p_hartley_2/sun/orb'
		}, {
			type: 'dynamo',
			url: '103p_hartley_2/ori'
		}]
	},
	'9p_tempel_1': {
		groups: ['comets'],
		radius: 5.0,
		label: 'Tempel 1 (9P/Tempel)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/9p_tempel_1/9p_tempel.gltf',
			rotate: [
				{ y: 90 }
			]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '9p_tempel_1/sun/orb'
		}, {
			type: 'dynamo',
			url: '9p_tempel_1/ori'
		}]
	},
	'81p_wild_2': {
		groups: ['comets'],
		radius: 2.5,
		label: 'Wild 2 (81P/Wild)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun'],
			[-800047271, 'jupiter'],
			[-797029475, 'sun']
		],
		trail: {
			length: undefined,
			lengthCoverages: [
				[1356976800, Number.NEGATIVE_INFINITY, -611927948.817],
				[189345600, -611927948.817, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.5, 2.5, 2.5]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '81p_wild_2/sun/1/orb'
		}, {
			type: 'dynamo',
			url: '81p_wild_2/jupiter/orb'
		}, {
			type: 'dynamo',
			url: '81p_wild_2/sun/2/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	'67p_churyumov_gerasimenko': {
		groups: ['comets'],
		radius: 4.1,
		label: 'Churyumov–Gerasimenko (67P/C-G)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/67p_churyumov_gerasimenko/67p_churyumov_gerasimenko.gltf',
			rotate: [
				{ x: 90 }
			],
			scale: 0.00124
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '67p_churyumov_gerasimenko/sun/orb'
		}, {
			type: 'spin',
			axis: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.15191127889562422, 0.404099951782066, 0.9020123016422935),
			axisInFrameSpace: false,
			periodInHours: 12.0550932412
		}, {
			type: 'dynamo',
			url: '67p_churyumov_gerasimenko/ori'
		}],
		postCreateFunction: (entity) => {
			// Get the orientation just right for working with Rosetta photos.
			entity.setOrientation(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.26732846830704055, 0.017948528101847026, 0.22012096235022358, 0.9379552773483394));

			// Geysers
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 1, 1, 100, 1, 1, [1, -0.25, 1.2], [0, 0, 1]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 2, 0.5, 100, 1, 1, [-1.2, -0.25, 0.6], [0.2, -0.5, 1]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 1, 0.07, 100, 1, 10, [-1.2, 0.1, 0.6], [0.2, -0.5, 1]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 1, 1, 100, 1, 1, [-0.8, 0.75, 1.0], [0.2, 0.5, 1]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 1, 0.5, 100, 1, 1, [-0.8, 0.35, -1.0], [0.2, 0.25, -1]);
		}
	},
	'19p_borrelly': {
		groups: ['comets'],
		radius: 2.4,
		label: 'Borrelly (19P/Borrelly)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/19p_borrelly/borrelly.gltf'
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: '19p_borrelly/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	c_1995_o1: {
		groups: ['comets'],
		radius: 5.0,
		label: 'Hale-Bopp (C/1995 O1)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [5, 5, 5]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: 'c_1995_o1/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
			axisInFrameSpace: false,
			periodInHours: 11.766666666
		}]
	},
	c_2010_x1: {
		groups: ['comets'],
		radius: 5.0,
		label: 'Elenin (C/2010 X1)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun'],
			[370699266.182, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [5, 5, 5]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: 'c_2010_x1/sun/pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	c_2012_s1: {
		groups: ['comets'],
		radius: 3.0,
		label: 'ISON (C/2012 S1)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun'],
			[440596867.184, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3, 3, 3]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: 'c_2012_s1/sun/pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	c_2013_a1: {
		groups: ['comets'],
		radius: 5.0,
		label: 'Siding Spring (C/2013 A1)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [5, 5, 5]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: 'c_2013_a1/sun/pos'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
			axisInFrameSpace: false,
			periodInHours: 8
		}]
	},
	c_2019_y4: {
		groups: ['comets'],
		radius: 3.0,
		label: 'ATLAS (C/2019 Y4)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3, 3, 3]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: 'c_2019_y4/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	c_2020_f3: {
		groups: ['comets'],
		radius: 6.0,
		label: 'NEOWISE (C/2020 F3)',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [6, 6, 6]
		},
		comet: {},
		controllers: [{
			type: 'dynamo',
			url: 'c_2020_f3/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
			axisInFrameSpace: false,
			periodInHours: 7.58
		}]
	}
});

// Default export to help with tree-shaking.



/***/ }),

/***/ "../pioneer/scripts/src/entities/comparison.js":
/*!*****************************************************!*\
  !*** ../pioneer/scripts/src/entities/comparison.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	rose_bowl: {
		groups: ['comparison'],
		radius: 0.15,
		label: 'Rose Bowl',
		parents: [],
		model: {
			url: '$STATIC_ASSETS_URL/models/comparison/rose_bowl/rose_bowl.gltf',
			rotate: [
				{ x: 90 },
				{ z: -90 }
			]
		},
		controllers: [{
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	school_bus: {
		groups: ['comparison'],
		radius: 0.0065,
		label: 'School bus',
		parents: [],
		model: {
			url: '$STATIC_ASSETS_URL/models/comparison/school_bus/school_bus.gltf',
			rotate: [
				{ x: 90 },
				{ z: -90 }
			]
		},
		controllers: [{
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	scientist: {
		groups: ['comparison'],
		radius: 0.000835,
		label: 'Scientist',
		parents: [],
		model: {
			url: '$STATIC_ASSETS_URL/models/comparison/scientist/scientist.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/earth_moon.js":
/*!*****************************************************!*\
  !*** ../pioneer/scripts/src/entities/earth_moon.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/** @module pioneer-scripts */


_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	moon: {
		groups: ['earth', 'moons'],
		radius: 1737.4,
		label: 'Moon',
		parents: [
			[Number.NEGATIVE_INFINITY, 'earth']
		],
		trail: {
			length: undefined,
			color: [0.0, 0.6, 0.8, 0.7]
		},
		spheroid: {
			equatorialRadius: 1737.4,
			polarRadius: 1737.4,
			planetographic: true
		},
		spheroidLOD: {
			features: ['normalMap', 'shadowEntities'],
			textures: {
				color: {
					url: 'moon/color_$SIZE_$FACE.png',
					sizes: [16, 512, 4096]
				},
				normal: {
					url: 'moon/normal_$SIZE_$FACE.png',
					sizes: [16, 512, 2048]
				}
			},
			shadowEntities: ['earth']
		},
		controllers: [{
			type: 'dynamo',
			url: 'moon/earth/orb'
		}, {
			type: 'dynamo',
			url: 'moon/ori'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/earth_spacecraft.js":
/*!***********************************************************!*\
  !*** ../pioneer/scripts/src/entities/earth_spacecraft.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var _entity_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity_utils */ "../pioneer/scripts/src/entities/entity_utils.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */




_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_3d_winds: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00200,
		extentsRadius: 0.00250,
		label: '3D-Winds',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5573.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_3d_winds'
		}]
	},
	sc_ace: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0008,
		extentsRadius: 0.0023,
		label: 'ACE',
		parents: [
			[265550465.18489534, 'earth'],
			[694267269.1839212, '']
		],
		trail: {
			length: 31715490.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ace/ace.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_ace',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.0033
		}]
	},
	sc_acrimsat: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0015,
		label: 'ACRIMSAT',
		parents: [
			[-963797, 'earth'],
			[459950467, ''] // End of mission
		],
		trail: {
			length: 5933.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_acrimsat/acrimsat.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_acrimsat'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.00238
		}]
	},
	sc_aim: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00070,
		extentsRadius: 0.0014,
		label: 'AIM',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5788.83
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_aim'
		}]
	},
	sc_aqua: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00400,
		extentsRadius: 0.015,
		label: 'Aqua',
		parents: [
			[73781738, 'earth']
		],
		trail: {
			length: 5933.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_aqua/Aqua.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_aqua'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_aqua',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_ascends: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'ASCENDS',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5573.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_ascends'
		}]
	},
	sc_aura: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.003450,
		extentsRadius: 0.017,
		label: 'Aura',
		parents: [
			[143161358, 'earth']
		],
		trail: {
			length: 5933.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_aura/Aura.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_aura'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_aura',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_c_nofs: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'C/NOFS',
		parents: [
			[352800006.1854904, 'earth'],
			[502051928.18300515, '']
		],
		trail: {
			length: 5573.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_c_nofs'
		}]
	},
	sc_calipso: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001650,
		extentsRadius: 0.005,
		label: 'CALIPSO',
		parents: [
			[199506047, 'earth']
		],
		trail: {
			length: 5933.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_calipso/calipso.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_calipso'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_calipso',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}]
	},
	sc_chandra: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0059,
		extentsRadius: 0.010,
		label: 'Chandra',
		parents: [
			[339465600, 'earth'],
			[709344000, '']
		],
		trail: {
			length: 228505.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_chandra/chandra.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_chandra/earth/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.70710678118, -0.70710678118, 0)
			}
		}]
	},
	sc_clarreo: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'CLARREO',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5573.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_clarreo'
		}]
	},
	sc_cloudsat: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0025,
		extentsRadius: 0.0025,
		label: 'CloudSat',
		parents: [
			[199491286, 'earth']
		],
		trail: {
			length: 5933.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cloudsat/CloudSat.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cloudsat'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cloudsat',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_cluster_ii_fm5: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001450,
		extentsRadius: 0.00435,
		label: 'Rumba',
		parents: [
			[19105314, 'earth']
		],
		trail: {
			length: 195541.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cluster_ii_fm5'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cluster_ii_fm5',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_cluster_ii_fm6: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001450,
		extentsRadius: 0.00435,
		label: 'Salsa',
		parents: [
			[17028089, 'earth']
		],
		trail: {
			length: 195351.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cluster_ii_fm6'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cluster_ii_fm6',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_cluster_ii_fm7: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001450,
		extentsRadius: 0.00435,
		label: 'Samba',
		parents: [
			[17028093, 'earth']
		],
		trail: {
			length: 195316.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cluster_ii_fm7'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cluster_ii_fm7',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_cluster_ii_fm8: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001450,
		extentsRadius: 0.00435,
		label: 'Tango',
		parents: [
			[19105052, 'earth']
		],
		trail: {
			length: 195388.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cluster_ii/cluster_ii.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cluster_ii_fm8'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cluster_ii_fm8',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_cygnss_1: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 1',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_1'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_2: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 2',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_3: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 3',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_3'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_3',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_4: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 4',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_4'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_4',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_5: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 5',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_5'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_5',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_6: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 6',
		parents: [
			[548415404.1851876, 'earth'],
			[722736069, '']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_6'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_6',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_7: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 7',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_7'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_7',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_cygnss_8: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0008,
		label: 'CYGNSS 8',
		parents: [
			[548415404.1851876, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cygnss/CYGNSS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cygnss_8'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_cygnss_8',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_dscovr: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00090,
		extentsRadius: 0.0020,
		label: 'DSCOVR',
		parents: [
			[476711467.18497694, 'earth']
		],
		trail: {
			length: 60 * 60 * 24 * 365
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_dscovr/dscovr.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_dscovr/earth/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_dscovr',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_eo_1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0030,
		extentsRadius: 0.0010,
		label: 'EO-1',
		parents: [
			[344589947.18311954, 'earth'],
			[544104069.186, '']
		],
		trail: {
			length: 5933.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_eo_1/eo-1.gltf',
			rotate: [
				{ y: 45 }
			],
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_eo_1'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_eo_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_explorer_1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0010,
		extentsRadius: 0.0010,
		label: 'Explorer 1',
		parents: [
			[-1322726967, 'earth'],
			[-939025103, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_explorer_1_v2/explorer_1.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_explorer_1/earth'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_explorer_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.000022
		}]
	},
	sc_face: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'FACE',
		parents: [
			[347025366.1839032, 'earth'],
			[631022168.1838934, '']
		],
		trail: {
			length: 5933.33
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_face'
		}]
	},
	sc_fgrst: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00140,
		extentsRadius: 0.0040,
		label: 'FGRST',
		parents: [
			[344589947.18311954, 'earth'],
			[661006268.1833516, '']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_fgrst'
		}]
	},
	sc_gacm: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'GACM',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_gacm'
		}]
		// mission is cancelled
	},
	sc_galex: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0010,
		extentsRadius: 0.00140,
		label: 'GALEX',
		parents: [
			[352800006.1854904, 'earth'],
			[425718607.184, '']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_galex'
		}]
	},
	sc_geo_cape: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'GEO-CAPE',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_geo_cape'
		}]
		// mission is cancelled
	},
	sc_geotail: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0018,
		extentsRadius: 0.003,
		label: 'Geotail',
		parents: [
			[-234758765, 'earth'],
			[722891591, '']
		],
		trail: {
			length: 450372.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_geotail/geotail.gltf',
			shadowEntities: ['earth']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_geotail/earth/orb'
		}, {
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.662, 0.749, 0, 0)
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis,
			periodInHours: 0.00083333333,
			relativeToTime: 0
		}]
	},
	sc_goes_12: {
		groups: ['earth', 'spacecraft'],
		radius: 0.003,
		label: 'GOES 12',
		parents: [
			[344589947.18311954, 'earth'],
			[661006268.1833516, '']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_goes_12'
		}]
	},
	sc_goes_13: {
		groups: ['earth', 'spacecraft'],
		radius: 0.003,
		label: 'GOES 13',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_goes_13'
		}]
	},
	sc_goes_14: {
		groups: ['earth', 'spacecraft'],
		radius: 0.003,
		label: 'GOES 14',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_goes_14'
		}]
	},
	sc_goes_15: {
		groups: ['earth', 'spacecraft'],
		radius: 0.003,
		label: 'GOES 15',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5733.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_goes_15'
		}]
	},
	sc_gpm: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0020,
		extentsRadius: 0.007,
		label: 'GPM',
		parents: [
			[629484755.7856493, 'earth']
		],
		trail: {
			length: 5549.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_gpm/GPM.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_gpm'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_gpm',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}],
		postCreateFunction: (entity) => {
			const spin = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpinController);
			spin.setJoint('GPM_antenna');
			spin.setRate(pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.degToRad(192));
			spin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg, true);
			spin.setClampedToRealTime(true);
		}
	},
	sc_grace_1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.0019,
		label: 'GRACE-1',
		parents: [
			[69656411.096817, 'earth'],
			[562382552.2587994, '']
		],
		trail: {
			length: 5575.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grace/grace.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_grace_1/earth/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sc_grace_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],
			update: (entity) => {
				const microwave = /** @type {Pioneer.ConnectedSpriteComponent} */(entity.getComponent('microwave'));
				const engine = entity.getScene().getEngine();
				const newOffset = pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.wrap(microwave.getTextureYOffset() - pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(engine.getTimeRate(), -1, +1) * engine.getDeltaTime(), 0, 1);
				microwave.setTextureYOffset(newOffset);
				const other = entity.getScene().getEntity('sc_grace_2');
				const shouldBeEnabled = other !== null && other.getPosition().distance(entity.getPosition()) <= 3929;
				if (shouldBeEnabled !== microwave.isEnabled()) {
					microwave.setEnabled(shouldBeEnabled);
				}
			}
		}],
		postCreateFunction: entity => {
			const microwave = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ConnectedSpriteComponent, 'microwave');
			microwave.setTextureUrl('$STATIC_ASSETS_URL/sprites/sine_wave.png');
			microwave.setEntity1('sc_grace_1');
			microwave.setEntity1Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, -0.00165, 0));
			microwave.setEntity2('sc_grace_2');
			microwave.setEntity2Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, -0.00165, 0));
			microwave.setWidths(0.0005, 0.0005);
			microwave.setColorMultiplier(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(0.5, 1.0, 1.0));
			microwave.setTextureRepeat(true);
			microwave.setTextureStretch(4);
		}
	},
	sc_grace_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.0019,
		label: 'GRACE-2',
		parents: [
			[69656411.096817, 'earth'],
			[562382552.2588, '']
		],
		trail: {
			length: 5575.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grace/grace.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_grace_2/earth/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sc_grace_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_grace_fo1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.0019,
		label: 'GRACE-FO 1',
		parents: [
			[580290547.185, 'earth']
		],
		trail: {
			length: 5575.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grace_fo/graceFO.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_grace_fo1'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sc_grace_fo2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],
			update: (entity) => {
				const microwave = /** @type {Pioneer.ConnectedSpriteComponent} */(entity.getComponent('microwave'));
				const engine = entity.getScene().getEngine();
				const newOffset = pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.wrap(microwave.getTextureYOffset() - pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.clamp(engine.getTimeRate(), -1, +1) * engine.getDeltaTime(), 0, 1);
				microwave.setTextureYOffset(newOffset);
				const other = entity.getScene().getEntity('sc_grace_fo2');
				const shouldBeEnabled = other !== null && other.getPosition().distance(entity.getPosition()) <= 3929;
				if (shouldBeEnabled !== microwave.isEnabled()) {
					const laser1 = /** @type {Pioneer.ConnectedSpriteComponent} */(entity.getComponent('laser1'));
					const laser2 = /** @type {Pioneer.ConnectedSpriteComponent} */(entity.getComponent('laser2'));
					microwave.setEnabled(shouldBeEnabled);
					laser1.setEnabled(shouldBeEnabled);
					laser2.setEnabled(shouldBeEnabled);
				}
			}
		}],
		postCreateFunction: entity => {
			const microwave = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ConnectedSpriteComponent, 'microwave');
			microwave.setTextureUrl('$STATIC_ASSETS_URL/sprites/sine_wave.png');
			microwave.setEntity1('sc_grace_fo1');
			microwave.setEntity1Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -0.00165));
			microwave.setEntity2('sc_grace_fo2');
			microwave.setEntity2Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -0.00165));
			microwave.setWidths(0.0005, 0.0005);
			microwave.setColorMultiplier(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(0.5, 1.0, 1.0));
			microwave.setTextureRepeat(true);
			microwave.setTextureStretch(4);

			const laser1 = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ConnectedSpriteComponent, 'laser1');
			laser1.setTextureUrl('$STATIC_ASSETS_URL/sprites/line.png');
			laser1.setEntity1('sc_grace_fo1');
			laser1.setEntity1Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(+0.0003, 0.00015, -0.00165));
			laser1.setEntity2('sc_grace_fo2');
			laser1.setEntity2Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.0003, 0.00015, -0.00165));
			laser1.setWidths(0.00002, 0.00002);
			laser1.setColorMultiplier(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(1, 0.24, 0.64));
			laser1.setTextureRepeat(false);

			const laser2 = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ConnectedSpriteComponent, 'laser2');
			laser2.setTextureUrl('$STATIC_ASSETS_URL/sprites/line.png');
			laser2.setEntity1('sc_grace_fo1');
			laser2.setEntity1Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.0003, 0.00015, -0.00165));
			laser2.setEntity2('sc_grace_fo2');
			laser2.setEntity2Offset(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(+0.0003, 0.00015, -0.00165));
			laser2.setWidths(0.00002, 0.00002);
			laser2.setColorMultiplier(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(1, 0.24, 0.64));
			laser2.setTextureRepeat(false);
		}
	},
	sc_grace_fo2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.0019,
		label: 'GRACE-FO 2',
		parents: [
			[580290547.185, 'earth']
		],
		trail: {
			length: 5575.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grace_fo/graceFO.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_grace_fo2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sc_grace_fo1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			}
		}]
	},
	sc_grifex: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.000150,
		extentsRadius: 0.00034,
		label: 'GRIFEX',
		parents: [
			[476542806.1849232, 'earth']
		],
		trail: {
			length: 5706.25
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grifex/grifex.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_grifex'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_grifex',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_hubble_space_telescope: {
		groups: ['earth', 'spacecraft', 'telescope'],
		occlusionRadius: 0.0066,
		extentsRadius: 0.0066,
		label: 'Hubble',
		parents: [
			[-305719099.92837775, 'earth']
		],
		trail: {
			length: 5748.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_hubble/Hubble.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_hubble_space_telescope/earth/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_hubble_space_telescope',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}]
	},
	sc_hyspiri: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.004,
		extentsRadius: 0.012,
		label: 'HyspIRI',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5733.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_hyspiri/HyspIRI.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_hyspiri'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_hyspiri',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_ibex: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0005,
		extentsRadius: 0.001,
		label: 'IBEX',
		parents: [
			[277718464.1823969, 'earth']
		],
		trail: {
			length: 797489.16
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ibex/iBEX.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_ibex',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis,
			periodInHours: 0.00416
		}]
	},
	sc_icesat_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00198,
		extentsRadius: 0.0065,
		label: 'ICESat-2',
		parents: [
			[590288589.182, 'earth']
		],
		trail: {
			length: 5653.2
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_icesatii/ICESat2.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_icesat_2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_icesat_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_image: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00113,
		extentsRadius: 0.006,
		label: 'IMAGE',
		// Boom is 500 meters long!  Does not appear in explorer.
		parents: [
			[7288547.186, 'earth'],
			[188163587.1835355, '']
		],
		trail: {
			length: 55541
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_image/image.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_image'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_image',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_integral: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0025,
		extentsRadius: 0.005,
		label: 'INTEGRAL',
		parents: [
			[367498866.18276465, 'earth']
		],
		trail: {
			length: 229689.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_integral'
		}]
	},
	sc_ipex: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0001,
		extentsRadius: 0.00015,
		label: 'IPEX',
		parents: [
			[439586087.183, 'earth']
		],
		trail: {
			length: 5862.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ipex/IPEX.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_ipex'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_ipex',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_isas: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001,
		extentsRadius: 0.0015,
		label: 'ISAS',
		parents: [
			[-186102945.06492478, 'earth'],
			[-183424845.06434903, '']
		],
		trail: {
			length: 92680.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_isas/isas.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_isas',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_isas',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_iss: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.008,
		extentsRadius: 0.072,
		label: 'ISS',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_iss/ISS_stationary.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_iss'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_iss',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}],
		postCreateFunction: (entity) => {
			const vectorForAlphaGimbal = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0.5, 0.5 * Math.sqrt(3.0));
			const vectorForBetaGimbalAxis = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0.5 * Math.sqrt(3.0), -0.5);
			const vectorForBetaGimbalPoint = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0.5, 0.5 * Math.sqrt(3.0));

			// Align the right solar panel alpha gimbal to the sun.
			let align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('20_P4_Truss');
			align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis);
			align.setSecondaryAxis(vectorForAlphaGimbal);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the left solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('23_S4_Truss');
			align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis);
			align.setSecondaryAxis(vectorForAlphaGimbal);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('20_P4_Truss_01');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('20_P4_Truss_02');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('23_S4_Truss_01');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('23_S4_Truss_02');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('32_S6_Truss_01');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('32_S6_Truss_02');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('08_P6_Truss_01');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Align the right solar panel alpha gimbal to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
			align.setJoint('08_P6_Truss_02');
			align.setPrimaryAxis(vectorForBetaGimbalAxis);
			align.setSecondaryAxis(vectorForBetaGimbalPoint);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');

			// Make RapidScat antenna spin.
			const rapidScatSpin = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpinController);
			rapidScatSpin.setJoint('RapidScat_dish');
			rapidScatSpin.setRate(pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.degToRad(108));
			rapidScatSpin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis, true);
			rapidScatSpin.setClampedToRealTime(true);
			rapidScatSpin.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Interval(465418867.184, 524890952.183)); // Lost power at 2016-08-19T15:01:24.

			// Show ECOSTRESS only when mounted.
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.showSubObjectDuringInterval(entity, 'Ecostress', 584127348, Number.POSITIVE_INFINITY);

			// Show EMIT only when mounted.
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.showSubObjectDuringInterval(entity, 'EMIT', 711345507, Number.POSITIVE_INFINITY);

			// Show OCO-3 only when mounted.
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.showSubObjectDuringInterval(entity, 'OCO3', 610718469, Number.POSITIVE_INFINITY);

			// Show RapidScat only when mounted.
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.showSubObjectDuringInterval(entity, '45_RapidScat', 465418867.184, 575406069.184);
		}
	},
	sc_iss_ecostress: {
		groups: ['instrument', 'sc_iss'],
		occlusionRadius: 0.001,
		extentsRadius: 0.0012,
		label: 'ECOSTRESS',
		parents: [
			[584127348, 'sc_iss']
		],
		controllers: [{
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.0200195, -0.00202631, 0.0161099),
			coverage: [584127348, Number.POSITIVE_INFINITY]
		}],
		postCreateFunction: (entity) => {
			const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RotateByEntityOrientationController);
			rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Interval(584127348, Number.POSITIVE_INFINITY));
		}
	},
	sc_iss_emit: {
		groups: ['instrument', 'sc_iss'],
		occlusionRadius: 0.0008,
		extentsRadius: 0.0013,
		label: 'EMIT',
		parents: [
			[711345507, 'sc_iss']
		],
		controllers: [{
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.024, -0.00225, 0.00325),
			coverage: [711345507, Number.POSITIVE_INFINITY]
		}],
		postCreateFunction: (entity) => {
			const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RotateByEntityOrientationController);
			rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Interval(711345507, Number.POSITIVE_INFINITY));
		}
	},
	sc_iss_oco_3: {
		groups: ['instrument', 'sc_iss'],
		occlusionRadius: 0.0008,
		extentsRadius: 0.0012,
		label: 'OCO-3',
		parents: [
			[610718469, 'sc_iss']
		],
		controllers: [{
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.0156458, -0.00195982, 0.0200232),
			coverage: [610718469, Number.POSITIVE_INFINITY]
		}],
		postCreateFunction: (entity) => {
			const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RotateByEntityOrientationController);
			rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Interval(610718469, Number.POSITIVE_INFINITY));
		}
	},
	sc_iss_rapidscat: {
		groups: ['instrument', 'sc_iss'],
		occlusionRadius: 0.0008,
		extentsRadius: 0.0002,
		label: 'RapidScat',
		parents: [
			[465418867.184, 'sc_iss'],
			[575406069.184, '']
		],
		controllers: [{
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.0100725, -0.00133401, 0.0162145),
			coverage: [465418867.184, 575406069.184]
		}],
		postCreateFunction: (entity) => {
			const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RotateByEntityOrientationController);
			rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Interval(465418867.184, 575406069.184));
		}
	},
	sc_ixpe: {
		groups: ['earth', 'spacecraft', 'telescope'],
		occlusionRadius: 0.0055,
		extentsRadius: 0.0026,
		label: 'IXPE',
		parents: [
			[692324766.6007013, 'earth']
		],
		trail: {
			length: 5400
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ixpe/ixpe.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_ixpe'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	sc_jason_1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0014,
		extentsRadius: 0.004,
		label: 'Jason-1',
		parents: [
			[352800006.1854904, 'earth'],
			[458074266.1839004, '']
		],
		trail: {
			length: 6744.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ostm/ostm.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_jason_1',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_jason_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_jason_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0014,
		extentsRadius: 0.004,
		label: 'OSTM/Jason-2',
		parents: [
			[344589947.18311954, 'earth'],
			[623851269.182, '']
		],
		trail: {
			length: 6744.25
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ostm/ostm.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_jason_2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_jason_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_jason_3: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0014,
		extentsRadius: 0.004,
		label: 'Jason-3',
		parents: [
			[506497796.18443054, 'earth']
		],
		trail: {
			length: 6721.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ostm/ostm.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_jason_3'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_jason_3',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_jwst: {
		groups: ['earth', 'spacecraft'],
		radius: 0.010,
		label: 'James Webb Space Telescope',
		parents: [
			[693708549.184, 'earth']
		],
		trail: {
			length: 5900033.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_jwst/webb_deployed.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_jwst/earth/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'align',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, 694937889.184],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/sc_jwst/webb_stowed.gltf');
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/sc_jwst/webb_deployed.gltf');
			}
		}]
	},
	sc_landsat_5: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'Landsat 5',
		parents: [
			[352800006.1854904, 'earth'],
			[473889066.18410677, '']
		],
		trail: {
			length: 5933.33
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_landsat_5'
		}]
	},
	sc_landsat_7: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.004,
		extentsRadius: 0.012,
		label: 'Landsat 7',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_landsat_7/LandSat7.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_landsat_7'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_landsat_7',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_landsat_8: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.004,
		extentsRadius: 0.0095,
		label: 'Landsat 8',
		parents: [
			[413877787.185, 'earth']
		],
		trail: {
			length: 5933.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_landsat_8/LandSat8.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_landsat_8'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_landsat_8',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}]
	},
	sc_landsat_9: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.004,
		extentsRadius: 0.015,
		label: 'Landsat 9',
		parents: [
			[686043940.723348, 'earth']
		],
		trail: {
			length: 5933.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_landsat_9/Landsat9.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_landsat_9'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_landsat_9',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_list: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'LIST',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5933.33
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_list'
		}]
	},
	sc_m_cubed: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0001,
		label: 'M-Cubed',
		parents: [
			[373032066.182, 'earth']
		],
		trail: {
			length: 5768.333333333333
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_m_cubed/mCubed.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_m_cubed'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_m_cubed',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_mcubed_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0001,
		extentsRadius: 0.0002,
		label: 'MCubed-2',
		parents: [
			[439560067.183, 'earth']
		],
		trail: {
			length: 5861.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mcubed_2/M-Cubed2.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mcubed_2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_mcubed_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_mms_1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0017,
		extentsRadius: 0.013,
		label: 'MMS 1',
		parents: [
			[479519767.1855569, 'earth']
		],
		trail: {
			length: 85994.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mms_1'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.00556
		}]
	},
	sc_mms_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0017,
		extentsRadius: 0.013,
		label: 'MMS 2',
		parents: [
			[479519767.1855569, 'earth']
		],
		trail: {
			length: 85962.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mms_2'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.00556
		}]
	},
	sc_mms_3: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0017,
		extentsRadius: 0.013,
		label: 'MMS 3',
		parents: [
			[479519767.1855569, 'earth']
		],
		trail: {
			length: 86347.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mms_3'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.00556
		}]
	},
	sc_mms_4: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0017,
		extentsRadius: 0.013,
		label: 'MMS 4',
		parents: [
			[479519767.1855569, 'earth']
		],
		trail: {
			length: 86024.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mms/MMS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mms_4'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg,
			periodInHours: 0.00556
		}]
	},
	sc_nisar: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.006,
		extentsRadius: 0.017,
		label: 'NISAR',
		parents: [
			[757339269, 'earth']
		],
		trail: {
			length: 5573.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_nisar/Nisar.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'orbitalElements',
			eccentricity: 0,
			semiMajorAxis: 7118,
			meanAngularMotion: 0.0011382582,
			meanAnomalyAtEpoch: 0,
			inclination: Math.PI / 180 * 98.5,
			longitudeOfAscendingNode: 0,
			argumentOfPeriapsis: 0,
			coverage: [757339269, Number.POSITIVE_INFINITY]
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_nisar',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_noaa_14: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'NOAA 14',
		parents: [
			[344589947.18311954, 'earth'],
			[661006268.1833516, '']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_noaa_14'
		}]
	},
	sc_noaa_15: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'NOAA 15',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_noaa_15'
		}]
	},
	sc_noaa_16: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'NOAA 16',
		parents: [
			[344589947.18311954, 'earth'],
			[661006268.1833516, '']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_noaa_16'
		}]
	},
	sc_noaa_17: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'NOAA 17',
		parents: [
			[344589947.18311954, 'earth'],
			[661006268.1833516, '']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_noaa_17'
		}]
	},
	sc_noaa_18: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'NOAA 18',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_noaa_18'
		}]
	},
	sc_noaa_19: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'NOAA 19',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_noaa_19'
		}]
	},
	sc_nustar: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.006,
		extentsRadius: 0.006,
		label: 'NuSTAR',
		parents: [
			[392875303.185, 'earth']
		],
		trail: {
			length: 5798.66
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_nustar/nustar.gltf',
			shadowEntities: ['earth']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_nustar'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis,
				target: 'sun',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_oco_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0021,
		extentsRadius: 0.004,
		label: 'OCO-2',
		parents: [
			[457567050.184, 'earth']
		],
		trail: {
			length: 5933.333333333333
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_oco_2/oco2.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_oco_2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}]
	},
	sc_path: {
		// mission cancelled
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'PATH',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_path'
		}]
	},
	sc_polar: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0012,
		extentsRadius: 0.005,
		label: 'Polar',
		parents: [
			[-121608237.81469652, 'earth'],
			[262612565.1855274, '']
		],
		trail: {
			length: 66571.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_polar/polar.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_polar',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_polar',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_quikscat: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0016,
		extentsRadius: 0.0018,
		label: 'QuikSCAT',
		parents: [
			[344589947.18311954, 'earth'],
			[591710469.182, '']
		],
		trail: {
			length: 6061.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_quikscat/QuikSCAT.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_quikscat'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_quikscat',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_race: {
		groups: ['earth', 'spacecraft'],
		radius: 0.00015,
		label: 'RACE',
		parents: [
			[467726467.182, 'earth'],
			[467812867.182, '']
		],
		trail: {
			length: 5933.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_race'
		}]
	},
	sc_raincube: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00035,
		extentsRadius: 0.0005,
		label: 'RainCube',
		parents: [
			[608189026.1856545, 'earth'],
			[662040069.184, '']
		],
		trail: {
			length: 5743.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_raincube/Raincube.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_raincube'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_raincube',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_rax_2: {
		groups: ['earth', 'spacecraft'],
		radius: 0.0002,
		label: 'RAX-2',
		parents: [
			[373067348.182, 'earth'],
			[418824067.186, '']
		],
		trail: {
			length: 5743.0
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_rax_2'
		}]
	},
	sc_rbsp_a: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'Van Allen Probe A',
		parents: [
			[399585967.183, 'earth'],
			[624628869.182, '']
		],
		trail: {
			length: 32214.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_rbsp/rbsp.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_rbsp_a'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_rbsp_a',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_rbsp_b: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'Van Allen Probe B',
		parents: [
			[399585967.183, 'earth'],
			[616766469.184, '']
		],
		trail: {
			length: 32574.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_rbsp/rbsp.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_rbsp_b'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_rbsp_b',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_sac_d: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.003,
		extentsRadius: 0.0045,
		label: 'Aquarius',
		parents: [
			[360987666.185, 'earth'],
			[486907267.185, '']
		],
		trail: {
			length: 5884.25
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_sac_d/aquarius.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_sac_d'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_sac_d',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}]
	},
	sc_sclp: {
		groups: ['earth', 'spacecraft'],
		radius: 0.004,
		label: 'SCLP',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5933
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_sclp'
		}]
	},
	sc_sdo: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0022,
		extentsRadius: 0.00315,
		label: 'SDO',
		parents: [
			[505918808.18474686, 'earth']
		],
		trail: {
			length: 86137.66
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_sdo/sdo.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_sdo'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_sdo',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_sentinel_6: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0026,
		extentsRadius: 0.0031,
		label: 'Sentinel-6 Michael Freilich',
		parents: [
			[659322339.7879795, 'earth']
		],
		trail: {
			length: 5933.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_sentinel_6/Sentinel6.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_sentinel_6'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_sentinel_6',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_smap: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.003,
		extentsRadius: 0.009,
		label: 'SMAP',
		parents: [
			[476542806.1849232, 'earth']
		],
		trail: {
			length: 5906.8
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_smap/SMAP.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_smap'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_smap',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}],
		postCreateFunction: (entity) => {
			const spin = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpinController);
			spin.setJoint('arm_etc');
			spin.setRate(pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.degToRad(87.6));
			spin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis, true);
			spin.setClampedToRealTime(true);
		}
	},
	sc_soho: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00215,
		extentsRadius: 0.00425,
		label: 'SOHO',
		parents: [
			[265550465.18489534, 'earth']
		],
		trail: {
			length: 60 * 60 * 24 * 365
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_soho/soho.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_soho',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_soho',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_sorce: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.001,
		extentsRadius: 0.0022,
		label: 'SORCE',
		parents: [
			[344589947.18311954, 'earth'],
			[635860869.185, '']
		],
		trail: {
			length: 5812.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_sorce/sorce.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_sorce'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_sorce',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_starling_1: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00023,
		extentsRadius: 0.00076,
		label: 'Starling-1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'earth']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_starling/starling.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_starling_1'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_starling_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_starling_2: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00023,
		extentsRadius: 0.00076,
		label: 'Starling-2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'earth']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_starling/starling.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_starling_2'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_starling_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_starling_3: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00023,
		extentsRadius: 0.00076,
		label: 'Starling-3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'earth']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_starling/starling.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_starling_3'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_starling_3',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_starling_4: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00023,
		extentsRadius: 0.00076,
		label: 'Starling-4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'earth']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_starling/starling.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_starling_4'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_starling_4',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis
			}
		}]
	},
	sc_suomi_npp: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0022,
		extentsRadius: 0.008,
		label: 'Suomi NPP',
		parents: [
			[373067348.01, 'earth']
		],
		trail: {
			length: 5798.66
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_npp/NPP.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_suomi_npp'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_suomi_npp',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}]
	},
	sc_swift: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0028,
		extentsRadius: 0.0028,
		label: 'Swift',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_swift'
		}]
	},
	sc_swot: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.005,
		extentsRadius: 0.009,
		label: 'SWOT',
		parents: [
			[347025366.1839032, 'earth']
		],
		trail: {
			length: 5933
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_swot_v2/swot.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_swot'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_swot',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_tdrs_3: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 3',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86137.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_3'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_5: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 5',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86137.66
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_5'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_6: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 6',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86137.66
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_6'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_7: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 7',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86151.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_7'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_8: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 8',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86151.2
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_8'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_9: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 9',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86151.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_9'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_10: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 10',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 86151.2
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_10'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_11: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 11',
		parents: [
			[412868947.185, 'earth']
		],
		trail: {
			length: 86151.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_11'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_12: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 12',
		parents: [
			[443808067.185, 'earth']
		],
		trail: {
			length: 86151.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_12'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_tdrs_13: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.0085,
		label: 'TDRS 13',
		parents: [
			[556338669.183, 'earth']
		],
		trail: {
			length: 86151.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tdrs/tdrs.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tdrs_13'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}]
	},
	sc_terra: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0034,
		extentsRadius: 0.012,
		label: 'Terra',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933.33
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_terra/Terra.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_terra'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_terra',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_tess: {
		groups: ['earth', 'spacecraft', 'telescope'],
		occlusionRadius: 0.002,
		extentsRadius: 0.003,
		label: 'TESS',
		parents: [
			[577366932.3626, 'earth']
		],
		trail: {
			length: 591840
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_tess/TESS.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_tess/earth/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	sc_themis_a: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.000400,
		extentsRadius: 0.00170,
		label: 'THEMIS A',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 98428.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_themis/themis.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_themis_a'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis,
			periodInHours: 0.0008333
		}]
	},
	sc_themis_d: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.000400,
		extentsRadius: 0.00170,
		label: 'THEMIS D',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 114807.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_themis/themis.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_themis_d'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis,
			periodInHours: 0.0008333
		}]
	},
	sc_themis_e: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.000400,
		extentsRadius: 0.00170,
		label: 'THEMIS E',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 105907.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_themis/themis.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_themis_e'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis,
			periodInHours: 0.0008333
		}]
	},
	sc_timed: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.005,
		label: 'TIMED',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5933
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_timed'
		}]
	},
	sc_trmm: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.002550,
		extentsRadius: 0.0073,
		label: 'TRMM',
		parents: [
			[-66052736.817, 'earth'],
			[482328067.186, '']
		],
		trail: {
			length: 5545.6
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_trmm/TRMM.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'orbitalElements',
			eccentricity: 0.00111201719,
			semiMajorAxis: 6744.5,
			meanAngularMotion: 0.0011382582,
			meanAnomalyAtEpoch: 0,
			inclination: Math.PI / 180 * 30,
			longitudeOfAscendingNode: 0,
			argumentOfPeriapsis: 0,
			coverage: [-66052736.817, 482328067.186]
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_trmm',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_uars: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00535,
		extentsRadius: 0.00535,
		label: 'UARS',
		parents: [
			[352800006.1854904, 'earth'],
			[370106644.184, '']
		],
		trail: {
			length: 5490.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_uars',
			dataType: 'pos'
		}]
	},
	sc_wind: {
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.00120,
		extentsRadius: 0.00750,
		label: 'WIND',
		parents: [
			[543931270, 'earth']
		],
		trail: {
			length: 16485927.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_wind/wind.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_wind/earth/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'velocity',
				target: 'sc_wind',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}]
	},
	sc_wise: {
		// no model at all, 2D still in explorer
		groups: ['earth', 'spacecraft'],
		occlusionRadius: 0.0014200,
		extentsRadius: 0.001420,
		label: 'WISE',
		parents: [
			[344589947.18311954, 'earth']
		],
		trail: {
			length: 5715.4
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_wise'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/entity_utils.js":
/*!*******************************************************!*\
  !*** ../pioneer/scripts/src/entities/entity_utils.js ***!
  \*******************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "EntityUtils": function() { return /* binding */ EntityUtils; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");


/**
 * A collection of utilities for entity creation.
 */
class EntityUtils {
	/**
	 * Adds a geyser to an entity.
	 * @param {Pioneer.Entity} entity
	 * @param {number} size
	 * @param {number} alpha
	 * @param {number} particleNumber
	 * @param {number} speed
	 * @param {number} spread
	 * @param {number[]} position
	 * @param {number[] | undefined} direction
	 */
	static addGeyser(entity, size, alpha, particleNumber, speed, spread, position, direction) {
		const particleSpray = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ParticleSprayComponent);
		particleSpray.setNumberOfParticles(particleNumber);
		particleSpray.setSizeOfParticles(0.25 * size * spread);
		particleSpray.setSpeedOfParticles(speed * size);
		particleSpray.setColorOfParticles(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 0.5 * alpha));
		particleSpray.setSpread(1 * spread);
		particleSpray.setParticleSpacingRandom(false);
		particleSpray.setLength(2.5 * size);
		particleSpray.setOriginOffset(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(position[0], position[1], position[2]));
		particleSpray.setDirection(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(direction[0], direction[1], direction[2]));
	}

	/**
	 * Shows the subobject of an entity only during the given interval.
	 * @param {Pioneer.Entity} entity
	 * @param {string} subObjectName
	 * @param {number} startTime
	 * @param {number} endTime
	 */
	static showSubObjectDuringInterval(entity, subObjectName, startTime, endTime) {
		const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent);
		model.setHiddenObject(subObjectName, true);
		const coverageController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CoverageController);
		coverageController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(startTime, endTime));
		coverageController.setEnterFunction((entity) => {
			const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent);
			model.setHiddenObject(subObjectName, false);
		});
		coverageController.setExitFunction((entity) => {
			const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent);
			model.setHiddenObject(subObjectName, true);
		});
	}
}


/***/ }),

/***/ "../pioneer/scripts/src/entities/jupiter_irregular_moons.js":
/*!******************************************************************!*\
  !*** ../pioneer/scripts/src/entities/jupiter_irregular_moons.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	aitne: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.5,
		label: 'Aitne',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'aitne/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	ananke: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 14.0,
		label: 'Ananke',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [14, 14, 14],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ananke/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	aoede: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 2.0,
		label: 'Aoede',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'aoede/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	arche: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.5,
		label: 'Arche',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'arche/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	autonoe: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 2.0,
		label: 'Autonoe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'autonoe/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	callirrhoe: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 4.3,
		label: 'Callirrhoe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [4.3, 4.3, 4.3],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'callirrhoe/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	carme: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 23.0,
		label: 'Carme',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [23, 23, 23],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'carme/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	carpo: {
		groups: ['jupiter', 'moons', 'irregular'],
		radius: 1.5,
		label: 'Carpo',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'carpo/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	chaldene: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.9,
		label: 'Chaldene',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.9, 1.9, 1.9],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'chaldene/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	cyllene: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1.0,
		label: 'Cyllene',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'cyllene/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	dia: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 2,
		label: 'Dia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: 2,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'dia/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	eirene: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 2,
		label: 'Eirene',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 2,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'eirene/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	elara: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 43.0,
		label: 'Elara',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [43, 43, 43],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'elara/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	erinome: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.6,
		label: 'Erinome',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.6, 1.6, 1.6],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'erinome/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	ersa: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 1.5,
		label: 'Ersa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 1.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ersa/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	euanthe: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1.5,
		label: 'Euanthe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'euanthe/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	eukelade: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 2.0,
		label: 'Eukelade',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'eukelade/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	eupheme: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'Eupheme',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'eupheme/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	euporie: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1.0,
		label: 'Euporie',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'euporie/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	eurydome: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1.5,
		label: 'Eurydome',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'eurydome/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	harpalyke: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 2.2,
		label: 'Harpalyke',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.2, 2.2, 2.2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'harpalyke/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	hegemone: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1.5,
		label: 'Hegemone',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'hegemone/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	helike: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 2.0,
		label: 'Helike',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'helike/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	hermippe: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 2.0,
		label: 'Hermippe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'hermippe/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	herse: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.0,
		label: 'Herse',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'herse/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	himalia: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 85.0,
		label: 'Himalia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [85, 85, 85],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'himalia/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	iocaste: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 2.6,
		label: 'Iocaste',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.6, 2.6, 2.6],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'iocaste/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	isonoe: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.9,
		label: 'Isonoe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.9, 1.9, 1.9],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'isonoe/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_li: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'Jupiter LI',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_li/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lii: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 0.5,
		label: 'Jupiter LII',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lii/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_liv: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 0.5,
		label: 'Jupiter LIV',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_liv/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lv: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'Jupiter LV',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lv/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lvi: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 0.5,
		label: 'Jupiter LVI',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lvi/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lix: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1,
		label: 'Jupiter LIX',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lix/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxi: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'Jupiter LXI',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxi/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxiii: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'Jupiter LXIII',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxiii/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxiv: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'Jupiter LXIV',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxiv/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxvi: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'Jupiter LXVI',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxvi/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxvii: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1,
		label: 'Jupiter LXVII',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxvii/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxviii: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'Jupiter LXVIII',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxviii/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxix: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'Jupiter LXIX',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxix/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxx: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1.5,
		label: 'Jupiter LXX',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxx/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	jupiter_lxxii: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'Jupiter LXXII',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter_lxxii/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kale: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.0,
		label: 'Kale',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kale/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kallichore: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.0,
		label: 'Kallichore',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kallichore/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kalyke: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 2.6,
		label: 'Kalyke',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.6, 2.6, 2.6],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kalyke/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kore: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1.0,
		label: 'Kore',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kore/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	leda: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 10.0,
		label: 'Leda',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [10, 10, 10],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'leda/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	lysithea: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 18.0,
		label: 'Lysithea',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [18, 18, 18],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'lysithea/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	megaclite: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 2.7,
		label: 'Megaclite',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.7, 2.7, 2.7],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'megaclite/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	mneme: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1.0,
		label: 'Mneme',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'mneme/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	orthosie: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1.0,
		label: 'Orthosie',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'orthosie/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	pandia: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 1.5,
		label: 'Pandia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 1.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'pandia/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	pasiphae: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 30.0,
		label: 'Pasiphae',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [30, 30, 30],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'pasiphae/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	pasithee: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1.0,
		label: 'Pasithee',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'pasithee/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	philophrosyne: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1,
		label: 'Philophrosyne',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'philophrosyne/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	praxidike: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 3.4,
		label: 'Praxidike',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [3.4, 3.4, 3.4],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'praxidike/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_2: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'S/2003 J 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_2/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_4: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1,
		label: 'S/2003 J 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_4/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_9: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'S/2003 J 9',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_9/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_10: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'S/2003 J 10',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_10/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_12: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 0.5,
		label: 'S/2003 J 12',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_12/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_16: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'S/2003 J 16',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_16/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_23: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1,
		label: 'S/2003 J 23',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_23/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2003_j_24: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'S/2003 J 24',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2003_j_24/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2011_j_3: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 1.5,
		label: 'S/2011 J 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2011_j_3/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2016_j_3: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'S/2016 J 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2016_j_3/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2016_j_4: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 0.5,
		label: 'S/2016 J 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2016_j_4/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2018_j_2: {
		groups: ['jupiter', 'moons', 'irregular', 'himalia'],
		radius: 1.5,
		label: 'S/2018 J 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2018_j_2/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2018_j_3: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'S/2018 J 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2018_j_3/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2018_j_4: {
		groups: ['jupiter', 'moons', 'irregular', 'carpo'],
		radius: 1,
		label: 'S/2018 J 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2018_j_4/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2021_j_1: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 0.5,
		label: 'S/2021 J 1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2021_j_1/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2021_j_2: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'S/2021 J 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2021_j_2/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2021_j_3: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1,
		label: 'S/2021 J 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2021_j_3/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2021_j_4: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'S/2021 J 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2021_j_4/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2021_j_5: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 1,
		label: 'S/2021 J 5',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2021_j_5/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2021_j_6: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'S/2021 J 6',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2021_j_6/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2022_j_1: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'S/2022 J 1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2022_j_1/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2022_j_2: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 0.5,
		label: 'S/2022 J 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2022_j_2/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2022_j_3: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 0.5,
		label: 'S/2022 J 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2022_j_3/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sinope: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 19.0,
		label: 'Sinope',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [19, 19, 19],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sinope/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sponde: {
		groups: ['jupiter', 'moons', 'irregular', 'pasiphae'],
		radius: 1.0,
		label: 'Sponde',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sponde/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	taygete: {
		groups: ['jupiter', 'moons', 'irregular', 'carme'],
		radius: 2.5,
		label: 'Taygete',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.5, 2.5, 2.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'taygete/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	thelxinoe: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 1.0,
		label: 'Thelxinoe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1, 1, 1],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'thelxinoe/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	themisto: {
		groups: ['jupiter', 'moons', 'irregular'],
		radius: 4.0,
		label: 'Themisto',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [4, 4, 4],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'themisto/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	thyone: {
		groups: ['jupiter', 'moons', 'irregular', 'ananke'],
		radius: 2.0,
		label: 'Thyone',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'thyone/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	valetudo: {
		groups: ['jupiter', 'moons', 'irregular'],
		radius: 0.5,
		label: 'Valetudo',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.5,
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'valetudo/jupiter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/jupiter_regular_moons.js":
/*!****************************************************************!*\
  !*** ../pioneer/scripts/src/entities/jupiter_regular_moons.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/** @module pioneer-scripts */


_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	adrastea: {
		groups: ['jupiter', 'moons', 'amalthea', 'inner', 'regular'],
		radius: 8.2,
		label: 'Adrastea',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [8.2, 8.2, 8.2],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'adrastea/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'adrastea/ori'
		}]
	},
	amalthea: {
		groups: ['jupiter', 'moons', 'amalthea', 'inner', 'regular'],
		radius: 83.5,
		label: 'Amalthea',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [83.5, 83.5, 83.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'amalthea/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'amalthea/ori'
		}]
	},
	callisto: {
		groups: ['jupiter', 'moons', 'main', 'galilean', 'regular'],
		radius: 2410.3,
		label: 'Callisto',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		spheroid: {
			equatorialRadius: 2410.3,
			polarRadius: 2410.3,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'callisto/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			},
			shadowEntities: ['jupiter', 'io', 'europa', 'ganymede']
		},
		controllers: [{
			type: 'dynamo',
			url: 'callisto/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'callisto/ori'
		}]
	},
	europa: {
		groups: ['jupiter', 'moons', 'main', 'galilean', 'regular'],
		radius: 1569.0,
		label: 'Europa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		spheroid: {
			equatorialRadius: 1569.0,
			polarRadius: 1569.0,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'europa/color_$SIZE_$FACE.png',
					sizes: [4, 512, 1024]
				}
			},
			shadowEntities: ['jupiter', 'io', 'callisto', 'ganymede']
		},
		controllers: [{
			type: 'dynamo',
			url: 'europa/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'europa/ori'
		}]
	},
	ganymede: {
		groups: ['jupiter', 'moons', 'main', 'galilean', 'regular'],
		radius: 2634.1,
		label: 'Ganymede',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		spheroid: {
			equatorialRadius: 2634.1,
			polarRadius: 2634.1,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'ganymede/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			},
			shadowEntities: ['jupiter', 'io', 'europa', 'callisto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ganymede/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'ganymede/ori'
		}]
	},
	io: {
		groups: ['jupiter', 'moons', 'main', 'galilean', 'regular'],
		radius: 1821.3,
		label: 'Io',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		spheroid: {
			equatorialRadius: 1821.3,
			polarRadius: 1821.3,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'io/color_$SIZE_$FACE.png',
					sizes: [4, 512, 1024]
				}
				// I believe there is a heightmap version as well, but the min-to-max radius is not noticable
			},
			shadowEntities: ['jupiter', 'europa', 'ganymede', 'callisto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'io/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'io/ori'
		}]
	},
	metis: {
		groups: ['jupiter', 'moons', 'amalthea', 'inner', 'regular'],
		radius: 21.5,
		label: 'Metis',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [21.5, 21.5, 21.5],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'metis/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'metis/ori'
		}]
	},
	thebe: {
		groups: ['jupiter', 'moons', 'amalthea', 'inner', 'regular'],
		radius: 49.0,
		label: 'Thebe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'jupiter']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [49, 49, 49],
			shadowEntities: ['jupiter']
		},
		controllers: [{
			type: 'dynamo',
			url: 'thebe/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'thebe/ori'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/lunar_spacecraft.js":
/*!***********************************************************!*\
  !*** ../pioneer/scripts/src/entities/lunar_spacecraft.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_apollo_15: {
		groups: ['moon', 'spacecraft'],
		radius: 0.004,
		label: 'Apollo 15',
		parents: [
			[-897044358.3260887, 'moon'],
			[-896822958.3195117, '']
		],
		trail: {
			length: 6855.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_apollo_15',
			dataType: 'pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sc_artemis_1: {
		groups: ['moon', 'spacecraft'],
		radius: 0.005,
		label: 'Artemis I',
		parents: [
			[721860361, 'earth'],
			[724052473, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_artemis_1/artemis_cmsm.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_artemis_1/earth/pos'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_artemis_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_capstone: {
		groups: ['moon', 'spacecraft'],
		radius: 0.0005,
		label: 'CAPSTONE',
		parents: [
			[710192447.9999855, 'earth'],
			[721583059, 'moon']
		],
		trail: {
			length: undefined,
			lengthCoverages: [
				[4000000, Number.NEGATIVE_INFINITY, 721583059],
				[1210909, 721583059, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_capstone/capstone.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_capstone/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_capstone/moon/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'align',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_clementine: {
		groups: ['moon', 'spacecraft'],
		radius: 0.002,
		label: 'Clementine',
		parents: [
			[-187185539.81536362, 'moon'],
			[-178496939.81459716, '']
		],
		trail: {
			length: 5408.5
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_clementine/clementine.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_clementine/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_grail_a: {
		groups: ['moon', 'spacecraft'],
		radius: 0.001,
		label: 'Ebb',
		parents: [
			[368763000, 'moon'],
			[414201667.18513304, '']
		],
		trail: {
			length: 41115.75
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grail/grail_b.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_grail_a/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_grail_a',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_grail_b: {
		groups: ['moon', 'spacecraft'],
		radius: 0.001,
		label: 'Flow',
		parents: [
			[368763000, 'moon'],
			[414201667.18513304, '']
		],
		trail: {
			length: 41239.8
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_grail/grail_b.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_grail_b/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_grail_b',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_ladee: {
		groups: ['moon', 'spacecraft'],
		radius: 0.0012,
		label: 'LADEE',
		parents: [
			[431798467.18253195, 'moon'],
			[451355187.44558257, '']
		],
		trail: {
			length: 7889.57
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ladee/ladee.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_ladee/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_ladee',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_lcross: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.00130,
		extentsRadius: 0.0022,
		label: 'LCROSS',
		parents: [
			[298635466.0304444, 'moon'],
			[308360200.75, '']
		],
		trail: {
			length: 3598022.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_lcross/lcross.gltf',
			rotate: [
				{ z: -90 }
			],
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_lcross/moon/all',
			dataType: 'pos',
			coverage: [Number.NEGATIVE_INFINITY, 308360200.750]
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_lcross',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_lcross_impact_site: {
		groups: ['moon', 'sc_lcross', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'LCROSS Impact Site',
		parents: [
			[298635466.0304444, 'moon']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(-1.4782008103461848, -0.8648271467797672, 0),
			coverage: [298635466.0304444, Number.POSITIVE_INFINITY]
		}]
	},
	sc_lunar_flashlight: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.00025,
		extentsRadius: 0.0005,
		label: 'Lunar Flashlight',
		parents: [
			[724019554, 'earth'],
			[737164869, '']
		],
		trail: {
			length: 10000000
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_lunar_flashlight/lunar_flashlight.gltf',
			shadowEntities: ['earth']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_lunar_flashlight/earth_v3'
		}, {
			type: 'align',
			primary: {
				type: 'align',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}]
	},
	sc_lunar_icecube: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.0002,
		extentsRadius: 0.0012,
		label: 'Lunar IceCube',
		parents: [
			[721864426, 'earth'],
			[734111601, 'moon']
		],
		trail: {
			length: undefined,
			lengthCoverages: [
				[3000000, Number.NEGATIVE_INFINITY, 734111601],
				[441920, 734111601, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_lunar_icecube/lunar_icecube.gltf',
			shadowEntities: ['earth', 'moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_lunar_icecube/earth/pos'
		}, {
			type: 'dynamo',
			url: 'sc_lunar_icecube/moon/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_lunar_prospector: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.00065300,
		extentsRadius: 0.0022,
		label: 'Lunar Prospector',
		parents: [
			[-62206800, 'moon'],
			[-13402020, '']
		],
		trail: {
			length: 7260.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_lunar_prospector/lunar_prospector.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_lunar_prospector/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'align',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg,
			periodInHours: 0.008333
		}]
	},
	sc_lunar_reconnaissance_orbiter: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.00272,
		extentsRadius: 0.0038,
		label: 'Lunar Reconnaissance Orbiter',
		parents: [
			[298635426.1844444, 'earth'],
			[298929666, 'moon']
		],
		trail: {
			length: 7106.66,
			lengthCoverages: [
				[1000000, Number.NEGATIVE_INFINITY, 299040641],
				[7106.66, 299040641, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_lunar_reconnaissance_orbiter/LRO.gltf',
			rotate: [
				{ z: -90 }
			],
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_lunar_reconnaissance_orbiter/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_lunar_reconnaissance_orbiter/moon/orb'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_lunar_reconnaissance_orbiter',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'moon',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_lunar_reconnaissance_orbiter/ori'
		}]
	},
	sc_smart_1: {
		// no model at all; 2D still
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.006530,
		label: 'SMART-1',
		parents: [
			[117977163.35299999, 'moon'],
			[210585600, '']
		],
		trail: {
			length: 273091.0
		},
		controllers: [{
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}, {
			type: 'animdata',
			url: 'sc_smart_1/moon/all',
			dataType: 'pos'
		}]
	},
	sc_themis_b: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.000400,
		extentsRadius: 0.00170,
		label: 'ARTEMIS P1',
		parents: [
			[366638466.1829504, 'moon'],
			[694267209.1839211, '']
		],
		trail: {
			length: 94838.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_themis/themis.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_themis_b/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
			periodInHours: 0.0008333
		}]
	},
	sc_themis_c: {
		groups: ['moon', 'spacecraft'],
		occlusionRadius: 0.000400,
		extentsRadius: 0.00170,
		label: 'ARTEMIS P2',
		parents: [
			[366638466.1829504, 'moon'],
			[694267209.1839211, '']
		],
		trail: {
			length: 204186.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_themis/themis.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_themis_c/moon/all',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
			periodInHours: 0.0008333
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/mars_moons.js":
/*!*****************************************************!*\
  !*** ../pioneer/scripts/src/entities/mars_moons.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/** @module pioneer-scripts */


_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	phobos: {
		groups: ['mars', 'moons'],
		radius: 14.0,
		label: 'Phobos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'mars']
		],
		trail: {
			length: undefined,
			color: [0.89, 0.51, 0.35, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/phobos/phobos.gltf',
			scale: [1, 1, 1],
			rotate: [
				{ z: 90 },
				{ y: 90 }
			],
			shadowEntities: ['mars']
		},
		controllers: [{
			type: 'dynamo',
			url: 'phobos/mars/orb'
		}, {
			type: 'dynamo',
			url: 'phobos/ori'
		}]
	},
	deimos: {
		groups: ['mars', 'moons'],
		radius: 8.70951,
		label: 'Deimos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'mars']
		],
		trail: {
			length: undefined,
			color: [0.89, 0.51, 0.35, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/deimos/deimos.gltf',
			scale: [1, 1, 1],
			rotate: [
				{ y: -180 }
			],
			shadowEntities: ['mars']
		},
		controllers: [{
			type: 'dynamo',
			url: 'deimos/mars/orb'
		}, {
			type: 'dynamo',
			url: 'deimos/ori'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/mars_spacecraft.js":
/*!**********************************************************!*\
  !*** ../pioneer/scripts/src/entities/mars_spacecraft.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_mars_2020: {
		groups: ['mars', 'spacecraft', 'landers'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.003,
		label: 'Mars 2020',
		parents: [
			[649385564, 'earth'],
			[649595376, 'sun'],
			[666932224, 'mars'],
			[666952859, 'sc_mars_2020_landing_site']
		],
		trail: {
			length: 10000000.0,
			lengthCoverages: [
				[10000000, 649385564, 666932224],
				[3000, 666932224, 666953098.003000],
				[9676800, 666953098.003000 + 9676800, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_2020/cruise_whole/msl_cruise_stage.gltf',
			rotate: [
				{ x: -90 }
			],
			shadowEntities: ['mars']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_2020/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_2020/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_2020/mars/pos'
		}, {
			type: 'dynamo',
			url: 'sc_mars_2020/surface/lin'
		}, {
			type: 'custom',
			func: (entity) => { // This is needed because M2020_LANDING_SITE is slightly off of M2020_DIMU_A.
				const controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TranslateController);
				controller.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-0.125148, 0.026867, -0.023641));
				return controller;
			},
			coverage: [666952859, 666953098.003000]
		}, {
			type: 'dynamo',
			url: 'sc_mars_2020/quat'
		}, {
			type: 'dynamo',
			url: 'sc_mars_2020/surface/quat_v2'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 0.00833333333,
			relativeToTime: 649385564,
			coverage: [649385564, 666952859]
		}, {
			type: 'rotateByEntityOrientation', // Rotate the position for IAU_MARS dynamo.
			entityForOrientation: 'mars',
			coverage: [666952859, Number.POSITIVE_INFINITY]
		}, {
			type: 'custom',
			func: (entity) => {
				const groundClamp = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.GroundClampController);
				groundClamp.setDistanceFromGround(0.001);
				groundClamp.setGroundComponentRef('mars', 'cmts');
				groundClamp.setUp(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg);
				groundClamp.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(666953086.614, Number.POSITIVE_INFINITY));
				return groundClamp;
			}
		}, {
			type: 'coverage', // Make it change to Perseverance when it lands.
			coverage: [666953086.614, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const div = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
				div.getDiv().innerHTML.replace('Mars 2020', 'Perseverance');
			},
			exit: (entity) => {
				const div = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
				div.getDiv().innerHTML.replace('Perseverance', 'Mars 2020');
			}
		}, {
			type: 'coverage', // Make the first part of the rover surface trail start at landing.
			coverage: [666953098.003000, 666953098.003000 + 9676800],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setStartTime(666953098.003000);
					trail.setRelativeStartTime(false);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeStartTime(true);
				}
			}
		}, {
			type: 'coverage', // Coverage for making trail relative to entity.
			coverage: [666932224, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
				}
			}
		}, {
			type: 'coverage', // Change the model to the rover at the right time.
			coverage: [666953086.614, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_2020/rover/perseverance.gltf');
				model.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.5, -0.5, 0.5, -0.5));
				model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0.001));
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_2020/cruise_whole/msl_cruise_stage.gltf');
				model.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.7071067811865478, -0.7071067811865472, 0, 0));
				model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0));
			}
		}, {
			type: 'coverage', // Make the trail not fade when on the ground.
			coverage: [666953098.003000, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setIgnoreDistance(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setIgnoreDistance(false);
				}
			}
		}, { // Remove the cruise pieces when starting the EDL.
			type: 'coverage',
			coverage: [666952458, 666953086.614],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setHiddenObject('solar_panels', true);
					model.setHiddenObject('frame_etc', true);
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setHiddenObject('solar_panels', false);
					model.setHiddenObject('frame_etc', false);
				}
			}
		}, {
			// Since the ground clamp controller and the CMTS map the trail will need to be repopulated.
			// Right now the only method is to add an update every few seconds:
			type: 'coverage',
			coverage: [666953086.614, Number.POSITIVE_INFINITY],
			update: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.resetPoints();
				}
			},
			updateInterval: 10
		}]
	},
	sc_mars_2020_landing_site: {
		groups: ['mars', 'sc_mars_2020', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Mars 2020 Landing Site',
		parents: [
			[649385563.6433017, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(0.32191947313922714, 1.351772964399859, -2.2364351843552868),
			coverage: [649385563.6433017, Number.POSITIVE_INFINITY]
		}]
	},
	sc_mars_science_laboratory: {
		groups: ['mars', 'spacecraft', 'landers'],
		occlusionRadius: 0.001515,
		extentsRadius: 0.004,
		label: 'Mars Science Laboratory',
		parents: [
			[375594733, 'earth'],
			[376039259, 'sun'],
			[397477501, 'mars'],
			[397502386.832, 'sc_mars_science_laboratory_landing_site']
		],
		trail: {
			length: 10000000,
			lengthCoverages: [
				[10000000, 375594733, 397501373],
				[3000, 397501373, 397502386.832 + 9676800],
				[9676800, 397502386.832 + 9676800, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_science_laboratory/cruise/msl_cruisestage.gltf',
			rotate: [
				{ x: -90 }
			],
			shadowEntities: ['mars']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/edl/pos'
		}, {
			type: 'custom',
			func: (entity) => { // This is needed because MSL_LANDING_SITE is slightly off of MSL_SITE_1.
				const controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TranslateController);
				controller.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.002583, 0.002995, 0.001937));
				return controller;
			},
			coverage: [397501373, 397502386.832]
		}, {
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/surface/lin_v2'
		}, {
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/quat'
		}, {
			type: 'dynamo',
			url: 'sc_mars_science_laboratory/surface/quat_v2'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 0.00833333333,
			relativeToTime: 375594733,
			coverage: [375594733, 397501866]
		}, {
			type: 'rotateByEntityOrientation', // Rotate the position for IAU_MARS dynamo.
			entityForOrientation: 'mars',
			rotatingOrientation: false,
			coverage: [397501373, Number.POSITIVE_INFINITY]
		}, {
			type: 'rotateByEntityOrientation', // Rotate the orientation for IAU_MARS dynamo.
			entityForOrientation: 'mars',
			rotatingPosition: false,
			coverage: [397502386.832, Number.POSITIVE_INFINITY]
		}, {
			type: 'custom',
			func: (entity) => {
				// Add a ground clamp when the rover is on the ground. The dymamo gets pretty close, but this is closer.
				const groundClamp = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.GroundClampController);
				groundClamp.setDistanceFromGround(0.00098);
				groundClamp.setGroundComponentRef('mars', 'cmts');
				groundClamp.setUp(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg);
				groundClamp.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(397502386.832, Number.POSITIVE_INFINITY));
				return groundClamp;
			}
		}, {
			type: 'coverage', // Make it change to Curiosity when it lands.
			coverage: [397502386.832, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const div = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
				div.getDiv().innerHTML.replace('Mars Science Laboratory', 'Curiosity');
			},
			exit: (entity) => {
				const div = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
				div.getDiv().innerHTML.replace('Curiosity', 'Mars Science Laboratory');
			}
		}, { // Coverage for making trail relative to entity.
			type: 'coverage',
			coverage: [397501373, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
				}
			}
		}, { // Change the model to the rover at the right time.
			type: 'coverage',
			coverage: [397502324, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_science_laboratory/rover/curiosity_static.gltf');
					model.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.5, -0.5, 0.5, -0.5));
					model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0.001));
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_science_laboratory/cruise/msl_cruisestage.gltf');
					model.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.7071067811865478, -0.7071067811865472, 0, 0));
					model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0));
				}
			}
		}, {
			type: 'coverage', // Make the trail not fade when on the ground.
			coverage: [397502386.832, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setIgnoreDistance(true);
				}

			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setIgnoreDistance(false);
				}
			}
		}, { // Remove the cruise pieces when starting the EDL.
			type: 'coverage',
			coverage: [397501758, 397502386.832],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setHiddenObject('solar_panels', true);
					model.setHiddenObject('frame_etc', true);
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setHiddenObject('solar_panels', false);
					model.setHiddenObject('frame_etc', false);
				}
			}
		}, {
			// Since the ground clamp controller and the CMTS map the trail will need to be repopulated.
			// Right now the only method is to add an update every few seconds:
			type: 'coverage',
			coverage: [397502386.832, Number.POSITIVE_INFINITY],
			update: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.resetPoints();
				}
			},
			updateInterval: 10
		}]
	},
	sc_mars_science_laboratory_landing_site: {
		groups: ['mars', 'sc_mars_science_laboratory', 'sites'],
		occlusionRadius: 0.001515,
		extentsRadius: 0.004,
		systemRadius: 200,
		label: 'Curiosity Landing Site',
		parents: [
			[375594732.3829685, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(-4.589466996319 / 180 * Math.PI, 137.441632996891 / 180 * Math.PI, -4.927711819685555),
			coverage: [375594732.3829685, Number.POSITIVE_INFINITY]
		}]
	},
	sc_mars_exploration_rover_1: {
		groups: ['mars', 'spacecraft', 'landers'],
		occlusionRadius: 0.0013,
		extentsRadius: 0.0026,
		label: 'Opportunity',
		parents: [
			[110911022.184, 'earth'],
			[111234172, 'sun'],
			[128262836, 'mars'],
			[128278419, 'sc_mars_exploration_rover_1_landing_site'],
			[581920316.8566707, '']
		],
		trail: {
			length: 6720.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 128262836],
				[6720.0, 128262836, 128278419],
				[0, 128278523.336, 581920316.856]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_1/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_1/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_1/mars/pos'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_1/edl/pos'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_1/surface/pos'
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_mars_exploration_rover_1',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'align',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			coverage: [Number.NEGATIVE_INFINITY, 128278523.336]
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity,
			coverage: [128278523.336, 581920316.856]
		}, {
			type: 'coverage',
			coverage: [128278419, 581920316.856],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
				}
			}
		}, {
			type: 'coverage',
			coverage: [128278523.336, 581920316.856],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/rover/mer_static.gltf');
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf');
				}
			}
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, 128262836],
			enter: (entity) => {
				const align = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
				if (align !== null) {
					align.setPrimaryAlignType('point');
					align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis);
					align.setPrimaryTargetEntity('sun');
				}
			},
			exit: (entity) => {
				const align = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
				if (align !== null) {
					align.setPrimaryAlignType('velocity');
					align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg);
					align.setPrimaryTargetEntity('sc_mars_exploration_rover_1');
				}
			}
		}],
		postCreateFunction: (entity) => {
			// Get it into the MER-1_TOPO frame.
			const rotate = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.RotateController);
			const rot90 = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
			rot90.setFromAxes(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg, undefined);
			rotate.setRotation(rot90);
			rotate.setRotatingOrientation(false);
			rotate.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(128278419, 581920316.856));

			// Get it into the J2000 frame.
			const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.RotateByEntityOrientationController, 'landingRotateByEntity', entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController));
			rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(128278419, 581920316.856));
		}
	},
	sc_mars_exploration_rover_1_landing_site: {
		groups: ['mars', 'sc_mars_exploration_rover_1', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Opportunity Landing Site',
		parents: [
			[110911022.184, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(-0.034003934569818886, -0.09644392740547784, -2.018490164449304),
			coverage: [110911022.184, Number.POSITIVE_INFINITY]
		}]
	},
	sc_mars_exploration_rover_2: {
		groups: ['mars', 'spacecraft', 'landers'],
		occlusionRadius: 0.0013,
		extentsRadius: 0.0026,
		label: 'Spirit',
		parents: [
			[108541883.184, 'earth'],
			[108887371, 'sun'],
			[126444477, 'mars'],
			[126462105, 'sc_mars_exploration_rover_2_landing_site'],
			[322567479.3896215, '']
		],
		trail: {
			length: 6720.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 126444477],
				[6720.0, 126444477, 126462105],
				[0, 126462396.105800, 322567479.389620]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_2/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_2/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_2/mars/pos'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_2/edl/pos'
		}, {
			type: 'dynamo',
			url: 'sc_mars_exploration_rover_2/surface/pos'
		}, {
			type: 'rotateByEntityOrientation', // Get surface dynamo into J2000 frame.
			coverage: [126462105, 322567479.389620]
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_mars_exploration_rover_2',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'align',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			coverage: [Number.NEGATIVE_INFINITY, 126462105]
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity,
			coverage: [126462105, 322567479.389620]
		}, {
			type: 'coverage',
			coverage: [126462105, 322567479.389620],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
				}
			}
		}, {
			type: 'coverage',
			coverage: [126462396.105800, 322567479.389620],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/rover/mer_static.gltf');
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_mars_exploration_rover/cruise/mpf_mera_merb_cruise.gltf');
				}
			}
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, 126444477],
			enter: (entity) => {
				const align = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
				if (align !== null) {
					align.setPrimaryAlignType('point');
					align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis);
					align.setPrimaryTargetEntity('sun');
				}
			},
			exit: (entity) => {
				const align = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
				if (align !== null) {
					align.setPrimaryAlignType('velocity');
					align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg);
					align.setPrimaryTargetEntity('sc_mars_exploration_rover_2');
				}
			}
		}],
		postCreateFunction: (entity) => {
			// Get it into the MER-2_TOPO frame.
			const rotate = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.RotateController);
			const rot90 = new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion();
			rot90.setFromAxes(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis, pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg, undefined);
			rotate.setRotation(rot90);
			rotate.setRotatingOrientation(false);
			rotate.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(126462105, 322567479.389620));
		}
	},
	sc_mars_exploration_rover_2_landing_site: {
		groups: ['mars', 'sc_mars_exploration_rover_2', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Spirit Landing Site',
		parents: [
			[108541883.184, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(-0.25432749290990797, 3.062677242395019, -2.614394925059969),
			coverage: [108541883.184, Number.POSITIVE_INFINITY]
		}]
	},
	sc_insight: {
		groups: ['mars', 'spacecraft', 'landers'],
		radius: 0.00306,
		label: 'InSight',
		parents: [
			[578795968.9654216, 'earth'],
			[579182469.185, 'sun'],
			[596376069.183, 'mars']
		],
		trail: {
			length: 32137022.16,
			lengthCoverages: [
				[32137022.16, Number.NEGATIVE_INFINITY, 596376069.183],
				[14400, 596376069.183, 596533471.284 - 3600],
				[3600, 596533471.284 - 3600, 596533602],
				[0, 596533602, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_insight/lander/insight.gltf',
			rotate: [
				{ y: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_insight/earth/pos'
		}, {
			type: 'dynamo',
			url: 'sc_insight/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_insight/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_insight_edl/mars/pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'align',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			coverage: [578795968.9654216, 596533602]
		}, {
			type: 'dynamo',
			url: 'sc_insight/ori'
		}, {
			type: 'dynamo',
			url: 'sc_insight_edl/ori'
		}, {
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(0.07881611091588075, 2.3734709256393973, -2.996371903616364),
			llaOnSpheroidEntity: 'mars',
			coverage: [596533602, Number.POSITIVE_INFINITY]
		}, {
			type: 'coverage',
			coverage: [596533471.284 - 3600, 596533602],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
				}
			}
		}, {
			type: 'coverage',
			coverage: [578795968.9654216, 596533602],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_insight/cruise/model.gltf');
					model.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(Math.sqrt(0.5), 0, Math.sqrt(0.5), 0));
					model.setTranslation(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero);
				}
			}
		}, {
			type: 'coverage',
			coverage: [596533602, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (model !== null) {
					model.setUrl('$STATIC_ASSETS_URL/models/sc_insight/lander/insight.gltf');
					model.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(Math.sqrt(0.5), Math.sqrt(0.5), 0, 0));
					model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0.00085));
				}
			}
		}]
	},
	sc_insight_landing_site: {
		groups: ['mars', 'sc_insight', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'InSight Landing Site',
		parents: [
			[578795968.9654216, 'mars'],
			[596533602, '']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(0.07881611091588075, 2.3734709256393973, -2.996371903616364),
			coverage: [578795968.9654216, 596533602]
		}]
	},
	sc_marco_a: {
		groups: ['mars', 'spacecraft'],
		radius: 0.00044375,
		label: 'MarCO A',
		parents: [
			[578796051, 'earth'],
			[579182469.185, 'sun'],
			[596376069.183, 'mars'],
			[596552080, 'sun'],
			[631152000, '']
		],
		trail: {
			length: 6720.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 579182469.185],
				[6720.0, 579182469.185, 596552080],
				[10000000, 596552080, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_marco/model.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_marco_a/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_marco_a/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_marco_a/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_marco_a/sun/2/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}]
	},
	sc_marco_b: {
		groups: ['mars', 'spacecraft'],
		radius: 0.00044375,
		label: 'MarCO B',
		parents: [
			[578796051, 'earth'],
			[579182469.185, 'sun'],
			[596376069.183, 'mars'],
			[596552080, 'sun'],
			[631152000, '']
		],
		trail: {
			length: 6720.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 579182469.185],
				[6720.0, 579182469.185, 596552080],
				[10000000, 596552080, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_marco/model.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_marco_b/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_marco_b/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_marco_b/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_marco_b/sun/2/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}]
	},
	sc_mars_odyssey: {
		groups: ['mars', 'spacecraft'],
		occlusionRadius: 0.0013,
		extentsRadius: 0.004,
		label: 'Mars Odyssey',
		parents: [
			[39932700, 'earth'],
			[40233664, 'sun'],
			[57128464, 'mars']
		],
		trail: {
			length: 6727.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 57128464],
				[6727.0, 57128464, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_odyssey/mars_odyssey.gltf',
			environmentMap: {
				cubemap: '$STATIC_ASSETS_URL/env_maps/park_gray/$FACE.jpg'
			},
			shadowEntities: ['mars', 'deimos', 'phobos']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_odyssey/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_odyssey/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_odyssey/mars/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mars',
				axis: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-0.95630475596, 0.29237170472, 0)
			},
			secondary: {
				type: 'velocity',
				target: 'sc_mars_odyssey',
				axis: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.29237170472, 0.95630475596, 0)
			}
		}, {
			type: 'dynamo',
			url: 'sc_mars_odyssey/ori'
		}]
	},
	sc_mars_reconnaissance_orbiter: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0068,
		label: 'Mars Reconnaissance Orbiter',
		parents: [
			[177122516, 'earth'],
			[177429664, 'sun'],
			[195285665, 'mars']
		],
		trail: {
			length: 6720.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 195285665],
				[6720.0, 195285665, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_reconnaissance_orbiter/MRO.gltf',
			environmentMap: {
				cubemap: '$STATIC_ASSETS_URL/env_maps/park_gray/$FACE.jpg'
			},
			shadowEntities: ['mars', 'deimos', 'phobos']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_reconnaissance_orbiter/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_reconnaissance_orbiter/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_reconnaissance_orbiter/mars/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_mars_reconnaissance_orbiter',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_mars_reconnaissance_orbiter/ori'
		}]
	},
	sc_maven: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0057,
		label: 'MAVEN',
		parents: [
			[438074509.3428109, 'earth'],
			[438296467, 'sun'],
			[464590867, 'mars']
		],
		trail: {
			length: 16139.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_maven/Maven.gltf',
			rotate: [
				{ x: 90 },
				{ z: 90 }
			],
			environmentMap: {
				cubemap: '$STATIC_ASSETS_URL/env_maps/park_gray/$FACE.jpg'
			},
			shadowEntities: ['mars', 'deimos', 'phobos']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_maven/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_maven/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_maven/mars/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_maven/ori'
		}]
	},
	sc_mars_express: {
		groups: ['mars', 'spacecraft'],
		radius: 0.006,
		label: 'Mars Express',
		parents: [
			[107853140.59600002, 'earth'],
			[108232264, 'sun'],
			[125539264, 'mars']
		],
		trail: {
			length: 25000.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 126749131],
				[12720.0, 126749131, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_express/mars_express.gltf',
			rotate: [
				{ x: 90 },
				{ z: -180 }
			],
			environmentMap: {
				cubemap: '$STATIC_ASSETS_URL/env_maps/park_gray/$FACE.jpg'
			},
			shadowEntities: ['mars', 'deimos', 'phobos']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_mars_express/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_express/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_mars_express/mars/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			}
		}, {
			type: 'dynamo',
			url: 'sc_mars_express/ori'
		}]
	},
	sc_phoenix: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0027,
		label: 'Phoenix',
		parents: [
			[239496427, 'earth'],
			[239618121, 'sun'],
			[265008306, 'mars'],
			[265030318, 'sc_phoenix_landing_site'],
			[278942465, '']
		],
		trail: {
			length: 45411186.0,
			lengthCoverages: [
				[45411186, Number.NEGATIVE_INFINITY, 265008306],
				[50000, 265008306, 265030318],
				[500, 265030318, 265030769],
				[0, 265030769, 278942465]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_phoenix/cruise/phoenix_cruise.gltf',
			rotate: [
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_phoenix/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_phoenix/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_phoenix/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_phoenix/phx_topo/pos'
		}, {
			type: 'dynamo',
			url: 'sc_phoenix/ori'
		}, {
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.027059368126568832, 0.013878235928918032, -0.04367634407940447),
			coverage: [265030769, 278942465]
		}, {
			type: 'rotateByEntityOrientation',
			rotatingOrientation: false,
			coverage: [265030769, 278942465]
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			}
		}, {
			type: 'coverage',
			coverage: [265030324 - 7 * 60, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/sc_phoenix/edl/phoenix_edl.gltf');
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/sc_phoenix/cruise/phoenix_cruise.gltf');
			}
		}],
		postCreateFunction: (entity) => {
			entity.addParentChangedCallback((entity, _, newParent) => {
				if (newParent !== null) {
					const parentName = newParent.getName();
					const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
					if (parentName === 'sc_phoenix_landing_site') {
						trail.setRelativeToEntity('mars');
						trail.setRelativeToEntityOrientation(true);
					}
					else {
						trail.setRelativeToEntity('');
						trail.setRelativeToEntityOrientation(false);
					}
				}
			});
		}
	},
	sc_phoenix_landing_site: {
		groups: ['mars', 'sc_phoenix', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Phoenix Landing Site',
		parents: [
			[239496427, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(1.1906355815662266, -2.1947740491302206, -2.5912352775421823),
			coverage: [239496427, Number.POSITIVE_INFINITY]
		}]
	},
	sc_trace_gas_orbiter: {
		groups: ['mars', 'spacecraft'],
		radius: 0.00875915,
		label: 'Trace Gas Orbiter',
		parents: [
			[511257268, 'earth'],
			[511941668, 'sun'],
			[530107268, 'mars']
		],
		trail: {
			length: 6720.0,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 530160041],
				[6720.0, 530160041, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_trace_gas_orbiter/TGO.gltf',
			rotate: [
				{ x: -90 },
				{ y: -90 }
			],
			environmentMap: {
				cubemap: '$STATIC_ASSETS_URL/env_maps/park_gray/$FACE.jpg'
			},
			shadowEntities: ['mars', 'deimos', 'phobos']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_trace_gas_orbiter/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_trace_gas_orbiter/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_trace_gas_orbiter/mars/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			}
		}, {
			type: 'dynamo',
			url: 'sc_trace_gas_orbiter/ori'
		}],
		postCreateFunction: (entity) => {
			// Align the right solar panel to the sun.
			let align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
			align.setJoint('right_array_1');
			align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis);
			align.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');
			// Align the left solar panel to the sun.
			align = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController);
			align.setJoint('left_array_1');
			align.setPrimaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis);
			align.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis);
			align.setSecondaryAlignType('point');
			align.setSecondaryTargetEntity('sun');
		}
	},
	sc_mars_orbiter_mission: {
		groups: ['mars', 'spacecraft'],
		radius: 0.00275,
		label: 'Mars Orbiter Mission',
		parents: [
			[623211069.1823474, 'mars']
		],
		trail: {
			length: 234146.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_mars_orbiter_mission/mars',
			dataType: 'pos'
		}]
	},
	sc_mars_global_surveyor: {
		groups: ['mars', 'spacecraft'],
		occlusionRadius: 0.003,
		extentsRadius: 0.005,
		label: 'Mars Global Surveyor',
		parents: [
			[-72699545, 'mars'],
			[215697664.184, '']
		],
		trail: {
			length: 7068.67
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_mars_global_surveyor/mars_global_surveyor.gltf',
			shadowEntities: ['mars']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_mars_global_surveyor_mission',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mars',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			}
		}]
	},
	sc_mars_climate_orbiter: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0011,
		label: 'Mars Climate Orbiter',
		parents: [
			[-33318000, 'sun'],
			[-8650375.816, '']
		],
		trail: {
			length: 24587405.0 * 3.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_mars_climate_orbiter',
			dataType: 'pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sc_mars_pathfinder: {
		groups: ['mars', 'spacecraft'],
		radius: 0.00033,
		label: 'Mars Pathfinder',
		parents: [
			[-91704541, 'sun'],
			[-78692880, '']
		],
		trail: {
			length: 12874372.0 * 4.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_mars_pathfinder',
			dataType: 'pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sc_mars_pathfinder_landing_site: {
		groups: ['mars', 'sc_mars_pathfinder', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Mars Pathfinder Landing Site',
		parents: [
			[-97045250.817, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(19.13 * Math.PI / 180, -33.22 * Math.PI / 180, 0),
			coverage: [-97045250.817, Number.POSITIVE_INFINITY]
		}]
	},
	sc_mars_polar_lander: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0018,
		label: 'Mars Polar Lander',
		parents: [
			[-31298400, 'sun'],
			[-2476735.816, '']
		],
		trail: {
			length: 41109006.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_mars_polar_lander',
			dataType: 'pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sc_viking_1_orbiter: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0047,
		label: 'Viking 1 Orbiter',
		parents: [
			[-742490410, 'mars'],
			[-663249600, '']
		],
		trail: {
			length: 88649.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_viking_1_orbiter',
			dataType: 'pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sc_viking_1_lander_landing_site: {
		groups: ['mars', 'sc_viking_1_lander', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Viking 1 Lander Landing Site',
		parents: [
			[-768926233.817, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(22.27 * Math.PI / 180, 312.05 * Math.PI / 180, 0),
			coverage: [-768926233.817, Number.POSITIVE_INFINITY]
		}]
	},
	sc_viking_2_orbiter: {
		groups: ['mars', 'spacecraft'],
		radius: 0.0047,
		label: 'Viking 2 Orbiter',
		parents: [
			[-738460186, 'mars'],
			[-676517400, '']
		],
		trail: {
			length: 98694.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_viking_2_orbiter',
			dataType: 'pos'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sc_viking_2_lander_landing_site: {
		groups: ['mars', 'sc_viking_2_lander', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Viking 2 Lander Landing Site',
		parents: [
			[-767208013.818, 'mars']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(47.64 * Math.PI / 180, -225.71 * Math.PI / 180, 0),
			coverage: [-767208013.818, Number.POSITIVE_INFINITY]
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/mercury_spacecraft.js":
/*!*************************************************************!*\
  !*** ../pioneer/scripts/src/entities/mercury_spacecraft.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_messenger: {
		groups: ['mercury', 'spacecraft'],
		occlusionRadius: 0.00133,
		extentsRadius: 0.0035,
		label: 'MESSENGER',
		parents: [
			[144789279.39320505, 'earth'],
			[145066469, 'sun'],
			[175801890, 'earth'],
			[176659095, 'sun'],
			[214828942, 'venus'],
			[215033751, 'sun'],
			[234289415, 'venus'],
			[234436749, 'sun'],
			[253547108, 'mercury'],
			[253671753, 'sun'],
			[276485360, 'mercury'],
			[276627276, 'sun'],
			[307423681, 'mercury'],
			[307651285, 'sun'],
			[353474040, 'mercury'],
			[483694028.351, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_messenger/Messenger.gltf',
			rotate: [
				{ z: -90 },
				{ y: 90 }
			],
			shadowEntities: ['mercury']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_messenger/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/earth/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/venus/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/venus/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/4/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/mercury/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/5/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/mercury/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/6/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/mercury/flyby3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/sun/7/orb'
		}, {
			type: 'dynamo',
			url: 'sc_messenger/mercury/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mercury',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_messenger',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_messenger/ori'
		}]
	},
	sc_messenger_impact_site: {
		groups: ['mercury', 'sc_messenger', 'sites'],
		radius: 0.001,
		label: 'MESSENGER Impact Site',
		parents: [
			[Number.NEGATIVE_INFINITY, 'mercury']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(0.9501527254431932, -2.615904550043192, -0.910251923861324),
			coverage: [483694028.351, Number.POSITIVE_INFINITY]
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/minor_planets.js":
/*!********************************************************!*\
  !*** ../pioneer/scripts/src/entities/minor_planets.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



// NEOs are near-earth objects
// PHAs are potentially hazardous asteroids
// TNOs are trans-neptunian objects

_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	'1_ceres': {
		groups: ['dwarf planets'],
		radius: 473.0,
		label: 'Ceres',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		spheroid: {
			equatorialRadius: 482.6,
			polarRadius: 445.6,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: '1_ceres/color_$SIZE_$FACE.jpg',
					sizes: [16, 512, 4096]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: '1_ceres/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'101955_bennu': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.246,
		label: 'Bennu',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/101955_bennu/Bennu.gltf',
			rotate: [
				{ x: 83 },
				{ z: -168 }
			],
			scale: 0.0009956
		},
		controllers: [{
			type: 'dynamo',
			url: '101955_bennu/sun/orb'
		}, {
			type: 'dynamo',
			url: '101955_bennu/ori'
		}]
	},
	'11351_leucus': {
		groups: ['asteroids'],
		radius: 17.0775,
		label: 'Leucus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 17.0775
		},
		controllers: [{
			type: 'dynamo',
			url: '11351_leucus/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 445.732
		}]
	},
	'12923_zephyr': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 1.03,
		label: 'Zephyr',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.03, 1.03, 1.03]
		},
		controllers: [{
			type: 'dynamo',
			url: '12923_zephyr/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.891
		}]
	},
	'134340_pluto': {
		groups: ['dwarf planets', 'moons', '134340_pluto_barycenter'],
		radius: 1187.0,
		label: 'Pluto',
		labelFadeEntity: 'sun',
		parents: [
			[Number.NEGATIVE_INFINITY, '134340_pluto_barycenter']
		],
		trail: {
			length: undefined
		},
		spheroid: {
			equatorialRadius: 1187.0,
			polarRadius: 1187.0,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: '134340_pluto/color_$SIZE_$FACE.png',
					sizes: [4, 512, 4096]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: '134340_pluto/134340_pluto_barycenter/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: 'charon'
			},
			secondary: {
				type: 'velocity',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
				target: 'charon'
			}
		}]
	},
	'134340_pluto_barycenter': {
		groups: ['134340_pluto', 'barycenters'],
		occlusionRadius: 0.001,
		extentsRadius: 28000,
		systemRadius: 130153,
		label: 'Barycenter',
		labelFadeEntity: '134340_pluto',
		trail: {
			length: undefined
		},
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		controllers: [{
			type: 'dynamo',
			url: '134340_pluto_barycenter/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}],
		postCreateFunction: (entity) => {
			const divComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
			divComponent.setFadeWhenCloseToCamera(false);
			entity.setCanOcclude(false);
		}
	},
	'136108_haumea': {
		groups: ['dwarf planets', 'TNOs'],
		radius: 816.0,
		label: 'Haumea',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/136108_haumea/haumea.gltf',
			scale: [1, 1, 1]
		},
		controllers: [{
			type: 'dynamo',
			url: '136108_haumea/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	'136199_eris': {
		groups: ['dwarf planets', 'TNOs'],
		radius: 1163.0,
		label: 'Eris',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		spheroid: {
			equatorialRadius: 1163.0,
			polarRadius: 1163.0,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: '136199_eris/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: '136199_eris/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	'136472_makemake': {
		groups: ['dwarf planets', 'TNOs'],
		radius: 715.0,
		label: 'Makemake',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		spheroid: {
			equatorialRadius: 717.0,
			polarRadius: 710.0,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: '136472_makemake/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: '136472_makemake/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	'14827_hypnos': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.4535,
		label: 'Hypnos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.4535, 0.4535, 0.4535]
		},
		controllers: [{
			type: 'dynamo',
			url: '14827_hypnos/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'15094_polymele': {
		groups: ['asteroids'],
		radius: 10.5375,
		label: 'Polymele',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 10.5375
		},
		controllers: [{
			type: 'dynamo',
			url: '15094_polymele/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 5.8607
		}]
	},
	'1566_icarus': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.805,
		label: 'Icarus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.805, 0.800, 0.585]
		},
		controllers: [{
			type: 'dynamo',
			url: '1566_icarus/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.2726
		}]
	},
	'16_psyche': {
		groups: ['asteroids'],
		radius: 125.0,
		label: '16 Psyche',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/16_psyche/psycheAsteroid.gltf',
			scale: [100, 100, 100],
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: '16_psyche/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	'1620_geographos': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 2.5,
		label: 'Geographos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.5, 1.0, 1.05]
		},
		controllers: [{
			type: 'dynamo',
			url: '1620_geographos/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 5.224
		}]
	},
	'162173_ryugu': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.45,
		label: 'Ryugu',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/162173_ryugu/ryugu.gltf',
			rotate: [
				{ x: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'ssd/162173_ryugu/sun/orb'
		}, {
			type: 'dynamo',
			url: '162173_ryugu/ori'
		}]
	},
	'1862_apollo': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.75,
		label: 'Apollo',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.75, 0.75, 0.75]
		},
		controllers: [{
			type: 'dynamo',
			url: '1862_apollo/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.065
		}]
	},
	'1981_midas': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.975,
		label: 'Midas',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.975, 0.975, 0.975]
		},
		controllers: [{
			type: 'dynamo',
			url: '1981_midas/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 5.22
		}]
	},
	'1991_vg': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.00425,
		label: '1991 VG',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.00425, 0.00425, 0.00425]
		},
		controllers: [{
			type: 'dynamo',
			url: '1991_vg/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'1993_hd': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 0.005,
		label: '1993 HD',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '1993_hd/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'1994_cc_a': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.325,
		label: '1994 CC',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.325, 0.325, 0.325]
		},
		controllers: [{
			type: 'dynamo',
			url: '1994_cc_a/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.38860
		}]
	},
	// Needs spice
	// '1994_cc_b': {
	// 	groups: ['asteroids', 'NEOs', 'PHAs'],
	// 	radius: 0.025,
	// 	label: '1994 CC B',
	// 	parents: [
	// 		[Number.NEGATIVE_INFINITY, 'sun']
	// 	],
	// 	trail: {
	// 		length: undefined
	// 	},
	// 	model: {
	// 		url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
	// 		scale: [0.025, 0.025, 0.025]
	// 	},
	// 	dynamo: [{
	// 		url: '1994_cc_b/1994_cc_a/orb',
	// 		parent: '1994_cc_a'
	// 	}, {
	// 		url: '1994_cc_b/ori'
	// 	}]
	// },
	// Needs spice
	// '1994_cc_c': {
	// 	groups: ['asteroids', 'NEOs', 'PHAs'],
	// 	radius: 0.00417,
	// 	label: '1994 CC C',
	// 	parents: [
	// 		[Number.NEGATIVE_INFINITY, 'sun']
	// 	],
	// 	trail: {
	// 		length: undefined
	// 	},
	// 	model: {
	// 		url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
	// 		scale: [0.00417, 0.00417, 0.00417]
	// 	},
	// 	dynamo: [{
	// 		url: '1994_cc_c/1994_cc_a/orb',
	// 		parent: '1994_cc_a'
	// 	}, {
	// 		url: '1994_cc_c/ori'
	// 	}]
	// },
	'1996_xb27': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.042,
		label: '1996 XB<sub>27</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.042, 0.042, 0.042]
		},
		controllers: [{
			type: 'dynamo',
			url: '1996_xb27/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 1.195
		}]
	},
	'1998_ky26': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.015,
		label: '1998 KY<sub>26</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.015, 0.015, 0.015]
		},
		controllers: [{
			type: 'dynamo',
			url: '1998_ky26/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 0.1784
		}]
	},
	'1998_ml14': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.5,
		label: '1998 ML<sub>14</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.5, 0.5, 0.5]
		},
		controllers: [{
			type: 'dynamo',
			url: '1998_ml14/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 14.28
		}]
	},
	'1998_qe2': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 1.375,
		label: '1998 QE<sub>2</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.375, 1.375, 1.375]
		},
		controllers: [{
			type: 'dynamo',
			url: '1998_qe2/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 4.749
		}]
	},
	'1999_ao10': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.025,
		label: '1999 AO<sub>10</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.025, 0.025, 0.025]
		},
		controllers: [{
			type: 'dynamo',
			url: '1999_ao10/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'1999_cg9': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '1999 CG<sub>9</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '1999_cg9/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'1999_vx25': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '1999 VX<sub>25</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '1999_vx25/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2_pallas': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 291,
		label: 'Pallas',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [291, 278, 250]
		},
		controllers: [{
			type: 'dynamo',
			url: '2_pallas/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 7.8132
		}]
	},
	'2000_ae205': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2000 AE<sub>205</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2000_ae205/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2000_lg6': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2000 LG<sub>6</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2000_lg6/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2000_sg344': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.0185,
		label: '2000 SG<sub>344</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.0185, 0.0185, 0.0185]
		},
		controllers: [{
			type: 'dynamo',
			url: '2000_sg344/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2001_bb16': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2001 BB<sub>16</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2001_bb16/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2001_fr85': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2001 FR<sub>85</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2001_fr85/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2001_gp2': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2001 GP<sub>2</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2001_gp2/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2001_qj142': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2001 QJ<sub>142</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2001_qj142/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2001_sn263_a': {
		groups: ['asteroids', 'NEOs'],
		radius: 1.45,
		label: '(153591) 2001 SN<sub>263</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.4, 1.35, 1.45]
		},
		controllers: [{
			type: 'dynamo',
			url: '2001_sn263_a/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.423
		}]
	},
	// Needs spice
	// '2001_sn263_b': {
	// 	groups: ['asteroids', 'NEOs'],
	// 	radius: 0.215,
	// 	label: '2001 SN263 B',
	// 	parents: [
	// 		[Number.NEGATIVE_INFINITY, 'sun']
	// 	],
	// 	trail: {
	// 		length: 537840
	// 	},
	// 	model: {
	// 		url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
	// 		scale: [0.215, 0.215, 0.215]
	// 	},
	// 	dynamo: [{
	// 		url: '2001_sn263_b/2001_sn263_a/orb',
	// 		parent: '2001_sn263_a'
	// 	}, {
	// 		url: '2001_sn263_b/ori'
	// 	}]
	// },
	// Needs spice
	// '2001_sn263_c': {
	// 	groups: ['asteroids', 'NEOs'],
	// 	radius: 0.385,
	// 	label: '2001 SN263 C',
	// 	parents: [
	// 		[Number.NEGATIVE_INFINITY, 'sun']
	// 	],
	// 	trail: {
	// 		length: 59270
	// 	},
	// 	model: {
	// 		url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
	// 		scale: [0.385, 0.385, 0.385]
	// 	},
	// 	dynamo: [{
	// 		url: '2001_sn263_c/2001_sn263_a/orb',
	// 		parent: '2001_sn263_a'
	// 	}, {
	// 		url: '2001_sn263_c/ori'
	// 	}]
	// },
	'2003_sm84': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2003 SM<sub>84</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2003_sm84/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2003_uv11': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.13,
		label: '(503941) 2003 UV<sub>11</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.13, 0.13, 0.13]
		},
		controllers: [{
			type: 'dynamo',
			url: '2003_uv11/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 18.25
		}]
	},
	'2003_yn107': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.01,
		label: '2003 YN<sub>107</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.01, 0.01, 0.01]
		},
		controllers: [{
			type: 'dynamo',
			url: '2003_yn107/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2005_er95': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2003 ER<sub>95</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2005_er95/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2005_lc': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2005 LC',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2005_lc/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2005_qp87': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2005 QP<sub>87</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2005_qp87/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2005_yu55': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.18,
		label: '2005 YU<sub>55</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.18, 0.18, 0.18]
		},
		controllers: [{
			type: 'dynamo',
			url: '2005_yu55/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 18
		}]
	},
	'2006_bz147': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2006 BZ<sub>147</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2006_bz147/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2006_jy26': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.00475,
		label: '2006 JY<sub>26</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.00475, 0.00475, 0.00475]
		},
		controllers: [{
			type: 'dynamo',
			url: '2006_jy26/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2006_qq56': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2006 QQ<sub>56</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2006_qq56/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2006_rh120': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.00125,
		label: '2006 RH<sub>120</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.00125, 0.00125, 0.00125]
		},
		controllers: [{
			type: 'dynamo',
			url: '2006_rh120/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 0.04583
		}]
	},
	'2006_ub17': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2006 UB<sub>17</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2006_ub17/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2007_tf15': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2007 TF<sub>15</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2007_tf15/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2007_un12': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2007 UN<sub>12</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2007_un12/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2007_vu6': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2007 VU<sub>6</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2007_vu6/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_bt2': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 BT<sub>2</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_bt2/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_cx118': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 CX<sub>118</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_cx118/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_ea9': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 EA<sub>9</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_ea9/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_el': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 EL',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_el/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_hu4': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 HU<sub>4</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_hu4/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_jl24': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 JL<sub>24</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_jl24/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 0.05385
		}]
	},
	'2008_kt': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 KT',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_kt/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_tc3': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.00205,
		label: '2008 TC<sub>3</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.00205, 0.00205, 0.00205]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_tc3/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 0.0269409
		}]
	},
	'2008_ts10': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2008 TS<sub>10</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_ts10/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2008_ua202': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.025,
		label: '2008 UA<sub>202</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.025, 0.025, 0.025]
		},
		controllers: [{
			type: 'dynamo',
			url: '2008_ua202/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2009_bd': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.0055,
		label: '2009 BD',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.0055, 0.0055, 0.0055]
		},
		controllers: [{
			type: 'dynamo',
			url: '2009_bd/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2009_os5': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2009 OS<sub>5</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2009_os5/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2009_rt1': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2009 RT<sub>1</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2009_rt1/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2009_yf': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2009 YF',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2009_yf/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2010_an61': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2010 AN<sub>61</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2010_an61/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2010_dj': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2010 DJ',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2010_dj/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2010_jw34': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2010 JW<sub>34</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2010_jw34/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2010_tg19': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2010 TG<sub>19</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2010_tg19/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2010_tn167': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2010 TN<sub>167</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2010_tn167/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2010_ub': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.005,
		label: '2010 UB',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.005, 0.005, 0.005]
		},
		controllers: [{
			type: 'dynamo',
			url: '2010_ub/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2063_bacchus': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.555,
		label: 'Bacchus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.555, 0.265, 0.25]
		},
		controllers: [{
			type: 'dynamo',
			url: '2063_bacchus/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 14.904
		}]
	},
	'21_lutetia': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 60.5,
		label: 'Lutetia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [60.5, 50.5, 37.5]
		},
		controllers: [{
			type: 'dynamo',
			url: '21_lutetia/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 8.1655
		}]
	},
	'2101_adonis': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.2615,
		label: 'Adonis',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.2615, 0.2615, 0.2615]
		},
		controllers: [{
			type: 'dynamo',
			url: '2101_adonis/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'2102_tantalus': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.8245,
		label: 'Tantalus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.8245, 0.8245, 0.8245]
		},
		controllers: [{
			type: 'dynamo',
			url: '2102_tantalus/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.384
		}]
	},
	'2135_aristaeus': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.5,
		label: 'Aristaeus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.5, 0.5, 0.5]
		},
		controllers: [{
			type: 'dynamo',
			url: '2135_aristaeus/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'216_kleopatra': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 138,
		label: 'Kleopatra',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [138, 47, 39]
		},
		controllers: [{
			type: 'dynamo',
			url: '216_kleopatra/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 5.385
		}]
	},
	'21900_orus': {
		groups: ['asteroids'],
		radius: 25.405,
		label: 'Orus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: 25.405
		},
		controllers: [{
			type: 'dynamo',
			url: '21900_orus/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 13.45
		}]
	},
	'225088_2007_or10': {
		groups: ['dwarf planets', 'TNOs'],
		radius: 615,
		label: '2007 OR<sub>10</sub>',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [615, 615, 596.55]
		},
		controllers: [{
			type: 'dynamo',
			url: '225088_2007_or10/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 22.40
		}]
	},
	'2340_hathor': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.105,
		label: 'Hathor',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.105, 0.105, 0.105]
		},
		controllers: [{
			type: 'dynamo',
			url: '2340_hathor/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.350
		}]
	},
	'243_ida': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 29.9,
		label: 'Ida',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [18.6 * 1.3, 25.4 * 1.3, 59.8 * 1.3],
			rotate: [
				{ y: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: '243_ida/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 4.634
		}]
	},
	'25143_itokawa': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.165,
		label: 'Itokawa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/25143_itokawa/itokawa.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: '25143_itokawa/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12.132
		}]
	},
	'253_mathilde': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 33,
		label: 'Mathilde',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [33, 24, 23]
		},
		controllers: [{
			type: 'dynamo',
			url: '253_mathilde/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 417.7
		}]
	},
	'2867_steins': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 3.415,
		label: 'Šteins',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3.415, 2.85, 2.21]
		},
		controllers: [{
			type: 'dynamo',
			url: '2867_steins/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 6.049
		}]
	},
	'3_juno': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 160,
		label: 'Juno',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [160, 133.5, 100]
		},
		controllers: [{
			type: 'dynamo',
			url: '3_juno/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 7.210
		}]
	},
	'3122_florence': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 2.2,
		label: 'Florence',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.2, 2.2, 2.2]
		},
		controllers: [{
			type: 'dynamo',
			url: '3122_florence/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.3581
		}]
	},
	'3200_phaethon': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 2.9,
		label: 'Phaethon',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.9, 2.9, 2.9]
		},
		controllers: [{
			type: 'dynamo',
			url: '3200_phaethon/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.604
		}]
	},
	'3362_khufu': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.35,
		label: 'Khufu',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.35, 0.35, 0.35]
		},
		controllers: [{
			type: 'dynamo',
			url: '3362_khufu/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'3548_eurybates': {
		groups: ['asteroids'],
		radius: 31.9425,
		label: 'Eurybates',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 31.9425
		},
		controllers: [{
			type: 'dynamo',
			url: '3548_eurybates/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 8.711
		}]
	},
	'367943_duende': {
		groups: ['asteroids', 'NEOs'],
		radius: 0.020,
		label: 'Duende',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.01, 0.01, 0.02]
		},
		controllers: [{
			type: 'dynamo',
			url: '367943_duende/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 9.485
		}]
	},
	'37655_illapa': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.75,
		label: 'Illapa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.75, 0.75, 0.75]
		},
		controllers: [{
			type: 'dynamo',
			url: '37655_illapa/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.6556
		}]
	},
	'4_vesta': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 262.7,
		label: 'Vesta',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/4_vesta/4_vesta.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: '4_vesta/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'4015_wilson-harrington': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 2.0,
		label: 'Wilson-Harrington',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2, 2, 2]
		},
		controllers: [{
			type: 'dynamo',
			url: '4015_wilson-harrington/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.5736
		}]
	},
	'4179_toutatis': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 2.13,
		label: 'Toutatis',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.35, 1.015, 2.13]
		},
		controllers: [{
			type: 'dynamo',
			url: '4179_toutatis/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 176
		}]
	},
	'4183_cuno': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 1.8255,
		label: 'Cuno',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.8255, 1.8255, 1.89255]
		},
		controllers: [{
			type: 'dynamo',
			url: '4183_cuno/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.5595
		}]
	},
	'433_eros': {
		groups: ['asteroids', 'NEOs'],
		radius: 8.42,
		label: 'Eros',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/433_eros/433_eros.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: '433_eros/sun/orb'
		}, {
			type: 'dynamo',
			url: '433_eros/ori'
		}]
	},
	'4450_pan': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.5,
		label: 'Pan',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.5, 0.5, 0.5]
		},
		controllers: [{
			type: 'dynamo',
			url: '4450_pan/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 56.48
		}]
	},
	'4486_mithra': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 1.175,
		label: 'Mithra',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.175, 0.825, 0.72]
		},
		controllers: [{
			type: 'dynamo',
			url: '4486_mithra/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 67.5
		}]
	},
	'4769_castalia': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.9,
		label: 'Castalia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.4, 0.4, 0.9]
		},
		controllers: [{
			type: 'dynamo',
			url: '4769_castalia/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 4.095
		}]
	},
	'486958_arrokoth': {
		groups: ['TNOs'],
		radius: 15.0,
		label: 'Arrokoth',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/486958_arrokoth/mu69.gltf',
			scale: [1, 1, 1],
			rotate: [
				{ x: -110 },
				{ y: 180 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: '486958_arrokoth/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}, {
			type: 'spin',
			axis: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-6.121453676996425e-10, 0.9396926211599973, 0.34202014229786787),
			periodInHours: 13
		}],
		postCreateFunction: (entity) => {
			const spin = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.SpinController);
			if (spin !== null) {
				spin.setReferenceAngle(0);
				spin.setReferenceTime(599590968);
			}
		}
	},
	'5011_ptah': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.78,
		label: 'Ptah',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.78, 0.78, 0.78]
		},
		controllers: [{
			type: 'dynamo',
			url: '5011_ptah/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 12
		}]
	},
	'52246_donaldjohanson': {
		groups: ['asteroids'],
		radius: 1.9475,
		label: 'Donaldjohanson',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: 1.9475
		},
		controllers: [{
			type: 'dynamo',
			url: '52246_donaldjohanson/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	'5535_annefrank': {
		groups: ['asteroids'],
		radius: 2.412,
		label: 'Annefrank',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 2.412
		},
		controllers: [{
			type: 'dynamo',
			url: '5535_annefrank/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 15.12
		}]
	},
	'617_patroclus': {
		groups: ['asteroids', '617_patroclus_barycenter'],
		radius: 64,
		label: 'Patroclus',
		labelFadeEntity: 'sun',
		parents: [
			[Number.NEGATIVE_INFINITY, '617_patroclus_barycenter']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [64, 58, 49],
			shadowEntities: ['menoetius']
		},
		controllers: [{
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: 'menoetius'
			}
		}],
		postCreateFunction: (entity) => {
			// Add the controller for going around sun from earth to venus.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController, undefined, entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController));
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0;
			oe.semiMajorAxis = 664;
			oe.meanAngularMotion = 0.00001697791;
			oe.meanAnomalyAtEpoch = Math.PI;
			oe.setOrbitOrientationFromElements(1.97244894756, 0, 0);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);
		}
	},
	'617_patroclus_barycenter': {
		groups: ['asteroids'],
		radius: 664,
		label: 'Patroclus',
		labelFadeEntity: '617_patroclus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		controllers: [{
			type: 'dynamo',
			url: '617_patroclus/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}],
		postCreateFunction: (entity) => {
			entity.setCanOcclude(false);
		}
	},
	'6239_minos': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.237,
		label: 'Minos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.237, 0.237, 0.237]
		},
		controllers: [{
			type: 'dynamo',
			url: '6239_minos/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 3.5558
		}]
	},
	'6489_golevka': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.265,
		label: 'Golevka',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.265, 0.265, 0.265]
		},
		controllers: [{
			type: 'dynamo',
			url: '6489_golevka/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 6.026
		}]
	},
	'65803_didymos': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.39,
		label: 'Didymos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/65803_didymos/Didymos.gltf',
			rotate: [
				{ z: 180 },
				{ x: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: '65803_didymos/sun/orb'
		}, {
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0, 1, 0, 0)
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.2593,
			relativeToTime: 0
		}]
	},
	'66391_moshup': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.766,
		label: 'Moshup',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.766, 0.7475, 0.6735]
		},
		controllers: [{
			type: 'dynamo',
			url: '66391_moshup/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 2.7645
		}]
	},
	// Needs spice
	// 'squannit': {
	// 	groups: ['asteroids', 'NEOs', 'PHAs'],
	// 	radius: 0.180,
	// 	label: 'Squannit',
	// 	parents: [
	// 		[Number.NEGATIVE_INFINITY, 'sun']
	// 	],
	// 	trail: {
	// 		length: 57600
	// 	},
	// 	model: {
	// 		url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
	// 		scale: [0.180, 0.180, 0.180]
	// 	},
	// 	dynamo: [{
	// 		url: 'squannit/66391_moshup/orb',
	// 		parent: '66391_moshup'
	// 	}],
	// 	spin: {
	// 		axis: Pioneer.Vector3.ZAxis,
	// 		periodInHours: 12
	// 	}
	// },
	'69230_hermes': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.425,
		label: 'Hermes',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [0.425, 0.425, 0.425]
		},
		controllers: [{
			type: 'dynamo',
			url: '69230_hermes/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 13.894
		}]
	},
	'90377_sedna': {
		groups: ['dwarf planets', 'TNOs'],
		radius: 497.5,
		label: 'Sedna',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [497.5, 497.5, 497.5]
		},
		controllers: [{
			type: 'dynamo',
			url: '90377_sedna/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 10.273
		}]
	},
	'951_gaspra': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 9.1,
		label: 'Gaspra',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/951_gaspra/gaspra.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: '951_gaspra/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 7.042
		}]
	},
	'9969_braille': {
		groups: ['asteroids', 'asteroid belt'],
		radius: 1.05,
		label: 'Braille',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.05, 0.5, 0.5]
		},
		controllers: [{
			type: 'dynamo',
			url: '9969_braille/sun/orb'
		}, {
			type: 'spin',
			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
			periodInHours: 226.4
		}]
	},
	'99942_apophis': {
		groups: ['asteroids', 'NEOs', 'PHAs'],
		radius: 0.225,
		label: 'Apophis',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/99942_apophis/apophis.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: '99942_apophis/sun/orb'
		}, {
			type: 'spin',
			// Goldstone and Arecibo radar observations of (99942) Apophis in 2012–2013, Marina Brozovic et al, 2018
			// Converted 246.8°, -59.3° to XYZ.
			axis: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.20112425201023415, 0.46925803805904115, 0.8598522715968735),
			periodInHours: 30.4
		}]
	},
	'152830_dinkinesh': {
		groups: ['asteroids'],
		radius: 0.45,
		label: 'Dinkinesh',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: 0.45
		},
		controllers: [{
			type: 'dynamo',
			url: '152830_dinkinesh/sun/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	charon: {
		groups: ['134340_pluto', 'moons', '134340_pluto_barycenter'],
		radius: 603.5,
		label: 'Charon',
		parents: [
			[Number.NEGATIVE_INFINITY, '134340_pluto_barycenter']
		],
		trail: {
			length: undefined
		},
		spheroid: {
			equatorialRadius: 603.5,
			polarRadius: 603.5,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: 'charon/color_$SIZE_$FACE.png',
					sizes: [4, 512, 2048]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: 'charon/134340_pluto_barycenter/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: '134340_pluto'
			},
			secondary: {
				type: 'velocity',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
				target: '134340_pluto'
			}
		}]
	},
	dactyl: {
		groups: ['243_ida', 'moons'],
		radius: 0.7,
		label: 'Dactyl',
		parents: [
			[Number.NEGATIVE_INFINITY, '243_ida']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [0.8, 0.7, 0.6],
			rotate: [
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: '243_ida'
			}
		}],
		postCreateFunction: (entity) => {
			// Add the controller for going around sun from earth to venus.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController, undefined, entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.AlignController));
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0;
			oe.semiMajorAxis = 90;
			oe.meanAngularMotion = 8.726646e-5; // 20 hrs per orbit
			oe.meanAnomalyAtEpoch = 0;
			oe.orbitOrientation.set(0.8728453580255966, 0.1876084386162498, -0.08948587100888229, 0.4415159494547423);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);
		}
	},
	dimorphos: {
		groups: ['65803_didymos', 'moons'],
		radius: 0.085,
		label: 'Dimorphos',
		parents: [
			[Number.NEGATIVE_INFINITY, '65803_didymos']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/dimorphos/Dimorphos.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'dimorphos/65803_didymos/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: '65803_didymos'
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
				target: '65803_didymos',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	hiiaka: {
		groups: ['136108_haumea', 'moons'],
		radius: 160.0,
		label: 'Hi\'iaka',
		parents: [
			[Number.NEGATIVE_INFINITY, '136108_haumea']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [160, 160, 160]
		},
		controllers: [{
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: '136108_haumea'
			}
		}],
		postCreateFunction: (entity) => {
			// Add the controller for going around sun from earth to venus.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController, undefined, entity.getControllerByType('align'));
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0.0513;
			oe.semiMajorAxis = 49880;
			oe.meanAngularMotion = 1.48049e-6; // 49.12 days per orbit
			oe.meanAnomalyAtEpoch = 0;
			oe.setOrbitOrientationFromElements(2.20532822965, 0, 0);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);
		}
	},
	hydra: {
		groups: ['134340_pluto', 'moons', '134340_pluto_barycenter'],
		radius: 25.0,
		label: 'Hydra',
		parents: [
			[Number.NEGATIVE_INFINITY, '134340_pluto_barycenter']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [25, 25, 25],
			shadowEntities: ['134340_pluto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'hydra/134340_pluto_barycenter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kerberos: {
		groups: ['134340_pluto', 'moons', '134340_pluto_barycenter'],
		radius: 8.25,
		label: 'Kerberos',
		parents: [
			[Number.NEGATIVE_INFINITY, '134340_pluto_barycenter']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [8.25, 8.25, 8.25],
			shadowEntities: ['134340_pluto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kerberos/134340_pluto_barycenter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	menoetius: {
		groups: ['617_patroclus_barycenter', 'moons'],
		radius: 58,
		label: 'Menoetius',
		parents: [
			[Number.NEGATIVE_INFINITY, '617_patroclus_barycenter']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [58, 54, 45],
			shadowEntities: ['617_patroclus']
		},
		controllers: [{
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: '617_patroclus'
			}
		}],
		postCreateFunction: (entity) => {
			// Add the controller for going around sun from earth to venus.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController, undefined, entity.getControllerByType('align'));
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0;
			oe.semiMajorAxis = 664;
			oe.meanAngularMotion = 0.00001697791;
			oe.meanAnomalyAtEpoch = 0;
			oe.setOrbitOrientationFromElements(1.97244894756, 0, 0);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);
		}
	},
	namaka: {
		groups: ['136108_haumea', 'moons'],
		radius: 85.0,
		label: 'Nāmaka',
		parents: [
			[Number.NEGATIVE_INFINITY, '136108_haumea']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [85, 85, 85]
		},
		controllers: [{
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxis,
				target: '136108_haumea'
			}
		}],
		postCreateFunction: (entity) => {
			// Add the controller for going around sun from earth to venus.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController, undefined, entity.getControllerByType('align'));
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0.249;
			oe.semiMajorAxis = 25657;
			oe.meanAngularMotion = 3.9786e-6; // 18.2783 days per orbit
			oe.meanAnomalyAtEpoch = 0;
			oe.setOrbitOrientationFromElements(1.97244894756, 0, 0);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);
		}
	},
	nix: {
		groups: ['134340_pluto', 'moons', '134340_pluto_barycenter'],
		radius: 24.0,
		label: 'Nix',
		parents: [
			[Number.NEGATIVE_INFINITY, '134340_pluto_barycenter']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [24, 24, 24],
			shadowEntities: ['134340_pluto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'nix/134340_pluto_barycenter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	styx: {
		groups: ['134340_pluto', 'moons', '134340_pluto_barycenter'],
		radius: 5.5,
		label: 'Styx',
		parents: [
			[Number.NEGATIVE_INFINITY, '134340_pluto_barycenter']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [5.5, 5.5, 5.5],
			shadowEntities: ['134340_pluto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'styx/134340_pluto_barycenter/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/neptune_moons.js":
/*!********************************************************!*\
  !*** ../pioneer/scripts/src/entities/neptune_moons.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	despina: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 90,
		label: 'Despina',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [90, 90, 90],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'despina/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'despina/ori'
		}]
	},
	galatea: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 102,
		label: 'Galatea',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [102, 102, 102],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'galatea/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'galatea/ori'
		}]
	},
	halimede: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 31,
		label: 'Halimede',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [31, 31, 31],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'halimede/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	hippocamp: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 17.4,
		label: 'Hippocamp',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [17.4, 17.4, 17.4],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'hippocamp/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	laomedeia: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 21,
		label: 'Laomedeia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [21, 21, 21],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'laomedeia/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	larissa: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 108,
		label: 'Larissa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [108, 108, 108],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'larissa/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'larissa/ori'
		}]
	},
	naiad: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 48,
		label: 'Naiad',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [48, 48, 48],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'naiad/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'naiad/ori'
		}]
	},
	nereid: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 170.0,
		label: 'Nereid',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [170, 170, 170],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'nereid/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	neso: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 30,
		label: 'Neso',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [30, 30, 30],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'neso/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	proteus: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 232.5,
		label: 'Proteus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/proteus/proteus.gltf',
			scale: [1, 1, 1]
		},
		controllers: [{
			type: 'dynamo',
			url: 'proteus/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'proteus/ori'
		}]
	},
	psamathe: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 20,
		label: 'Psamathe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [20, 20, 20],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'psamathe/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sao: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 22,
		label: 'Sao',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [22, 22, 22],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sao/neptune/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	thalassa: {
		groups: ['neptune', 'moons', 'regular'],
		radius: 54,
		label: 'Thalassa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [54, 54, 54],
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'thalassa/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'thalassa/ori'
		}]
	},
	triton: {
		groups: ['neptune', 'moons', 'irregular'],
		radius: 1353.4,
		label: 'Triton',
		parents: [
			[Number.NEGATIVE_INFINITY, 'neptune']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 1353.4,
			polarRadius: 1353.4,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'triton/color_$SIZE_$FACE.jpg',
					sizes: [16, 512, 4096]
				}
			},
			shadowEntities: ['neptune']
		},
		controllers: [{
			type: 'dynamo',
			url: 'triton/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'triton/ori'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/outer_planet_spacecraft.js":
/*!******************************************************************!*\
  !*** ../pioneer/scripts/src/entities/outer_planet_spacecraft.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _controllers_keyframe_pointing_controller__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../controllers/keyframe_pointing_controller */ "../pioneer/scripts/src/controllers/keyframe_pointing_controller.js");
/* harmony import */ var _controllers_keyframe_spin_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../controllers/keyframe_spin_controller */ "../pioneer/scripts/src/controllers/keyframe_spin_controller.js");
/** @module pioneer-scripts */





_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_juno: {
		groups: ['jupiter', 'spacecraft'],
		occlusionRadius: 0.001732,
		extentsRadius: 0.010000,
		label: 'Juno',
		parents: [
			[365836752.1832, 'earth'],
			[366088266.183, 'sun'],
			[434433667.182, 'earth'],
			[434793667.182, 'sun'],
			[519652868.184, 'jupiter'],
			[676339597, 'ganymede'],
			[676381521, 'jupiter'],
			[717700360, 'europa'],
			[717727733, 'jupiter'],
			[757191924, 'io'],
			[757203571, 'jupiter'],
			[760247560, 'io'],
			[760262808, 'jupiter']
		],
		trail: {
			length: undefined,
			lengthCoverages: [
				[63072000, Number.NEGATIVE_INFINITY, 519652868.184],
				[5184000, 519652868.184, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_juno/Juno.gltf',
			rotate: [{
				x: 90
			}],
			shadowEntities: ['jupiter', 'europa', 'ganymede', 'callisto', 'io']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_juno/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/sun/preflyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/earth/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/sun/postflyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/ganymede/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/europa/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/io/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_juno/io/2/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity,
			coverage: [365836752.1832, Number.POSITIVE_INFINITY]
		}, {
			type: 'dynamo',
			url: 'sc_juno/ori'
		}, {
			type: 'coverage',
			coverage: [393471366, 529748408 + 600],
			update: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				const cover = model.getThreeJsObjectByName('engine_cover');
				if (cover !== null) {
					const time = entity.getScene().getEngine().getTime();
					const nextCloseIndex = pioneer__WEBPACK_IMPORTED_MODULE_1__.Sort.getIndex(time, junoEngineCoverOpenings, (a, b) => a[1] < b);
					const openTime = junoEngineCoverOpenings[nextCloseIndex][0];
					const closeTime = junoEngineCoverOpenings[nextCloseIndex][1];
					const u = pioneer__WEBPACK_IMPORTED_MODULE_1__.MathUtils.clamp01(((closeTime - openTime) / 2 - Math.abs(time - (closeTime + openTime) / 2)) / 600);
					cover.rotation.x = pioneer__WEBPACK_IMPORTED_MODULE_1__.MathUtils.lerp(Math.PI, Math.PI / 8, u);
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				const cover = model.getThreeJsObjectByName('engine_cover');
				if (cover !== null) {
					cover.rotation.x = Math.PI;
				}
			}
		}, {
			type: 'coverage',
			coverage: [399637867.183, 520959604.184],
			update: (entity) => {
				const particleSpray = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ParticleSprayComponent);
				const time = entity.getScene().getEngine().getTime();
				const nextCloseIndex = pioneer__WEBPACK_IMPORTED_MODULE_1__.Sort.getIndex(time, junoEngineBurns, (a, b) => a[1] < b);
				const startTime = junoEngineBurns[nextCloseIndex][0];
				const endTime = junoEngineBurns[nextCloseIndex][1];
				const enabled = startTime <= time && time < endTime;
				particleSpray.setEnabled(enabled);
			},
			exit: (entity) => {
				const particleSpray = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ParticleSprayComponent);
				particleSpray.setEnabled(false);
			}
		}, {
			type: 'coverage',
			coverage: [519652868.184, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail) {
					trail.setRelativeToEntity('jupiter');
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail) {
					trail.setRelativeToEntity('');
				}
			}
		}],
		postCreateFunction: (entity) => {
			// Use the keyframes to point in the right direction.
			const keyframePointing = entity.addControllerByClass(_controllers_keyframe_pointing_controller__WEBPACK_IMPORTED_MODULE_2__.KeyframePointingController);
			keyframePointing.setKeyframes(junoPointingKeyframes);
			keyframePointing.setDirection(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis);
			keyframePointing.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(365836752.1832, 521025625));

			// Use the keyframes to spin at the right rates.
			const keyframeSpin = entity.addControllerByClass(_controllers_keyframe_spin_controller__WEBPACK_IMPORTED_MODULE_3__.KeyframeSpinController);
			keyframeSpin.setKeyframes(junoSpinKeyframes);
			keyframeSpin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis);
			keyframeSpin.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(365836752.1832, 521025625));
			keyframeSpin.setStartingAngle(-0.96); // an angle to match the start of the ori dynamo.

			// Set up the engine burn.
			const particleSpray = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ParticleSprayComponent);
			particleSpray.setNumberOfParticles(100);
			particleSpray.setSizeOfParticles(0.0003);
			particleSpray.setSpeedOfParticles(0.01);
			particleSpray.setColorOfParticles(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(1, 0.75, 0, 0.25));
			particleSpray.setSpread(-3);
			particleSpray.setParticleSpacingRandom(false);
			particleSpray.setLength(0.003);
			particleSpray.setOriginOffset(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, -0.0017));
			particleSpray.setDirection(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg);
			particleSpray.setEnabled(false);
		}
	},
	sc_cassini: {
		groups: ['saturn', 'spacecraft'],
		occlusionRadius: 0.0034,
		extentsRadius: 0.005500,
		label: 'Cassini',
		parents: [
			[-69820368.42763124, 'earth'],
			[-69537536.818, 'sun'],
			[-53179136.814, 'venus'],
			[-53092736.814, 'sun'],
			[-16495135.816, 'venus'],
			[-16451935.816, 'sun'],
			[-11951935.817, 'earth'],
			[-11660335.817, 'sun'],
			[139219264.185, 'saturn'],
			[558743640, '']
		],
		dependents: ['sc_huygens'],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_cassini/Cassini.gltf',
			rotate: [
				{ x: -90 },
				{ z: 180 }
			],
			shadowEntities: ['saturn', 'titan', 'enceladus', 'mimas', 'tethys']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_cassini/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/venus/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/venus/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/sun/3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/earth/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/sun/4/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'sc_cassini/quat'
		}, {
			type: 'coverage',
			coverage: [-13098535.817, 534124760.143],
			update: (entity) => {
				const particleSpray = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ParticleSprayComponent);
				const time = entity.getScene().getEngine().getTime();
				const nextCloseIndex = pioneer__WEBPACK_IMPORTED_MODULE_1__.Sort.getIndex(time, cassiniEngineBurns, (a, b) => a[1] < b);
				const startTime = cassiniEngineBurns[nextCloseIndex][0];
				const endTime = cassiniEngineBurns[nextCloseIndex][1];
				const enabled = startTime <= time && time < endTime;
				particleSpray.setEnabled(enabled);
			},
			exit: (entity) => {
				const particleSpray = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ParticleSprayComponent);
				particleSpray.setEnabled(false);
			}
		}, {
			type: 'coverage',
			coverage: [157212064.184, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const modelComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (modelComponent !== null) {
					modelComponent.setHiddenObject('huygens_probe', true);
				}
			},
			exit: (entity) => {
				const modelComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
				if (modelComponent !== null) {
					modelComponent.setHiddenObject('huygens_probe', false);
				}
			}
		}],
		postCreateFunction: (entity) => {
			// Set up the engine burn.
			const particleSpray = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ParticleSprayComponent);
			particleSpray.setNumberOfParticles(50);
			particleSpray.setSizeOfParticles(0.0003);
			particleSpray.setSpeedOfParticles(0.01);
			particleSpray.setColorOfParticles(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Color(1, 0.75, 0, 0.25));
			particleSpray.setSpread(-3);
			particleSpray.setParticleSpacingRandom(false);
			particleSpray.setLength(0.002);
			particleSpray.setOriginOffset(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0.00029, 0.0033));
			particleSpray.setDirection(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis);
			particleSpray.setEnabled(false);
		}
	},
	// sc_europa_clipper: { // Consistent breaking error when loading the Dynamo file. Not worth fixing atm.
	// 	groups: ['jupiter', 'europa', 'ganymede', 'callisto', 'spacecraft'],
	// 	occlusionRadius: 0.003,
	// 	extentsRadius: 0.011,
	// 	label: 'Europa Clipper',
	// 	parents: [
	// 		[781796651, 'sun'],
	// 		[849443647, 'earth'],
	// 		[849694384, 'sun'],
	// 		[954569001, 'jupiter'],
	// 		[1096736672, '']
	// 	],
	// 	trail: {
	// 		length: undefined
	// 	},
	// 	model: {
	// 		url: '$STATIC_ASSETS_URL/models/sc_europa_clipper/europa_clipper.gltf',
	// 		shadowEntities: ['jupiter', 'earth', 'mars', 'europa']
	// 	},
	// 	controllers: [{
	// 		type: 'dynamo',
	// 		url: 'sc_europa_clipper/sun/orb'
	// 	}, {
	// 		type: 'dynamo',
	// 		url: 'sc_europa_clipper/earth/flyby/orb'
	// 	}, {
	// 		type: 'dynamo',
	// 		url: 'sc_europa_clipper/jupiter/orb'
	// 	}, {
	// 		type: 'align',
	// 		primary: {
	// 			type: 'point',
	// 			target: 'sun',
	// 			axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
	// 		}
	// 	}]
	// },
	sc_galileo: {
		groups: ['jupiter', 'spacecraft'],
		occlusionRadius: 0.003,
		extentsRadius: 0.0055,
		label: 'Galileo',
		parents: [
			[-321964226.73959994, 'earth'],
			[-321559829, 'sun'],
			[-312199026, 'venus'],
			[-311946958, 'sun'],
			[-286252262, 'earth'],
			[-285827020, 'sun'],
			[-223105356, 'earth'],
			[-222610262, 'sun'],
			[-129268796, 'jupiter'],
			[117442702, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_galileo/galileo.gltf',
			shadowEntities: ['jupiter', 'earth', 'venus'],
			rotate: [
				{ x: -90 },
				{ z: 180 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_galileo/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_galileo/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_galileo/venus/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_galileo/earth/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_galileo/earth/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_galileo/jupiter/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'mercury',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis,
				target: 'earth',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_galileo/quat'
		}],
		postCreateFunction: (entity) => {
			// Make the rotor spin.
			const spin = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.SpinController);
			spin.setJoint('spinning_section');
			spin.setRate(3 * 2 * Math.PI / 60);
			spin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg, true);
		}
	},
	sc_galileo_probe: {
		groups: ['jupiter', 'spacecraft'],
		radius: 0.00072,
		label: 'Galileo Probe',
		parents: [
			[-321964226.73959994, 'sc_galileo'],
			[-129268796, 'jupiter'],
			[-128353980, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_galileo_probe/galileo_probe.gltf',
			rotate: [
				{ x: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_galileo_probe/galileo/orb'
		}, {
			type: 'dynamo',
			url: 'sc_galileo_probe/jupiter/orb'
		}, {
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity,
			coverage: [-321964226.73959994, -141114537.48322043]
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, -141114537.48322043],
			enter: (entity) => {
				const div = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
				if (div !== null) {
					div.setEnabled(false);
				}
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setEnabled(false);
				}
				const translateController = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TranslateController);
				translateController.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0.001));
			},
			exit: (entity) => {
				const div = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.DivComponent);
				if (div !== null) {
					div.setEnabled(true);
				}
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trail !== null) {
					trail.setEnabled(true);
				}
				const translateController = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TranslateController);
				translateController.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-0.000016, 0.000024, 0.0007));
			}
		}],
		postCreateFunction: (entity) => {
			// Make the model centered.
			const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
			model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, -0.001));

			// Move it so that its dynamo start lines up with galileo on release.
			const translateController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TranslateController);
			translateController.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-0.000016, 0.000024, 0.0007));
			translateController.setRelativeToOrientation(true);
			translateController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(-321964226.73959994, -128353980));

			// Orient it so that it lines up with galileo on release.
			const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.RotateByEntityOrientationController);
			rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(-321964226.73959994, -141114537.48322043));
			const fixed = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.FixedController);
			fixed.setOrientation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.40004226980201746, 0.3894033591393042, -0.7928008139628516, 0.24453645053961984));
			fixed.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(-141114537.48322043, Number.POSITIVE_INFINITY));
		}
	},
	sc_huygens: {
		groups: ['saturn', 'spacecraft', 'titan'],
		occlusionRadius: 0.00130,
		extentsRadius: 0.00130,
		label: 'Huygens',
		parents: [
			[157212064.184, 'saturn'],
			[158945582, 'titan'],
			[158974766.184, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_huygens/Huygens.gltf',
			rotate: [
				{ x: -90 },
				{ z: 180 }
			],
			shadowEntities: ['saturn', 'titan', 'enceladus', 'mimas', 'tethys']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_huygens/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'sc_huygens/titan/orb'
		}, {
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.8295521744501194, 0.09912464029342342, -0.04158756948048668, -0.5479853735424731)
		}, {
			type: 'custom',
			func: (entity) => {
				// Needed because spice doesn't go all the way down.
				const keyframeController1 = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.KeyframeController);
				keyframeController1.addPositionKeyframe(158965616.707, // When the spice runs out.
					new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-74.84608000701567, -3832.0774028380238, -305.9513410781612));
				keyframeController1.addPositionKeyframe(158965667.7750001,
					new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-168.19015737501377, -3541.733393771429, -291.12326824195395));
				keyframeController1.addPositionKeyframe(158965894.184, // When Huygens deploys its parachute  at 152 km altitude
					new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-376.8992769951708, -2686.9622048526126, -273.33138256355716));
				return keyframeController1;
			}
		}, {
			type: 'custom',
			func: (entity) => {
				// Separate keyframe controller needed for parachute landing, since it is a sharp edge, slowing the velocity drastically.
				const keyframeController2 = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.KeyframeController);
				keyframeController2.addPositionKeyframe(158965894.184, // When Huygens deploys its parachute  at 152 km altitude
					new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-376.8992769951708, -2686.9622048526126, -273.33138256355716));
				keyframeController2.addPositionKeyframe(158974766.184, // When Huygens lands on the ground
					new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-251.2479743710496, -2548.813556954952, -266.5500089234507));
				return keyframeController2;
			}
		}, {
			type: 'custom',
			func: (entity) => {
				// Reverse the model translation.
				const translateController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TranslateController);
				translateController.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-0.0013, 0, 0.0011));
				translateController.setRelativeToOrientation(true);
				translateController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(157212064.184, 158974766.184));
				return translateController;
			}
		}, {
			type: 'custom',
			func: (entity) => {
				// Use the keyframes to spin at the right rates.
				const keyframeSpin = entity.addControllerByClass(_controllers_keyframe_spin_controller__WEBPACK_IMPORTED_MODULE_3__.KeyframeSpinController);
				keyframeSpin.setKeyframes(huygensSpinKeyframes);
				keyframeSpin.setAxis(pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg);
				keyframeSpin.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Interval(157212064.184, Number.POSITIVE_INFINITY));
				return keyframeSpin;
			}
		}, {
			type: 'coverage',
			coverage: [158965616.707, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trailComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trailComponent !== null) {
					trailComponent.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trailComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.TrailComponent);
				if (trailComponent !== null) {
					trailComponent.setRelativeToEntityOrientation(false);
				}
			}
		}],
		postCreateFunction: (entity) => {
			// Make the model centered.
			const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.ModelComponent);
			model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.0013, 0, -0.0011));
		}
	},
	sc_huygens_landing_site: {
		groups: ['titan', 'sc_huygens', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Huygens Landing Site',
		parents: [
			[157212064.184, 'titan']
		],
		controllers: [{
			type: 'fixed',
			llaOnSpheroid: new pioneer__WEBPACK_IMPORTED_MODULE_1__.LatLonAlt(-0.18453331247520502, 2.9263055188728955, 0),
			coverage: [157212064.184, Number.POSITIVE_INFINITY]
		}]
	},
	sc_juice: {
		groups: ['jupiter', 'ganymede', 'spacecraft'],
		occlusionRadius: 0.007,
		extentsRadius: 0.0135,
		label: 'JUICE',
		parents: [
			[734748207, 'earth'],
			[735606318, 'sun'],
			[777026548, 'earth'],
			[778061110, 'sun'],
			[809697014, 'venus'],
			[810162491, 'sun'],
			[843697642, 'earth'],
			[844049179, 'sun'],
			[916393497, 'earth'],
			[916903199, 'sun'],
			[994471790, 'jupiter'],
			[1103217877, 'ganymede']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_juice/juice.gltf',
			shadowEntities: ['ganymede', 'jupiter', 'earth']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_juice/earth/launch'
		}, {
			type: 'dynamo',
			url: 'sc_juice/sun'
		}, {
			type: 'dynamo',
			url: 'sc_juice/earth/flyby1'
		}, {
			type: 'dynamo',
			url: 'sc_juice/venus/flyby'
		}, {
			type: 'dynamo',
			url: 'sc_juice/earth/flyby2'
		}, {
			type: 'dynamo',
			url: 'sc_juice/earth/flyby3'
		}, {
			type: 'dynamo',
			url: 'sc_juice/jupiter'
		}, {
			type: 'dynamo',
			url: 'sc_juice/ganymede'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			},
			secondary: {
				type: 'align',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_juice/quat'
		}]
	},
	sc_pioneer_10: {
		groups: ['sun', 'jupiter', 'spacecraft'],
		occlusionRadius: 0.002118055,
		extentsRadius: 0.003,
		label: 'Pioneer 10',
		parents: [
			[-878291717.8145751, 'earth'],
			[-878146409, 'sun'],
			[-824046472, 'jupiter'],
			[-822011429, 'sun']
		],
		trail: {
			length: 60 * 60 * 24 * 365 * 10
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_pioneer/pioneer.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_pioneer_10/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_10/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_10/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_10/sun/2/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}]
	},
	sc_pioneer_11: {
		groups: ['sun', 'jupiter', 'saturn', 'spacecraft'],
		occlusionRadius: 0.002118055,
		extentsRadius: 0.003,
		label: 'Pioneer 11',
		parents: [
			[-843816855.8143449, 'earth'],
			[-843644357, 'sun'],
			[-792658454, 'jupiter'],
			[-790152245, 'sun'],
			[-643302619, 'saturn'],
			[-640194311, 'sun']
		],
		trail: {
			length: 60 * 60 * 24 * 365 * 10
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_pioneer/pioneer.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_pioneer_11/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_11/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_11/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_11/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_11/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'sc_pioneer_11/sun/3/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			}
		}]
	},
	sc_voyager_1: {
		groups: ['jupiter', 'saturn', 'sun', 'spacecraft'],
		occlusionRadius: 0.00183,
		extentsRadius: 0.0043000,
		label: 'Voyager 1',
		parents: [
			[-704412035.617, 'earth'],
			[-703530245, 'sun'],
			[-660264745, 'jupiter'],
			[-655057463, 'sun'],
			[-606239665, 'saturn'],
			[-600733702, 'sun']
		],
		trail: {
			length: 946080000,
			lengthCoverages: [
				[157680000, Number.NEGATIVE_INFINITY, 377123932.454],
				[946080000, 377123932.454, Number.POSITIVE_INFINITY],
				[5184000, -660264745, -655057463],
				[5184000, -606239665, -600733702]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_voyager/Voyager.gltf',
			rotate: [
				{ x: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_voyager_1/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_1/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_1/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_1/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_1/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_1/sun/3/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			}
		}, {
			type: 'dynamo',
			url: 'sc_voyager_1/ori'
		}]
	},
	sc_voyager_2: {
		groups: ['jupiter', 'saturn', 'uranus', 'neptune', 'sun', 'spacecraft'],
		occlusionRadius: 0.00183,
		extentsRadius: 0.0043000,
		label: 'Voyager 2',
		parents: [
			[-705788847.817, 'earth'],
			[-704774613, 'sun'],
			[-650828783, 'jupiter'],
			[-642276063, 'sun'],
			[-582886481, 'saturn'],
			[-574538624, 'sun'],
			[-440395228, 'uranus'],
			[-439259319, 'sun'],
			[-327233138, 'neptune'],
			[-326252606, 'sun']
		],
		trail: {
			length: 946080000,
			lengthCoverages: [
				[157680000, Number.NEGATIVE_INFINITY, 651751314.724],
				[946080000, 651751314.724, Number.POSITIVE_INFINITY],
				[5184000, -650828783, -642276063],
				[5184000, -582886481, -574538624],
				[5184000, -440395228, -439259319],
				[5184000, -327233138, -326252606]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_voyager/Voyager.gltf',
			rotate: [
				{ x: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_voyager_2/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/sun/3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/sun/4/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/neptune/orb'
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/sun/5/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			}
		}, {
			type: 'dynamo',
			url: 'sc_voyager_2/ori'
		}]
	}
});

// Cassini engine burn start/stop times
const cassiniEngineBurns = [
	[-13098535.817, -13098146.797],
	[-12342535.817, -12342421.197],
	[-10612735.817, -10612663.357],
	[14274064.185, 14274070.255],
	[36653454.185, 36653459.605],
	[71128864.186, 71128875.066],
	[105091264.185, 105091282.755],
	[118339264.182, 118339287.092],
	[138968824.185, 138969181.735],
	[140692084.184, 140692123.174],
	[141916392.184, 141922237.024],
	[146548444.183, 146551498.073],
	[147846664.183, 147846668.693],
	[152302564.182, 152302569.842],
	[154285264.183, 154285267.193],
	[156518584.184, 156518669.274],
	[157466284.184, 157466438.074],
	[159139264.184, 159139404.074],
	[160168144.185, 160168264.795],
	[161978464.185, 161978469.745],
	[163011064.185, 163011104.295],
	[163869664.186, 163869667.996],
	[164528404.186, 164528414.466],
	[165853384.186, 165853391.046],
	[166370464.186, 166370502.696],
	[168008344.186, 168008476.766],
	[174127084.184, 174127086.454],
	[176341864.183, 176341881.793],
	[176952124.183, 176952139.533],
	[178261744.183, 178261753.433],
	[178699444.183, 178699535.673],
	[180420064.182, 180420240.372],
	[182368684.182, 182368777.962],
	[184039204.183, 184039282.793],
	[185162584.183, 185162597.343],
	[196273205.186, 196273208.936],
	[197566385.186, 197566387.476],
	[199978145.185, 199978148.205],
	[202994705.185, 202994717.245],
	[207734765.183, 207734800.073],
	[211183265.182, 211183306.302],
	[211500485.182, 211500537.082],
	[212965745.182, 212965786.692],
	[214371665.182, 214371670.582],
	[216354545.183, 216354568.983],
	[219456245.183, 219456251.063],
	[219887345.184, 219887389.034],
	[220835165.184, 220835169.094],
	[221266265.184, 221266275.434],
	[222644225.185, 222644240.975],
	[224109485.185, 224109487.885],
	[226090325.185, 226090329.355],
	[227038025.186, 227038032.946],
	[227469065.186, 227469075.266],
	[228387005.186, 228387008.496],
	[228846905.186, 228846923.006],
	[230225585.186, 230225608.176],
	[231577265.185, 231577300.725],
	[232982885.185, 232982919.625],
	[233930525.185, 233930529.665],
	[234334565.185, 234334641.855],
	[235309205.185, 235309210.915],
	[235740245.184, 235740294.424],
	[239704565.183, 239704568.933],
	[242004965.183, 242004968.253],
	[242979665.182, 242979748.272],
	[244876985.182, 244876993.442],
	[247203665.183, 247203671.283],
	[248986685.183, 248986692.503],
	[249417845.183, 249417942.863],
	[250365665.183, 250365669.503],
	[250801865.183, 250801924.453],
	[252201785.184, 252201798.884],
	[253728965.184, 253728983.974],
	[255535625.185, 255535853.415],
	[256682225.185, 256682228.065],
	[257684225.185, 257684269.165],
	[258146525.185, 258146533.105],
	[258722525.186, 258722543.076],
	[261147905.186, 261147925.516],
	[262453685.186, 262453688.326],
	[264259265.185, 264259272.395],
	[267474305.184, 267474379.954],
	[271073765.183, 271073780.663],
	[272731805.183, 272731887.753],
	[275208605.182, 275208611.692],
	[276214805.182, 276214829.892],
	[277127525.182, 277127545.362],
	[277506665.182, 277506708.062],
	[279455045.183, 279455100.823],
	[279799805.183, 279799837.073],
	[280747565.183, 280747571.013],
	[282126485.183, 282126503.483],
	[282471245.183, 282471256.053],
	[286040946.185, 286040974.915],
	[287532306.185, 287532308.475],
	[289858866.186, 289858897.046],
	[291603966.186, 291603971.806],
	[292809906.186, 292809948.366],
	[294188586.186, 294188602.066],
	[295567266.185, 295567279.505],
	[296945946.185, 296945956.015],
	[297893586.185, 297893599.995],
	[299272206.184, 299272220.614],
	[300687786.184, 300687808.034],
	[302066526.183, 302066563.313],
	[303703506.183, 303703583.793],
	[304824006.183, 304824009.283],
	[305390946.183, 305390972.583],
	[308925306.182, 308925311.352],
	[309355506.182, 309355530.682],
	[310684866.183, 310684869.093],
	[312200586.183, 312200601.223],
	[534124756.143, 534124760.143]
];

/** The times when the Juno engine cover starts opening or finishes closing, respectively.
 *  The 600 is because the hatch takes 600 seconds to close and the number given is the start of the closing time. */
const junoEngineCoverOpenings = [
	[393471366, 393500886 + 600],
	[399019747, 399882847 + 600],
	[400569547, 400988287 + 600],
	[420541747, 420794047 + 600],
	[454490527, 454649587 + 600],
	[487136707, 487309087 + 600],
	[519804068, 521041148 + 600],
	[528958868, 529748408 + 600]
];

const junoEngineBurns = [
	[399637867.183, 399639659.183],
	[400933867.182, 400935660.182],
	[420714067.185, 420714067.185 + 5],
	[454572067.185, 454572067.185 + 5],
	[487231267.185, 487231267.185 + 5],
	[520957868.184, 520959604.184]
];

/** Pointing for Juno, since its orientation doesn't work so well. It can point at an entity, 'velocity', or '-velocity'.
 *  The transition happens for the 5 minutes prior to the start time of the next event. */
const junoPointingKeyframes = /** @type {[number, string][]} */([
	[365835906, 'velocity'],
	[365836206, 'sun'],
	[371908866, 'sun'],
	[371909466, 'earth'],
	[399631646, 'earth'],
	[399632628, 'sun'],
	[399635271, 'sun'],
	[399636306, '-velocity'], // DSM-1
	[399640481, '-velocity'],
	[399641686, 'sun'],
	[399700717, 'sun'],
	[399641887, 'earth'],
	[400927646, 'earth'],
	[400928454, 'sun'],
	[400931272, 'sun'],
	[400932282, '-velocity'], // DSM-2
	[400936477, '-velocity'],
	[400937632, 'sun'],
	[401003197, 'sun'],
	[401009197, 'earth'],
	[423014467, 'earth'],
	[423014767, 'sun'],
	[436924867, 'sun'],
	[436925167, 'earth'],
	[520954868, 'earth'],
	[520955888, '-velocity'], // JOI
	[520960808, '-velocity'],
	[520962008, 'sun'],
	[521018048, 'sun'],
	[521025625, 'earth'] // Dynamo ori starts here
]);

const junoSpinKeyframes = /** @type {[number, number][]} */([
	[394545667, 1 * Math.PI / 30], // convert from rpm to rad/sec
	[394545967, 2 * Math.PI / 30],
	[399636967, 2 * Math.PI / 30],
	[399637264, 5 * Math.PI / 30], // DSM-1
	[399637866, 5 * Math.PI / 30],
	[399639659, 5.5 * Math.PI / 30],
	[399639788, 5.5 * Math.PI / 30],
	[399640072, 2 * Math.PI / 30],
	[400932921, 2 * Math.PI / 30],
	[400933214, 5 * Math.PI / 30], // DSM-2
	[400933866, 5 * Math.PI / 30],
	[400935660, 5.5 * Math.PI / 30],
	[400935790, 5.5 * Math.PI / 30],
	[400936068, 2 * Math.PI / 30],
	[520956548, 2 * Math.PI / 30],
	[520956848, 5 * Math.PI / 30], // JOI
	[520960088, 5 * Math.PI / 30],
	[520960388, 2 * Math.PI / 30],
	[521025625, 2 * Math.PI / 30] // Dynamo ori starts here
]);

const huygensSpinKeyframes = /** @type {[number, number][]} */([
	[157212064.184, 7.5 * Math.PI / 30], // convert from rpm to rad/sec
	[158965863.184, 7.5 * Math.PI / 30],
	[158966163.184, 2.6 * Math.PI / 30],
	[158966434.184, 0],
	[158966883.184, -5.6 * Math.PI / 30], // starts spinning clockwise
	[158967123.184, -9.7 * Math.PI / 30],
	[158967363.184, -7.3 * Math.PI / 30],
	[158968263.184, -2.8 * Math.PI / 30],
	[158973723.184, -1 * Math.PI / 30]
]);


/***/ }),

/***/ "../pioneer/scripts/src/entities/planets_and_stars.js":
/*!************************************************************!*\
  !*** ../pioneer/scripts/src/entities/planets_and_stars.js ***!
  \************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var _scene_helpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../scene_helpers */ "../pioneer/scripts/src/scene_helpers.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */




_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	observable_universe: {
		groups: ['stars'],
		radius: 5e23,
		systemRadius: 5e23,
		label: 'Observable Universe',
		parents: [],
		controllers: [{
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}],
		postCreateFunction: (entity) => {
			entity.setCanOcclude(false);
		}
	},
	milky_way: {
		groups: ['stars'],
		radius: 1e18,
		systemRadius: 1.3e+19,
		label: 'Milky Way',
		parents: [
			[Number.NEGATIVE_INFINITY, 'observable_universe']
		],
		controllers: [{
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}],
		postCreateFunction: (entity, extraOptions) => {
			entity.setCanOcclude(false);

			const fixedController = entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.FixedController);
			// Get it in the right orientation, using the galactic north and galactic center.
			// Galactic North Pole in J2000: 12h 51m 26.27549s, +27° 07′ 41.7043"
			// Galactic Center in J2000: 7h 45m 37.19910s, −28° 56′ 10.2207"
			// From Liu, Jia-Cheng & Zhu, Zi & Zhang, Hong. (2010). Reconsidering the Galactic coordinate system. Astronomy and Astrophysics. 526. 10.1051/0004-6361/201014961.
			const northPole = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3();
			const northPoleRa = 192.85948120833 * Math.PI / 180;
			const northPoleDec = 27.12825119444 * Math.PI / 180;
			northPole.x = Math.cos(northPoleRa) * Math.cos(northPoleDec);
			northPole.y = Math.sin(northPoleRa) * Math.cos(northPoleDec);
			northPole.z = Math.sin(northPoleDec);
			const center = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3();
			const centerRa = 266.40499625 * Math.PI / 180;
			const centerDec = -28.93617241667 * Math.PI / 180;
			center.x = Math.cos(centerRa) * Math.cos(centerDec);
			center.y = Math.sin(centerRa) * Math.cos(centerDec);
			center.z = Math.sin(centerDec);
			const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion();
			orientation.setFromAxes(center, undefined, northPole);
			fixedController.setOrientation(orientation);

			// Add milky way sprite, if it's in the options.
			if (extraOptions && extraOptions.milkyWaySprite) {
				const sprite = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpriteComponent);
				sprite.setTextureUrl('$STATIC_ASSETS_URL/sprites/milky_way.png');
				sprite.setSize(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector2(12e17, 12e17));
				sprite.setTransparent(true);
				sprite.setBlending('normal');
				sprite.setFadeDistance(12e15);
			}

			// Spin of the milky way. Later I should change it to work with particles and use the galaxy rotation curve.
			const spinController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpinController);
			spinController.setAxis(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.8676661356982597, -0.19807638974470915, 0.45598379452940485), false);
			spinController.setRate(-2.192686e-17);
			spinController.setReferenceAngle(0);
			spinController.setReferenceTime(0);
		}
	},
	sun: {
		groups: ['stars'],
		radius: 695500,
		systemRadius: 2.991957e+13,
		label: 'Sun',
		parents: [
			[Number.NEGATIVE_INFINITY, 'milky_way']
		],
		spheroid: {
			equatorialRadius: 695500,
			polarRadius: 695500,
			planetographic: false
		},
		spheroidLOD: {
			features: ['colorMapEmmissive'],
			textures: {
				color: {
					url: 'sun/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			}
		},
		controllers: [{
			type: 'fixed',
			position: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.Zero,
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}],
		postCreateFunction: (entity, extraOptions) => {
			// Add the light source for the sun.
			const lightSourceComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.LightSourceComponent);
			lightSourceComponent.setAbsoluteMagnitude(4.83);

			// Atmosphere glow when you're close up to the sun.
			const sunAtmosphere = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			sunAtmosphere.setEmissivity(1.0);
			sunAtmosphere.setScaleHeight(2e5);
			sunAtmosphere.setDensity(8e-7);
			sunAtmosphere.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(255.0 / 255.0, 255.0 / 255.0, 64.0 / 255.0));

			// Sprite glow when you're far away from the sun.
			const sunGlowSprite = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpriteComponent);
			sunGlowSprite.setBillboard(true);
			sunGlowSprite.setTextureUrl('$STATIC_ASSETS_URL/sprites/sun_glow.png');
			sunGlowSprite.setSize(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector2(100, 100));
			sunGlowSprite.setSizeUnits('pixels');
			sunGlowSprite.setTransparent(true);
			sunGlowSprite.setColorMultiplier(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(1.0, 1.0, 0.5));
			sunGlowSprite.setRenderOrder(-2); // Make it render in the same order as the stars.

			// Set the position in the milky way.
			// Distance from sun to galactic center: 7.98 kpc.
			// From Malkin, Zinovy. (2012). The current best estimate of the Galactocentric distance of the Sun based on comparison of different statistical techniques.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.OrbitalElementsController);
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_2__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0;
			oe.semiMajorAxis = 246237071000000000.0;
			oe.meanAngularMotion = -2.192686e-17; // 230 million years per orbit.
			oe.meanAnomalyAtEpoch = Math.PI;
			// Use the orientation calculated from the milky way above.
			oe.orbitOrientation.set(-0.48894750765094835, -0.4832106839985283, 0.19625375824756275, 0.6992297419646486);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);

			// Add the stars and the galaxies, since they are sun-centric.
			if (extraOptions !== undefined && extraOptions.skybox === true) {
				const skyboxComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SkyboxComponent);
				skyboxComponent.setTextureUrl('$STATIC_ASSETS_URL/textures/starmap_' + (extraOptions.skyboxResolution || 2048) + '.jpg');
			}
			if (extraOptions === undefined || (extraOptions.skybox === true && extraOptions.starfield === true) || extraOptions.starfield !== false) {
				const galaxyComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.StarfieldComponent);
				galaxyComponent.setUrl('$STATIC_ASSETS_URL/stars/galaxies.0.bin');
				for (let i = 0; i < 6; i++) {
					const starfieldComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.StarfieldComponent);
					starfieldComponent.setUrl('$STATIC_ASSETS_URL/stars/stars.' + i + '.bin');
				}
			}

			// Add the heliosphere, if specified.
			// Using "A Three-dimensional Map of the Heliosphere from IBEX", 2021 Reisenfeld et al. as a reference.
			if (extraOptions !== undefined && extraOptions.heliosphere) {
				const model = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				model.setUrl('$STATIC_ASSETS_URL/models/heliosphere/voyager_heliosphere.gltf');
				// Get it just the right size so Voyager 1 leaves it around 2012-08 and Voyager 2 leaves it around 2018-11.
				model.setScale(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(2.01e8, 1.9e8, 1.9e8));
				model.setForceLoaded(true);
				// Rotate so it's heading in the correct direction.
				const llaNose = new pioneer__WEBPACK_IMPORTED_MODULE_2__.LatLonAlt(0, -105 * Math.PI / 180, 0); // Lat/lon of nose in J2000 Ecliptic.
				const xyzNose = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3();
				pioneer__WEBPACK_IMPORTED_MODULE_2__.Geometry.getXYZFromLLAOnSphere(xyzNose, llaNose, 1);
				xyzNose.rotate(_scene_helpers__WEBPACK_IMPORTED_MODULE_1__.SceneHelpers.getEclipJ2000ToJ2000Rotation(), xyzNose);
				xyzNose.normalize(xyzNose);
				const rotation = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion();
				rotation.setFromVectorFromTo(
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.9937396508197329, 0.11171728072160429, 0.0008692392338424033),
					xyzNose);
				model.setRotation(rotation);
			}
		}
	},
	mercury: {
		groups: ['planets'],
		radius: 2439.4,
		systemRadius: 292764,
		label: 'Mercury',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.6, 0.6, 0.6, 0.7]
		},
		spheroid: {
			equatorialRadius: 2439.4,
			polarRadius: 2439.4,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: 'mercury/color_$SIZE_$FACE.png',
					sizes: [4, 512, 4096]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: 'mercury/sun/orb'
		}, {
			type: 'dynamo',
			url: 'mercury/ori'
		}]
	},
	venus: {
		groups: ['planets'],
		radius: 6051.8,
		systemRadius: 726216,
		label: 'Venus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.9, 0.80, 0.45, 0.7]
		},
		spheroid: {
			equatorialRadius: 6051.8,
			polarRadius: 6051.8,
			planetographic: false
		},
		spheroidLOD: {
			textures: {
				color: {
					url: 'venus/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			}
		},
		controllers: [{
			type: 'dynamo',
			url: 'venus/sun/orb'
		}, {
			type: 'dynamo',
			url: 'venus/ori'
		}],
		postCreateFunction: (entity) => {
			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(15.0);
			atmosphereComponent.setDensity(0.001);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(213.0 / 255.0, 160.0 / 255.0, 94.0 / 255.0));
			atmosphereComponent.setSunBrightness(0.25);
		}
	},
	earth: {
		groups: ['planets'],
		radius: 6378.1,
		systemRadius: 765372,
		label: 'Earth',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.0, 0.6, 0.8, 0.7]
		},
		spheroid: {
			equatorialRadius: 6378.137,
			polarRadius: 6356.752,
			planetographic: true
		},
		spheroidLOD: {
			features: ['normalMap', 'specularMap', 'nightMap', 'decalMap', 'nightMapEmmissive', 'shadowEntities'],
			textures: {
				color: {
					url: 'earth/color_$SIZE_$FACE.png',
					sizes: [16, 512, 4096]
				},
				normal: {
					url: 'earth/normal_$SIZE_$FACE.png',
					sizes: [16, 512, 4096]
				},
				specular: {
					url: 'earth/specular_$SIZE_$FACE.png',
					sizes: [16, 512, 4096]
				},
				night: {
					url: 'earth/night_$SIZE_$FACE.png',
					sizes: [16, 512, 4096]
				},
				decal: {
					url: 'earth/cloud_$SIZE_$FACE.png',
					sizes: [16, 512, 4096]
				}
			},
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'earth/sun/orb'
		}, {
			type: 'dynamo',
			url: 'earth/ori'
		}],
		postCreateFunction: (entity, extraOptions) => {
			if (extraOptions && extraOptions.clouds === false) {
				const spheroidLODComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpheroidLODComponent);
				spheroidLODComponent.setTexture('decal', '');
			}

			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(8.0);
			atmosphereComponent.setDensity(0.0015);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(1.5 * 143.0 / 255.0, 1.5 * 178.0 / 255.0, 1.5 * 255.0 / 255.0));
			atmosphereComponent.setSunBrightness(2.0);
			atmosphereComponent.setSunsetColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(1, 0.5, 0));
			atmosphereComponent.setSunsetIntensity(1.2);
		}
	},
	mars: {
		groups: ['planets'],
		radius: 3396.2,
		systemRadius: 46922,
		label: 'Mars',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.89, 0.51, 0.35, 0.7]
		},
		spheroid: {
			equatorialRadius: 3396.19,
			polarRadius: 3376.2,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'mars/color_$SIZE_$FACE.png',
					sizes: [4, 512, 4096]
				}
				// normal: 'mars/normal_$SIZE_$FACE.png',
			},
			shadowEntities: ['phobos', 'deimos']
		},
		controllers: [{
			type: 'dynamo',
			url: 'mars/sun/orb'
		}, {
			type: 'dynamo',
			url: 'mars/ori'
		}],
		postCreateFunction: (entity) => {
			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(10.8);
			atmosphereComponent.setDensity(0.001);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(225.0 / 255.0, 178.0 / 255.0, 112.0 / 255.0));
			atmosphereComponent.setSunBrightness(0.8);
			atmosphereComponent.setSunsetColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(10.0 / 255.0, 75.0 / 255.0, 140.0 / 255.0));
			atmosphereComponent.setSunsetIntensity(1.0);
		}
	},
	jupiter: {
		groups: ['planets'],
		radius: 71492,
		systemRadius: 3782501,
		label: 'Jupiter',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.95, 0.71, 0.64, 0.7]
		},
		spheroid: {
			equatorialRadius: 71492,
			polarRadius: 66854,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'jupiter/color_$SIZE_$FACE.jpg',
					sizes: [16, 512, 4096]
				}
			},
			shadowEntities: ['io', 'europa', 'ganymede', 'callisto']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jupiter/sun/orb'
		}, {
			type: 'dynamo',
			url: 'jupiter/ori'
		}, {
			type: 'coverage',
			coverage: [Number.NEGATIVE_INFINITY, Number.POSITIVE_INFINITY],
			update: (entity) => {
				if (entity.getOrientation().isNaN()) {
					return;
				}

				/*
				In order to update the spots, you can use these helpful functions.

				// Get the camera the view from earth.
				e = () => { c = app._pioneer.getViewport(0).getCamera(); p = new Pioneer.Vector3(); p.sub(app._scene.get('earth').getPosition(), app._scene.get('jupiter').getPosition()); p.mult(p, .99); c.getEntity().setPosition(p); c.setFieldOfView(0.0008); };

				// The code moves time backward by the light-time distance between earth and jupiter.
				// So if a photo was taken at time T, then the will move to T - ltej.
				// VERY useful for getting photos exact, and works perfectly for photos as far back as 1963 (and likely further).
				// It moves time backward by the light-time distance between earth and jupiter.
				// So if a photo was taken at time T, then the will move to T - ltej.
				// VERY useful for getting photos exact, and works perfectly for photos as far back as 1963 (and likely further).
				t = () => { p = new Pioneer.Vector3(); p.sub(app._scene.get('earth').getPosition(), app._scene.get('jupiter').getPosition()); app._pioneer.setTime(app._pioneer.getTime() - p.magnitude() / 299792.458); console.log(app._pioneer.getTime()); };

				// Rotate jupiter by the given angle to match.
				r = (angle) => { s = app._scene.get('jupiter', 'spheroidLOD'); s.setLongitudeRotation(Pioneer.MathUtils.degToRad(angle)); };

				Make sure to turn off the coverage controller below.
				Find a photo from earth of Jupiter (https://www.missionjuno.swri.edu/junocam/planning). Go to the time when the photo was taken.
				Run e();
				Run t();
				Now you'll be at the right time and position from earth to see the photo.
				Run r(angle) until the spot matches the right location.
				Add this angle to the Jupiter GRS spreadsheet column F. Do this for a number of photos.
				Also look up http://jupos.privat.t-online.de/index.htm for numbers to add to array above.
				*/

				// Get the right index for the current time.
				const time = entity.getScene().getEngine().getTime();
				const rotations = jupiterRotationData.rotations;
				const currentDriftRate = (rotations[rotations.length - 1][1] - rotations[rotations.length - 2][1]) / (rotations[rotations.length - 1][0] - rotations[rotations.length - 2][0]);
				let rate = currentDriftRate; // The rate of drift in degrees per second from the index point. It is set to the current rate of jupiter's rotation.
				let index = jupiterRotationData.hintIndex;
				if (time < rotations[index][0] || (index < rotations.length - 1 && rotations[index + 1][0] <= time)) {
					if (time >= rotations[rotations.length - 1][0]) { // After the last point.
						index = rotations.length - 1;
						// The rate just stays the current rate.
					}
					else if (time < rotations[0][0]) { // Before the first point.
						index = 0;
						rate = 0; // No rate, since not enough data.
					}
					else { // Somewhere in between points.
						for (let i = rotations.length - 2; i >= 0; i--) {
							if (rotations[i][0] <= time && time < rotations[i + 1][0]) {
								index = i;
								rate = (rotations[i + 1][1] - rotations[i][1]) / (rotations[i + 1][0] - rotations[i][0]);
							}
						}
					}
				}
				else if (index < rotations.length - 1) {
					rate = (rotations[index + 1][1] - rotations[index][1]) / (rotations[index + 1][0] - rotations[index][0]);
				}
				jupiterRotationData.hintIndex = index;
				// Get the angle in system II.
				const angle = rotations[index][1] + (time - rotations[index][0]) * rate;
				// Do the calculation from System II to System III and taking into account the texture offset.
				const actualAngle = pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.wrap(jupiterRotationData.referenceAngleInSystemIII
					- (angle + jupiterRotationData.textureAngleOffset - jupiterRotationData.referenceAngleInSystemII)
					+ (time - jupiterRotationData.referenceTime) * jupiterRotationData.offsetFactor, 0, 360);
				// Apply the rotation.
				const spheroidLOD = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.SpheroidLODComponent);
				if (spheroidLOD !== null) {
					spheroidLOD.setLongitudeRotation(pioneer__WEBPACK_IMPORTED_MODULE_2__.MathUtils.degToRad(actualAngle));
				}
			}
		}],
		postCreateFunction: (entity) => {
			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(200.0);
			atmosphereComponent.setDensity(5.0e-5);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(234.0 / 255.0, 202.0 / 255.0, 170.0 / 255.0));
			atmosphereComponent.setSunBrightness(0.25);
		}
	},
	saturn: {
		groups: ['planets'],
		radius: 60268,
		systemRadius: 7184413,
		label: 'Saturn',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 60268,
			polarRadius: 54364,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities', 'shadowRings'],
			textures: {
				color: {
					url: 'saturn/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			},
			shadowEntities: ['iapetus', 'dione', 'rhea', 'tethys', 'titan']
		},
		controllers: [{
			type: 'dynamo',
			url: 'saturn/sun/orb'
		}, {
			type: 'dynamo',
			url: 'saturn/ori'
		}],
		postCreateFunction: (entity) => {
			const ringsComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RingsComponent);
			ringsComponent.setInnerRadius(74270.580913);
			ringsComponent.setOuterRadius(140478.924731);
			ringsComponent.setTopTextureUrl('$STATIC_ASSETS_URL/sprites/saturn_rings_top.png');
			ringsComponent.setBottomTextureUrl('$STATIC_ASSETS_URL/sprites/saturn_rings_bottom.png');
			ringsComponent.setFadeDistance(250);
			ringsComponent.setShadowEntities(['iapetus', 'dione', 'rhea', 'tethys', 'titan']);

			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(200.0);
			atmosphereComponent.setDensity(5.0e-5);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(234.0 / 255.0, 202.0 / 255.0, 151.0 / 255.0));
		}
	},
	uranus: {
		groups: ['planets'],
		radius: 25559,
		systemRadius: 1164893,
		label: 'Uranus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 25559,
			polarRadius: 24973,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'uranus/color_$SIZE_$FACE.png',
					sizes: [4, 256]
				}
			},
			shadowEntities: ['titania', 'oberon', 'umbriel', 'ariel', 'miranda']
		},
		controllers: [{
			type: 'dynamo',
			url: 'uranus/sun/orb'
		}, {
			type: 'dynamo',
			url: 'uranus/ori'
		}],
		postCreateFunction: (entity) => {
			const ringsComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RingsComponent);
			ringsComponent.setInnerRadius(26840);
			ringsComponent.setOuterRadius(103000);
			ringsComponent.setTopTextureUrl('$STATIC_ASSETS_URL/sprites/uranus_rings.png');
			ringsComponent.setBottomTextureUrl('$STATIC_ASSETS_URL/sprites/uranus_rings.png');
			ringsComponent.setFadeDistance(250);
			ringsComponent.setShadowEntities(['miranda', 'ariel', 'umbriel', 'titania', 'oberon']);

			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(200.0);
			atmosphereComponent.setDensity(5.0e-5);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(147.0 / 255.0, 183.0 / 255.0, 201.0 / 255.0));
			atmosphereComponent.setSunsetColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(164.0 / 255.0, 168.0 / 255.0, 102.0 / 255.0));
			atmosphereComponent.setSunsetIntensity(1.0);
		}
	},
	neptune: {
		groups: ['planets'],
		radius: 24764,
		systemRadius: 43213894,
		label: 'Neptune',
		parents: [
			[Number.NEGATIVE_INFINITY, 'sun']
		],
		trail: {
			length: undefined,
			color: [0.48, 0.69, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 24764,
			polarRadius: 24341,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'neptune/color_$SIZE_$FACE.png',
					sizes: [4, 256]
				}
			},
			shadowEntities: ['triton', 'proteus', 'despina', 'galatea', 'larissa']
		},
		controllers: [{
			type: 'dynamo',
			url: 'neptune/sun/orb'
		}, {
			type: 'dynamo',
			url: 'neptune/ori'
		}],
		postCreateFunction: (entity) => {
			const ringsComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.RingsComponent);
			ringsComponent.setInnerRadius(40900);
			ringsComponent.setOuterRadius(62964);
			ringsComponent.setTopTextureUrl('$STATIC_ASSETS_URL/sprites/neptune_rings.png');
			ringsComponent.setBottomTextureUrl('$STATIC_ASSETS_URL/sprites/neptune_rings.png');
			ringsComponent.setFadeDistance(250);

			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(200.0);
			atmosphereComponent.setDensity(5.0e-5);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(138.0 / 255.0, 160.0 / 255.0, 255.0 / 255.0));
		}
	}
});

const jupiterRotationData = {
	hintIndex: 0, // A special variable to keep track of the current index in the rotations array below.
	textureAngleOffset: -60.38, // Get the red spot at 0 degrees longitude in System III.
	referenceTime: 617098056, // A known good photo from JunoCam planning on 2019-07-22T20:44
	referenceAngleInSystemII: 313.47, // The angle in System II for the photo.
	referenceAngleInSystemIII: 305, // The angle in System III for that photo.
	offsetFactor: -0.000003074, // The scaling factor that moves from System II to System III.
	rotations: [ // Data in System II from charts at http://jupos.org.
		[-1136116758, 15], // 1964-01-01
		[-1037534358, 28], // 1967-02-15
		[-938951958, 22], // 1970-04-01
		[-867931156, 0], // 1972-07-01
		[-812721554, 12], // 1974-04-01
		[-744292752, 47], // 1976-06-01
		[-639143949, 62], // 1979-10-01
		[-533822346, 48], // 1983-02-01
		[-483883145, 27], // 1984-09-01
		[-391953544, 15], // 1987-08-01
		[102427264, 85], // 2003-04-01
		[315576066, 138], // 2010-01-01
		[615211269, 312], // 2019-06-30
		[660052869, 347] // 2020-11-30
	]
};


/***/ }),

/***/ "../pioneer/scripts/src/entities/saturn_major_moons.js":
/*!*************************************************************!*\
  !*** ../pioneer/scripts/src/entities/saturn_major_moons.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var _entity_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity_utils */ "../pioneer/scripts/src/entities/entity_utils.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */




_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	dione: {
		groups: ['saturn', 'moons', 'inner', 'major'],
		radius: 561.7,
		label: 'Dione',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 561.7,
			polarRadius: 561.7,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'dione/color_$SIZE_$FACE.png',
					sizes: [4, 512, 2048]
				}
			},
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'dione/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'dione/ori'
		}]
	},
	enceladus: {
		groups: ['saturn', 'moons', 'inner', 'major'],
		radius: 252.1,
		label: 'Enceladus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 252.1,
			polarRadius: 252.1,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'enceladus/color_$SIZE_$FACE.png',
					sizes: [4, 512, 2048]
				}
			},
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'enceladus/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'enceladus/ori'
		}],
		postCreateFunction: (entity) => {
			// A
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-25.20 * 0.8, -69.23 * 0.8, -240.99 * 0.8], [-0.0999, -0.2747, -0.9563]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-61.73 * 0.8, -24.61 * 0.8, -243.08 * 0.8], [-0.2449, -0.0976, -0.9646]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-35.82 * 0.8, -46.87 * 0.8, -245.00 * 0.8], [-0.1421, -0.1859, -0.9722]);

			// B
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [30.37 * 0.7, -17.54 * 0.7, -249.55 * 0.7], [0.1205, -0.0696, -0.9902]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [0.00 * 0.7, 2.20 * 0.7, -251.99 * 0.7], [0, 0.0087, -0.9999]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-30.94 * 0.7, 30.94 * 0.7, -248.17 * 0.7], [-0.1227, 0.1227, -0.9848]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [45.99 * 0.7, -34.55 * 0.7, -245.35 * 0.7], [0.1824, -0.1371, -0.9736]);

			// C
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-51.91 * 0.9, 0.68 * 0.9, -246.59 * 0.9], [-0.2059, 0.0026, -0.9785]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-31.81 * 0.9, -13.36 * 0.9, -249.63 * 0.9], [-0.1262, -0.0530, -0.9905]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-5.49 * 0.9, -29.77 * 0.9, -250.18 * 0.9], [-0.0217, -0.1181, -0.9927]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [16.54 * 0.9, -47.1 * 0.9, -247.01 * 0.9], [0.0656, -0.1869, -0.9801]);

			// D
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [-16.47 * 0.8, 60.14 * 0.8, -244.16 * 0.8], [-0.0653, 0.2386, -0.9689]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [51.52 * 0.8, 23.97 * 0.8, -245.51 * 0.8], [0.2044, 0.0951, -0.9742]);
			_entity_utils__WEBPACK_IMPORTED_MODULE_1__.EntityUtils.addGeyser(entity, 100, 0.1, 20, 0.002, 4, [28.13 * 0.8, 33.52 * 0.8, -248.17 * 0.8], [0.1116, 0.1330, -0.9848]);
		}
	},
	hyperion: {
		groups: ['saturn', 'moons', 'outer', 'major'],
		radius: 135.0,
		label: 'Hyperion',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/hyperion/hyperion.gltf',
			scale: [1, 1, 1]
		},
		controllers: [{
			type: 'dynamo',
			url: 'hyperion/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}]
	},
	iapetus: {
		groups: ['saturn', 'moons', 'outer', 'major'],
		radius: 735.6,
		label: 'Iapetus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 735.6,
			polarRadius: 735.6,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'iapetus/color_$SIZE_$FACE.png',
					sizes: [4, 512, 2048]
				}
			},
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'iapetus/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'iapetus/ori'
		}]
	},
	mimas: {
		groups: ['saturn', 'moons', 'inner', 'major'],
		radius: 198.3,
		label: 'Mimas',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/mimas/mimas.gltf',
			scale: [1, 1, 1]
		},
		controllers: [{
			type: 'dynamo',
			url: 'mimas/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'mimas/ori'
		}]
	},
	rhea: {
		groups: ['saturn', 'moons', 'outer', 'major'],
		radius: 764.3,
		label: 'Rhea',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 764.3,
			polarRadius: 764.3,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'rhea/color_$SIZE_$FACE.png',
					sizes: [4, 512, 2048]
				}
			},
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'rhea/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'rhea/ori'
		}]
	},
	tethys: {
		groups: ['saturn', 'moons', 'inner', 'major'],
		radius: 538.4,
		label: 'Tethys',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 538.4,
			polarRadius: 527.5,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'tethys/color_$SIZE_$FACE.png',
					sizes: [4, 512, 2048]
				}
			},
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'tethys/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'tethys/ori'
		}]
	},
	titan: {
		groups: ['saturn', 'moons', 'outer', 'major'],
		radius: 2575.0,
		label: 'Titan',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		spheroid: {
			equatorialRadius: 2575.0,
			polarRadius: 2575.0,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'titan/color_$SIZE_$FACE.png',
					sizes: [4, 512, 1024]
				}
			},
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'titan/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'titan/ori'
		}],
		postCreateFunction: (entity) => {
			const atmosphereComponent = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AtmosphereComponent);
			atmosphereComponent.setScaleHeight(75.0);
			atmosphereComponent.setDensity(0.0005);
			atmosphereComponent.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(179.0 / 255.0, 145.0 / 255.0, 53.0 / 255.0));
			atmosphereComponent.setSunsetColor(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Color(0.0 / 255.0, 71.0 / 255.0, 204.0 / 255.0));
			atmosphereComponent.setSunsetIntensity(0.5);
		}
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/saturn_minor_moons.js":
/*!*************************************************************!*\
  !*** ../pioneer/scripts/src/entities/saturn_minor_moons.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	aegaeon: {
		groups: ['saturn', 'moons', 'minor', 'ring moonlet'],
		radius: 0.12,
		label: 'Aegaeon',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.12, 0.12, 0.12],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'aegaeon/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	aegir: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Aegir',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'aegir/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	albiorix: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 16.0,
		label: 'Albiorix',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [16, 16, 16],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'albiorix/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	alvaldi: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3,
		label: 'Alvaldi',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'alvaldi/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	angrboda: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'Angrboda',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'angrboda/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	anthe: {
		groups: ['saturn', 'moons', 'minor', 'alkyonides'],
		radius: 0.9,
		label: 'Anthe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [0.9, 0.9, 0.9],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'anthe/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	atlas: {
		groups: ['saturn', 'moons', 'minor', 'ring shepherd'],
		radius: 15.1,
		label: 'Atlas',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [15.1, 15.1, 15.1],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'atlas/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'atlas/ori'
		}]
	},
	bebhionn: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 3.0,
		label: 'Bebhionn',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'bebhionn/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	beli: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'Beli',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'beli/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	bergelmir: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Bergelmir',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'bergelmir/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	bestla: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.5,
		label: 'Bestla',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3.5, 3.5, 3.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'bestla/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	calypso: {
		groups: ['saturn', 'moons', 'minor', 'trojan'],
		radius: 10.7,
		label: 'Calypso',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [10.7, 10.7, 10.7],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'calypso/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'calypso/ori'
		}]
	},
	daphnis: {
		groups: ['saturn', 'moons', 'minor', 'ring shepherd'],
		radius: 3.8,
		label: 'Daphnis',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3.8, 3.8, 3.8],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'daphnis/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	eggther: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3,
		label: 'Eggther',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'eggther/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	epimetheus: {
		groups: ['saturn', 'moons', 'minor', 'co-orbital'],
		radius: 58.1,
		label: 'Epimetheus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [58.1, 58.1, 58.1],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'epimetheus/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'epimetheus/ori'
		}]
	},
	erriapus: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 5.0,
		label: 'Erriapus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [5, 5, 5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'erriapus/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	farbauti: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.5,
		label: 'Farbauti',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.5, 2.5, 2.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'farbauti/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	fenrir: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'Fenrir',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2, 2, 2],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'fenrir/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	fornjot: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Fornjot',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'fornjot/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	geirrod: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Geirrod',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'geirrod/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	gerd: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Gerd',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'gerd/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	greip: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Greip',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'greip/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	gridr: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Gridr',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'gridr/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	gunnlod: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Gunnlod',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'gunnlod/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	hati: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Hati',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'hati/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	helene: {
		groups: ['saturn', 'moons', 'minor', 'trojan'],
		radius: 17.6,
		label: 'Helene',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [17.6, 17.6, 17.6],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'helene/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'helene/ori'
		}]
	},
	hyrrokkin: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Hyrrokkin',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'hyrrokkin/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	ijiraq: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 6.0,
		label: 'Ijiraq',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [6, 6, 6],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ijiraq/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	janus: {
		groups: ['saturn', 'moons', 'minor', 'co-orbital'],
		radius: 89.5,
		label: 'Janus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [89.5, 89.5, 89.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'janus/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'janus/ori'
		}]
	},
	jarnsaxa: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Jarnsaxa',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'jarnsaxa/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kari: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Kari',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kari/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	kiviuq: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 8.0,
		label: 'Kiviuq',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [8, 8, 8],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'kiviuq/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	loge: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Loge',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'loge/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	methone: {
		groups: ['saturn', 'moons', 'minor', 'alkyonides'],
		radius: 1.6,
		label: 'Methone',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.6, 1.6, 1.6],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'methone/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	mundilfari: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.5,
		label: 'Mundilfari',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [3.5, 3.5, 3.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'mundilfari/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	narvi: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.5,
		label: 'Narvi',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3.5, 3.5, 3.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'narvi/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	paaliaq: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 11.0,
		label: 'Paaliaq',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [11, 11, 11],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'paaliaq/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	pallene: {
		groups: ['saturn', 'moons', 'minor', 'alkyonides'],
		radius: 2.5,
		label: 'Pallene',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.5, 2.5, 2.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'pallene/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	pan: {
		groups: ['saturn', 'moons', 'minor', 'ring shepherd'],
		radius: 14.1,
		label: 'Pan',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [14.1, 14.1, 14.1],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'pan/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'pan/ori'
		}]
	},
	pandora: {
		groups: ['saturn', 'moons', 'minor', 'ring shepherd'],
		radius: 40.7,
		label: 'Pandora',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [40.7, 40.7, 40.7],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'pandora/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'pandora/ori'
		}]
	},
	phoebe: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 106.5,
		label: 'Phoebe',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/phoebe/phoebe.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'phoebe/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'phoebe/ori'
		}]
	},
	polydeuces: {
		groups: ['saturn', 'moons', 'minor', 'trojan'],
		radius: 1.3,
		label: 'Polydeuces',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.3, 1.3, 1.3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'polydeuces/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	prometheus: {
		groups: ['saturn', 'moons', 'minor', 'ring shepherd'],
		radius: 43.1,
		label: 'Prometheus',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [43.1, 43.1, 43.1],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'prometheus/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'prometheus/ori'
		}]
	},
	s_2004_s_7: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3,
		label: 'S/2004 S 7',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_7/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_12: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.5,
		label: 'S/2004 S 12',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_12/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_13: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3,
		label: 'S/2004 S 13',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_13/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_17: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'S/2004 S 17',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_17/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_21: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2004 S 21',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_21/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_24: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 1.5,
		label: 'S/2004 S 24',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_24/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_28: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'S/2004 S 28',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_28/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_31: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 2,
		label: 'S/2004 S 31',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_31/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_36: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2004 S 36',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_36/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_37: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'S/2004 S 37',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_37/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_39: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2004 S 39',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_39/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_1: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.5,
		label: 'S/2006 S 1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_1/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_3: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3,
		label: 'S/2006 S 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_3/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_2: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3,
		label: 'S/2007 S 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_2/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_3: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.5,
		label: 'S/2007 S 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_3/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2009_s_1: {
		groups: ['saturn', 'moons', 'propeller moonlet'],
		radius: 0.150,
		label: 'S/2009 S 1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 0.150,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}],
		postCreateFunction: (entity) => {
			// Add the controller for going around sun from earth to venus.
			const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController, undefined, entity.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.FixedController));
			const oe = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
			oe.epoch = 0;
			oe.eccentricity = 0;
			oe.semiMajorAxis = 1.17e5;
			oe.meanAngularMotion = 1.5472777e-4;
			oe.meanAnomalyAtEpoch = -1.5;
			oe.orbitOrientation.set(-0.9397445462795919, 0.02005900203250964, -0.052689008288728606, -0.33719681579275607);
			oeController.addOrbitalElements(-1e100, oe);
			oeController.addOrbitalElements(+1e100, oe);
		}
	},
	s_2019_s_1: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 3,
		label: 'S/2019 S 1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 3,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_1/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	saturn_lviii: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Saturn LVIII',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'saturn_lviii/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	saturn_lx: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 2,
		label: 'Saturn LX',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'saturn_lx/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	saturn_lxiv: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'Saturn LXIV',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 1.5,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'saturn_lxiv/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	siarnaq: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 20.0,
		label: 'Siarnaq',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [20, 20, 20],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'siarnaq/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	skathi: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 4.0,
		label: 'Skathi',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [4, 4, 4],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'skathi/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	skoll: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Skoll',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'skoll/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	skrymir: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Skrymir',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'skrymir/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	surtur: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.0,
		label: 'Surtur',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'surtur/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	suttungr: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.5,
		label: 'Suttungr',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [3.5, 3.5, 3.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'suttungr/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	tarqeq: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 3.0,
		label: 'Tarqeq',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3, 3, 3],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'tarqeq/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	tarvos: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 7.5,
		label: 'Tarvos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [7.5, 7.5, 7.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'tarvos/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	telesto: {
		groups: ['saturn', 'moons', 'minor', 'trojan'],
		radius: 12.4,
		label: 'Telesto',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [12.4, 12.4, 12.4],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'telesto/saturn/orb'
		}, {
			type: 'dynamo',
			url: 'telesto/ori'
		}]
	},
	thiazzi: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2,
		label: 'Thiazzi',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: 2,
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'thiazzi/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	thrymr: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 3.5,
		label: 'Thrymr',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [3.5, 3.5, 3.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'thrymr/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	ymir: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 9.0,
		label: 'Ymir',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: undefined,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [9, 9, 9],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ymir/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_40: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 40',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 66061440,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_40/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_41: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 41',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 79022304,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_41/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_42: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 42',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 79998624,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_42/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_43: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 43',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 84678912,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_43/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_44: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.5,
		label: 'S/2004 S 44',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 88660224,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.5, 2.5, 2.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_44/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_45: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 45',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 89743680,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_45/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_46: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2004 S 46',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 95694912,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_46/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_47: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 47',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 65879136,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_47/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_48: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 48',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 107343360,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_48/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_49: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 49',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 109231200,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_49/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_50: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2004 S 50',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 108902016,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_50/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_51: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 51',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 131278752,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_51/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_52: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2004 S 52',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 141175872,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_52/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2004_s_53: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2004 S 53',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 115986816,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2004_s_53/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2005_s_4: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 2.5,
		label: 'S/2005 S 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 38899008,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.5, 2.5, 2.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2005_s_4/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2005_s_5: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2005 S 5',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 101763648,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2005_s_5/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_10: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2006 S 10',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 84943296,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_10/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_11: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2006 S 11',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 90052992,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_11/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_12: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 2.0,
		label: 'S/2006 S 12',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 89428320,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_12/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_13: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2006 S 13',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 91638432,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_13/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_14: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2006 S 14',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 99591552,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_14/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_15: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2006 S 15',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 104886144,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_15/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_16: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2006 S 16',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 104329728,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_16/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_17: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2006 S 17',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 109259712,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_17/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_18: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2006 S 18',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 112181760,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_18/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_19: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2006 S 19',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 120038112,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_19/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_20: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.5,
		label: 'S/2006 S 20',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 49012128,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.5, 2.5, 2.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_20/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2006_s_9: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2006 S 9',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 55977696,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2006_s_9/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_5: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2007 S 5',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 64530432,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_5/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_6: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2007 S 6',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 82036800,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_6/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_7: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2007 S 7',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 65170656,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_7/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_8: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 2.0,
		label: 'S/2007 S 8',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 72308160,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_8/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2007_s_9: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2007 S 9',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 93145248,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2007_s_9/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_10: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 10',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 97030656,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_10/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_11: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 11',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 96336000,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_11/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_12: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 12',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 98396640,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_12/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_13: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 13',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 98921088,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_13/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_14: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 2.0,
		label: 'S/2019 S 14',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 77167296,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_14/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_15: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 15',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 100357056,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_15/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_16: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 16',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 115877088,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_16/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_17: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 17',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 111576096,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_17/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_18: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 18',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 114657984,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_18/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_19: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 19',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 113879520,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_19/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_2: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 69104448,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_2/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_20: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 20',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 118838880,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_20/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_21: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 21',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 141378048,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_21/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_3: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 72380736,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_3/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_4: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 78128064,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_4/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_5: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2019 S 5',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 85568832,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_5/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_6: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 2.0,
		label: 'S/2019 S 6',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 79202880,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_6/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_7: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 7',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 93337056,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_7/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_8: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 8',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 94061952,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_8/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2019_s_9: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2019 S 9',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 94444704,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2019_s_9/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_1: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 2.0,
		label: 'S/2020 S 1',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 38975040,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_1/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_10: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2020 S 10',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 131951808,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_10/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_2: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2020 S 2',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 77552640,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_2/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_3: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 1.5,
		label: 'S/2020 S 3',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 78450336,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_3/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_4: {
		groups: ['saturn', 'moons', 'minor', 'gallic'],
		radius: 1.5,
		label: 'S/2020 S 4',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 80085888,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_4/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_5: {
		groups: ['saturn', 'moons', 'minor', 'inuit'],
		radius: 1.5,
		label: 'S/2020 S 5',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 80687232,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_5/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_6: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2020 S 6',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 100989504,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_6/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_7: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2020 S 7',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 74450880,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_7/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_8: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 1.5,
		label: 'S/2020 S 8',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 106109568,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [1.5, 1.5, 1.5],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_8/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	s_2020_s_9: {
		groups: ['saturn', 'moons', 'minor', 'norse'],
		radius: 2.0,
		label: 'S/2020 S 9',
		parents: [
			[Number.NEGATIVE_INFINITY, 'saturn']
		],
		trail: {
			length: 132621408,
			color: [0.72, 0.65, 0.52, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [2.0, 2.0, 2.0],
			shadowEntities: ['saturn']
		},
		controllers: [{
			type: 'dynamo',
			url: 's_2020_s_9/saturn/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/small_body_spacecraft.js":
/*!****************************************************************!*\
  !*** ../pioneer/scripts/src/entities/small_body_spacecraft.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var _animation__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../animation */ "../pioneer/scripts/src/animation.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */




_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_dart: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '65803_didymos', 'dimorphos', 'spacecraft'],
		occlusionRadius: 0.0012,
		extentsRadius: 0.00625,
		label: 'DART',
		parents: [
			[691007069, 'earth'],
			[691418893, 'sun'],
			[717454117, '65803_didymos']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_dart/dart.gltf',
			shadowEntities: ['earth']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_dart/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dart/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dart/65803_didymos/pos'
		}, {
			type: 'custom',
			func: (entity) => {
				// The current spice misses Dimorphos, so we cut the spice short and keyframe the rest to make it hit.
				const keyframeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.KeyframeController);
				keyframeController.addPositionKeyframe(717503237, // Forced end of spice.
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-10320.163052194115, 13421.106828492655, 5349.381737812169));
				keyframeController.addPositionKeyframe(717503237 + 2890.2383179924736, // Dimorphos impact
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.9047084058613565, -0.7147384471771195, -0.30125475602973617));
				return keyframeController;
			}
		}, {
			type: 'align',
			primary: {
				type: 'velocity',
				target: 'sc_dart',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			coverage: [Number.NEGATIVE_INFINITY, 717454117]
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'dimorphos',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			},
			coverage: [717454117, Number.POSITIVE_INFINITY]
		}]
	},
	sc_dawn: {
		groups: ['small body spacecraft', 'asteroid spacecraft', 'dwarf planet spacecraft', '4_vesta', '1_ceres', 'spacecraft'],
		occlusionRadius: 0.000885,
		extentsRadius: 0.00985,
		label: 'Dawn',
		parents: [
			[244168849.8323595, 'earth'],
			[244461608, 'sun'],
			[288169447, 'mars'],
			[288210177, 'sun'],
			[363182466, '4_vesta'],
			[400075267, 'sun'],
			[476712067, '1_ceres'],
			[594302469.184, '']
		],
		trail: {
			length: 659889.75
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_dawn/model.gltf',
			rotate: [
				{ z: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_dawn/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dawn/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dawn/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dawn/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dawn/vesta/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dawn/sun/3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_dawn/ceres/orb'
		}, {
			// Beginning of launch has bad spice, so we supplement with fixed.
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.9999478154504517, 0.008904517167862874, 0.004868284692665544, -0.0011729254143642916),
			coverage: [244168849.8323595, 244171353.18400002]
		}, {
			type: 'dynamo',
			url: 'sc_dawn/ori'
		}]
	},
	sc_deep_impact: {
		groups: ['small body spacecraft', 'comet spacecraft', '9p_tempel_1', '103p_hartley_2', 'spacecraft'],
		occlusionRadius: 0.001650,
		extentsRadius: 0.00300,
		label: 'Deep Impact',
		parents: [
			[158829812.068274, 'earth'],
			[159287744, 'sun'],
			[173560752, '9p_tempel_1'],
			[173923158, 'sun'],
			[251798121, 'earth'],
			[253531474, 'sun'],
			[282984399, 'earth'],
			[285405903, 'sun'],
			[330384030, 'earth'],
			[331534813, 'sun'],
			[342017751, '103p_hartley_2'],
			[342368983, 'sun'],
			[429192067, '']
		],
		trail: {
			length: 47421459.0,
			lengthCoverages: [
				[362406, 173560752, 173923158], // 9/P Tempel flyby
				[1733353, 251798121, 253531474], // Earth flyby 1
				[2421504, 282984399, 285405903], // Earth blyby 2
				[1150783, 330384030, 331534813], // Earth flyby 3
				[351232, 342017751, 342368983] // 103/P Hartley flyby
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_deep_impact/deep_impact_wo_impactor.gltf',
			rotate: [
				{ y: -90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_deep_impact/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/9p_tempel_1/pos'
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/earth/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/earth/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/earth/flyby3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/103p_hartley_2/pos'
		}, {
			// Backup for when quat dynamo doesn't cover.
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact/quat'
		}]
	},
	sc_deep_impact_impactor: {
		groups: ['small body spacecraft', 'comet spacecraft', '9p_tempel_1', 'sc_deep_impact', 'spacecraft'],
		occlusionRadius: 0.001,
		extentsRadius: 0.00100,
		label: 'Deep Impact Impactor',
		parents: [
			[158829812.068274, 'sc_deep_impact'],
			[173642464.18400002, '9p_tempel_1'],
			[173727938.18158135, '']
		],
		trail: {
			length: 27830.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_deep_impact_impactor/deep_impact_impactor.gltf',
			rotate: [
				{ y: -90 }
			]
		},
		controllers: [{
			type: 'custom',
			func: (entity) => {
				// There are spice kernels for the impactor, but they don't release or impact at the right locations.
				//   So we use a keyframe controller here.
				const keyframeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.KeyframeController);
				keyframeController.addPositionKeyframe(173642464.18400002, // Release from Deep Impact
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.000713, -0.000055, 0),
					'sc_deep_impact', undefined,
					'sc_deep_impact');
				keyframeController.addPositionKeyframe(173656621.40411958, // Push away from Deep Impact
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-123095.24746842826, -48294.70341251187, 61743.99881253781),
					'sc_deep_impact', 173642464.18400002);
				keyframeController.addPositionKeyframe(173727938.18158135, // Impact
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(1.580046751199936, 3.178179950746365, -0.628457454223176));
				return keyframeController;
			}
		}, {
			// Start it off with the right direction.
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.000713, -0.000055, 0),
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			relativeToEntity: 'sc_deep_impact',
			coverage: [158829812.068274, 173642464.18400002]
		}, {
			// The quat dynamo doesn't quite reach the impact (short 10 seconds) so fix the orientation as a backup.
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.9060465048532422, 0.3173702681972099, 0.2649483984949708, 0.09032269948692226),
			coverage: [173642464.18400002, Number.POSITIVE_INFINITY]
		}, {
			type: 'dynamo',
			url: 'sc_deep_impact_impactor/quat',
			coverage: [173642464.18400002, Number.POSITIVE_INFINITY]
		}]
	},
	sc_deep_impact_impactor_impact_site: {
		groups: ['small body sites', 'comet sites', '9p_tempel_1', 'sc_deep_impact', 'sc_deep_impact_impactor', 'sites'],
		radius: 0.001,
		label: 'Deep Impact Impactor Impact Site',
		parents: [
			[173727938.18158135, '9p_tempel_1']
		],
		controllers: [{
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(3.1153282512332603, -1.2860729555237982, -1.277920399403075),
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			relativeToEntity: '9p_tempel_1',
			coverage: [173727938.18158135, Number.POSITIVE_INFINITY]
		}]
	},
	sc_deep_space_1: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '9969_braille', 'spacecraft'],
		occlusionRadius: 0.00125,
		extentsRadius: 0.005000,
		label: 'Deep Space 1',
		parents: [
			[-37470248, 'earth'],
			[-36628312, 'sun'],
			[-13523799, '9969_braille'],
			[-13496699, 'sun'],
			[54458637, '19p_borrelly'],
			[54476825, 'sun'],
			[61977664.184, '']
		],
		trail: {
			length: 40845609.0,
			lengthCoverages: [
				[27100, -13523799, -13496699],
				[18188, 54458637, 54476825]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_deep_space_1/deep_space_1.gltf',
			rotate: [
				{ x: 90 },
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_deep_space_1/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_space_1/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_deep_space_1/9969_braille/pos'
		}, {
			type: 'dynamo',
			url: 'sc_deep_space_1/19p_borrelly/pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis,
				target: 'earth'
			},
			secondary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxisNeg,
				target: 'sun'
			}
		}, {
			type: 'dynamo',
			url: 'sc_deep_space_1/quat'
		}]
	},
	sc_near_shoemaker: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '253_mathilde', '433_eros', 'spacecraft'],
		occlusionRadius: 0.002,
		extentsRadius: 0.0034000,
		label: 'NEAR',
		parents: [
			[-122129937, 'sun'],
			[-61397606, 'earth'],
			[-60793811, 'sun'],
			[-79403925, '253_mathilde'],
			[-79210250, 'sun'],
			[-8425610, '433_eros'],
			[36675809.3654, '']
		],
		trail: {
			length: 63919069.0,
			lengthCoverages: [
				[400000, -8425610, 35279032.137],
				[0, 35279032.137, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_near_shoemaker/near.gltf',
			rotate: [
				{ x: 90 },
				{ z: 135 }
			]
		},
		controllers: [{
			type: 'custom',
			func: (entity) => {
				// Add an OE controller because the dynamo doesn't go back to launch.
				// This data was calculated by the computeOrbit function in Pioneer Play.
				const oeController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.OrbitalElementsController);
				const oe = new pioneer__WEBPACK_IMPORTED_MODULE_2__.OrbitalElements();
				oe.eccentricity = 0.3722732412046076;
				oe.epoch = -122129937;
				oe.semiMajorAxis = 235420679.8644008;
				oe.orbitOrientation.set(0.25408339907533106, 0.05463135384055627, -0.18986948069810847, 0.9467875272685549);
				oe.meanAngularMotion = 1.0085301888805118e-7;
				oe.meanAnomalyAtEpoch = -0.005941352116228519;
				oeController.addOrbitalElements(-122129937, oe);
				oeController.addOrbitalElements(-113227200, oe);
				oeController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Interval(-122129937, -113227200));
				return oeController;
			}
		}, {
			type: 'dynamo',
			url: 'sc_near_shoemaker/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_near_shoemaker/earth/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_near_shoemaker/253_mathilde/pos'
		}, {
			type: 'dynamo',
			url: 'sc_near_shoemaker/433_eros/orb'
		}, {
			// Cover the launch period.
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.5052018803124495, -0.11842169431143575, 0.7652511949887616, -0.3809697770341459),
			coverage: [-122129937, -121953528.049046]
		}, {
			type: 'dynamo',
			url: 'sc_near_shoemaker/quat'
		}, {
			// Add a fixed controller for after it lands.
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.930389249841349, 4.935129554115763, -4.002004469114965),
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.11222410400554989, 0.7066112547219852, -0.6897721372150081, 0.11099857612696495),
			coverage: [35279032.137, 36675809.3654]
		}, {
			// Get the landing fixed coverage coords in the J2000 frame.
			type: 'rotateByEntityOrientation',
			coverage: [35279032.137, 36675809.3654]
		}]
	},
	sc_near_shoemaker_landing_site: {
		groups: ['433_eros', 'sc_near_shoemaker', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'NEAR Shoemaker Landing Site',
		parents: [
			[36675809.3654, '433_eros']
		],
		controllers: [{
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.930389249841349, 4.935129554115763, -4.002004469114965),
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.11222410400554989, 0.7066112547219852, -0.6897721372150081, 0.11099857612696495),
			relativeToEntity: '433_eros',
			coverage: [36675809.3654, Number.POSITIVE_INFINITY]
		}]
	},
	sc_lucy: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '52246_donaldjohanson', '3548_eurybates', '15094_polymele', '11351_leucus', '21900_orus', '617_patroclus', 'menoetius', 'spacecraft'],
		occlusionRadius: 0.002,
		extentsRadius: 0.007125,
		label: 'Lucy',
		parents: [
			[687656642.763, 'earth'],
			[687915086, 'sun'],
			[718960993, 'earth'],
			[719531941, 'sun'],
			[787134972, 'earth'],
			[787532222, 'sun'],
			[798252820, '52246_donaldjohanson'],
			[798584539, 'sun'],
			[870652086, '3548_eurybates'],
			[872642047, 'sun'],
			[872642047, '15094_polymele'],
			[875308504, 'sun'],
			[891166024, '11351_leucus'],
			[894761809, 'sun'],
			[909384911, '21900_orus'],
			[912190135, 'sun'],
			[977590306, 'earth'],
			[978108682, 'sun'],
			[1046169596, '617_patroclus_barycenter'],
			[1047892376, 'sun']
		],
		dependents: [
			'152830_dinkinesh'
		],
		trail: {
			length: 63919069.0,
			lengthCoverages: [
				[719531941 - 718960993, 718960993, 719531941],
				[787532222 - 787134972, 787134972, 787532222],
				[798584539 - 798252820, 798252820, 798584539],
				[872642047 - 870652086, 870652086, 872642047],
				[875308504 - 872642047, 872642047, 875308504],
				[894761809 - 891166024, 891166024, 894761809],
				[912190135 - 909384911, 909384911, 912190135],
				[978108682 - 977590306, 977590306, 978108682],
				[1047892376 - 1046169596, 1046169596, 1047892376]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_lucy/lucy.gltf',
			rotate: [
				{ x: 90 },
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_lucy/earth/launch/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}, {
			type: 'dynamo',
			url: 'sc_lucy/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/earth/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/earth/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/52246_donaldjohanson/pos'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/3548_eurybates/pos'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/15094_polymele/pos'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/11351_leucus/pos'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/21900_orus/pos'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/earth/flyby3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_lucy/617_patroclus/pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis,
				target: 'earth'
			},
			secondary: {
				type: 'align',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis,
				target: 'sun',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_lucy/quat'
		}]
	},
	sc_new_horizons: {
		groups: ['small body spacecraft', 'dwarf planet spacecraft', 'TNO spacecraft', '134340_pluto', '486958_arrokoth', 'spacecraft'],
		occlusionRadius: 0.00135,
		extentsRadius: 0.0026,
		label: 'New Horizons',
		parents: [
			[190972278.33046317, 'earth'],
			[191055829, 'sun'],
			[225619606, 'jupiter'],
			[226100665, 'sun'],
			[490130161, '134340_pluto'],
			[490167848, 'sun'],
			[598753684, '486958_arrokoth'],
			[600203601, 'sun']
		],
		trail: {
			length: 60 * 60 * 24 * 365 * 3
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_new_horizons/new_horizons.gltf',
			rotate: [
				{ y: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_new_horizons/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/jupiter/orb'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/pluto/orb'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/sun/3/pos'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/mu69/pos'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/sun/4/pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis
			}
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/ori/1'
		}, {
			type: 'dynamo',
			url: 'sc_new_horizons/ori/2'
		}]
	},
	sc_rosetta: {
		groups: ['small body spacecraft', 'comet spacecraft', '67p_churyumov_gerasimenko', 'spacecraft'],
		occlusionRadius: 0.001400,
		extentsRadius: 0.016000,
		label: 'Rosetta',
		parents: [
			[131491581.583, 'earth'],
			[131901500, 'sun'],
			[162704887, 'earth'],
			[163831232, 'sun'],
			[225623375, 'mars'],
			[225657862, 'sun'],
			[248111015, 'earth'],
			[248475560, 'sun'],
			[311055929, 'earth'],
			[311664877, 'sun'],
			[452394238, '67p_churyumov_gerasimenko'],
			[528503957.968, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_rosetta/rosettaPhilae.gltf',
			rotate: [
				{ x: 180 },
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_rosetta/earth/launch/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/earth/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/mars/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/sun/3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/earth/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/sun/4/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/earth/flyby3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/sun/5/orb'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/67p_churyumov_gerasimenko/pos'
		}, {
			type: 'dynamo',
			url: 'sc_rosetta/ori'
		}, {
			type: 'coverage',
			coverage: [469053367.183, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const modelComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				if (modelComponent !== null) {
					modelComponent.setHiddenObject('Philae', true);
					// modelComponent.setHiddenObject('foil_gold_h', true);
				}
			},
			exit: (entity) => {
				const modelComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				if (modelComponent !== null) {
					modelComponent.setHiddenObject('Philae', false);
					// modelComponent.setHiddenObject('foil_gold_h', false);
				}
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const solarPanelAlignLeft = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
				solarPanelAlignLeft.setJoint('panels_01');
				solarPanelAlignLeft.setSecondaryAlignType('point');
				solarPanelAlignLeft.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis);
				solarPanelAlignLeft.setSecondaryTargetEntity('sun');
				return solarPanelAlignLeft;
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const solarPanelAlignRight = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
				solarPanelAlignRight.setJoint('panels_02');
				solarPanelAlignRight.setSecondaryAlignType('point');
				solarPanelAlignRight.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis);
				solarPanelAlignRight.setSecondaryTargetEntity('sun');
				return solarPanelAlignRight;
			}
		}]
	},
	sc_rosetta_impact_site: {
		groups: ['small body sites', 'comet sites', '67p_churyumov_gerasimenko', 'sc_rosetta', 'sites'],
		radius: 0.001,
		label: 'Rosetta Impact Site',
		parents: [
			[528503957.968, '67p_churyumov_gerasimenko']
		],
		controllers: [{
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(1.7309310500292525, 0.3509303067271947, 1.1641920075039298),
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			relativeToEntity: '67p_churyumov_gerasimenko',
			coverage: [528503957.968, Number.POSITIVE_INFINITY]
		}]
	},
	sc_osiris_rex: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '101955_bennu', 'spacecraft'],
		occlusionRadius: 0.001600,
		extentsRadius: 0.005,
		label: 'OSIRIS-REx',
		parents: [
			[526676400, 'earth'],
			[527025408, 'sun'],
			[558938468, 'earth'],
			[559919190, 'sun'],
			[591770603, '101955_bennu'],
			[674049669, 'sun'],
			[748358886, 'earth'],
			[749140122, 'sun']
		],
		dependents: ['sc_osiris_rex_src', '99942_apophis'], // These aren't parents and so they are named here.
		trail: {
			length: 102742.5,
			lengthCoverages: [
				[10000000, Number.NEGATIVE_INFINITY, 599748661],
				[672000.0, 599748661, 668095733],
				[10000000, 668095733, Number.POSITIVE_INFINITY]
			]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_osiris_rex_v2/osiris_rex_articulated_panels.gltf',
			rotate: [
				{ x: 90 }
			],
			shadowEntities: ['bennu']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_osiris_rex/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/sun/1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/earth/flyby/orb'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/sun/2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/bennu/pos'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/sun/3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/earth/sample_return/orb'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/sun/4/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth', // Orientated so that the SRC will come off at the right orientation.
				axis: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.175109477645991, 0.45028151394683397, 0.8755473882299549)
			},
			secondary: {
				type: 'align',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.ZAxis
			},
			coverage: [658200668.0606446, Number.POSITIVE_INFINITY]
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex/ori'
		}, {
			// For the animations, used "The OSIRIS-REx Spacecraft and the Touch and Go Sample Acquisition Mechanism", Kyle Brown 2020.
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeSubobjectVisibleAnimation(model, 'Tagsam_housing_cover', true, [
					[593036911, false] // Head cover jettisoned.
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Tagsam_rod_bottom', 'z', [
					[595442726, 0], // First extending.
					[595442726 + 1 * 180, -2.51758508612],
					[595442726 + 2 * 180, -2.51758508612], // Folds back after first extending.
					[595442726 + 3 * 180, 0],
					[656502686 - 220 * 60, 0], // At T-220m it unfurls.
					[656502686 - 220 * 60 + 360, -3.71758508612],
					[656502686 + 2 * 60 + 90, -3.71758508612], // At T+2m it parks.
					[656502686 + 2 * 60 + 90 + 180, 0],
					[656502686 + 10 * 24 * 3600 + 0 * 180, 0], // It stores the head in the SRC module.
					[656502686 + 10 * 24 * 3600 + 2 * 180, -2.73771997401],
					[656502686 + 10 * 24 * 3600 + 4 * 180, 0]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Tagsam_rod_top', 'z', [
					[593728111, 0], // Frangibolts fired and TAGSAM is unlocked.
					[593728111 + 2, 0.15],
					[595442726, 0.15], // First extending.
					[595442726 + 1 * 180, 2.73247002363],
					[595442726 + 2 * 180, 2.73247002363], // Folds back after first extending.
					[595442726 + 3 * 180, 0.15],
					[656502686 - 220 * 60, 0.15], // At T-220m it unfurls.
					[656502686 - 220 * 60 + 360, 3.73247002363],
					[656502686 + 2 * 60 + 90, 3.73247002363], // At T+2m it parks.
					[656502686 + 2 * 60 + 90 + 180, 0.15],
					[656502686 + 10 * 24 * 3600 + 0 * 180, 0.15], // It stores the head in the SRC module.
					[656502686 + 10 * 24 * 3600 + 1 * 180, 1.16136826422],
					[656502686 + 10 * 24 * 3600 + 2 * 180, 0.509601235],
					[656502686 + 10 * 24 * 3600 + 3 * 180, 1.16136826422],
					[656502686 + 10 * 24 * 3600 + 4 * 180, 0.15]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'tagsam_head', 'z', [
					[595442726 + 1 * 180, 0], // First extending.
					[595442726 + 1.5 * 180, 1.57079632679], // Folds back after first extending.
					[595442726 + 2 * 180, 1.57079632679],
					[656502686 - 220 * 60, 0], // At T-220m it unfurls.
					[656502686 - 220 * 60 + 90, 1.57079632679],
					[656502686 + 2 * 60, 1.57079632679], // At T+2m it parks.
					[656502686 + 2 * 60 + 90, 0],
					[656502686 + 10 * 24 * 3600, 0], // It stores the head in the SRC module.
					[656502686 + 10 * 24 * 3600 + 360, 1.01463145268]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeSubobjectVisibleAnimation(model, 'tagsam_head', true, [
					[656502686 + 10 * 24 * 3600 + 360, false] // At T+10d, the head is stowed. We don't have the SRC stowage piece, so the head will just disappear.
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Gimbal_Base_Right', 'z', [
					[656501483 + 0 * 60, -70 * Math.PI / 180],
					[656501483 + 2 * 60, 0],
					[656503242 + 0 * 60, 0],
					[656503242 + 2 * 180, -70 * Math.PI / 180]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Gimbal_Base_Left', 'z', [
					[656501483 + 0 * 60, -70 * Math.PI / 180],
					[656501483 + 2 * 60, 0],
					[656503242 + 0 * 60, 0],
					[656503242 + 2 * 180, -70 * Math.PI / 180]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Gimbal_Pivot_Right', 'x', [
					[656501483 + 2 * 60, 0],
					[656501483 + 4 * 60, 38 * Math.PI / 180],
					[656503242, 38 * Math.PI / 180],
					[656503242 + 2 * 60, 0]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Gimbal_Pivot_Left', 'x', [
					[656501483 + 2 * 60, 0],
					[656501483 + 4 * 60, -38 * Math.PI / 180],
					[656503242, -38 * Math.PI / 180],
					[656503242 + 2 * 60, 0]
				]);
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				return _animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeSubobjectVisibleAnimation(model, 'heatshield', true, [
					[748824183.985732, false] // At this time, the SRC is released.
				]);
			}
		}]
	},
	sc_osiris_rex_src: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '101955_bennu', 'sample return capsule'],
		occlusionRadius: 0.0008,
		extentsRadius: 0.0005,
		label: 'OSIRIS-REx SRC',
		parents: [
			[748824183.985732, 'sc_osiris_rex'],
			[748832190, 'earth'],
			[748839215, '']
		],
		dependents: ['sc_osiris_rex'],
		trail: {
			length: 360
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_osiris_rex_v2/src/osiris_rex_heatshield.gltf',
			rotate: [
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_osiris_rex_src/sc_osiris_rex'
		}, {
			type: 'dynamo',
			url: 'sc_osiris_rex_src/earth'
		}, {
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(-0.7795827954678449, -0.23701239922750972, 0.5441503490850964, -0.19994045416955505)
		}, {
			type: 'coverage',
			coverage: [748838642, 748839373],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
				}
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const translate = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.TranslateController);
				translate.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, 0.0012));
				translate.setRelativeToOrientation(true);
				return translate;
			},
			coverage: [748824183.985732, 748839215]
		}],
		postCreateFunction: (entity) => {
			const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
			model.setTranslation(new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0, 0, -0.0012));
		}
	},
	sc_philae: {
		groups: ['small body spacecraft', 'comet spacecraft', '67p_churyumov_gerasimenko', 'spacecraft', 'landers'],
		occlusionRadius: 0.0006,
		extentsRadius: 0.001,
		label: 'Philae',
		parents: [
			[469053367.183, '67p_churyumov_gerasimenko'],
			[469078512.324, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_philae/philae.gltf',
			rotate: [
				{ x: 180 },
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_philae/67p_churyumov_gerasimenko/pos'
		}, {
			// The orientation of Rosetta when it is detached.
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.05763938670269045, 0.04093459828351704, 0.6750586755218195, 0.7343690110337115)
		}, {
			type: 'custom',
			func: (entity) => {
				// Get the lander's origin and model aligned with the spacecraft when they separate.
				const originOffset = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.0021658104318583687, 0.0011575046500869896, 0.00011875498849156656);
				const modelOffset = new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(0.00147, 0, 0);
				const translateController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.TranslateController);
				translateController.setTranslation(originOffset);
				// Also set the model's translation, so everything aligns.
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				model.setTranslation(modelOffset);
				return translateController;
			},
			coverage: [469053367.183, 469078512.324]
		}]
	},
	sc_philae_landing_site: {
		groups: ['small body sites', 'comet sites', '67p_churyumov_gerasimenko', 'sc_philae', 'sites'],
		radius: 0.001,
		systemRadius: 200,
		label: 'Philae Landing Site',
		parents: [
			[469078512.324, '67p_churyumov_gerasimenko']
		],
		controllers: [{
			type: 'fixed',
			position: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(2.4452763955965984, -0.12110982508097201, -0.36032099522959377),
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion.Identity,
			relativeToEntity: '67p_churyumov_gerasimenko',
			coverage: [469078512.324, Number.POSITIVE_INFINITY]
		}]
	},
	sc_psyche: {
		groups: ['small body spacecraft', 'asteroid spacecraft', '16_psyche', 'spacecraft'],
		occlusionRadius: 0.0031,
		extentsRadius: 0.025,
		label: 'Psyche',
		parents: [
			[750482453, 'earth'],
			[750686758, 'sun'],
			[831828698, 'mars'],
			[832302380, 'sun'],
			[931665741, '16_psyche']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_psyche/psyche.gltf',
			rotate: [
				{ y: -90 },
				{ x: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_psyche/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_psyche/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_psyche/mars/orb'
		}, {
			type: 'dynamo',
			url: 'sc_psyche/16_psyche/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.XAxisNeg
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const solarPanelAlignLeft = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
				solarPanelAlignLeft.setJoint('ArrayGimbleLeft');
				solarPanelAlignLeft.setSecondaryAlignType('point');
				solarPanelAlignLeft.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis);
				solarPanelAlignLeft.setSecondaryTargetEntity('sun');
				return solarPanelAlignLeft;
			}
		}, {
			type: 'custom',
			func: (entity) => {
				const solarPanelAlignRight = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.AlignController);
				solarPanelAlignRight.setJoint('ArrayGimbleRight');
				solarPanelAlignRight.setSecondaryAlignType('point');
				solarPanelAlignRight.setSecondaryAxis(pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3.YAxis);
				solarPanelAlignRight.setSecondaryTargetEntity('sun');
				return solarPanelAlignRight;
			}
		}]
	},
	sc_stardust: {
		groups: ['small body spacecraft', 'comet spacecraft', '81p_wild_2', '9p_tempel_1', 'spacecraft'],
		occlusionRadius: 0.00065,
		extentsRadius: 0.003000,
		label: 'Stardust',
		parents: [
			[-28304869.3, 'earth'],
			[-28038699, 'sun'],
			[32627842, 'earth'],
			[33120541, 'sun'],
			[89379733, '5535_annefrank'],
			[89550209, 'sun'],
			[126009572, '81p_wild_2'],
			[126678668, 'sun'],
			[190336290, 'earth'],
			[190866114, 'sun'],
			[284944970, 'earth'],
			[285742028, 'sun'],
			[350896766, '9p_tempel_1'],
			[351068113, 'sun'],
			[354279666, '']
		],
		trail: {
			length: 62659492.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_stardust/stardust_articulated.gltf',
			shadowEntities: ['earth'],
			rotate: [
				{ x: 90 },
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_stardust/earth/launch/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/sun/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/earth/flyby1/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/5535_annefrank/pos'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/81p_wild_2/pos'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/earth/flyby2/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/earth/flyby3/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/9p_tempel_1/pos'
		}, {
			type: 'dynamo',
			url: 'sc_stardust/quat'
		}, {
			// Orientation dynamo doesn't quite reach to the end.
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.382740492391079, -0.1080542417135509, -0.5511677923678098, -0.7335175941913997),
			coverage: [351017063, 354279666]
		}, {
			// Hide the SRC when it is released.
			type: 'coverage',
			coverage: [190576755.185 - 64.40161622339717, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				for (const object of ['Stardust_capsule', 'Stardust_tex_01_c', 'Stardust_tex_02_c', 'Stardust_tex_03_c', 'Stardust_tex_02_c2', 'Stardust_Sample_Collection1']) {
					model.setHiddenObject(object, true);
				}
			},
			exit: (entity) => {
				const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
				for (const object of ['Stardust_capsule', 'Stardust_tex_01_c', 'Stardust_tex_02_c', 'Stardust_tex_03_c', 'Stardust_tex_02_c2', 'Stardust_Sample_Collection1']) {
					model.setHiddenObject(object, false);
				}
			}
		}],
		postCreateFunction: (entity) => {
			const model = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.ModelComponent);
			const stardustAnimation = (/** @type {number} */angle, /** @type {number} */timeOffset, /** @type {number} */duration) => {
				return /** @type {[number, number][]} */([
					[4449664 + timeOffset, angle],
					[4449664 + timeOffset + duration, 0],
					[10411264 - timeOffset - duration, 0],
					[10411264 - timeOffset, angle],
					[81864064 + timeOffset, angle],
					[81864064 + timeOffset + duration, 0],
					[92664064 - timeOffset - duration, 0],
					[92664064 - timeOffset, angle],
					[125496064 + timeOffset, angle],
					[125496064 + timeOffset + duration, 0],
					[126363664 - timeOffset - duration, 0],
					[126363664 - timeOffset, angle]
				]);
			};
			_animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Stardust_capsule', 'x', stardustAnimation(1.481785, 0, 600));
			_animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Stardust_Sample_Collection1', 'x', stardustAnimation(-Math.PI, 610, 300));
			_animation__WEBPACK_IMPORTED_MODULE_1__.Animation.makeJointRotationAnimation(model, 'Stardust_Sample_Collection2', 'x', stardustAnimation(-Math.PI, 920, 300));
		}
	},
	sc_stardust_src: {
		groups: ['small body spacecraft', 'comet spacecraft', '81p_wild_2', 'earth', 'spacecraft'],
		occlusionRadius: 0.0004,
		extentsRadius: 0.0008,
		label: 'Stardust SRC',
		parents: [
			[190576690.7833838, 'sc_stardust'],
			[190576755.185, 'earth'],
			[190591985.184, '']
		],
		trail: {
			length: 14547.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_stardust_src/stardust_capsule.gltf',
			shadowEntities: ['earth'],
			rotate: [
				{ x: 90 },
				{ z: 90 }
			]
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_stardust_src/earth/pos'
		}, {
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_2__.Quaternion(0.5761056269233067, 0.6860897901682099, 0.2627910947477326, 0.3582233199772653)
		}, {
			// Make the SRC trail relative to earth orientation.
			type: 'coverage',
			coverage: [190591100, Number.POSITIVE_INFINITY],
			enter: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(true);
					trail.setStartTime(1600);
				}
			},
			exit: (entity) => {
				const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.TrailComponent);
				if (trail !== null) {
					trail.setRelativeToEntityOrientation(false);
					trail.setStartTime(18000);
				}
			}
		}, {
			// The spice kernels for the SRC don't release at the right position, so we use a keyframe controller to fill the gap.
			type: 'custom',
			func: (entity) => {
				const keyframeControllerRelease = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.KeyframeController);
				keyframeControllerRelease.addPositionKeyframe(190576755.185 - 64.40161622339717, // Release
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.0010057, 0, 0.0001569),
					'sc_stardust', undefined,
					'sc_stardust', undefined);
				keyframeControllerRelease.addPositionKeyframe(190576755.185, // Dynamo starts
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-0.016734488308429718, -0.019199222326278687, -0.00404781848192215),
					'sc_stardust');
				return keyframeControllerRelease;
			}
		}, {
			// The spice kernels for the SRC don't land correctly,
			//   so we use a keyframe controller to fill the gap.
			type: 'custom',
			func: (entity) => {
				const keyframeControllerLand = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_2__.KeyframeController);
				keyframeControllerLand.addPositionKeyframe(190591163, // Spice doesn't look as good after this point.
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-1979.4577357598625, -4478.591383446022, 4136.322858267745),
					'earth'
				);
				keyframeControllerLand.addPositionKeyframe(190591445.184, // Starts more gentle descent with parachute.
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-1947.8360605285134, -4491.082890234251, 4123.1018367103425),
					'earth'
				);
				keyframeControllerLand.addPositionKeyframe(190591985.184, // Lands
					new pioneer__WEBPACK_IMPORTED_MODULE_2__.Vector3(-1918.7633689113482, -4478.864184129612, 4103.897124245734),
					'earth'
				);
				return keyframeControllerLand;
			}
		}, {
			// Get the landing animation above into the J2000 frame.
			type: 'rotateByEntityOrientation',
			coverage: [190591163, 190591985.184]
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/solar_spacecraft.js":
/*!***********************************************************!*\
  !*** ../pioneer/scripts/src/entities/solar_spacecraft.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_biosentinel: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.0002,
		extentsRadius: 0.0005,
		label: 'BioSentinel',
		parents: [
			[721866289, 'earth'],
			[722273637, 'moon'],
			[722923565, 'sun']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_biosentinel/biosentinel.gltf',
			shadowEntities: ['moon']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_biosentinel/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_biosentinel/moon/orb'
		}, {
			type: 'dynamo',
			url: 'sc_biosentinel/sun/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis,
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			}
		}]
	},
	sc_kepler_space_telescope: {
		groups: ['sun', 'spacecraft', 'telescope'],
		occlusionRadius: 0.002350,
		extentsRadius: 0.00400,
		label: 'Kepler',
		parents: [
			[289679042.1855, 'earth'],
			[290348743, 'sun'],
			[595512069.183, '']
		],
		trail: {
			length: 32190048
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_kepler/Kepler.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_kepler/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_kepler/sun/orb'
		}, {
			type: 'align',
			primary: {
				type: 'align',
				target: 'sun',
				// This number is from 290.666... RA 44.5 DEC, the center of the Kepler cone.
				targetAxis: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(0.25176480336, -0.66735243742, 0.7009092643),
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			},
			secondary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.XAxisNeg
			}
		}]
	},
	sc_mariner_2: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.002,
		extentsRadius: 0.0025000,
		label: 'Mariner 2',
		parents: [
			[-1178599240.703784, 'sun'],
			[409233667.18358755, '']
		],
		trail: {
			length: 29411352.0
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_mariner_2',
			dataType: 'pos'
		}]
	},
	sc_parker_solar_probe: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.0015,
		extentsRadius: 0.003,
		label: 'Parker Solar Probe',
		parents: [
			[587333783.3431, 'earth'],
			[587454078, 'sun']
		],
		trail: {
			length: 12942631.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_parker_solar_probe/PSP.gltf'
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_parker_solar_probe/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_parker_solar_probe/sun/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_spitzer: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.0085,
		extentsRadius: 0.004,
		label: 'Spitzer',
		parents: [
			[115064804, 'earth'],
			[115493678, 'sun'],
			[633614469, '']
		],
		trail: {
			length: 32167331.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_spitzer/SPITZER.gltf',
			rotate: [
				{ z: -90 },
				{ x: -90 }
			],
			shadowEntities: ['venus', 'mercury']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_spitzer/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_spitzer/sun/orb'
		}, {
			type: 'fixed',
			orientation: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion(0.5258297992951877, 0.8139480432783324, -0.1400557906856776, -0.20341086625833524),
			coverage: [115064804, 174548493]
		}, {
			type: 'dynamo',
			url: 'sc_spitzer/quat'
		}]
	},
	sc_stereo_ahead: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.003,
		extentsRadius: 0.003000,
		label: 'STEREO Ahead',
		parents: [
			[215097110, 'earth'],
			[221418192, 'sun']
		],
		trail: {
			length: 29809031.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_stereo_ahead/stereo_a.gltf',
			rotate: [
				{ x: 90 }
			],
			shadowEntities: ['venus', 'mercury']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_stereo_ahead/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stereo_ahead/sun/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_stereo_ahead',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg
			}
		}]
	},
	sc_stereo_behind: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.003,
		extentsRadius: 0.003000,
		label: 'STEREO Behind',
		parents: [
			[215097110, 'earth'],
			[224468337, 'sun'],
			[527860868.182, '']
		],
		trail: {
			length: 33473699.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_stereo_behind/stereo_b.gltf',
			rotate: [
				{ x: 90 }
			],
			shadowEntities: ['venus', 'mercury']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_stereo_behind/earth/orb'
		}, {
			type: 'dynamo',
			url: 'sc_stereo_behind/sun/orb'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_stereo_behind',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg
			}
		}]
	},
	sc_ulysses: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.002,
		extentsRadius: 0.002,
		label: 'Ulysses',
		parents: [
			[-291488100, 'sun'],
			[268142464.18410408, '']
		],
		trail: {
			length: 140294739.0
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_ulysses/ulysses.gltf',
			shadowEntities: ['venus', 'mercury']
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_ulysses',
			dataType: 'pos'
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'sun',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxis
			},
			secondary: {
				type: 'velocity',
				target: 'sc_ulysses',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxisNeg
			}
		}]
	},
	sc_wmap: {
		groups: ['sun', 'spacecraft'],
		occlusionRadius: 0.0026,
		extentsRadius: 0.0026,
		label: 'WMAP',
		parents: [
			[339422466.184, 'sun'],
			[360158466.184, '']
		],
		trail: {
			length: 60 * 60 * 24 * 365
		},
		controllers: [{
			type: 'animdata',
			url: 'sc_wmap',
			dataType: 'pos'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/uranus_major_moons.js":
/*!*************************************************************!*\
  !*** ../pioneer/scripts/src/entities/uranus_major_moons.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/** @module pioneer-scripts */


_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	ariel: {
		groups: ['uranus', 'moons', 'major'],
		radius: 578.9,
		label: 'Ariel',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 578.9,
			polarRadius: 578.9,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'ariel/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			},
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ariel/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'ariel/ori'
		}]
	},
	miranda: {
		groups: ['uranus', 'moons', 'major'],
		radius: 235.8,
		label: 'Miranda',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 235.8,
			polarRadius: 235.8,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'miranda/color_$SIZE_$FACE.png',
					sizes: [4, 256]
				}
			},
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'miranda/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'miranda/ori'
		}]
	},
	oberon: {
		groups: ['uranus', 'moons', 'major'],
		radius: 761.4,
		label: 'Oberon',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 761.4,
			polarRadius: 761.4,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'oberon/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			},
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'oberon/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'oberon/ori'
		}]
	},
	titania: {
		groups: ['uranus', 'moons', 'major'],
		radius: 788.4,
		label: 'Titania',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 788.4,
			polarRadius: 788.4,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'titania/color_$SIZE_$FACE.png',
					sizes: [4, 512]
				}
			},
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'titania/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'titania/ori'
		}]
	},
	umbriel: {
		groups: ['uranus', 'moons', 'major'],
		radius: 584.7,
		label: 'Umbriel',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		spheroid: {
			equatorialRadius: 584.7,
			polarRadius: 584.7,
			planetographic: false
		},
		spheroidLOD: {
			features: ['shadowEntities'],
			textures: {
				color: {
					url: 'umbriel/color_$SIZE_$FACE.png',
					sizes: [4, 256]
				}
			},
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'umbriel/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'umbriel/ori'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/uranus_minor_moons.js":
/*!*************************************************************!*\
  !*** ../pioneer/scripts/src/entities/uranus_minor_moons.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	belinda: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 45.0,
		label: 'Belinda',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [45, 45, 45],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'belinda/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'belinda/ori'
		}]
	},
	bianca: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 25.7,
		label: 'Bianca',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [25.7, 25.7, 25.7],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'bianca/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'bianca/ori'
		}]
	},
	caliban: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 36,
		label: 'Caliban',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [36, 36, 36],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'caliban/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	cordelia: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 20.1,
		label: 'Cordelia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [20.1, 20.1, 20.1],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'cordelia/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'cordelia/ori'
		}]
	},
	cressida: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 39.8,
		label: 'Cressida',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [39.8, 39.8, 39.8],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'cressida/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'cressida/ori'
		}]
	},
	cupid: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 9.0,
		label: 'Cupid',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [9, 9, 9],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'cupid/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	desdemona: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 32.0,
		label: 'Desdemona',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [32, 32, 32],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'desdemona/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'desdemona/ori'
		}]
	},
	ferdinand: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 10,
		label: 'Ferdinand',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [10, 10, 10],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ferdinand/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	francisco: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 11,
		label: 'Francisco',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [11, 11, 11],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'francisco/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	juliet: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 46.8,
		label: 'Juliet',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [46.8, 46.8, 46.8],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'juliet/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'juliet/ori'
		}]
	},
	mab: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 12.5,
		label: 'Mab',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [12.5, 12.5, 12.5],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'mab/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	margaret: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 10,
		label: 'Margaret',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [10, 10, 10],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'margaret/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	ophelia: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 22.4,
		label: 'Ophelia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [22.4, 22.4, 22.4],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'ophelia/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'ophelia/ori'
		}]
	},
	perdita: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 15.0,
		label: 'Perdita',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [15, 15, 15],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'perdita/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	portia: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 67.6,
		label: 'Portia',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [67.6, 67.6, 67.6],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'portia/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'portia/ori'
		}]
	},
	prospero: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 25,
		label: 'Prospero',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [25, 25, 25],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'prospero/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	puck: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 81.0,
		label: 'Puck',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [81, 81, 81],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'puck/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'puck/ori'
		}]
	},
	rosalind: {
		groups: ['uranus', 'moons', 'minor', 'inner'],
		radius: 36.0,
		label: 'Rosalind',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [36, 36, 36],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'rosalind/uranus/orb'
		}, {
			type: 'dynamo',
			url: 'rosalind/ori'
		}]
	},
	setebos: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 24,
		label: 'Setebos',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [24, 24, 24],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'setebos/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	stephano: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 16,
		label: 'Stephano',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_2/generic_asteroid_2.gltf',
			scale: [16, 16, 16],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'stephano/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	sycorax: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 82,
		label: 'Sycorax',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_3/generic_asteroid_3.gltf',
			scale: [82, 82, 82],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sycorax/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	},
	trinculo: {
		groups: ['uranus', 'moons', 'minor', 'irregular'],
		radius: 9,
		label: 'Trinculo',
		parents: [
			[Number.NEGATIVE_INFINITY, 'uranus']
		],
		trail: {
			length: undefined,
			color: [0.67, 0.92, 1.00, 0.7]
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/generic/asteroid_1/generic_asteroid_1.gltf',
			scale: [9, 9, 9],
			shadowEntities: ['uranus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'trinculo/uranus/orb'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entities/venus_spacecraft.js":
/*!***********************************************************!*\
  !*** ../pioneer/scripts/src/entities/venus_spacecraft.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */



_entity__WEBPACK_IMPORTED_MODULE_0__.Entity.register({
	sc_magellan: {
		groups: ['venus', 'spacecraft'],
		occlusionRadius: 0.003200,
		extentsRadius: 0.006000,
		label: 'Magellan',
		parents: [
			[-336388283.36, 'sun'],
			[-296448521.457, 'venus'],
			[-164631538.81763855, '']
		],
		trail: {
			length: undefined
		},
		model: {
			url: '$STATIC_ASSETS_URL/models/sc_magellan/magellan.gltf',
			shadowEntities: ['venus']
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_magellan/venus/orb'
		}, {
			type: 'custom',
			func: (entity) => {
				// Add the controller for going around sun from earth to venus.
				const oeCruiseController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController);
				const oeCruise = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
				oeCruise.epoch = -336394683.816;
				oeCruise.eccentricity = 0.1791852824104108;
				oeCruise.semiMajorAxis = 128280596.63956015;
				oeCruise.meanAngularMotion = 2.5073465306679634e-7;
				oeCruise.meanAnomalyAtEpoch = 2.9229288382327625;
				oeCruise.orbitOrientation.set(0.8728453580255966, 0.1876084386162498, -0.08948587100888229, 0.4415159494547423);
				oeCruiseController.addOrbitalElements(-336388283.360, oeCruise);
				oeCruiseController.addOrbitalElements(-296448521.457, oeCruise);
				return oeCruiseController;
			}
		}, {
			type: 'custom',
			func: (entity) => {
				// Add the controller for the venus orbital insertion and first few orbits that aren't covered by spice.
				const oeVOIController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElementsController);
				// Orbital insertion with hyperbolic eccentricity.
				const oeVOI = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
				oeVOI.epoch = -296448521.457;
				oeVOI.eccentricity = 1.272922970547487;
				oeVOI.semiMajorAxis = 23358.593430196037;
				oeVOI.meanAngularMotion = 0.00015965302516479147;
				oeVOI.meanAnomalyAtEpoch = -6.138103356108873;
				oeVOI.orbitOrientation.set(-0.49933963770188916, 0.11817755769547109, 0.7262027627540558, -0.45751889408554064);
				oeVOIController.addOrbitalElements(-296448521.457, oeVOI);
				oeVOIController.addOrbitalElements(-296410230.351, oeVOI);
				// Extra orbits from Aug 10 to Aug 16 to connect to the start of the spice/dynamo.
				const oeVOI2 = new pioneer__WEBPACK_IMPORTED_MODULE_1__.OrbitalElements();
				oeVOI2.epoch = -295884037.7511;
				oeVOI2.eccentricity = 0.39186818222106645;
				oeVOI2.semiMajorAxis = 10434.012201911135;
				oeVOI2.meanAngularMotion = 0.000534773863104956;
				oeVOI2.meanAnomalyAtEpoch = -1.5165416917234864;
				oeVOI2.orbitOrientation.set(-0.4665778554219434, 0.18802595119032475, 0.7217932088991018, -0.47535871728198204);
				oeVOIController.addOrbitalElements(-296410230.351, oeVOI2);
				oeVOIController.addOrbitalElements(-295884037.7511, oeVOI2);
				return oeVOIController;
			}
		}, {
			type: 'align',
			primary: {
				type: 'point',
				target: 'earth',
				axis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.YAxis
			},
			secondary: {
				type: 'align',
				axis: new pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3(-Math.sqrt(0.5), Math.sqrt(0.5), 0),
				target: 'venus',
				targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_1__.Vector3.ZAxisNeg
			}
		}]
	},
	sc_venus_express: {
		groups: ['venus', 'spacecraft'],
		occlusionRadius: 0.0009,
		extentsRadius: 0.0040,
		label: 'Venus Express',
		parents: [
			[184784702, 'earth'],
			[185369766, 'sun'],
			[197902579, 'venus'],
			[473341201, '']
		],
		trail: {
			length: 779592.165087551
		},
		controllers: [{
			type: 'dynamo',
			url: 'sc_venus_express/earth'
		}, {
			type: 'dynamo',
			url: 'sc_venus_express/sun'
		}, {
			type: 'dynamo',
			url: 'sc_venus_express/venus'
		}, {
			type: 'fixed',
			orientation: pioneer__WEBPACK_IMPORTED_MODULE_1__.Quaternion.Identity
		}, {
			type: 'dynamo',
			url: 'sc_venus_express/quat'
		}]
	}
});


/***/ }),

/***/ "../pioneer/scripts/src/entity.js":
/*!****************************************!*\
  !*** ../pioneer/scripts/src/entity.js ***!
  \****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Entity": function() { return /* binding */ Entity; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * @typedef Options
 * @property {string[]} [groups]
 * @property {string} [label]
 * @property {string} [labelFadeEntity] - The entity that when this gets close to it, the label fades.
 * @property {number} [occlusionRadius]
 * @property {number} [extentsRadius]
 * @property {number} [radius] - This applies to occlusion and extents radii.
 * @property {number} [systemRadius] - The radius within which all children reside.
 * @property {[number, string][]} parents
 * @property {string[]} [dependents]
 * @property {string} [lightSource]
 * @property {TrailOptions} [trail]
 * @property {SpheroidOptions} [spheroid]
 * @property {SpheroidLODOptions} [spheroidLOD]
 * @property {CMTSOptions} [cmts]
 * @property {ModelOptions} [model]
 * @property {CometOptions} [comet]
 * @property {ControllersOptions[]} [controllers]
 * @property {(entity: Pioneer.Entity, extraOptions?: ExtraOptions) => void} [postCreateFunction]
 */

/**
 * @typedef ExtraOptions
 * @property {string} [namePrefix] - A prefix that will be prepended to the name of the entity.
 * @property {string} [nameSuffix] - A suffix that will be appended to the name of the entity.
 * @property {boolean} [milkyWaySprite] - Whether or not to use the milky way sprite.
 * @property {boolean} [skybox] - A skybox that is used instead of the stars.
 * @property {number} [skyboxResolution] - The resolution of the skybox.
 * @property {boolean} [starfield] - A starfield that is used instead of the skybox.
 * @property {boolean} [heliosphere] - Whether or not the sun has a heliosphere.
 * @property {boolean} [clouds] - Whether the earth has clouds or not.
 * @private
 */

/**
 * @typedef {FixedOptions | SpinOptions | DynamoOptions | AnimdataOptions | AlignOptions | RotateByEntityOrientation | CoverageOptions | CustomControllerOptions | OrbitalElementsOptions} ControllersOptions
 */

/**
 * @typedef TrailOptions
 * @property {string} [name]
 * @property {number | undefined} length
 * @property {[number, number, number, number]} [color]
 * @property {string} [relativeTo]
 * @property {[number, number, number][]} [lengthCoverages]
 */

/**
 * @typedef SpheroidOptions
 * @property {string} [name]
 * @property {number} equatorialRadius
 * @property {number} polarRadius
 * @property {boolean} planetographic
 */

/**
 * @typedef SpheroidLODOptions
 * @property {string} [name]
 * @property {string[]} [features]
 * @property {Object.<string, SpheroidTextureOptions>} [textures]
 * @property {string[]} [shadowEntities]
 */

/**
 * @typedef SpheroidTextureOptions
 * @property {string} url
 * @property {number[]} sizes
 */

/**
 * @typedef CMTSOptions
 * @property {string} [name]
 * @property {Object.<string, string>} textures
 * @property {string[]} [shadowEntities]
 * @property {number} [maxLevel]
 */

/**
 * @typedef ModelOptions
 * @property {string} [name]
 * @property {string} url
 * @property {ModelRotateOptions[]} [rotate]
 * @property {[number, number, number] | number} [scale]
 * @property {string[]} [shadowEntities]
 * @property {ModelEnvironmentMapOptions} [environmentMap]
 * @property {boolean} [useCompressedTextures]
 */

/**
 * @typedef ModelRotateOptions
 * @property {number} [x]
 * @property {number} [y]
 * @property {number} [z]
 */

/**
 * @typedef ModelEnvironmentMapOptions
 * @property {string} [cubemap]
 * @property {string} [cylindrical]
 */

/**
 * @typedef CometOptions
 * @property {string} [name]
 * @property {number} [timeLength]
 */

/**
 * @typedef FixedOptions
 * @property {'fixed'} type
 * @property {string} [name]
 * @property {Pioneer.Vector3} [position]
 * @property {Pioneer.Quaternion} [orientation]
 * @property {string} [relativeToEntity]
 * @property {Pioneer.LatLonAlt} [llaOnSpheroid]
 * @property {string} [llaOnSpheroidEntity]
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef SpinOptions
 * @property {'spin'} type
 * @property {string} [name]
 * @property {Pioneer.Vector3} axis
 * @property {boolean} [axisInFrameSpace]
 * @property {number} periodInHours
 * @property {number} [relativeToTime]
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef DynamoOptions
 * @property {'dynamo'} type
 * @property {string} [name]
 * @property {string} url
 * @property {boolean} [parentIsBarycenter]
 * @property {boolean} [customUrl]
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef AnimdataOptions
 * @property {'animdata'} type
 * @property {string} [name]
 * @property {string} url
 * @property {string} dataType
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef AlignOptions
 * @property {'align'} type
 * @property {string} [name]
 * @property {AlignAxisOptions} primary
 * @property {AlignAxisOptions} [secondary]
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef AlignAxisOptions
 * @property {string} type
 * @property {string} target
 * @property {Pioneer.Vector3} axis
 * @property {Pioneer.Vector3} [targetAxis]
 */

/**
 * @typedef RotateByEntityOrientation
 * @property {'rotateByEntityOrientation'} type
 * @property {string} [name]
 * @property {string} [entityForOrientation]
 * @property {boolean} [rotatingOrientation]
 * @property {boolean} [rotatingPosition]
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef OrbitalElementsOptions
 * @property {'orbitalElements'} type
 * @property {string} [name]
 * @property {number} [epoch]
 * @property {number} eccentricity Can be calculated from `e = 1 - 2 / (apoapsis / periapsis + 1)`.
 * @property {number} semiMajorAxis Can be calculated from `a = periapsis / (1 - e)`. In km.
 * @property {number} meanAngularMotion Can be calculated from `2 * PI / period`. In rad / s.
 * @property {number} meanAnomalyAtEpoch The mean angle at the epoch time. In rad.
 * @property {Pioneer.Quaternion} [orbitOrientation]
 * @property {number} [inclination]
 * @property {number} [longitudeOfAscendingNode]
 * @property {number} [argumentOfPeriapsis]
 * @property {[number, number]} [coverage]
 */

/**
 * @typedef CoverageOptions
 * @property {'coverage'} type
 * @property {string} [name]
 * @property {[number, number]} coverage
 * @property {(entity: Pioneer.Entity) => void} [enter]
 * @property {(entity: Pioneer.Entity) => void} [exit]
 * @property {(entity: Pioneer.Entity) => void} [update]
 * @property {number} [updateInterval]
 */

/**
 * @typedef CustomControllerOptions
 * @property {'custom'} type
 * @property {(entity: Pioneer.Entity) => Pioneer.BaseController} func
 * @property {[number, number]} [coverage]
 */

/**
  * Helpful functions for creating entities.
 * @hideconstructor
  */
class Entity {
	/**
	 * Every script that imports this needs to register its "entity name -> options" object so that the create script can use it.
	 * @param {Object<string, Options>} entities
	 */
	static register(entities) {
		for (const name in entities) {
			if (Object.prototype.hasOwnProperty.call(entities, name)) {
				this._entities.set(name, entities[name]);
			}
		}
	}

	/**
	 * Creates an entity.
	 * @param {string} name
	 * @param {Pioneer.Scene} scene
	 * @param {ExtraOptions} [extraOptions]
	 * @returns {Pioneer.Entity}
	 */
	static create(name, scene, extraOptions) {
		// Get the options for the entity's name.
		const options = Entity._entities.get(name);
		if (options === undefined) {
			throw new Error('Could not find the options for the entity with name ' + name);
		}

		return this.createFromOptions(name, options, scene, extraOptions);
	}

	/**
	 * Create an entity from the given options.
	 * @param {string} name
	 * @param {Options} options
	 * @param {Pioneer.Scene} scene
	 * @param {ExtraOptions} [extraOptions]
	 * @returns {Pioneer.Entity}
	 */
	static createFromOptions(name, options, scene, extraOptions) {
		// Create the actual name given the prefix and suffix options.
		let actualName = name;
		if (extraOptions) {
			if (extraOptions.namePrefix) {
				actualName = extraOptions.namePrefix + actualName;
			}
			if (extraOptions.nameSuffix) {
				actualName = actualName + extraOptions.nameSuffix;
			}
		}

		// Check if entity already exists.
		let entity = scene.getEntity(actualName);
		if (entity !== null) {
			return entity;
		}

		// Create the entity.
		entity = scene.addEntity(actualName);

		// Process the options.
		try {
			if (options.radius) {
				entity.setOcclusionRadius(options.radius);
				entity.setExtentsRadius(options.radius);
			}
			if (options.occlusionRadius) {
				entity.setOcclusionRadius(options.occlusionRadius);
			}
			if (options.extentsRadius) {
				entity.setExtentsRadius(options.extentsRadius);
			}

			// Add the parenting table.
			for (const [startTime, parentName] of options.parents) {
				entity.addParentingTableEntry(startTime, parentName);
			}

			if (options.label) {
				const component = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.DivComponent);
				const div = component.getDiv();
				div.innerHTML = options.label;
				div.className = 'pioneer-label-div';
			}

			if (options.labelFadeEntity) {
				const divComponent = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.DivComponent);
				if (divComponent === null) {
					throw new Error('There is no label.');
				}
				divComponent.setFadeWhenCloseToEntity(options.labelFadeEntity);
			}

			if (options.trail) {
				const component = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.TrailComponent, options.trail.name);
				component.setStartTime(options.trail.length);
				if (options.trail.color) {
					component.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(options.trail.color[0], options.trail.color[1], options.trail.color[2], options.trail.color[3]));
				}
				else {
					component.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 0.5));
				}
				if (options.trail.relativeTo) {
					component.setRelativeToEntity(options.trail.relativeTo);
				}
				if (options.trail.lengthCoverages) {
					const trailLength = options.trail.length;
					for (let i = 0, l = options.trail.lengthCoverages.length; i < l; i++) {
						const lengthCoverage = options.trail.lengthCoverages[i];
						const coverageController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CoverageController, `trail_length_coverage.${i}`, entity.getController(0) ?? undefined);
						coverageController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(lengthCoverage[1], lengthCoverage[2]));
						coverageController.setEnterFunction((entity) => {
							const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.TrailComponent);
							if (trail !== null) {
								trail.setStartTime(lengthCoverage[0]);
							}
						});
						coverageController.setExitFunction((entity) => {
							const trail = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.TrailComponent);
							if (trail !== null) {
								trail.setStartTime(trailLength);
							}
						});
					}
				}
			}

			if (options.spheroid) {
				const component = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent, options.spheroid.name);
				component.setEquatorialRadius(options.spheroid.equatorialRadius);
				component.setPolarRadius(options.spheroid.polarRadius);
				component.setPlanetographic(options.spheroid.planetographic);
			}

			if (options.spheroidLOD) {
				const component = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidLODComponent, options.spheroidLOD.name ?? 'basic');
				if (options.spheroidLOD.features) {
					for (let i = 0, l = options.spheroidLOD.features.length; i < l; i++) {
						component.setFeature(options.spheroidLOD.features[i], true);
					}
				}
				if (options.spheroidLOD.textures) {
					component.setMapping('cube');
					for (const name in options.spheroidLOD.textures) {
						component.setTexture(name, '$STATIC_ASSETS_URL/maps/' + options.spheroidLOD.textures[name].url, options.spheroidLOD.textures[name].sizes);
					}
				}
				if (options.spheroidLOD.shadowEntities) {
					component.setShadowEntities(options.spheroidLOD.shadowEntities);
				}
			}

			if (options.cmts) {
				const component = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CMTSComponent, options.cmts.name);
				if (options.cmts.textures) {
					for (const name in options.cmts.textures) {
						const url = options.cmts.textures[name];
						component.setBaseUrl(name, url);
					}
					component.setMaxLevel(options.cmts.maxLevel || 0);
				}
				if (options.cmts.shadowEntities) {
					component.setShadowEntities(options.cmts.shadowEntities);
				}
			}

			if (options.model) {
				const component = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent, options.model.name);
				component.setUrl(options.model.url);
				if (options.model.rotate) {
					const rotation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
					rotation.set(1, 0, 0, 0);
					for (let i = 0, l = options.model.rotate.length; i < l; i++) {
						let axis;
						let angle;
						const rotate = options.model.rotate[i];
						if (rotate.x !== undefined) {
							axis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(1, 0, 0);
							angle = rotate.x;
						}
						else if (rotate.y !== undefined) {
							axis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 1, 0);
							angle = rotate.y;
						}
						else if (rotate.z !== undefined) {
							axis = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(0, 0, 1);
							angle = rotate.z;
						}
						else {
							throw new Error('Invalid model rotate axis.');
						}
						angle = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(angle);
						const r = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
						r.setFromAxisAngle(axis, angle);
						rotation.mult(r, rotation);
					}
					component.setRotation(rotation);
				}
				if (options.model.scale) {
					const scale = options.model.scale;
					if (Array.isArray(scale)) {
						component.setScale(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(scale[0], scale[1], scale[2]));
					}
					else {
						component.setScale(scale);
					}
				}
				if (options.model.useCompressedTextures === true) {
					component.setUseCompressedTextures(true);
				}
				if (options.model.shadowEntities) {
					component.setShadowEntities(options.model.shadowEntities);
				}

				if (options.model.environmentMap) {
					if (options.model.environmentMap.cubemap) {
						component.setEnvironmentCubemapUrl(options.model.environmentMap.cubemap);
						component.setEnvironmentCylindricalUrl('');
					}
					else if (options.model.environmentMap.cylindrical) {
						component.setEnvironmentCylindricalUrl(options.model.environmentMap.cylindrical);
						component.setEnvironmentCubemapUrl('');
					}
				}
			}

			if (options.comet) {
				const dustTail = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CometTailComponent, options.comet.name);
				if (options.comet.timeLength !== undefined) {
					dustTail.setTimeLength(options.comet.timeLength);
				}
				dustTail.setLightSource('sun');

				const gasTail = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CometTailComponent);
				gasTail.setTimeLength(dustTail.getTimeLength() * 0.5);
				gasTail.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(0.214, 0.235, 0.371, 0.5));
				gasTail.setStarAccelerationMultiplier(10.0);
				gasTail.setLightSource('sun');

				const coma = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CometTailComponent);
				// coma.setTimeLength(dustTail.getTimeLength() * 0.1);
				coma.setStarAccelerationMultiplier(0);
				coma.setColor(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Color(1, 1, 1, 10));
				coma.setNumberOfParticles(1);
				coma.setLightSource('sun');
			}

			if (options.controllers) {
				for (let i = 0, l = options.controllers.length; i < l; i++) {
					const controllerOptions = options.controllers[i];
					const type = controllerOptions.type;
					let controller;
					if (type === 'fixed') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.FixedController, controllerOptions.name);
						if (controllerOptions.position) {
							controller.setPosition(controllerOptions.position);
						}
						if (controllerOptions.orientation) {
							controller.setOrientation(controllerOptions.orientation);
						}
						if (controllerOptions.relativeToEntity) {
							// Add a rotate by parent orientation to get the fixed position in the J2000 frame.
							const rotateByEntityOrientationController = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.RotateByEntityOrientationController);
							rotateByEntityOrientationController.setEntityForOrientation(controllerOptions.relativeToEntity);
							if (controllerOptions.coverage && controllerOptions.coverage.length === 2) {
								rotateByEntityOrientationController.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(controllerOptions.coverage[0], controllerOptions.coverage[1]));
							}
						}
						if (controllerOptions.llaOnSpheroid) {
							const parentName = controllerOptions.llaOnSpheroidEntity ?? options.parents[0][1];
							const parent = scene.getEntity(parentName);
							if (parent !== null) {
								const spheroid = parent.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent);
								if (spheroid === null) {
									throw new Error('Missing spheroid component.');
								}
								if (controllerOptions.coverage && controllerOptions.coverage.length === 2) {
									controller.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(controllerOptions.coverage[0], controllerOptions.coverage[1]));
								}
								// Get the xyz from the lla and set the position.
								const position = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3();
								spheroid.xyzFromLLA(position, controllerOptions.llaOnSpheroid);
								controller.setPosition(position);
								// Get the ori from the lla and set the orientation.
								const orientation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion();
								spheroid.orientationFromLLA(orientation, controllerOptions.llaOnSpheroid);
								controller.setOrientation(orientation);
								// Add a rotate by parent orientation to get it in the J2000 frame.
								const rotateByEntityOrientation = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.RotateByEntityOrientationController);
								if (controllerOptions.coverage && controllerOptions.coverage.length === 2) {
									rotateByEntityOrientation.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(controllerOptions.coverage[0], controllerOptions.coverage[1]));
								}
								const groundClamp = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.GroundClampController);
								groundClamp.setGroundComponentRef(parentName, 'cmts');
								if (controllerOptions.coverage && controllerOptions.coverage.length === 2) {
									groundClamp.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(controllerOptions.coverage[0], controllerOptions.coverage[1]));
								}
							}
						}
					}
					else if (type === 'dynamo') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.DynamoController, controllerOptions.name);
						if (!controllerOptions.customUrl) {
							controller.setBaseUrl('$DYNAMIC_ASSETS_URL/dynamo/' + controllerOptions.url);
						}
						else {
							controller.setBaseUrl(controllerOptions.url);
						}
						if (controllerOptions.parentIsBarycenter) {
							controller.setHeaderValue('body', 1);
						}
					}
					else if (type === 'animdata') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.AnimdataController, controllerOptions.name);
						controller.setBaseUrlAndStateType('$ANIMDATA_URL/' + controllerOptions.url, controllerOptions.dataType);
					}
					else if (type === 'align') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.AlignController, controllerOptions.name);
						controller.setPrimaryAlignType(controllerOptions.primary.type);
						controller.setPrimaryTargetEntity(controllerOptions.primary.target);
						controller.setPrimaryAxis(controllerOptions.primary.axis);
						if (controllerOptions.primary.targetAxis) {
							controller.setPrimaryTargetAxis(controllerOptions.primary.targetAxis);
						}
						if (controllerOptions.secondary) {
							controller.setSecondaryAlignType(controllerOptions.secondary.type);
							controller.setSecondaryTargetEntity(controllerOptions.secondary.target);
							controller.setSecondaryAxis(controllerOptions.secondary.axis);
							if (controllerOptions.secondary.targetAxis) {
								controller.setSecondaryTargetAxis(controllerOptions.secondary.targetAxis);
							}
						}
					}
					else if (type === 'spin') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpinController, controllerOptions.name);
						controller.setAxis(controllerOptions.axis, controllerOptions.axisInFrameSpace ?? true);
						controller.setRate(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.twoPi / (controllerOptions.periodInHours * 3600));
						if (controllerOptions.relativeToTime !== undefined) {
							controller.setReferenceTime(controllerOptions.relativeToTime);
						}
					}
					else if (type === 'rotateByEntityOrientation') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.RotateByEntityOrientationController, controllerOptions.name);
						if (controllerOptions.entityForOrientation) {
							controller.setEntityForOrientation(controllerOptions.entityForOrientation);
						}
						if (controllerOptions.rotatingOrientation !== undefined) {
							controller.setRotatingOrientation(controllerOptions.rotatingOrientation);
						}
						if (controllerOptions.rotatingPosition !== undefined) {
							controller.setRotatingPosition(controllerOptions.rotatingPosition);
						}
					}
					else if (type === 'orbitalElements') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitalElementsController, controllerOptions.name);
						const epoch = controllerOptions.epoch ?? 0;
						const orbitalElements = new pioneer__WEBPACK_IMPORTED_MODULE_0__.OrbitalElements();
						orbitalElements.epoch = epoch;
						orbitalElements.eccentricity = controllerOptions.eccentricity;
						orbitalElements.semiMajorAxis = controllerOptions.semiMajorAxis;
						orbitalElements.meanAngularMotion = controllerOptions.meanAngularMotion;
						orbitalElements.meanAnomalyAtEpoch = controllerOptions.meanAnomalyAtEpoch;
						if (controllerOptions.orbitOrientation !== undefined) {
							orbitalElements.orbitOrientation.copy(controllerOptions.orbitOrientation);
						}
						else {
							if (controllerOptions.inclination === undefined || controllerOptions.longitudeOfAscendingNode === undefined || controllerOptions.argumentOfPeriapsis === undefined) {
								throw new Error('Either orbitOrientation or all of inclination, longitudeOfAscendingNode, and argumentOfPeriapsis must be defined.');
							}
							orbitalElements.setOrbitOrientationFromElements(controllerOptions.inclination, controllerOptions.longitudeOfAscendingNode, controllerOptions.argumentOfPeriapsis);
						}
						controller.addOrbitalElements(epoch, orbitalElements);
					}
					else if (type === 'coverage') {
						controller = entity.addControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CoverageController, controllerOptions.name);
						controller.setEnterFunction(controllerOptions.enter);
						controller.setExitFunction(controllerOptions.exit);
						controller.setUpdateFunction(controllerOptions.update);
						if (controllerOptions.updateInterval !== undefined) {
							controller.setUpdateInterval(controllerOptions.updateInterval);
						}
					}
					else if (type === 'custom') {
						controller = controllerOptions.func(entity);
					}
					else {
						throw new Error(`The type "${type}" is unknown.`);
					}
					if (controllerOptions.coverage && controllerOptions.coverage.length === 2) {
						controller.setCoverage(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(controllerOptions.coverage[0], controllerOptions.coverage[1]));
					}
				}
			}

			if (options.postCreateFunction) {
				options.postCreateFunction(entity, extraOptions);
			}
		}
		catch (error) {
			if (entity !== null) {
				scene.removeEntity(entity);
			}
			if (error instanceof Error) {
				error.message = `While creating "${actualName}": ${error.message}`;
			}
			throw error;
		}

		return entity;
	}

	/**
	 * Gets the entity options that are used to create the entity.
	 * @param {string} name
	 * @returns {Options | undefined}
	 */
	static getEntityOptions(name) {
		return Entity._entities.get(name);
	}

	/**
	 * Gets a list of all entity names that are within a given set of groups, which is a comma-separated list of groups that each entity must include.
	 * @param {string} groups
	 * @returns {Set<string>}
	 */
	static getEntityNamesInGroup(groups) {
		const matchingEntityNames = new Set();
		if (groups !== '') {
			const groupsArray = groups.split(',').map((group) => {
				return group.trim();
			});
			for (const [name, options] of Entity._entities) {
				const entityGroups = options.groups;
				if (!entityGroups) { // Entity has has no group.
					continue;
				}
				let matches = true;
				for (const group of groupsArray) {
					if (!entityGroups.includes(group)) {
						matches = false;
					}
				}
				if (!matches) {
					continue;
				}
				matchingEntityNames.add(name);
			}
		}
		else {
			for (const name of Entity._entities.keys()) {
				matchingEntityNames.add(name);
			}
		}
		return matchingEntityNames;
	}

	/**
	 * Gets a list of all groups that exist within the entities.
	 * @returns {Set<string>}
	 */
	static getGroups() {
		const groups = new Set();
		for (const options of this._entities.values()) {
			const entityGroups = options.groups;
			if (entityGroups !== undefined) {
				for (let i = 0; i < entityGroups.length; i++) {
					groups.add(entityGroups[i]);
				}
			}
		}
		return groups;
	}

	/**
	 * Create all of the entities that belong to a group.
	 * @param {string} groups - A comma-separated list of groups that each entity must include.
	 * @param {Pioneer.Scene} scene
	 * @param {ExtraOptions} [extraOptions]
	 */
	static createGroup(groups, scene, extraOptions) {
		const matchingEntityNames = this.getEntityNamesInGroup(groups);
		for (const entityName of matchingEntityNames) {
			this.create(entityName, scene, extraOptions);
		}
	}
}

/**
 * @type {Map<string, Options>}
 */
Entity._entities = new Map();


/***/ }),

/***/ "../pioneer/scripts/src/features.js":
/*!******************************************!*\
  !*** ../pioneer/scripts/src/features.js ***!
  \******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Features": function() { return /* binding */ Features; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity */ "../pioneer/scripts/src/entity.js");



/**
 * Functions for enabling and disabling special features on entities.
 */
class Features {
	/**
	 * Enables or disables the featureType of the entityName.
	 * @param {Pioneer.Scene} scene
	 * @param {string} entityName
	 * @param {string} featureType
	 * @param {boolean} enable
	 */
	static setEnabled(scene, entityName, featureType, enable) {
		const featureSetEnabledMap = entityFeatureSetEnabledMap[entityName];
		if (!featureSetEnabledMap) {
			throw new Error(`Attempted to access unavailable feature ${featureType} for ${entityName}.`);
		}
		const setEnabledFunction = featureSetEnabledMap[featureType];
		if (!setEnabledFunction) {
			throw new Error(`Attempted to access unavailable feature ${featureType} for ${entityName}.`);
		}
		setEnabledFunction(scene, enable);
	}

	/**
	 * Returns true if the featureType of the entityName is enabled.
	 * @param {Pioneer.Scene} scene
	 * @param {string} entityName
	 * @param {string} featureType
	 * @returns {boolean}
	 */
	static isEnabled(scene, entityName, featureType) {
		const featureIsEnabledMap = entityFeatureIsEnabledMap[entityName];
		if (!featureIsEnabledMap) {
			throw new Error(`Attempted to access unavailable feature ${featureType} for ${entityName}.`);
		}
		const isEnabledFunction = featureIsEnabledMap[featureType];
		if (!isEnabledFunction) {
			throw new Error(`Attempted to access unavailable feature ${featureType} for ${entityName}.`);
		}
		return isEnabledFunction(scene);
	}

	/**
	 * Enables or disables Jupiter's auroras.
	 * @param {Pioneer.Scene} scene
	 * @param {boolean} enable
	 */
	static setEnabledJupiterAuroras(scene, enable) {
		if (enable) {
			Features._createJupiterModelComponent(scene, 'auroras', 'auroras');
		}
		else if (enable === false) {
			scene.getEntity('jupiter').removeComponent('auroras');
		}
	}

	/**
	 * Returns true if Jupiter's auroras are enabled.
	 * @param {Pioneer.Scene} scene
	 * @returns {boolean}
	 */
	static isEnabledJupiterAuroras(scene) {
		return scene.getEntity('jupiter').getComponent('auroras') !== null;
	}

	/**
	 * Enables or disables Jupiter's magnetosphere.
	 * @param {Pioneer.Scene} scene
	 * @param {boolean} enable
	 */
	static setEnabledJupiterMagnetosphere(scene, enable) {
		if (enable) {
			Features._createJupiterModelComponent(scene, 'magnetosphere', 'magnetosphere');
		}
		else {
			scene.getEntity('jupiter').removeComponent('magnetosphere');
		}
	}

	/**
	 * Returns true if Jupiter's magnetosphere is enabled.
	 * @param {Pioneer.Scene} scene
	 * @returns {boolean}
	 */
	static isEnabledJupiterMagnetosphere(scene) {
		return scene.getEntity('jupiter').getComponent('magnetosphere') !== null;
	}

	/**
	 * Enables or disables Jupiter's radiation belt.
	 * @param {Pioneer.Scene} scene
	 * @param {boolean} enable
	 */
	static setEnabledJupiterRadiationBelt(scene, enable) {
		if (enable) {
			Features._createJupiterModelComponent(scene, 'radiation_belt_1', 'radbelt1');
			Features._createJupiterModelComponent(scene, 'radiation_belt_2', 'radbelt2');
			Features._createJupiterModelComponent(scene, 'radiation_belt_3', 'radbelt3');
			Features._createJupiterModelComponent(scene, 'radiation_belt_4', 'radbelt4');
		}
		else {
			const entity = scene.getEntity('jupiter');
			entity.removeComponent('radiation_belt_1');
			entity.removeComponent('radiation_belt_2');
			entity.removeComponent('radiation_belt_3');
			entity.removeComponent('radiation_belt_4');
		}
	}

	/**
	 * Returns true if Jupiter's radiation belt is enabled.
	 * @param {Pioneer.Scene} scene
	 * @returns {boolean}
	 */
	static isEnabledJupiterRadiationBelt(scene) {
		const entity = scene.getEntity('jupiter');
		return entity.getComponent('radiation_belt_1') !== null
				&& entity.getComponent('radiation_belt_2') !== null
				&& entity.getComponent('radiation_belt_3') !== null
				&& entity.getComponent('radiation_belt_4') !== null;
	}

	/**
	 * Enables or disables Saturn's magnetosphere.
	 * @param {Pioneer.Scene} scene
	 * @param {boolean} enable
	 */
	static setEnabledSaturnMagnetosphere(scene, enable) {
		if (enable) {
			_entity__WEBPACK_IMPORTED_MODULE_1__.Entity.createFromOptions('saturn_magnetosphere', {
				radius: 5027500,
				parents: [
					[Number.NEGATIVE_INFINITY, 'saturn']
				],
				model: {
					url: '$STATIC_ASSETS_URL/models/saturn/magnetosphere/saturn_magnetosphere.gltf',
					scale: 1078.27002124,
					rotate: [
						{ x: 90 }
					]
				},
				controllers: [{
					type: 'fixed',
					position: pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero
				}, {
					type: 'align',
					primary: {
						type: 'align',
						target: 'saturn',
						axis: pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis,
						targetAxis: pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.ZAxis
					},
					secondary: {
						type: 'point',
						target: 'sun',
						axis: pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.XAxis
					}
				}],
				postCreateFunction: (entity) => {
					entity.setCanOcclude(false);
					const thinModel = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent);
					thinModel.setUrl('$STATIC_ASSETS_URL/models/saturn/magnetosphere_thin/saturn_magnetosphere_thin.gltf');
					thinModel.setScale(1078.27002124);
					thinModel.setRotation(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion(Math.sqrt(0.5), Math.sqrt(0.5), 0, 0));
					thinModel.setPixelRadiusVisibleInterval(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(4000, Number.POSITIVE_INFINITY));
					thinModel.setResourcesLoadedCallback(() => {
						thinModel.getThreeJsObjects()[0].renderOrder = -1;
					});
					const thickModel = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent);
					thickModel.setPixelRadiusVisibleInterval(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Interval(0, 4000));
					thickModel.setResourcesLoadedCallback(() => {
						thickModel.getThreeJsObjects()[0].renderOrder = -1;
					});
				}
			}, scene);
		}
		else {
			scene.removeEntity('saturn_magnetosphere');
		}
	}

	/**
	 * Returns true if Saturn's magnetosphere is enabled.
	 * @param {Pioneer.Scene} scene
	 * @returns {boolean}
	 */
	static isEnabledSaturnMagnetosphere(scene) {
		return scene.getEntity('saturn_magnetosphere') !== null;
	}

	/**
	 * Creates a Jupiter model. Returns the component created.
	 * @param {Pioneer.Scene} scene - the scene where the entity is.
	 * @param {string} name - the folder and component name.
	 * @param {string} fileName - the name of the file inbetween the jupiter_ and .gltf.
	 * @private
	 */
	static _createJupiterModelComponent(scene, name, fileName) {
		const entity = scene.getEntity('jupiter');
		const model = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.ModelComponent, name);
		model.setUrl(`$STATIC_ASSETS_URL/models/${'jupiter'}/${name}/${'jupiter'}_${fileName}.gltf`);
		// Scale it, since the gltf uses a 100 km polar diameter model.
		model.setScale(1337.08);
		// Rotate the model to be in the right orientation.
		const rotation1 = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion(Math.SQRT1_2, Math.SQRT1_2, 0, 0); // 90 degrees around x-axis
		const rotation2 = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion(Math.SQRT1_2, 0, 0, Math.SQRT1_2); // 90 degrees around z-axis
		rotation1.mult(rotation2, rotation1);
		model.setRotation(rotation1);
	}
}

/**
 * A entityName to featureType to setEnabled function map.
 * @type {Record<string, Record<string, (scene: Pioneer.Scene, enable: boolean) => void>>}
 * @private
 */
const entityFeatureSetEnabledMap = {
	jupiter: {
		auroras: Features.setEnabledJupiterAuroras,
		magnetosphere: Features.setEnabledJupiterMagnetosphere,
		radiationBelt: Features.setEnabledJupiterRadiationBelt
	},
	saturn: {
		magnetosphere: Features.setEnabledSaturnMagnetosphere
	}
};

/**
 * A entityName to featureType to isEnabled function map.
 * @type {Record<string, Record<string, (scene: Pioneer.Scene) => boolean>>}
 * @private
 */
const entityFeatureIsEnabledMap = {
	jupiter: {
		auroras: Features.isEnabledJupiterAuroras,
		magnetosphere: Features.isEnabledJupiterMagnetosphere,
		radiationBelt: Features.isEnabledJupiterRadiationBelt
	},
	saturn: {
		magnetosphere: Features.isEnabledSaturnMagnetosphere
	}
};


/***/ }),

/***/ "../pioneer/scripts/src/index.js":
/*!***************************************!*\
  !*** ../pioneer/scripts/src/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Cameras": function() { return /* reexport safe */ _cameras__WEBPACK_IMPORTED_MODULE_0__.Cameras; },
/* harmony export */   "DateTime": function() { return /* reexport safe */ _date_time__WEBPACK_IMPORTED_MODULE_1__.DateTime; },
/* harmony export */   "Entity": function() { return /* reexport safe */ _entity__WEBPACK_IMPORTED_MODULE_2__.Entity; },
/* harmony export */   "Features": function() { return /* reexport safe */ _features__WEBPACK_IMPORTED_MODULE_3__.Features; },
/* harmony export */   "Mapping": function() { return /* reexport safe */ _mapping__WEBPACK_IMPORTED_MODULE_4__.Mapping; },
/* harmony export */   "Parenting": function() { return /* reexport safe */ _parenting__WEBPACK_IMPORTED_MODULE_5__.Parenting; },
/* harmony export */   "Placemarks": function() { return /* reexport safe */ _placemarks__WEBPACK_IMPORTED_MODULE_6__.Placemarks; },
/* harmony export */   "SceneHelpers": function() { return /* reexport safe */ _scene_helpers__WEBPACK_IMPORTED_MODULE_7__.SceneHelpers; },
/* harmony export */   "Transitions": function() { return /* reexport safe */ _transitions__WEBPACK_IMPORTED_MODULE_8__.Transitions; },
/* harmony export */   "AnnulusComponent": function() { return /* reexport safe */ _components_annulus_component__WEBPACK_IMPORTED_MODULE_9__.AnnulusComponent; },
/* harmony export */   "CelestialGridComponent": function() { return /* reexport safe */ _components_celestial_grid_component__WEBPACK_IMPORTED_MODULE_10__.CelestialGridComponent; },
/* harmony export */   "ConstellationsComponent": function() { return /* reexport safe */ _components_constellations_component__WEBPACK_IMPORTED_MODULE_11__.ConstellationsComponent; },
/* harmony export */   "DiscGridComponent": function() { return /* reexport safe */ _components_disc_grid_component__WEBPACK_IMPORTED_MODULE_12__.DiscGridComponent; },
/* harmony export */   "ShadowConeComponent": function() { return /* reexport safe */ _components_shadow_cone_component__WEBPACK_IMPORTED_MODULE_13__.ShadowConeComponent; },
/* harmony export */   "OrbitLineComponent": function() { return /* reexport safe */ _components_orbit_line_component__WEBPACK_IMPORTED_MODULE_14__.OrbitLineComponent; },
/* harmony export */   "TorusComponent": function() { return /* reexport safe */ _components_torus_component__WEBPACK_IMPORTED_MODULE_15__.TorusComponent; },
/* harmony export */   "WMTSComponent": function() { return /* reexport safe */ _components_wmts_component__WEBPACK_IMPORTED_MODULE_16__.WMTSComponent; },
/* harmony export */   "KeyframePointingController": function() { return /* reexport safe */ _controllers_keyframe_pointing_controller__WEBPACK_IMPORTED_MODULE_17__.KeyframePointingController; },
/* harmony export */   "KeyframeSpinController": function() { return /* reexport safe */ _controllers_keyframe_spin_controller__WEBPACK_IMPORTED_MODULE_18__.KeyframeSpinController; },
/* harmony export */   "PositionSumController": function() { return /* reexport safe */ _controllers_position_sum_controller__WEBPACK_IMPORTED_MODULE_19__.PositionSumController; },
/* harmony export */   "ZoomFitController": function() { return /* reexport safe */ _controllers_zoom_fit_controller__WEBPACK_IMPORTED_MODULE_20__.ZoomFitController; }
/* harmony export */ });
/* harmony import */ var _cameras__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./cameras */ "../pioneer/scripts/src/cameras.js");
/* harmony import */ var _date_time__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./date_time */ "../pioneer/scripts/src/date_time.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var _features__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./features */ "../pioneer/scripts/src/features.js");
/* harmony import */ var _mapping__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mapping */ "../pioneer/scripts/src/mapping.js");
/* harmony import */ var _parenting__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./parenting */ "../pioneer/scripts/src/parenting.js");
/* harmony import */ var _placemarks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./placemarks */ "../pioneer/scripts/src/placemarks.js");
/* harmony import */ var _scene_helpers__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./scene_helpers */ "../pioneer/scripts/src/scene_helpers.js");
/* harmony import */ var _transitions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./transitions */ "../pioneer/scripts/src/transitions.js");
/* harmony import */ var _components_annulus_component__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./components/annulus_component */ "../pioneer/scripts/src/components/annulus_component.js");
/* harmony import */ var _components_celestial_grid_component__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./components/celestial_grid_component */ "../pioneer/scripts/src/components/celestial_grid_component.js");
/* harmony import */ var _components_constellations_component__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./components/constellations_component */ "../pioneer/scripts/src/components/constellations_component.js");
/* harmony import */ var _components_disc_grid_component__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./components/disc_grid_component */ "../pioneer/scripts/src/components/disc_grid_component.js");
/* harmony import */ var _components_shadow_cone_component__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./components/shadow_cone_component */ "../pioneer/scripts/src/components/shadow_cone_component.js");
/* harmony import */ var _components_orbit_line_component__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./components/orbit_line_component */ "../pioneer/scripts/src/components/orbit_line_component.js");
/* harmony import */ var _components_torus_component__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./components/torus_component */ "../pioneer/scripts/src/components/torus_component.js");
/* harmony import */ var _components_wmts_component__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./components/wmts_component */ "../pioneer/scripts/src/components/wmts_component.js");
/* harmony import */ var _controllers_keyframe_pointing_controller__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./controllers/keyframe_pointing_controller */ "../pioneer/scripts/src/controllers/keyframe_pointing_controller.js");
/* harmony import */ var _controllers_keyframe_spin_controller__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./controllers/keyframe_spin_controller */ "../pioneer/scripts/src/controllers/keyframe_spin_controller.js");
/* harmony import */ var _controllers_position_sum_controller__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./controllers/position_sum_controller */ "../pioneer/scripts/src/controllers/position_sum_controller.js");
/* harmony import */ var _controllers_zoom_fit_controller__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./controllers/zoom_fit_controller */ "../pioneer/scripts/src/controllers/zoom_fit_controller.js");
/* harmony import */ var _entities_planets_and_stars__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./entities/planets_and_stars */ "../pioneer/scripts/src/entities/planets_and_stars.js");
/* harmony import */ var _entities_minor_planets__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ./entities/minor_planets */ "../pioneer/scripts/src/entities/minor_planets.js");
/* harmony import */ var _entities_comets__WEBPACK_IMPORTED_MODULE_23__ = __webpack_require__(/*! ./entities/comets */ "../pioneer/scripts/src/entities/comets.js");
/* harmony import */ var _entities_earth_moon__WEBPACK_IMPORTED_MODULE_24__ = __webpack_require__(/*! ./entities/earth_moon */ "../pioneer/scripts/src/entities/earth_moon.js");
/* harmony import */ var _entities_jupiter_regular_moons__WEBPACK_IMPORTED_MODULE_25__ = __webpack_require__(/*! ./entities/jupiter_regular_moons */ "../pioneer/scripts/src/entities/jupiter_regular_moons.js");
/* harmony import */ var _entities_jupiter_irregular_moons__WEBPACK_IMPORTED_MODULE_26__ = __webpack_require__(/*! ./entities/jupiter_irregular_moons */ "../pioneer/scripts/src/entities/jupiter_irregular_moons.js");
/* harmony import */ var _entities_mars_moons__WEBPACK_IMPORTED_MODULE_27__ = __webpack_require__(/*! ./entities/mars_moons */ "../pioneer/scripts/src/entities/mars_moons.js");
/* harmony import */ var _entities_neptune_moons__WEBPACK_IMPORTED_MODULE_28__ = __webpack_require__(/*! ./entities/neptune_moons */ "../pioneer/scripts/src/entities/neptune_moons.js");
/* harmony import */ var _entities_saturn_major_moons__WEBPACK_IMPORTED_MODULE_29__ = __webpack_require__(/*! ./entities/saturn_major_moons */ "../pioneer/scripts/src/entities/saturn_major_moons.js");
/* harmony import */ var _entities_saturn_minor_moons__WEBPACK_IMPORTED_MODULE_30__ = __webpack_require__(/*! ./entities/saturn_minor_moons */ "../pioneer/scripts/src/entities/saturn_minor_moons.js");
/* harmony import */ var _entities_uranus_major_moons__WEBPACK_IMPORTED_MODULE_31__ = __webpack_require__(/*! ./entities/uranus_major_moons */ "../pioneer/scripts/src/entities/uranus_major_moons.js");
/* harmony import */ var _entities_uranus_minor_moons__WEBPACK_IMPORTED_MODULE_32__ = __webpack_require__(/*! ./entities/uranus_minor_moons */ "../pioneer/scripts/src/entities/uranus_minor_moons.js");
/* harmony import */ var _entities_earth_spacecraft__WEBPACK_IMPORTED_MODULE_33__ = __webpack_require__(/*! ./entities/earth_spacecraft */ "../pioneer/scripts/src/entities/earth_spacecraft.js");
/* harmony import */ var _entities_lunar_spacecraft__WEBPACK_IMPORTED_MODULE_34__ = __webpack_require__(/*! ./entities/lunar_spacecraft */ "../pioneer/scripts/src/entities/lunar_spacecraft.js");
/* harmony import */ var _entities_mars_spacecraft__WEBPACK_IMPORTED_MODULE_35__ = __webpack_require__(/*! ./entities/mars_spacecraft */ "../pioneer/scripts/src/entities/mars_spacecraft.js");
/* harmony import */ var _entities_mercury_spacecraft__WEBPACK_IMPORTED_MODULE_36__ = __webpack_require__(/*! ./entities/mercury_spacecraft */ "../pioneer/scripts/src/entities/mercury_spacecraft.js");
/* harmony import */ var _entities_outer_planet_spacecraft__WEBPACK_IMPORTED_MODULE_37__ = __webpack_require__(/*! ./entities/outer_planet_spacecraft */ "../pioneer/scripts/src/entities/outer_planet_spacecraft.js");
/* harmony import */ var _entities_small_body_spacecraft__WEBPACK_IMPORTED_MODULE_38__ = __webpack_require__(/*! ./entities/small_body_spacecraft */ "../pioneer/scripts/src/entities/small_body_spacecraft.js");
/* harmony import */ var _entities_solar_spacecraft__WEBPACK_IMPORTED_MODULE_39__ = __webpack_require__(/*! ./entities/solar_spacecraft */ "../pioneer/scripts/src/entities/solar_spacecraft.js");
/* harmony import */ var _entities_venus_spacecraft__WEBPACK_IMPORTED_MODULE_40__ = __webpack_require__(/*! ./entities/venus_spacecraft */ "../pioneer/scripts/src/entities/venus_spacecraft.js");
/* harmony import */ var _entities_comparison__WEBPACK_IMPORTED_MODULE_41__ = __webpack_require__(/*! ./entities/comparison */ "../pioneer/scripts/src/entities/comparison.js");
/**
 * Interface to export classes from modules.
 */










// Components









// Controllers




























/***/ }),

/***/ "../pioneer/scripts/src/mapping.js":
/*!*****************************************!*\
  !*** ../pioneer/scripts/src/mapping.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Mapping": function() { return /* binding */ Mapping; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");


/**
 * Functions for enabling and disabling special features on entities.
 */
class Mapping {
	/**
	 * Gets all possible mapping types for a given entity.
	 * @param {string} entityName
	 * @returns string[]
	 */
	static getTypes(entityName) {
		return Mapping._types[entityName] ?? [];
	}

	/**
	 * Sets the entity to use the mapping given by the type.
	 * @param {Pioneer.Scene} scene
	 * @param {string} entityName
	 * @param {string} type
	 */
	static async set(scene, entityName, type) {
		// Enable the type and wait for it to be loaded.
		await Mapping.setEnabled(scene, entityName, type, true);
		// Disable all of the other non-matching types, including basic.
		for (const otherType of Mapping.getTypes(entityName)) {
			if (otherType !== type) {
				Mapping.setEnabled(scene, entityName, otherType, false);
			}
		}
		if (type !== 'basic') {
			Mapping.setEnabled(scene, entityName, 'basic', false);
		}
	}

	/**
	 * Enables or disables the given type. Used as a mapping from the 'type' to actual functions.
	 * @param {Pioneer.Scene} scene
	 * @param {string} entityName
	 * @param {string} type
	 * @param {boolean} enabled
	 * @private
	 */
	static async setEnabled(scene, entityName, type, enabled) {
		if (type === 'basic') {
			Mapping.setBasic(scene, entityName, enabled);
		}
		else if (type.startsWith('cmts')) {
			await Mapping.setCMTS(scene, entityName, type, enabled);
		}
		else {
			throw new Error(`Invalid type ${type}.`);
		}
	}

	/**
	 * Sets the entity to use the basic spheroidLOD.
	 * @param {Pioneer.Scene} scene
	 * @param {string} entityName
	 * @param {boolean} enabled
	 * @returns {Promise<void>}
	 * @private
	 */
	static async setBasic(scene, entityName, enabled) {
		const entity = scene.getEntity(entityName);
		if (entity === null) {
			throw new Error(`No entity named '${entityName}' exists.`);
		}
		const spheroidLOD = entity.getComponent('basic');
		if (spheroidLOD === null || spheroidLOD.getType() !== 'spheroidLOD') {
			throw new Error(`The entity '${entityName}' does not have a spheroidLOD named 'basic'.`);
		}
		spheroidLOD.setEnabled(enabled);
		if (enabled) {
			// Make it invisible, load it, and make it visible.
			spheroidLOD.setVisible(false);
			await spheroidLOD.getLoadedPromise();
			spheroidLOD.setVisible(true);
		}
	}

	/**
	 * Sets the entity to use CMTS.
	 * @param {Pioneer.Scene} scene
	 * @param {string} entityName
	 * @param {string} type
	 * @param {boolean} enabled
	 * @returns {Promise<void>}
	 * @private
	 */
	static async setCMTS(scene, entityName, type, enabled) {
		const entity = scene.getEntity(entityName);
		if (entity === null) {
			throw new Error(`No entity named '${entityName}' exists.`);
		}
		if (enabled && !entity.get('cmts')) {
			const cmts = entity.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.CMTSComponent, type);
			if (entityName === 'mars') {
				// Set the base urls.
				cmts.setBaseUrl('color', '$DYNAMIC_ASSETS_URL/cmts/1/' + entityName + '/color');
				cmts.setBaseUrl('height', '$DYNAMIC_ASSETS_URL/cmts/1/' + entityName + '/height');
				// Set the tile offsets for certain sites.
				cmts.addTileOffset(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(700.6128653358727, 3140.020080650305, 1073.622947405036), 1, 12, 1585, 2747, 1592, 2752); // M20
				cmts.addTileOffset(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(-2489.8644947661123, 2286.2056005322775, -271.3458260440484), 2, 12, 158, 1811, 169, 1825); // MSL
				cmts.addTileOffset(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3(-2432.935716315694, 2349.9743692542434, 267.129381207100), 2, 9, 8, 284, 8, 284); // InSight
			}
			else if (entityName === 'moon') {
				// Set the base urls.
				cmts.setBaseUrl('color', '$DYNAMIC_ASSETS_URL/cmts/' + entityName + '/color');
				cmts.setBaseUrl('normal', '$DYNAMIC_ASSETS_URL/cmts/' + entityName + '/normal');
				cmts.setBaseUrl('height', '$DYNAMIC_ASSETS_URL/cmts/' + entityName + '/height');
			}
			// Make it invisible, load it, and make it visible.
			cmts.setVisible(false);
			await cmts.getLoadedPromise();
			await cmts.getTilesLoadedPromise();
			cmts.setVisible(true);
		}
		else if (!enabled && entity.get('cmts')) {
			entity.removeComponent(entity.getComponentByType('cmts'));
		}
	}

	/**
	 * @type {Object<string, string[]>}
	 * @private
	 */
	static _types = {
		mars: ['cmts']
	};
}


/***/ }),

/***/ "../pioneer/scripts/src/parenting.js":
/*!*******************************************!*\
  !*** ../pioneer/scripts/src/parenting.js ***!
  \*******************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Parenting": function() { return /* binding */ Parenting; }
/* harmony export */ });
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./entity */ "../pioneer/scripts/src/entity.js");
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");



/**
 * Parenting helper functions.
 */
class Parenting {

	/**
	 * Gets the parent of the entity at the given time.
	 * @param {string} entityName
	 * @param {number} time
	 * @returns {string}
	 */
	static getParentOfEntity(entityName, time) {
		const entityOptions = _entity__WEBPACK_IMPORTED_MODULE_0__.Entity.getEntityOptions(entityName);
		if (entityOptions === undefined) {
			throw new Error(`There are no entity options for ${entityName}.`);
		}
		const parents = entityOptions.parents;
		const index = pioneer__WEBPACK_IMPORTED_MODULE_1__.Sort.getIndex(time, parents, isStartTimeLessThanTime);

		if (index < parents.length && time === parents[index][0]) {
			return parents[index][1];
		}
		else if (index > 0) {
			return parents[index - 1][1];
		}
		else {
			return '';
		}
	}

	/**
	 * Gets all of the ancestors of an entity for all times.
	 * @param {string} entityName - The name of the entity.
	 * @returns {Set<string>}
	 */
	static getAllAncestorsOfEntity(entityName) {
		const parents = new Set();
		this._getAllAncestorsOfEntityRecursed(entityName, parents);
		return parents;
	}

	/**
	 * Gets all of the ancestors of an entity for all times.
	 * @param {string} entityName - The name of the entity.
	 * @param {Set<string>} parents - The parents set that will be added to.
	 * @private
	 */
	static _getAllAncestorsOfEntityRecursed(entityName, parents) {
		const entityOptions = _entity__WEBPACK_IMPORTED_MODULE_0__.Entity.getEntityOptions(entityName);
		if (entityOptions === undefined || entityOptions.parents === undefined) {
			return;
		}
		const parentTable = entityOptions.parents;
		for (const parentEntry of parentTable) {
			const parentName = parentEntry[1];
			if (!parents.has(parentName)) {
				parents.add(parentName);
				this._getAllAncestorsOfEntityRecursed(parentName, parents);
			}
		}
	}
}

/**
 * Returns true if a < b.
 * @param {[number, string]} a
 * @param {number} b
 */
function isStartTimeLessThanTime(a, b) {
	return a[0] < b;
}


/***/ }),

/***/ "../pioneer/scripts/src/placemarks.js":
/*!********************************************!*\
  !*** ../pioneer/scripts/src/placemarks.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Placemarks": function() { return /* binding */ Placemarks; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * Helpful functions for placing markers on a spheroid.
 * @hideconstructor
 */
class Placemarks {
	/**
	 * Adds a placemark on an entity and returns it.
	 * @param {string} name - The name of the placemark entity.
	 * @param {string} label - The label to be displayed.
	 * @param {Pioneer.Entity} body - The entity on which the placemark will go.
	 * @param {number} latInDeg - The latitude in degrees.
	 * @param {number} lonInDeg - The longitude in degrees.
	 * @param {number} altitudeInKm - The altitude in km.
	 * @param {boolean} useOrientation - If true, orients the placemark entity to be along the east and north axes.
	 * @returns {Pioneer.Entity}
	 */
	static addPlacemark(name, label, body, latInDeg, lonInDeg, altitudeInKm, useOrientation = false) {
		const placemark = body.getScene().addEntity(name);
		placemark.setParent(body);
		placemark.setCanOcclude(false);
		placemark.setExtentsRadius(1);

		const divComponent = placemark.addComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.DivComponent);
		divComponent.setAlignment(new pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2(0.5, 0.5));
		divComponent.getDiv().innerHTML = label;

		placemark.addController('fixed');
		placemark.addController('rotateByEntityOrientation');

		this.updateLLA(placemark, latInDeg, lonInDeg, altitudeInKm, useOrientation);

		return placemark;
	}

	/**
	 * Updates a placemark with a new location.
	 * @param {Pioneer.Entity} placemark - The placemark to change.
	 * @param {number} latInDeg - The latitude in degrees.
	 * @param {number} lonInDeg - The longitude in degrees.
	 * @param {number} altitudeInKm - The altitude in km.
	 * @param {boolean} useOrientation - If true, orients the placemark entity to be along the east and north axes.
	 */
	static updateLLA(placemark, latInDeg, lonInDeg, altitudeInKm, useOrientation = false) {
		const body = placemark.getParent();
		const fixedController = placemark.getControllerByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.FixedController);
		const spheroidComponent = body.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent);
		if (fixedController === null || spheroidComponent === null) {
			throw new Error('No fixed controller and/or spheroid component.');
		}

		const lla = pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		const markPos = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();

		// Update the position using the given lat, lon, alt, and the spheroid.
		lla.set(pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(latInDeg), pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.degToRad(lonInDeg), altitudeInKm);
		spheroidComponent.xyzFromLLA(markPos, lla);
		fixedController.setPosition(markPos);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(markPos);

		// If we're setting the orientation, use the east and north of the location on the spheroid.
		if (useOrientation) {
			const markOri = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
			const east = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			const north = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			spheroidComponent.eastFromLLA(east, lla);
			spheroidComponent.northFromLLA(north, lla);
			markOri.setFromAxes(east, north, undefined);
			fixedController.setOrientation(markOri);
			pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(east);
			pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(north);
			pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(markOri);
		}

		pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
	}
};


/***/ }),

/***/ "../pioneer/scripts/src/scene_helpers.js":
/*!***********************************************!*\
  !*** ../pioneer/scripts/src/scene_helpers.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "SceneHelpers": function() { return /* binding */ SceneHelpers; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/* harmony import */ var _entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entity */ "../pioneer/scripts/src/entity.js");
/** @module pioneer-scripts */



/**
 * Helpful utilities for scenes.
 * @hideconstructor
 */
class SceneHelpers {
	/**
	 * The transformation from EclipJ2000 (a SPICE frame) to J2000 coordinates. This is the tilt from the equator to the ecliptic.
	 * @returns {Pioneer.Quaternion}
	 */
	static getEclipJ2000ToJ2000Rotation() {
		return this.eclipJ2000ToJ2000Rotation;
	}

	/**
	 * This returns a promise that resolves when all of the entities in `entityNames` have non-NaN positions and orientations.
	 * For entities that aren't covered in the current time, they count as immediately valid.
	 * @param {Pioneer.Scene} scene - the scene where the entities are
	 * @param {string[]} entityNames - the set of names of entities to be checked
	 * @param {number} [time] - an optional time to use
	 * @param {number} [timeout = 5.0] - the number of seconds to wait until the promise is rejected
	 * @param {number} [frequency = 0.030] - the number of seconds to wait before checking the positions and orientations again
	 * @returns {Promise<void>}
	 */
	static async waitTillEntitiesInPlace(scene, entityNames, time = undefined, timeout = 5.0, frequency = 0.030) {
		// Get the set of entities from the set of entity names.
		const entities = /** @type {Set<Pioneer.Entity>} */(new Set());
		for (const entityName of entityNames) {
			const entity = scene.getEntity(entityName);
			if (entity === null) {
				throw new Error('Entity "' + entityName + '" not added yet. Use Entity.create to add the entity.');
			}
			entities.add(entity);
		}

		// Wait on the promises of all controllers of every entity.
		const controllerPromises = [];
		for (const entity of entities) {
			for (let i = 0; i < entity.getNumControllers(); i++) {
				controllerPromises.push(entity.getController(i).getLoadedPromise());
			}
		}
		await Promise.all(controllerPromises);

		// If there was no time, set it to the current time.
		if (time === undefined) {
			time = scene.getEngine().getTime();
		}

		// Check the entities' positions and orientations every `frequency` seconds.
		return new Promise((resolve, reject) => {
			let timeSoFar = 0;
			const intervalCheck = setInterval(() => {
				// Check each entity in the list to see if is either not covered or has valid position and orientation.
				// If so, remove it from the list.
				const position = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
				const orientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
				for (const entity of entities) {
					const isInCoverage = entity.getPositionCoverage().contains(time);
					entity.getPositionAtTime(position, time);
					entity.getOrientationAtTime(orientation, time);
					const inPlace = !position.isNaN() && !orientation.isNaN();
					if (!isInCoverage || inPlace) {
						entities.delete(entity);
					}
				}
				pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
				pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
				// If there are no more entities in the list, resolve.
				if (entities.size === 0) {
					clearInterval(intervalCheck);
					resolve();
				}
				// If we've hit the timeout, reject.
				timeSoFar += frequency;
				if (timeSoFar >= timeout) {
					clearInterval(intervalCheck);
					let entitiesAsString = '';
					for (const entity of entities) {
						if (entitiesAsString !== '') {
							entitiesAsString += ', ';
						}
						entitiesAsString += '\'' + entity.getName() + '\'';
					}
					reject(new Error('Timed out (' + timeout + ' seconds) while waiting for entities to be in place. The remaining entities were [' + entitiesAsString + '].'));
				}
			}, frequency * 1000.0);
		}).then(() => scene.getEngine().waitUntilNextFrame());
	}

	/**
	 * Converts a lat, lon, alt into an xyz, with the xyz in either the standard J2000 or entity frame.
	 * @param {Pioneer.Vector3} out
	 * @param {Pioneer.Entity} entity
	 * @param {Pioneer.LatLonAlt} lla
	 * @param {boolean} inEntityFrame
	 */
	static llaToXYZ(out, entity, lla, inEntityFrame) {
		const spheroid = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent);
		if (spheroid !== null) {
			spheroid.xyzFromLLA(out, lla);
			if (!inEntityFrame) {
				out.rotate(entity.getOrientation(), out);
			}
		}
	}

	/**
	 * Converts an xyz to a lat, lon, alt, with the xyz in either the standard J2000 or entity frame.
	 * @param {Pioneer.LatLonAlt} out
	 * @param {Pioneer.Entity} entity
	 * @param {Pioneer.Vector3} xyz
	 * @param {boolean} inEntityFrame
	 */
	static xyzToLLA(out, entity, xyz, inEntityFrame) {
		const spheroid = entity.getComponentByClass(pioneer__WEBPACK_IMPORTED_MODULE_0__.SpheroidComponent);
		if (spheroid !== null) {
			const xyzInFrame = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
			if (inEntityFrame) {
				xyzInFrame.copy(xyz);
			}
			else {
				xyzInFrame.rotateInverse(entity.getOrientation(), xyz);
			}
			spheroid.llaFromXYZ(out, xyzInFrame);
			pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(xyzInFrame);
		}
	}

	/**
	 * Gets all of the other entities that the named entity is dependent upon, including all ancestors.
	 * @param {string} entityName - The name of the entity.
	 * @returns {Set<string>}
	 */
	static getDependentEntities(entityName) {
		const others = /** @type {Set<string>} */(new Set());
		this._getDependentEntitiesRecursed(entityName, others);
		others.delete(entityName);
		return others;
	}

	/**
	 * Recursive function for getDependentEntities().
	 * @param {string} entityName - The name of the entity.
	 * @param {Set<string>} others - The parents set that will be added to.
	 * @private
	 */
	static _getDependentEntitiesRecursed(entityName, others) {
		const entityOptions = _entity__WEBPACK_IMPORTED_MODULE_1__.Entity.getEntityOptions(entityName);
		if (entityOptions === undefined) {
			return;
		}
		const otherEntityNames = /** @type {Set<string>} */(new Set());
		// Get all parents.
		const parentTable = entityOptions.parents;
		for (const parentEntry of parentTable) {
			if (parentEntry[1] !== '') {
				otherEntityNames.add(parentEntry[1]);
			}
		}
		// Check for other relations.
		if (entityOptions.lightSource !== undefined) {
			otherEntityNames.add(entityOptions.lightSource);
		}
		if (entityOptions.trail !== undefined && entityOptions.trail.relativeTo !== undefined) {
			otherEntityNames.add(entityOptions.trail.relativeTo);
		}
		for (let i = 0, l = entityOptions.controllers.length; i < l; i++) {
			const controllerOptions = entityOptions.controllers[i];
			if (controllerOptions.type === 'align') {
				if (controllerOptions.primary.target !== undefined) {
					otherEntityNames.add(controllerOptions.primary.target);
				}
				if (controllerOptions.secondary !== undefined && controllerOptions.secondary.target !== undefined) {
					otherEntityNames.add(controllerOptions.secondary.target);
				}
			}
		}
		if (entityOptions.labelFadeEntity) {
			otherEntityNames.add(entityOptions.labelFadeEntity);
		}
		// Go through any other dependent entities.
		if (entityOptions.dependents) {
			for (let i = 0, l = entityOptions.dependents.length; i < l; i++) {
				otherEntityNames.add(entityOptions.dependents[i]);
			}
		}
		// Go through each entity found and recursively get its dependencies.
		for (const otherEntityName of otherEntityNames) {
			if (!others.has(otherEntityName)) {
				others.add(otherEntityName);
				this._getDependentEntitiesRecursed(otherEntityName, others);
			}
		}
	}
}

SceneHelpers.eclipJ2000ToJ2000Rotation = new pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion(0.9791532214288992, 0.2031230389823101, 0, 0);
SceneHelpers.eclipJ2000ToJ2000Rotation.freeze();


/***/ }),

/***/ "../pioneer/scripts/src/transitions.js":
/*!*********************************************!*\
  !*** ../pioneer/scripts/src/transitions.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Transitions": function() { return /* binding */ Transitions; }
/* harmony export */ });
/* harmony import */ var pioneer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pioneer */ "../pioneer/engine/src/index.js");
/** @module pioneer-scripts */


/**
 * Helpful custom transition functions to use with the Transition controller.
 * @hideconstructor
 */
class Transitions {
	/**
	 * A function which the transition controller will use that will jump from one position on a sphere to another position.
	 * It uses the z-axis for rotation. For how it works, see the bottom of the file.
	 * To use this function, do `transitionController.setTransitionFunction(jumpToLocationOnSphere.bind(undefined, 5, 1e4, true, earth))`.
	 * @param {number} jumpFactor - The height at which the camera will "bounce". A good number is 5.
	 * @param {number} radius - The "ground" radius to use when calculating the jump.
	 * @param {boolean} useNorthPole - The camera will use the north pole when rotating around its parent.
	 * @param {Pioneer.Entity} sphereEntity - The entity to use as the sphere and north pole reference. If undefined, the camera entity's parent is used.
	 * @param {Pioneer.Entity} cameraEntity - The camera entity.
	 * @param {Pioneer.Vector3} initialPosition - The initial position of the camera.
	 * @param {Pioneer.Vector3} finalPosition - The final position of the camera.
	 * @param {Pioneer.Quaternion} initialOrientation - The initial orientation of the camera.
	 * @param {Pioneer.Quaternion} finalOrientation - The final orientation of the camera.
	 * @param {number} u - The lerp parameter.
	 */
	static jumpToLocationOnSphere(jumpFactor, radius, useNorthPole, sphereEntity, cameraEntity, initialPosition, finalPosition, initialOrientation, finalOrientation, u) {
		// If the jump factor is zero, it won't work, so make it a very small number.
		if (jumpFactor <= 0) {
			jumpFactor = 0.001;
		}

		// Make the transition a little bit smoother.
		u = Transitions.easeInOut(u);

		// Get the radius of the parent of the camera entity.
		if (sphereEntity === undefined) {
			sphereEntity = cameraEntity.getParent();
		}

		// Make the initial and final position relative to the sphere entity.
		const initialPositionRel = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const finalPositionRel = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		if (cameraEntity.getParent() !== null) {
			cameraEntity.getParent().getPositionRelativeToEntity(initialPositionRel, initialPosition, sphereEntity);
			cameraEntity.getParent().getPositionRelativeToEntity(finalPositionRel, finalPosition, sphereEntity);
		}
		else {
			initialPositionRel.copy(initialPosition);
			finalPositionRel.copy(finalPosition);
		}

		// Get the radial variables that will be used in the calculations.
		const r0 = initialPositionRel.magnitude() - radius; // The radial distance of the initial position.
		const r1 = finalPositionRel.magnitude() - radius; // The radial distance of the final position.

		// Get the axis that will be used in both north pole and no-up transitions.
		const axisVec = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		if (useNorthPole && sphereEntity) {
			sphereEntity.getOrientation().getAxis(axisVec, 2);
		}
		else {
			axisVec.cross(initialPositionRel, finalPositionRel);
		}
		axisVec.normalize(axisVec);
		if (axisVec.isZero()) {
			axisVec.set(0, 0, 1);
		}

		// Get the angular distance between the points.
		let a0 = 0;
		// Get the p0 and p1 coordinates as (lon, lat, alt), but as a Vector3.
		const p0 = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const p1 = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const frame = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		frame.setFromAxis(axisVec, 2);
		p0.rotateInverse(frame, initialPositionRel);
		p1.rotateInverse(frame, finalPositionRel);
		// Get the lla0 and lla1 coordinates from the p0 and p1.
		const lla0 = pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		const lla1 = pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLLAFromXYZOnSphere(lla0, p0, 0);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Geometry.getLLAFromXYZOnSphere(lla1, p1, 0);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(p1);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(p0);
		// Get the a0 value that will be used in the _jumpOnCircle function.
		// It's a distance value based on the latitude and longitude.
		let lon0 = lla0.lon * Math.cos(lla0.lat);
		let lon1 = lla1.lon * Math.cos(lla1.lat);
		if (lon0 + Math.PI < lon1) {
			lon0 += 2.0 * Math.PI;
		}
		if (lon1 + Math.PI < lon0) {
			lon1 += 2.0 * Math.PI;
		}
		a0 = radius * jumpFactor * Math.sqrt((lon1 - lon0) * (lon1 - lon0) + (lla1.lat - lla0.lat) * (lla1.lat - lla0.lat));

		// Call the _jumpOnCircle function to get the a and r values used to set the new position.
		const p = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.get();
		Transitions._jumpOnCircle(p, a0, r0, r1, u);
		const a = p.x;
		const r = p.y;
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector2.pool.release(p);

		// Get the new position based on the new r and a.
		const newPosition = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		newPosition.normalize(initialPositionRel);
		newPosition.mult(newPosition, r + radius);
		const lla = pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.get();
		// Get a lerp value f of the angular distance.
		let f;
		if (a0 !== 0) {
			f = (a0 - a) / a0;
		}
		else {
			f = 0;
		}
		// Get the new lat, lon, alt position.
		lla.lat = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerp(lla0.lat, lla1.lat, f);
		lla.lon = pioneer__WEBPACK_IMPORTED_MODULE_0__.MathUtils.lerpAngle(lla0.lon, lla1.lon, f);
		lla.alt = r;
		// Convert it to the x, y, z position.
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Geometry.getXYZFromLLAOnSphere(newPosition, lla, radius);
		newPosition.rotate(frame, newPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla0);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.LatLonAlt.pool.release(lla1);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(frame);

		// Set the position.
		if (newPosition.isNaN()) {
			newPosition.copy(finalPositionRel);
		}
		if (cameraEntity.getParent() !== null) {
			sphereEntity.getPositionRelativeToEntity(newPosition, newPosition, cameraEntity.getParent());
		}
		cameraEntity.setPosition(newPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(newPosition);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(axisVec);

		// Make the camera always look at the parent, up aligned with the north pole axis or camera axis.
		const position = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		sphereEntity.getPositionRelativeToEntity(position, pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.Zero, cameraEntity);
		position.normalize(position);
		const up = pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.get();
		const orientation = pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.get();
		if (useNorthPole) {
			sphereEntity.getOrientation().getAxis(up, 2);
		}
		else {
			orientation.slerp(initialOrientation, finalOrientation, u);
			orientation.getAxis(up, 2);
		}
		up.setNormalTo(position, up);
		orientation.setFromAxes(undefined, position, up);
		cameraEntity.setOrientation(orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(up);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Quaternion.pool.release(orientation);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(position);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(initialPositionRel);
		pioneer__WEBPACK_IMPORTED_MODULE_0__.Vector3.pool.release(finalPositionRel);
	}

	/**
	 * Does a quadratic ease-in and ease-out of the u parameter.
	 * @param {number} u
	 * @returns {number}
	 */
	static easeInOut(u) {
		const sq = u * u;
		return sq / (2 * (sq - u) + 1);
	}

	/**
	 * Given two coordinates p0 = (a0, r0) and p1 = (0, r1), and a lerp value u, return a new coordinate (a, r) along the jump path.
	 * @param {Pioneer.Vector2} out - The result vector, x = a, y = r.
	 * @param {number} a0 - The initial angular distance.
	 * @param {number} r0 - The initial radial distance.
	 * @param {number} r1 - The final radial distance.
	 * @param {number} u - The lerp value.
	 * @private
	 */
	static _jumpOnCircle(out, a0, r0, r1, u) {
		// If the angle is not 0...
		let r = 0; // The radial distance to set.
		let a = 0; // The angular distance to set.
		if (Math.abs(a0 / (r1 - r0)) > 1e-6) {
			// Get the center angular coordinate.
			const aC = (r1 - r0) / -a0 * (r1 + r0) / 2 + a0 / 2;
			// Get the angle between aC-a0 and aC-a1
			const anglep1pcp0pc = Math.sign(a0) * Math.acos((r0 * r1 + (a0 - aC) * (-aC)) / Math.sqrt(r0 * r0 + (a0 - aC) * (a0 - aC)) / Math.sqrt(r1 * r1 + aC * aC));
			// Get the cos and sin values of u, scaled so that 0 is at p0 and 1 is at p1.
			const cosU = Math.cos(u * anglep1pcp0pc);
			const sinU = Math.sin(u * anglep1pcp0pc);
			// Calculate the new p value, going along the circle.
			r = (a0 - aC) * sinU + r0 * cosU;
			a = aC + (a0 - aC) * cosU - r0 * sinU;
		}
		// If the angle is 0, just lerp the radial and angular distance.
		else {
			r = u * r1 + (1 - u) * r0;
			a = (1 - u) * a0;
		}
		// Make it exact at the end to fix precision errors.
		if (u === 1) {
			r = r1;
			a = 0;
		}
		out.set(a, r);
	}
}

/* Notes on how _jumpOnCircle works.

The radius of the parent of the camera is R.
The initial and final positions are mapped onto cartesian plane:
	The x-axis is the angular distance between them.
	The y-axis is the radial distances of the points.
	The initial position p0 is at coordinates (a0, r0).
	The final position p1 is at coordinates (0, r1).
A line segment l is drawn from p0 to p1, and the midpoint on that line is pM.
A line lP starting from pM and perpendicular to l is drawn.
The point at which lP intersects the x-axis is pC, with coordinates (aC, 0).
A circle O is formed, with center at pC and two points on the circle, p0 and p1.
The circle O is the path along which the camera will travel.
The jumpFactor * R of the entity is multiplied to stretch out the coordinates system horizontally.

*/


/***/ }),

//JSON Modules

/***/ "./src/configs/scene_info.json":
/*!*************************************!*\
  !*** ./src/configs/scene_info.json ***!
  \*************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{\
	"zoomMax":12000000000,\
	"dynamicEntityGroups":[\
		"spacecraft"\
	],\
	"staticEntityGroups":[\
		"moons",\
		"stars",\
		"planets",\
		"dwarf planets"\
	],\
	"staticEntities":[\
		"moon",\
		"sc_osiris_rex",\
		"sc_lucy",\
		"sc_psyche",\
		"sc_deep_impact",\
		"sc_deep_impact_impactor",\
		"sc_deep_space_1",\
		"sc_near_shoemaker",\
		"sc_stardust",\
		"sc_stardust_src",\
		"sc_dawn",\
		"sc_rosetta",\
		"sc_galileo",\
		"sc_philae",\
		"sc_dart",\
		"sc_new_horizons",\
		"sc_chandra"\
	],\
	"title":{\
		"prefix":"Eyes on Asteroids",\
		"suffix":"NASA/JPL"\
	}\
}');

/***/ }),

/***/ "./src/configs/story_info.json":
/*!*************************************!*\
  !*** ./src/configs/story_info.json ***!
  \*************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('[{"title":"Asteroids 101","path":"asteroids_101","questions":["What are asteroids?","What does this app show me?"]},{"title":"Close Approaches","path":"asteroids_close_approach","questions":["What is a close approach?","Are we in danger of impact?"]},{"title":"Missions","path":"asteroids_missions","questions":["Can we visit an asteroid?","What can missions achieve?"]}]');

/***/ }),

/***/ "./src/configs/time_info.json":
/*!************************************!*\
  !*** ./src/configs/time_info.json ***!
  \************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"limits":{"min":"1990-01-01T00:00:00Z","max":"2034-01-01T00:00:00Z"}}');

/***/ }),

/***/ "./src/configs/view_info.json":
/*!************************************!*\
  !*** ./src/configs/view_info.json ***!
  \************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('[\
	{\
		"class":"HomeView",\
		"name":"home",\
		"components":[\
			"breadcrumb",\
			"clock",\
			"clockShortcut"\
		]\
	},\
	{\
		"class":"AsteroidView",\
		"name":"asteroid",\
		"components":[\
			"breadcrumb",\
			"clock",\
			"clockShortcut",\
			"asteroidPanel",\
			"loadIcon"\
		]\
	},\
	{\
		"class":"WatchView",\
		"name":"watch",\
		"components":[\
			"watchPanel",\
			"breadcrumb",\
			"clock",\
			"clockShortcut"\
		]\
	},\
	{\
		"class":"MissionView",\
		"name":"mission",\
		"components":[\
			"breadcrumb",\
			"clock",\
			"clockShortcut",\
			"missionPanel",\
			"loadIcon"\
		]\
	},\
	{\
		"class":"FollowingView",\
		"name":"following",\
		"components":[\
			"breadcrumb",\
			"clock",\
			"clockShortcut",\
			"followingPanel",\
			"loadIcon",\
			"definitionOverlay"\
		]\
	},\
	{\
		"class":"StoryView",\
		"name":"story",\
		"components":[\
			"clock",\
			"breadcrumb",\
			"story",\
			"overlay",\
			"definitionOverlay"\
		]\
	}\
]');

/***/ }),

/***/ "./src/data/definitions.json":
/*!***********************************!*\
  !*** ./src/data/definitions.json ***!
  \***********************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"asteroid":{"title":"Asteroid","html":"<div><p> Sometimes called minor planets, asteroids are rocky, airless remnants left over from the early formation of our solar system about 4.6 billion years ago.</p><p>Most of this ancient space rubble can be found orbiting the Sun between Mars and Jupiter within the main asteroid belt.</p><p>Unlike <span data-def=\\"comet\\">comets</span>, asteroids remain solid under extreme temperatures; this is due to their formation in the high heat, high density center of the solar nebula.</p><div class=\\"eyes-deepdive\\" data-storyid=\\"asteroids_101\\">Deep Dive into Asteroids 101</div></div>","related":["comet"]},"comet":{"title":"Comet","html":"<div><p>Comets are frozen leftovers from the formation of the solar system composed of dust, rock, and ice. They range from a few kilometers, to hundreds of kilometers wide.</p><p>As they orbit closer to the Sun, they heat up and spew gases and dust into a glowing head that can be larger than a planet. This material forms a tail that stretches millions of kilometers.</p><p>Unlike <span data-def=\\"asteroid\\">asteroids</span>, comets formed in areas of the solar nebula where it was cold enough for water and gases to freeze. Consequently, they are larger and rarer than asteroids, and tend to originate in the far reaches of the solar system.</p></div>","related":["asteroid"]},"neo":{"title":"NEO","html":"<div><h5>Near-Earth object</h5><p> A near-Earth object is any small solar system body whose orbit brings it within a certain distance of Earth. This distance is defined by having the closest approach to the sun, the <span data-def=\\"perihelion\\">perihelion</span>, be within 1.3 <span data-def=\\"au\\">AU</span></p><p>A sub-category of the NEO is the <span data-def=\\"pho\\">PHO</span>.</p></div>","related":["perihelion","au","pho"]},"pho":{"title":"PHO","html":"<div><h5>Potentially Hazardous Object</h5><p>To be defined as potentially hazardous, an object must be:</p><ul><li>Larger than 150 meters (almost 500 feet), roughly twice as big as the Statue of Liberty is tall.</li><li>Approach Earth\'s orbit to within about 7.5 million kilometers (4.6 million miles). This can also be expressed as having a <span data-def=\\"moid\\">MOID</span> of less than 0.05 <span data-def=\\"au\\">AU</span> (within 19.5 <span data-def=\\"ld\\">LD</span>s).</li></ul><p>PHOs can be both <span data-def=\\"asteroid\\">asteroids</span> and <span data-def=\\"comet\\">comets</span>, but the vast majority are asteroids. Learn more about the PHO, Apophis below.</p><div class=\\"eyes-deepdive\\" data-storyid=\\"asteroids_close_approach\\">Deep Dive into Close Approaches</div></div>","related":["asteroid","comet","moid","au","ld"]},"aphelion":{"title":"Aphelion","html":"<div><p>The aphelion is the point in the orbit of an object at which it is farthest from the sun.</p><p>The opposite case is called the <span data-def=\\"perihelion\\">perihelion</span>.</p></div>","related":["perihelion"]},"perihelion":{"title":"Perihelion","html":"<div><p>The perihelion is the point in the orbit of an object at which it is closest to the sun. </p><p>The opposite case is called the  <span data-def=\\"aphelion\\">aphelion</span>.</p></div>","related":["aphelion"]},"moid":{"title":"MOID","html":"<div><h5>Minimum Orbit Intersection Distance</h5><p>The MOID is the minimum distance between the orbits of two objects. It indicates the closest possible approach of two objects to each other.</p><p>For Earth, an object with a MOID of less than or equal to 0.05 <span data-def=\\"au\\">AU</span> is considered a possible <span data-def=\\"pho\\">Potentially Hazardous Object</span> if it\'s large enough.</p></div>","related":["au","pho"]},"oumuamua":{"title":"Oumuamua","html":"<div class=\\"oumuamua-animation\\"><h5>First interstellar object</h5><p>Discovered on October 19, 2017, Oumuamua is unlike any asteroid previously observed.</p><p>Although we don’t have a picture, its unusually shiny surface reflects sunlight with a variation factor of 10. This suggest a severely elongated shape, 5 to 10 times larger than its width. Along with its rapid speed and high eccentricity, it was determined to be of interstellar origin.</p><p>Passing Earth on October 14, 2017 at approximately 0.1618 <span data-def=\\"au\\">AU</span>, Oumuamua is now exiting our solar system, unlikely to ever return.</p></div>","related":["au"]},"au":{"title":"AU","html":"<div><h5>Astronomical Unit</h5><p>An AU is defined as exactly 92,955,807.273 miles (149,597,871 kilometers), or roughly the distance between the Earth and the Sun.</p><p>Jupiter orbits at about 5.2 times the Sun-Earth distance, so Jupiter’s distance from the Sun can be expressed as 5.2 AU.</p><p>1 AU is equivalent to 389,174 <span data-def=\\"ld\\">LD</span>s.</p></div>","related":["moid","ld"]},"ld":{"title":"LD","html":"<div><h5>Lunar Distance</h5><p>A lunar distance is defined exactly as 384,398 kilometers (238,854 miles); the average distance between the centers of the Earth and the Moon.</p><p>More technically, it\'s the length of the semi-major axis of the geocentric lunar orbit.</p><p>1 LD is equivalent to about 0.00257 <span data-def=\\"au\\">AU</span>.</p></div>","related":["au"]}}');

/***/ }),

/***/ "./src/data/heroes.json":
/*!******************************!*\
  !*** ./src/data/heroes.json ***!
  \******************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"99942_apophis":{"stats":{"discovery":"<p class=\'long\'>Discovered on June 19, 2004 at the Kitt Peak National Observatory in Arizona.</p>","rotation":30.4},"approach":{"fact":"<p class=\'long\'>On April 13, 2029, the asteroid Apophis will pass less than 23,239 miles (37,399 kilometers) from our planet’s surface – just outside the distance of geosynchronous satellites, and closer to Earth than any similarly sized <span class=\\"clickable underline\\" data-def=\\"pho\\">PHO</span> in recorded history. At that time, Apophis will be visible to observers on the ground in the Eastern Hemisphere without the aid of a telescope or binoculars.</p>"}},"4_vesta":{"stats":{"discovery":"<p class=\'long\'>One of the largest and earliest known asteroids, Vesta was discovered on March 29th, 1807, and was visited by the Dawn mission in 2011.</p>","rotation":5.342}},"433_eros":{"stats":{"discovery":"<p class=\'long\'>Discovered on August 13th, 1898, Eros was the first near-Earth Object (<span class=\\"clickable underline\\" data-def=\\"neo\\">NEO</span>) ever found, and the first asteroid ever orbited by a spacecraft, NEAR-Shoemaker.</p>","rotation":5.27},"approach":{"fact":"<p class=\'long\'>Eros will approach Earth within 0.39765 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span> on November 30th, 2025.</p>"}},"951_gaspra":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1916, Gaspra is the first asteroid to be closely approached by a spacecraft, which was Galileo in 1991.</p>","rotation":7.042}},"243_ida":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1884, Ida was visited by the Galileo spacecraft in August of 1993.</p>","rotation":4.634}},"81p_wild_2":{"stats":{"discovery":"<p class=\'long\'>This comet was discovered on January 6th, 1978, and was visited by the Stardust mission in January of 2004.</p>"}},"9p_tempel_1":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1867, comet Tempel 1 was the target of the Deep Impact mission, which physically collided with the comet on July 4th, 2005.</p>","rotation":40.7}},"21_lutetia":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1852, the asteroid was visited by the European space probe Rosetta in July of 2010.</p>","rotation":8.1655}},"67p_churyumov_gerasimenko":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1969, this comet was the first to be landed upon by a robotic mission from Earth, the European Space Agency\'s Rosetta mission. The Philae lander touched down in November of 2014.</p>","rotation":12.76},"approach":{"fact":"<p class=\'long\'>The comet approached Earth within 0.418 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span> on November 12th, 2021, and then will approach again in November of 2034 at a distance of 0.4523 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span>.</p>"}},"1_ceres":{"stats":{"discovery":"<p class=\'long\'>Discovered in January of 1801, Ceres was the first asteroid ever found, though it was initially classified as a planet. It remained an asteroid until 2006, when it was reclassified as a dwarf planet.</p>","rotation":9.0741}},"101955_bennu":{"stats":{"discovery":"<p class=\'long\'>Discovered in September of 1999, Bennu was the subject of the OSIRIS-REx mission, which touched down on the asteroid and collected a sample of the surface on October 20th, 2020. OSIRIS-REx departed Bennu in 2021, and delivered the capsule with pieces of the asteroid to Earth on September 24, 2023.</p>","rotation":4.296},"approach":{"fact":"<p class=\'long\'>Bennu is a <span class=\\"clickable underline\\" data-def=\\"pho\\">PHO</span>, and will have multiple close approaches with Earth over time. The next close approach will be in 2023, at a distance of 0.497 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span></p>"}},"103p_hartley_2":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1986, Comet Hartley 2 was the target of the Deep Impact/EPOXI mission, which flew by in November of 2010.</p>","rotation":18.1},"approach":{"fact":"<p class=\'long\'>103p/Hartley 2 is classified as an <span class=\\"clickable underline\\" data-def=\\"neo\\">NEO</span>, and will approach Earth within 0.3826 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span> on September 26th, 2023.</p>"}},"25143_itokawa":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1998, Itokawa was the first asteroid to be the target of a sample return mission. The Japanese space probe Hayabusa took a sample from the comet in November of 2005.</p>","rotation":12.132},"approach":{"fact":"<p class=\'long\'>Itokawa is classified as a <span class=\\"clickable underline\\" data-def=\\"pho\\">PHO</span>, and will next approach the Earth on March 6th, 2030, at a distance of 0.376 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span>.</p>"}},"16_psyche":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1852, the Psyche asteroid is the subject of the upcoming Psyche mission which will launch no earlier than 2023.</p>","rotation":4.196}},"65803_didymos":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1996, Didymos is part of a binary asteroid system with its smaller partner, Dimorphos. The DART mission targeted this system, successfully crashing a probe into Dimorphos on September 26th, 2022.</p>","rotation":2.2593},"approach":{"fact":"<p class=\'long\'>Didymos is a <span class=\\"clickable underline\\" data-def=\\"pho\\">PHO</span>, and approached Earth at a distance of 0.07123 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span> on October 4th, 2022.</p>"}},"dimorphos":{"stats":{"discovery":"<p class=\'long\'>First observed in 2003 (7 years after the discovery of Didymos), Dimorphos is the smaller twin of the Didymos binary asteroid system. The DART mission intentionally crashed into Dimorphos on September 26th, 2022, and successfully altered its orbit.</p>","rotation":11.92},"approach":{"fact":"<p class=\'long\'>Dimorphos and its binary system are classifed as a <span class=\\"clickable underline\\" data-def=\\"pho\\">PHO</span>, and approached Earth at a distance of 0.07123 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span> on October 4th, 2022.</p>"}},"52246_donaldjohanson":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1981, and named after the paleoanthropologist who discovered the \\"Lucy\\" fossil, this will be the second small body that the Lucy mission will encounter in 2025.</p>","rotation":252}},"3548_eurybates":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1973, Eurybates is the first Trojan Asteroid that the Lucy mission will visit in August of 2027. It has a small satellite named Queta.</p>","rotation":8.7}},"15094_polymele":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1999, Polymele is a Trojan Asteroid that will be visited by the Lucy mission in September of 2027.</p>","rotation":5.86}},"11351_leucus":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1997, Leucus is a Trojan Asteroid that will be visited by the Lucy mission in April of 2028.</p>","rotation":445.73}},"21900_orus":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1999, Orus is a Trojan Asteroid that will be visited by the Lucy mission in November of 2028.</p>","rotation":13.45}},"617_patroclus":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1906, Patroclus is a Trojan Asteroid that will be visited by the Lucy mission in 2033. In 2001, Patroclus was found to be part of a binary asteroid system with its smaller twin, named Menoetius.</p>","rotation":102.8}},"19p_borrelly":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1904, comet Borrelly was the target of the Deep Space 1 mission, which flew by in September of 2001.</p>"}},"5535_annefrank":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1942, the main belt asteroid 5535 Annefrank was used as a practice flyby target by the Stardust mission on November 2nd, 2002.</p>","rotation":15.12}},"9969_braille":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1992, Braille was visited by the Deep Space 1 mission on July 29th, 1999. The spacecraft passed within 26 km (16 miles) of the asteroid, which was the closest asteroid flyby ever at that time.</p>","rotation":226.4}},"162173_ryugu":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1999, Ryugu was the target of the Hayabusa2 mission, which orbited the asteroid for a year and a half, landed small rovers on it, and collected samples that were returned to Earth in December of 2020.</p>","rotation":7.63},"approach":{"fact":"<p class=\'long\'>Ryugu is a <span class=\\"clickable underline\\" data-def=\\"pho\\">PHO</span>, and will next approach Earth at a distance of 0.373 <span class=\\"clickable underline\\" data-def=\\"au\\">AU</span>s on June 3rd, 2025.</p>"}},"152830_dinkinesh":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1999, Dinkinesh will be the Lucy mission\'s first flyby target in early November of 2023. It will become the smallest main-belt asteroid ever visited.</p>"}},"73p_schwassmann_wachmann_3":{"stats":{"discovery":"<p class=\'long\'>Discovered in 1930, 73P/Schwassmann-Wachmann 3 is a periodic comet that began to disintegrate as it approached the sun in 1995. Initially, it split into four distinct fragments, but later further split into more than sixty pieces.</p>"},"category":"Comet","id":"73p_schwassmann_wachmann_3","iauName":"73P/Schwassmann Wachmann 3","displayName":"Schwassmann Wachmann 3"}}');

/***/ }),

/***/ "./src/data/stories/story_list.json":
/*!******************************************!*\
  !*** ./src/data/stories/story_list.json ***!
  \******************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"stories":{"asteroids_101":{"id":"asteroids_101","title":"Asteroids 101"},"asteroids_close_approach":{"id":"asteroids_close_approach","title":"What is a Close Approach?"},"asteroids_missions":{"id":"asteroids_missions","title":"Asteroid and Comet Missions"}},"external":{},"featured":[]}');

/***/ }),

/***/ "./src/data/tutorials.json":
/*!*********************************!*\
  !*** ./src/data/tutorials.json ***!
  \*********************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('[{"id":"intro","title":"<small>Welcome to</small><br>Eyes on Asteroids!","description":"You are looking at a real-time visualization of every known <span class=\'clickable underline\' data-def=\'asteroid\'>asteroid</span> or <span class=\'clickable underline\' data-def=\'comet\'>comet</span> that is classified as a <span class=\'clickable underline\' data-def=\'neo\'>Near-Earth Object (NEO)</span>.<br class=big-br>With asteroids represented as blue points, and comets as white points, our database is updated daily to give you approximately {{getNeoTotal}} NEOs (and counting). Additionally, you can explore most of NASA\'s asteroid and comet missions (past and present), from Galileo, to Lucy and DART.","extra":"<h5>Extra fact:</h5><p>Farther from Earth, the full asteroid belt contains over a million members, with the majority lying between Mars and Jupiter.</p>"},{"id":"nav3d","title":"Navigate 3D like an Expert","description":{"touch":"One finger controls your orbit in all directions. Pinch zoom for close inspection, large-scale overviews, and everything in-between.","desktop":"Left mouse click-and-drag controls your orbit in all directions. Scroll zoom for close inspection, macro overviews, and everything in-between."},"extra":{"desktop":"<h5>Secret tip:</h5><p>Use the \'A\', \'S\', \'D\', \'W\', \'Z\', and \'C\' keys only if you\'re a true expert. Hold the \'shift\' key to move even faster. </p>"},"targetSelector":"#pioneer","mask":{"xSizeMult":0.6,"ySizeMult":0.25}},{"id":"labels","title":"Info on the Fly","description":"Select any label or icon in the 3D screen to fly to it and bring up an information panel.","extra":"<h5>Don\'t get lost:</h5><p>The top-left NASA logo or \'See all asteroids\' button will always take you back home.</p>","targetSelector":"#pioneer","mask":{"xSizeMult":0.6,"ySizeMult":0.25}},{"id":"time","title":"<small>From 1990 to 2033</small><br>You Control Time.","description":"Drag the time slider left to go backwards, or right to go forwards in time. The LIVE button will always return you to the present time.","extra":"<h5>A little trick:</h5><p>To go even faster, zoom out and try again.</p>","targetSelector":"#time-slider-container"},{"id":"learn","title":"Learn by Scrolling","description":"Select \'Learn\' to access three different scrollable stories about asteroids and comets, including a tour through NASA\'s historic missions.","targetSelector":"nav.navigation div:nth-child(1).clickable button","mask":{"xSizeMult":0.7,"ySizeMult":0.7}},{"id":"watch","title":"Keep an Eye Out!","description":"Select the \'Asteroid Watch\' option to see the next five closest approaches to Earth, complete with a countdown.","extra":"<h5>Hint:</h5><p>Don\'t forget to play with that time slider!</p>","targetSelector":"nav.navigation div:nth-child(2).clickable button","mask":{"xSizeMult":0.7,"ySizeMult":0.7}},{"id":"filters","title":"Filter your View","description":"Select \'Filters\' to see just the comets, or just the asteroids, or just the <span class=\'clickable underline\' data-def=\'pho\'>Potentially Hazardous Objects (PHOs)</span>.","targetSelector":"nav.navigation div:nth-child(3).clickable button","mask":{"xSizeMult":0.7,"ySizeMult":0.7}},{"id":"search","title":"Looking for Something?","description":"Type it in the search bar to look through our entire NEO database.","targetSelector":".search>span.icon-search","mask":{"xSizeMult":0.5,"ySizeMult":0.5}},{"id":"settings","title":"Fine Tuning","description":"Use the settings menu to toggle display layers, incrementally zoom, change the lighting when the sun is not enough, and go full-screen.","alternateDescription":"Use the settings menu to toggle display layers, incrementally zoom, and change the lighting when the sun is not enough.","extra":"<h5>Just in case:</h5><p>The info icon will take you back here if you ever need a recap.</p>","targetSelector":"div.settings","mask":{"xSizeMult":0.5}},{"id":"complete","title":"Dare Mighty Things","description":"You are now armed with all the knowledge to explore Eyes on Asteroids like a pro. Happy Learning!","extra":"<h5>One last secret:</h5><p>Watch out for any underlined text; it may lead you down a rabbit hole of space knowledge...</p>"}]');

/***/ }),

/***/ "../eyes/src/data/entity_info.json":
/*!*****************************************!*\
  !*** ../eyes/src/data/entity_info.json ***!
  !*** copied to ./entity_info.json		 ***!
  \*****************************************/
/***/ (function(module) {

"use strict";
module.exports = JSON.parse('{"observable_universe":{"id":"observable_universe","displayName":"Observable universe","category":"Universe","searchable":false},"milky_way":{"id":"milky_way","displayName":"Milky way","category":"Galaxy","searchable":false},"sun":{"id":"sun","iauName":"Sun","category":"Star","subcategory":"Yellow Dwarf Star","planeEntity":"earth","keywords":["star","solar system"]},"mercury":{"id":"mercury","iauName":"Mercury","category":"Planet","subcategory":"Terrestrial","keywords":["terrestrial planet","solar system","planets"]},"venus":{"id":"venus","iauName":"Venus","category":"Planet","subcategory":"Terrestrial","keywords":["terrestrial planet","solar system","planets"]},"earth":{"id":"earth","iauName":"Earth","category":"Planet","subcategory":"Terrestrial","hasMoons":true,"planeEntity":"moon","keywords":["terrestrial planet","solar system","planets"]},"mars":{"id":"mars","iauName":"Mars","category":"Planet","subcategory":"Terrestrial","hasMoons":true,"keywords":["terrestrial planet","solar system","planets"]},"jupiter":{"id":"jupiter","iauName":"Jupiter","category":"Planet","subcategory":"Gas Giant","hasMoons":true,"keywords":["gas giant","solar system","planets"]},"saturn":{"id":"saturn","iauName":"Saturn","category":"Planet","subcategory":"Gas Giant","hasMoons":true,"keywords":["gas giant","solar system","planets"]},"neptune":{"id":"neptune","iauName":"Neptune","category":"Planet","subcategory":"Ice Giant","hasMoons":true,"keywords":["ice giant","solar system","planets"]},"uranus":{"id":"uranus","iauName":"Uranus","category":"Planet","subcategory":"Ice Giant","hasMoons":true,"keywords":["gas giant","solar system","planets","1781"]},"134340_pluto":{"id":"134340_pluto","iauName":"134340 Pluto","displayName":"Pluto","category":"Dwarf Planet","keywords":["dwarf planet","solar system","dwarf planet","trans-neptunian object","plutoid","kuiper belt object","plutino","synchronous","1930"]},"134340_pluto_barycenter":{"id":"134340_pluto_barycenter","displayName":"Pluto system","hasMoons":true,"comparisonFeature":false,"category":"Dwarf Planet","subcategory":"Barycenter","planeEntity":"134340_pluto","forceVisibleEntities":["134340_pluto"],"keywords":["barycenter"]},"617_patroclus_barycenter":{"id":"617_patroclus_barycenter","displayName":"Patroclus barycenter","category":"Asteroid","subcategory":"Barycenter","comparisonFeature":false,"forceVisibleEntities":["617_patroclus","menoetius"]},"21_lutetia":{"id":"21_lutetia","iauName":"21 Lutetia","displayName":"Lutetia","category":"Asteroid","keywords":["asteroid","asteroids","Rosetta"]},"253_mathilde":{"id":"253_mathilde","iauName":"253 Mathilde","displayName":"Mathilde","category":"Asteroid","keywords":["asteroid","asteroids"]},"11351_leucus":{"id":"11351_leucus","iauName":"11351 Leucus","displayName":"Leucus","category":"Asteroid","keywords":["asteroid","asteroids"]},"15094_polymele":{"id":"15094_polymele","iauName":"15094 Polymele","displayName":"Polymele","category":"Asteroid","keywords":["asteroid","asteroids"]},"21900_orus":{"id":"21900_orus","iauName":"21900 Orus","displayName":"Orus","category":"Asteroid","keywords":["asteroid","asteroids"]},"3548_eurybates":{"id":"3548_eurybates","iauName":"3548 Eurybates","displayName":"Eurybates","category":"Asteroid","keywords":["asteroid","asteroids"]},"5535_annefrank":{"id":"5535_annefrank","iauName":"5535 Annefrank","displayName":"Annefrank","category":"Asteroid","keywords":["asteroid","asteroids"]},"52246_donaldjohanson":{"id":"52246_donaldjohanson","iauName":"52246 Donaldjohanson","displayName":"Donaldjohanson","category":"Asteroid","keywords":["asteroid","asteroids"]},"617_patroclus":{"id":"617_patroclus","iauName":"617 Patroclus","displayName":"Patroclus","category":"Asteroid","keywords":["asteroid","asteroids"]},"951_gaspra":{"id":"951_gaspra","iauName":"951 Gaspra","displayName":"Gaspra","category":"Asteroid","keywords":["asteroid","asteroids"]},"2867_steins":{"id":"2867_steins","iauName":"2867 Steins","displayName":"Steins","category":"Asteroid","keywords":["asteroid","asteroids"]},"ariel":{"id":"ariel","iauName":"Ariel","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1851"]},"90377_sedna":{"id":"90377_sedna","iauName":"90377 Sedna","displayName":"Sedna","category":"Dwarf Planet","keywords":["dwarf planet","asteroids"]},"99942_apophis":{"id":"99942_apophis","iauName":"99942 Apophis","displayName":"Apophis","category":"Asteroid","keywords":["asteroid","asteroids"]},"486958_arrokoth":{"id":"486958_arrokoth","iauName":"486958 Arrokoth","displayName":"Arrokoth","category":"Asteroid","subcategory":"Kuiper Belt Object","keywords":["mu69","asteroid","asteroids","tno","cubewano","distant minor planet","pt1","1110113y","ultima thule","2014","kuiper belt object"]},"101955_bennu":{"id":"101955_bennu","iauName":"101955 Bennu","displayName":"Bennu","category":"Asteroid","subcategory":"B-Type Asteroid","keywords":["asteroid","asteroids","apollo","neo","pha","1999 rq36","1999","b-type"]},"152830_dinkinesh":{"id":"152830_dinkinesh","iauName":"152830 Dinkinesh","displayName":"Dinkinesh","category":"Asteroid","keywords":["asteroid","asteroids"]},"16_psyche":{"id":"16_psyche","iauName":"16 Psyche","displayName":"16 Psyche","category":"Asteroid","subcategory":"M-Type Asteroid","keywords":["asteroid","asteroids","m-type"]},"1_ceres":{"id":"1_ceres","iauName":"1 Ceres","displayName":"Ceres","category":"Dwarf Planet","keywords":["dwarf planet","asteroids","asteroid belt","a899 of","1943 xb","1801"]},"2_pallas":{"id":"2_pallas","iauName":"2 Pallas","displayName":"Pallas","category":"Asteroid","keywords":["asteroid","asteroids"]},"3_juno":{"id":"3_juno","iauName":"3 Juno","displayName":"Juno","category":"Asteroid","keywords":["asteroid","asteroids"]},"216_kleopatra":{"id":"216_kleopatra","iauName":"216 Kleopatra","displayName":"Kleopatra","category":"Asteroid","keywords":["asteroid","asteroids"]},"243_ida":{"id":"243_ida","iauName":"243 Ida","displayName":"Ida","category":"Asteroid","keywords":["asteroid","asteroids"],"hasMoons":true},"1566_icarus":{"id":"1566_icarus","iauName":"1566 Icarus","displayName":"Icarus","category":"Asteroid","keywords":["asteroid","asteroids"]},"1620_geographos":{"id":"1620_geographos","iauName":"1620 Geographos","displayName":"Geographos","category":"Asteroid","keywords":["asteroid","asteroids"]},"1862_apollo":{"id":"1862_apollo","iauName":"1862 Apollo","displayName":"Apollo","category":"Asteroid","keywords":["asteroid","asteroids"]},"1981_midas":{"id":"1981_midas","iauName":"1981 Midas","displayName":"Midas","category":"Asteroid","keywords":["asteroid","asteroids"]},"2063_bacchus":{"id":"2063_bacchus","iauName":"2063 Bacchus","displayName":"Bacchus","category":"Asteroid","keywords":["asteroid","asteroids"]},"2101_adonis":{"id":"2101_adonis","iauName":"2101 Adonis","displayName":"Adonis","category":"Asteroid","keywords":["asteroid","asteroids"]},"2102_tantalus":{"id":"2102_tantalus","iauName":"2102 Tantalus","displayName":"Tantalus","category":"Asteroid","keywords":["asteroid","asteroids"]},"2135_aristaeus":{"id":"2135_aristaeus","iauName":"2135 Aristaeus","displayName":"Aristaeus","category":"Asteroid","keywords":["asteroid","asteroids"]},"2340_hathor":{"id":"2340_hathor","iauName":"2340 Hathor","displayName":"Hathor","category":"Asteroid","keywords":["asteroid","asteroids"]},"3122_florence":{"id":"3122_florence","iauName":"3122 Florence","displayName":"Florence","category":"Asteroid","keywords":["asteroid","asteroids"]},"3200_phaethon":{"id":"3200_phaethon","iauName":"3200 Phaethon","displayName":"Phaethon","category":"Asteroid","keywords":["asteroid","asteroids"]},"3362_khufu":{"id":"3362_khufu","iauName":"3362 Khufu","displayName":"Khufu","category":"Asteroid","keywords":["asteroid","asteroids"]},"4015_wilson-harrington":{"id":"4015_wilson-harrington","iauName":"4015 Wilson-Harrington","displayName":"Wilson-Harrington","category":"Asteroid","keywords":["asteroid","asteroids"]},"4179_toutatis":{"id":"4179_toutatis","iauName":"4179 Toutatis","displayName":"Toutatis","category":"Asteroid","keywords":["asteroid","asteroids"]},"4183_cuno":{"id":"4183_cuno","iauName":"4183 Cuno","displayName":"Cuno","category":"Asteroid","keywords":["asteroid","asteroids"]},"4450_pan":{"id":"4450_pan","iauName":"4450 Pan","displayName":"Pan","category":"Asteroid","keywords":["asteroid","asteroids","minor moon","saturn"]},"4486_mithra":{"id":"4486_mithra","iauName":"4486 Mithra","displayName":"Mithra","category":"Asteroid","keywords":["asteroid","asteroids"]},"4769_castalia":{"id":"4769_castalia","iauName":"4769 Castalia","displayName":"Castalia","category":"Asteroid","keywords":["asteroid","asteroids"]},"5011_ptah":{"id":"5011_ptah","iauName":"5011 Ptah","displayName":"Ptah","category":"Asteroid","keywords":["asteroid","asteroids"]},"6239_minos":{"id":"6239_minos","iauName":"6239 Minos","displayName":"Minos","category":"Asteroid","keywords":["asteroid","asteroids"]},"6489_golevka":{"id":"6489_golevka","iauName":"6489 Golevka","displayName":"Golevka","category":"Asteroid","keywords":["asteroid","asteroids"]},"9969_braille":{"id":"9969_braille","iauName":"9969 Braille","displayName":"Braille","category":"Asteroid","keywords":["asteroid","asteroids"]},"12923_zephyr":{"id":"12923_zephyr","iauName":"12923 Zephyr","displayName":"Zephyr","category":"Asteroid","keywords":["asteroid","asteroids"]},"14827_hypnos":{"id":"14827_hypnos","iauName":"14827 Hypnos","displayName":"Hypnos","category":"Asteroid","keywords":["asteroid","asteroids"]},"25143_itokawa":{"id":"25143_itokawa","iauName":"25143 Itokawa","displayName":"Itokawa","category":"Asteroid","keywords":["asteroid","asteroids"]},"37655_illapa":{"id":"37655_illapa","iauName":"37655 Illapa","displayName":"Illapa","category":"Asteroid","keywords":["asteroid","asteroids"]},"65803_didymos":{"id":"65803_didymos","iauName":"65803 Didymos","displayName":"Didymos","category":"Asteroid","keywords":["asteroid","asteroids"],"hasMoons":true},"69230_hermes":{"id":"69230_hermes","iauName":"69230 Hermes","displayName":"Hermes","category":"Asteroid","keywords":["asteroid","asteroids"]},"136199_eris":{"id":"136199_eris","iauName":"136199 Eris","displayName":"Eris","category":"Dwarf Planet","keywords":["asteroid","asteroids","dwarf planet","tno","plutoid","sdo","binary","dysnomia","2005"]},"136108_haumea":{"id":"136108_haumea","iauName":"136108 Haumea","displayName":"Haumea","category":"Dwarf Planet","keywords":["asteroid","asteroids","dwarf planet","plutoid","tno","cubewano","trinary","2003 el61","2004"],"hasMoons":true},"136472_makemake":{"id":"136472_makemake","iauName":"136472 Makemake","displayName":"Makemake","category":"Dwarf Planet","keywords":["asteroid","asteroids","dwarf planet","cubewano","scattered-near","kuiper belt","2005 fy9","2005"]},"162173_ryugu":{"id":"162173_ryugu","iauName":"162173 Ryugu","displayName":"Ryugu","category":"Asteroid","keywords":["asteroid","asteroids","neo","pha","b-type","c-type"]},"4_vesta":{"id":"4_vesta","iauName":"4 Vesta","displayName":"Vesta","category":"Asteroid","subcategory":"Protoplanet","keywords":["asteroid","asteroids","main belt","vesta family","1807","protoplanet"]},"433_eros":{"id":"433_eros","iauName":"433 Eros","displayName":"Eros","category":"Asteroid","subcategory":"S-Type Asteroid","keywords":["asteroid","asteroids","neo","1898","prograde"]},"callisto":{"id":"callisto","iauName":"Callisto","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"]},"sc_chandra":{"id":"sc_chandra","iauName":"Chandra X-ray Observatory","category":"Spacecraft","subcategory":"Orbiter","keywords":["telescope","orbiter","earth","Columbia","X-ray","astrophysics"]},"charon":{"id":"charon","iauName":"Charon","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons","prograde","synchronous","1978"]},"67p_churyumov_gerasimenko":{"id":"67p_churyumov_gerasimenko","iauName":"67P/Churyumov-Gerasimenko","displayName":"67P/Churyumov-Gerasimenko","category":"Comet","subcategory":"Short-Period Comet","keywords":["comet","comets","jupiter-family","1969 r1","1969 iv","1969h","1975 p1","1976 vii","1975i","1982 viii","1982f","1989 vi","1988i","1969","chury","short-period"]},"1p_halley":{"id":"1p_halley","iauName":"1P/Halley","displayName":"Halley","category":"Comet","subcategory":"Short-Period Comet","keywords":["comet","comets","short-period","1p/halley"]},"103p_hartley_2":{"id":"103p_hartley_2","iauName":"103P/Hartley","displayName":"Hartley 2","category":"Comet","keywords":["comet"]},"1i_oumuamua":{"id":"1i_oumuamua","iauName":"1I/\'Oumuamua","displayName":"Oumuamua","category":"Comet","keywords":["comet","comets","1i/oumuamua"]},"9p_tempel_1":{"id":"9p_tempel_1","iauName":"9P/Tempel 1","displayName":"Tempel 1","category":"Comet","subcategory":"Jupiter-Family Comet","keywords":["comet","comets","periodic","jupiter-family","9p/tempel","1867"]},"19p_borrelly":{"id":"19p_borrelly","iauName":"19P/Borrelly","displayName":"Borrelly","category":"Comet","subcategory":"Jupiter-Family Comet","keywords":["comet","comets","periodic","jupiter-family","19p/borrelly","Deep Space 1"]},"81p_wild_2":{"id":"81p_wild_2","iauName":"81P/Wild 2","displayName":"Wild 2","category":"Comet","subcategory":"Short-Period Comet","keywords":["comet","comets","81p/wild","1978 xi","1984 xiv","1990 xxviii","1978"]},"adrastea":{"id":"adrastea","iauName":"Adrastea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"aegaeon":{"id":"aegaeon","iauName":"Aegaeon","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"aegir":{"id":"aegir","iauName":"Aegir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"aitne":{"id":"aitne","iauName":"Aitne","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"albiorix":{"id":"albiorix","iauName":"Albiorix","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"amalthea":{"id":"amalthea","iauName":"Amalthea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"ananke":{"id":"ananke","iauName":"Ananke","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"anthe":{"id":"anthe","iauName":"Anthe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"aoede":{"id":"aoede","iauName":"Aoede","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"arche":{"id":"arche","iauName":"Arche","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"atlas":{"id":"atlas","iauName":"Atlas","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"autonoe":{"id":"autonoe","iauName":"Autonoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"bebhionn":{"id":"bebhionn","iauName":"Bebhionn","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"belinda":{"id":"belinda","iauName":"Belinda","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"bergelmir":{"id":"bergelmir","iauName":"Bergelmir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"bestla":{"id":"bestla","iauName":"Bestla","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"bianca":{"id":"bianca","iauName":"Bianca","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"c_2010_x1":{"id":"c_2010_x1","iauName":"C/2010 X1","displayName":"Elenin","category":"Comet","keywords":["comet"]},"c_2012_s1":{"id":"c_2012_s1","iauName":"C/2012 S1","displayName":"ISON","category":"Comet","keywords":["comet"]},"caliban":{"id":"caliban","iauName":"Caliban","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"callirrhoe":{"id":"callirrhoe","iauName":"Callirrhoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"calypso":{"id":"calypso","iauName":"Calypso","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"carme":{"id":"carme","iauName":"Carme","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"carpo":{"id":"carpo","iauName":"Carpo","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"chaldene":{"id":"chaldene","iauName":"Chaldene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"cordelia":{"id":"cordelia","iauName":"Cordelia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"cressida":{"id":"cressida","iauName":"Cressida","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"cupid":{"id":"cupid","iauName":"Cupid","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"cyllene":{"id":"cyllene","iauName":"Cyllene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"dactyl":{"id":"dactyl","iauName":"243 Ida I Dactyl","displayName":"Dactyl","category":"Moon","subcategory":"Major Moon","keywords":["asteroid","minor moon","ida"]},"daphnis":{"id":"daphnis","iauName":"Daphnis","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"deimos":{"id":"deimos","iauName":"Deimos","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","mars","moons","synchronous","1877"]},"desdemona":{"id":"desdemona","iauName":"Desdemona","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"despina":{"id":"despina","iauName":"Despina","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"dia":{"id":"dia","iauName":"Dia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"dimorphos":{"id":"dimorphos","iauName":"Dimorphos","category":"Moon","subcategory":"Major Moon","keywords":["minor moon","solar system","65803 Didymos","asteroid"]},"dione":{"id":"dione","iauName":"Dione","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1684"]},"sc_dscovr":{"id":"sc_dscovr","iauName":"DSCOVR","category":"Spacecraft","subcategory":"Orbiter","keywords":["earth","orbiter","Deep Space Climate Observatory"]},"eirene":{"id":"eirene","iauName":"Eirene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"elara":{"id":"elara","iauName":"Elara","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"enceladus":{"id":"enceladus","iauName":"Enceladus","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1789"]},"epimetheus":{"id":"epimetheus","iauName":"Epimetheus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"erinome":{"id":"erinome","iauName":"Erinome","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"erriapus":{"id":"erriapus","iauName":"Erriapus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"ersa":{"id":"ersa","iauName":"Ersa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"euanthe":{"id":"euanthe","iauName":"Euanthe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"eukelade":{"id":"eukelade","iauName":"Eukelade","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"eupheme":{"id":"eupheme","iauName":"Eupheme","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"euporie":{"id":"euporie","iauName":"Euporie","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"europa":{"id":"europa","iauName":"Europa","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"],"ignoreDependentWhenUnloading":["sc_juno"]},"eurydome":{"id":"eurydome","iauName":"Eurydome","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"farbauti":{"id":"farbauti","iauName":"Farbauti","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"fenrir":{"id":"fenrir","iauName":"Fenrir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"galatea":{"id":"galatea","iauName":"Galatea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"ganymede":{"id":"ganymede","iauName":"Ganymede","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"],"ignoreDependentWhenUnloading":["sc_juno"]},"greip":{"id":"greip","iauName":"Greip","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"c_1995_o1":{"id":"c_1995_o1","iauName":"C/1995 O1","displayName":"Hale-Bopp","category":"Comet","subcategory":"Long-Period Comet","keywords":["comet","solar system","The Great Comet of 1997","C/1995 O1","1995"]},"ferdinand":{"id":"ferdinand","iauName":"Ferdinand","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"fornjot":{"id":"fornjot","iauName":"Fornjot","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"francisco":{"id":"francisco","iauName":"Francisco","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"halimede":{"id":"halimede","iauName":"Halimede","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"harpalyke":{"id":"harpalyke","iauName":"Harpalyke","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hati":{"id":"hati","iauName":"Hati","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"hegemone":{"id":"hegemone","iauName":"Hegemone","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"helene":{"id":"helene","iauName":"Helene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"helike":{"id":"helike","iauName":"Helike","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hermippe":{"id":"hermippe","iauName":"Hermippe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"herse":{"id":"herse","iauName":"Herse","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hiiaka":{"id":"hiiaka","iauName":"Hi\'iaka","displayName":"Hi\'iaka","category":"Moon","subcategory":"Major Moon","keywords":["asteroid","minor moon","haumea"]},"himalia":{"id":"himalia","iauName":"Himalia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"hippocamp":{"id":"hippocamp","iauName":"Hippocamp","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"hydra":{"id":"hydra","iauName":"Hydra","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons","outer moons"]},"hyperion":{"id":"hyperion","iauName":"Hyperion","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","outer moons","prograde","1848"]},"hyrrokkin":{"id":"hyrrokkin","iauName":"Hyrrokkin","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"iapetus":{"id":"iapetus","iauName":"Iapetus","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","outer moons","prograde","synchronous","1671"]},"io":{"id":"io","iauName":"Io","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","jupiter","moons","main group","galilean moons","prograde","synchronous","1610"],"ignoreDependentWhenUnloading":["sc_juno"]},"ijiraq":{"id":"ijiraq","iauName":"Ijiraq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"iocaste":{"id":"iocaste","iauName":"Iocaste","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"isonoe":{"id":"isonoe","iauName":"Isonoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"janus":{"id":"janus","iauName":"Janus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"jarnsaxa":{"id":"jarnsaxa","iauName":"Jarnsaxa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"juliet":{"id":"juliet","iauName":"Juliet","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"jupiter_li":{"id":"jupiter_li","iauName":"Jupiter LI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lii":{"id":"jupiter_lii","iauName":"Jupiter LII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_liv":{"id":"jupiter_liv","iauName":"Jupiter LIV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lix":{"id":"jupiter_lix","iauName":"Jupiter LIX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lv":{"id":"jupiter_lv","iauName":"Jupiter LV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lvi":{"id":"jupiter_lvi","iauName":"Jupiter LVI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxi":{"id":"jupiter_lxi","iauName":"Jupiter LXI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxiii":{"id":"jupiter_lxiii","iauName":"Jupiter LXIII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxiv":{"id":"jupiter_lxiv","iauName":"Jupiter LXIV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxix":{"id":"jupiter_lxix","iauName":"Jupiter LXIX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxvi":{"id":"jupiter_lxvi","iauName":"Jupiter LXVI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxvii":{"id":"jupiter_lxvii","iauName":"Jupiter LXVI","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxviii":{"id":"jupiter_lxviii","iauName":"Jupiter LXVIII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxx":{"id":"jupiter_lxx","iauName":"Jupiter LXX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"jupiter_lxxii":{"id":"jupiter_lxxii","iauName":"Jupiter LXXII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kale":{"id":"kale","iauName":"Kale","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kallichore":{"id":"kallichore","iauName":"Kallichore","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kalyke":{"id":"kalyke","iauName":"Kalyke","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"kari":{"id":"kari","iauName":"Kari","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"kerberos":{"id":"kerberos","iauName":"Kerberos","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons"]},"kiviuq":{"id":"kiviuq","iauName":"Kiviuq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"kore":{"id":"kore","iauName":"Kore","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"laomedeia":{"id":"laomedeia","iauName":"Laomedeia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"larissa":{"id":"larissa","iauName":"Larissa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"leda":{"id":"leda","iauName":"Leda","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"loge":{"id":"loge","iauName":"Loge","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"lysithea":{"id":"lysithea","iauName":"Lysithea","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"mab":{"id":"mab","iauName":"Mab","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"margaret":{"id":"margaret","iauName":"Margaret","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"megaclite":{"id":"megaclite","iauName":"Megaclite","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons","jupiter xix","S/2000 J 8"]},"menoetius":{"id":"menoetius","iauName":"Menoetius","displayName":"Menoetius","category":"Asteroid","keywords":["asteroid","asteroids","solar system","617 Patroclus"]},"methone":{"id":"methone","iauName":"Methone","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"metis":{"id":"metis","iauName":"Metis","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"mimas":{"id":"mimas","iauName":"Mimas","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1789","death star"]},"miranda":{"id":"miranda","iauName":"Miranda","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1948"]},"mneme":{"id":"mneme","iauName":"Mneme","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"moon":{"id":"moon","iauName":"Moon","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","earth","moons","synchronous"]},"mundilfari":{"id":"mundilfari","iauName":"Mundilfari","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"naiad":{"id":"naiad","iauName":"Naiad","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"namaka":{"id":"namaka","iauName":"Namaka","displayName":"Namaka","category":"Moon","subcategory":"Major Moon","keywords":["asteroid","minor moon","haumea"]},"narvi":{"id":"narvi","iauName":"Narvi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"nix":{"id":"nix","iauName":"Nix","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons"]},"nereid":{"id":"nereid","iauName":"Nereid","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons","irregular moons","prograde","1949"]},"neso":{"id":"neso","iauName":"Neso","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"oberon":{"id":"oberon","iauName":"Oberon","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1787"]},"ophelia":{"id":"ophelia","iauName":"Ophelia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"orthosie":{"id":"orthosie","iauName":"Orthosie","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"paaliaq":{"id":"paaliaq","iauName":"Paaliaq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pallene":{"id":"pallene","iauName":"Pallene","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pan":{"id":"pan","iauName":"Pan","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pandia":{"id":"pandia","iauName":"Pandia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"pandora":{"id":"pandora","iauName":"Pandora","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"pasiphae":{"id":"pasiphae","iauName":"Pasiphae","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"pasithee":{"id":"pasithee","iauName":"Pasithee","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"perdita":{"id":"perdita","iauName":"Perdita","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"philophrosyne":{"id":"philophrosyne","iauName":"Philophrosyne","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"phobos":{"id":"phobos","iauName":"Phobos","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","mars","moons","synchronous","1877"]},"phoebe":{"id":"phoebe","iauName":"Phoebe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","norse group","retrograde","1899"]},"polydeuces":{"id":"polydeuces","iauName":"Polydeuces","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"portia":{"id":"portia","iauName":"Portia","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"praxidike":{"id":"praxidike","iauName":"Praxidike","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"prometheus":{"id":"prometheus","iauName":"Prometheus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"prospero":{"id":"prospero","iauName":"Prospero","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"proteus":{"id":"proteus","iauName":"Proteus","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons","regular moons","prograde","synchronous","1989"]},"psamathe":{"id":"psamathe","iauName":"Psamathe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"puck":{"id":"puck","iauName":"Puck","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"rhea":{"id":"rhea","iauName":"Rhea","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","outer moons","prograde","synchronous","1672"]},"rosalind":{"id":"rosalind","iauName":"Rosalind","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"s_2003_j_10":{"id":"s_2003_j_10","iauName":"S/2003 J 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_12":{"id":"s_2003_j_12","iauName":"S/2003 J 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_16":{"id":"s_2003_j_16","iauName":"S/2003 J 16","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_2":{"id":"s_2003_j_2","iauName":"S/2003 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_23":{"id":"s_2003_j_23","iauName":"S/2003 J 23","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_24":{"id":"s_2003_j_24","iauName":"S/2003 J 24","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_4":{"id":"s_2003_j_4","iauName":"S/2003 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2003_j_9":{"id":"s_2003_j_9","iauName":"S/2003 J 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2004_s_7":{"id":"s_2004_s_7","iauName":"S/2004 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_12":{"id":"s_2004_s_12","iauName":"S/2004 S 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_13":{"id":"s_2004_s_13","iauName":"S/2004 S 13","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_17":{"id":"s_2004_s_17","iauName":"S/2004 S 17","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_21":{"id":"s_2004_s_21","iauName":"S/2004 S 21","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_24":{"id":"s_2004_s_24","iauName":"S/2004 S 24","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_28":{"id":"s_2004_s_28","iauName":"S/2004 S 28","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_31":{"id":"s_2004_s_31","iauName":"S/2004 S 31","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_36":{"id":"s_2004_s_36","iauName":"S/2004 S 36","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_37":{"id":"s_2004_s_37","iauName":"S/2004 S 37","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_39":{"id":"s_2004_s_39","iauName":"S/2004 S 39","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_40":{"id":"s_2004_s_40","iauName":"S/2004 S 40","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_41":{"id":"s_2004_s_41","iauName":"S/2004 S 41","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_42":{"id":"s_2004_s_42","iauName":"S/2004 S 42","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_43":{"id":"s_2004_s_43","iauName":"S/2004 S 43","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_44":{"id":"s_2004_s_44","iauName":"S/2004 S 44","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_45":{"id":"s_2004_s_45","iauName":"S/2004 S 45","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_46":{"id":"s_2004_s_46","iauName":"S/2004 S 46","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_47":{"id":"s_2004_s_47","iauName":"S/2004 S 47","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_48":{"id":"s_2004_s_48","iauName":"S/2004 S 48","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_49":{"id":"s_2004_s_49","iauName":"S/2004 S 49","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_50":{"id":"s_2004_s_50","iauName":"S/2004 S 50","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_51":{"id":"s_2004_s_51","iauName":"S/2004 S 51","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_52":{"id":"s_2004_s_52","iauName":"S/2004 S 52","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2004_s_53":{"id":"s_2004_s_53","iauName":"S/2004 S 53","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2005_s_4":{"id":"s_2005_s_4","iauName":"S/2005 S 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2005_s_5":{"id":"s_2005_s_5","iauName":"S/2005 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_1":{"id":"s_2006_s_1","iauName":"S/2006 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_10":{"id":"s_2006_s_10","iauName":"S/2006 S 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_11":{"id":"s_2006_s_11","iauName":"S/2006 S 11","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_12":{"id":"s_2006_s_12","iauName":"S/2006 S 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_13":{"id":"s_2006_s_13","iauName":"S/2006 S 13","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_14":{"id":"s_2006_s_14","iauName":"S/2006 S 14","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_15":{"id":"s_2006_s_15","iauName":"S/2006 S 15","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_16":{"id":"s_2006_s_16","iauName":"S/2006 S 16","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_17":{"id":"s_2006_s_17","iauName":"S/2006 S 17","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_18":{"id":"s_2006_s_18","iauName":"S/2006 S 18","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_19":{"id":"s_2006_s_19","iauName":"S/2006 S 19","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_20":{"id":"s_2006_s_20","iauName":"S/2006 S 20","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_3":{"id":"s_2006_s_3","iauName":"S/2006 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2006_s_9":{"id":"s_2006_s_9","iauName":"S/2006 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_2":{"id":"s_2007_s_2","iauName":"S/2007 S 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_3":{"id":"s_2007_s_3","iauName":"S/2007 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_5":{"id":"s_2007_s_5","iauName":"S/2007 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_6":{"id":"s_2007_s_6","iauName":"S/2007 S 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_7":{"id":"s_2007_s_7","iauName":"S/2007 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_8":{"id":"s_2007_s_8","iauName":"S/2007 S 8","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2007_s_9":{"id":"s_2007_s_9","iauName":"S/2007 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2009_s_1":{"id":"s_2009_s_1","iauName":"S/2009 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2011_j_3":{"id":"s_2011_j_3","iauName":"S/2011 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2016_j_3":{"id":"s_2016_j_3","iauName":"S/2016 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2016_j_4":{"id":"s_2016_j_4","iauName":"S/2016 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2018_j_2":{"id":"s_2018_j_2","iauName":"S/2018 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2018_j_3":{"id":"s_2018_j_3","iauName":"S/2018 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2018_j_4":{"id":"s_2018_j_4","iauName":"S/2018 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2019_s_1":{"id":"s_2019_s_1","iauName":"S/2019 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_10":{"id":"s_2019_s_10","iauName":"S/2019 S 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_11":{"id":"s_2019_s_11","iauName":"S/2019 S 11","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_12":{"id":"s_2019_s_12","iauName":"S/2019 S 12","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_13":{"id":"s_2019_s_13","iauName":"S/2019 S 13","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_14":{"id":"s_2019_s_14","iauName":"S/2019 S 14","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_15":{"id":"s_2019_s_15","iauName":"S/2019 S 15","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_16":{"id":"s_2019_s_16","iauName":"S/2019 S 16","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_17":{"id":"s_2019_s_17","iauName":"S/2019 S 17","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_18":{"id":"s_2019_s_18","iauName":"S/2019 S 18","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_19":{"id":"s_2019_s_19","iauName":"S/2019 S 19","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_2":{"id":"s_2019_s_2","iauName":"S/2019 S 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_20":{"id":"s_2019_s_20","iauName":"S/2019 S 20","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_21":{"id":"s_2019_s_21","iauName":"S/2019 S 21","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_3":{"id":"s_2019_s_3","iauName":"S/2019 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_4":{"id":"s_2019_s_4","iauName":"S/2019 S 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_5":{"id":"s_2019_s_5","iauName":"S/2019 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_6":{"id":"s_2019_s_6","iauName":"S/2019 S 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_7":{"id":"s_2019_s_7","iauName":"S/2019 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_8":{"id":"s_2019_s_8","iauName":"S/2019 S 8","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2019_s_9":{"id":"s_2019_s_9","iauName":"S/2019 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_1":{"id":"s_2020_s_1","iauName":"S/2020 S 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_10":{"id":"s_2020_s_10","iauName":"S/2020 S 10","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_2":{"id":"s_2020_s_2","iauName":"S/2020 S 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_3":{"id":"s_2020_s_3","iauName":"S/2020 S 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_4":{"id":"s_2020_s_4","iauName":"S/2020 S 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_5":{"id":"s_2020_s_5","iauName":"S/2020 S 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_6":{"id":"s_2020_s_6","iauName":"S/2020 S 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_7":{"id":"s_2020_s_7","iauName":"S/2020 S 7","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_8":{"id":"s_2020_s_8","iauName":"S/2020 S 8","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2020_s_9":{"id":"s_2020_s_9","iauName":"S/2020 S 9","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"s_2021_j_1":{"id":"s_2021_j_1","iauName":"S/2021 J 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_2":{"id":"s_2021_j_2","iauName":"S/2021 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_3":{"id":"s_2021_j_3","iauName":"S/2021 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_4":{"id":"s_2021_j_4","iauName":"S/2021 J 4","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_5":{"id":"s_2021_j_5","iauName":"S/2021 J 5","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2021_j_6":{"id":"s_2021_j_6","iauName":"S/2021 J 6","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2022_j_1":{"id":"s_2022_j_1","iauName":"S/2022 J 1","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2022_j_2":{"id":"s_2022_j_2","iauName":"S/2022 J 2","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"s_2022_j_3":{"id":"s_2022_j_3","iauName":"S/2022 J 3","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"sao":{"id":"sao","iauName":"Sao","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"gridr":{"id":"gridr","iauName":"Gridr","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S20","saturn liv"]},"angrboda":{"id":"angrboda","iauName":"Angrboda","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S22","saturn lv"]},"skrymir":{"id":"skrymir","iauName":"Skrymir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S23","saturn lvi"]},"gerd":{"id":"gerd","iauName":"Gerd","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S25","saturn lvii"]},"saturn_lviii":{"id":"saturn_lviii","iauName":"Saturn LVIII","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"eggther":{"id":"eggther","iauName":"Eggther","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S27","saturn lix"]},"saturn_lx":{"id":"saturn_lx","iauName":"Saturn LX","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"beli":{"id":"beli","iauName":"Beli","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S30","saturn lxi"]},"gunnlod":{"id":"gunnlod","iauName":"Gunnlod","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S32","saturn lxii"]},"thiazzi":{"id":"thiazzi","iauName":"Thiazzi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S33","saturn lxiii"]},"saturn_lxiv":{"id":"saturn_lxiv","iauName":"Saturn LXIV","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"alvaldi":{"id":"alvaldi","iauName":"Alvaldi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S35","saturn lxv"]},"geirrod":{"id":"geirrod","iauName":"Geirrod","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons","S/2004 S38","saturn lxvi"]},"setebos":{"id":"setebos","iauName":"Setebos","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"siarnaq":{"id":"siarnaq","iauName":"Siarnaq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sinope":{"id":"sinope","iauName":"Sinope","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"skathi":{"id":"skathi","iauName":"Skathi","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"skoll":{"id":"skoll","iauName":"Skoll","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sponde":{"id":"sponde","iauName":"Sponde","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"stephano":{"id":"stephano","iauName":"Stephano","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"styx":{"id":"styx","iauName":"Styx","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","pluto","moons"]},"surtur":{"id":"surtur","iauName":"Surtur","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"suttungr":{"id":"suttungr","iauName":"Suttungr","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sycorax":{"id":"sycorax","iauName":"Sycorax","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"tarqeq":{"id":"tarqeq","iauName":"Tarqeq","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"tarvos":{"id":"tarvos","iauName":"Tarvos","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"taygete":{"id":"taygete","iauName":"Taygete","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"telesto":{"id":"telesto","iauName":"Telesto","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"tethys":{"id":"tethys","iauName":"Tethys","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","inner moons","prograde","synchronous","1684"]},"thalassa":{"id":"thalassa","iauName":"Thalassa","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","neptune","moons"]},"thebe":{"id":"thebe","iauName":"Thebe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"thelxinoe":{"id":"thelxinoe","iauName":"Thelxinoe","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"themisto":{"id":"themisto","iauName":"Themisto","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"thrymr":{"id":"thrymr","iauName":"Thrymr","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"thyone":{"id":"thyone","iauName":"Thyone","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"titan":{"id":"titan","iauName":"Titan","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","saturn","moons","outer moons","prograde","synchronous","1655"]},"titania":{"id":"titania","iauName":"Titania","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1787"]},"trinculo":{"id":"trinculo","iauName":"Trinculo","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","uranus","moons"]},"triton":{"id":"triton","iauName":"Triton","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","neptune","moons","irregular moons","retrograde","synchronous","1846"]},"umbriel":{"id":"umbriel","iauName":"Umbriel","category":"Moon","subcategory":"Major Moon","keywords":["major moon","solar system","uranus","moons","prograde","synchronous","1851"]},"ymir":{"id":"ymir","iauName":"Ymir","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","saturn","moons"]},"sc_ace":{"id":"sc_ace","iauName":"ACE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_acrimsat":{"id":"sc_acrimsat","iauName":"ACRIMSAT","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_acs3":{"id":"sc_acs3","iauName":"ACS3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"],"disabled":true},"sc_aqua":{"id":"sc_aqua","iauName":"Aqua","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_artemis_1":{"id":"sc_artemis_1","iauName":"Artemis I","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_aura":{"id":"sc_aura","iauName":"Aura","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_biosentinel":{"id":"sc_biosentinel","iauName":"BioSentinel","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_calipso":{"id":"sc_calipso","iauName":"CALIPSO","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_capstone":{"id":"sc_capstone","iauName":"CAPSTONE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_cassini":{"id":"sc_cassini","iauName":"Cassini","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","saturn"],"hasEvents":true},"sc_clementine":{"id":"sc_clementine","iauName":"Clementine","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_cloudsat":{"id":"sc_cloudsat","iauName":"CloudSat","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm5":{"id":"sc_cluster_ii_fm5","iauName":"Rumba","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm6":{"id":"sc_cluster_ii_fm6","iauName":"Salsa","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm7":{"id":"sc_cluster_ii_fm7","iauName":"Samba","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cluster_ii_fm8":{"id":"sc_cluster_ii_fm8","iauName":"Tango","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_1":{"id":"sc_cygnss_1","iauName":"CYGNSS 1","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_2":{"id":"sc_cygnss_2","iauName":"CYGNSS 2","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_3":{"id":"sc_cygnss_3","iauName":"CYGNSS 3","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_4":{"id":"sc_cygnss_4","iauName":"CYGNSS 4","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_5":{"id":"sc_cygnss_5","iauName":"CYGNSS 5","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_6":{"id":"sc_cygnss_6","iauName":"CYGNSS 6","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_7":{"id":"sc_cygnss_7","iauName":"CYGNSS 7","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_cygnss_8":{"id":"sc_cygnss_8","iauName":"CYGNSS 8","category":"Spacecraft","subcategory":"Orbiter","constellation":"CYGNSS","keywords":["spacecraft","earth","orbiter"]},"sc_dart":{"id":"sc_dart","iauName":"DART","category":"Spacecraft","subcategory":"Impactor","altName":"boom","keywords":["spacecraft","65803_didymos","dimorphos","asteroid"],"hasEvents":true},"sc_dawn":{"id":"sc_dawn","iauName":"Dawn","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","vesta","ceres","small body mission"],"related":{"asteroid":["4_vesta","1_ceres"]},"hasEvents":true},"sc_deep_impact":{"id":"sc_deep_impact","iauName":"Deep Impact","category":"Spacecraft","subcategory":"Flyby","altName":"DI","keywords":["spacecraft","tempel 1","small body mission"],"related":{"comet":["9p_temp_1"]},"hasEvents":true},"sc_deep_impact_impactor":{"id":"sc_deep_impact_impactor","iauName":"Deep Impact Impactor","category":"Spacecraft","subcategory":"Impactor","altName":"DII","keywords":["spacecraft","tempel 1","small body mission"],"related":{"comet":["9p_temp_1"]},"hasEvents":true},"sc_deep_impact_impactor_impact_site":{"id":"sc_deep_impact_impactor_impact_site","displayName":"Deep Impact Impactor Impact Site","category":"Landing site","comparisonFeature":false},"sc_deep_space_1":{"id":"sc_deep_space_1","iauName":"Deep Space 1","category":"Spacecraft","subcategory":"Flyby","altName":"DS1","keywords":["spacecraft","9660 Braille","19p/Borrelly","small body mission"],"related":{"asteroid":["9969_braille"],"comet":["19p_borrelly"]},"hasEvents":true},"sc_eo_1":{"id":"sc_eo_1","iauName":"EO-1","category":"Spacecraft","subcategory":"Orbiter","altName":"Earth Observing-1","keywords":["spacecraft","earth","orbiter"]},"sc_euclid":{"id":"sc_euclid","iauName":"Euclid","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope"],"disabled":false},"sc_europa_clipper":{"id":"sc_europa_clipper","iauName":"Europa Clipper","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","europa"]},"sc_explorer_1":{"id":"sc_explorer_1","iauName":"Explorer 1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_galileo":{"id":"sc_galileo","iauName":"Galileo","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","outer planet mission","orbiter","jupiter"],"hasEvents":true},"sc_galileo_probe":{"id":"sc_galileo_probe","iauName":"Galileo Probe","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","outer planet mission","orbiter","jupiter"],"hasEvents":true},"sc_geotail":{"id":"sc_geotail","iauName":"Geotail","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_gpm":{"id":"sc_gpm","iauName":"GPM","category":"Spacecraft","subcategory":"Orbiter","altName":"Global Precipitation Measurement","keywords":["spacecraft","earth","orbiter"]},"sc_grace_1":{"id":"sc_grace_1","iauName":"GRACE-1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_grace_2":{"id":"sc_grace_2","iauName":"GRACE-2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_grace_fo1":{"id":"sc_grace_fo1","iauName":"GRACE-FO1","category":"Spacecraft","subcategory":"Orbiter","altName":"GRACE Follow-On","keywords":["spacecraft","earth","orbiter"]},"sc_grace_fo2":{"id":"sc_grace_fo2","iauName":"GRACE-FO2","category":"Spacecraft","subcategory":"Orbiter","altName":"GRACE Follow-On","keywords":["spacecraft","earth","orbiter"]},"sc_grail_a":{"id":"sc_grail_a","iauName":"GRAIL A","category":"Spacecraft","subcategory":"Orbiter","altName":"Ebb","keywords":["spacecraft","moon","orbiter","ebb"]},"sc_grail_b":{"id":"sc_grail_b","iauName":"GRAIL B","category":"Spacecraft","subcategory":"Orbiter","altName":"Flow","keywords":["spacecraft","moon","orbiter","flow"]},"sc_grifex":{"id":"sc_grifex","iauName":"GRIFEX","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_hubble_space_telescope":{"id":"sc_hubble_space_telescope","iauName":"Hubble Space Telescope","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope","1990"]},"sc_huygens":{"id":"sc_huygens","iauName":"Huygens","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","titan","cassini","lander"],"hasEvents":true},"sc_ibex":{"id":"sc_ibex","iauName":"IBEX","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_icesat_2":{"id":"sc_icesat_2","iauName":"ICESat-2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_image":{"id":"sc_image","iauName":"IMAGE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_insight":{"id":"sc_insight","iauName":"InSight","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","mars","lander","seismic","2018"],"landingDate":"2018-11-26T19:45:00"},"sc_ipex":{"id":"sc_ipex","iauName":"IPEX","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_isas":{"id":"sc_isas","iauName":"ISAS","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_iss":{"id":"sc_iss","iauName":"International Space Station","category":"Spacecraft","subcategory":"Orbiter","altName":"ISS","keywords":["iss","international","international space","station","earth","orbiter","1998","emit","ecostress","oco-3"],"customDistance":0.1},"sc_iss_ecostress":{"id":"sc_iss_ecostress","iauName":"ECOSTRESS","category":"Instrument","cameraOptions":{"forwardVector":"-y-axis"},"comparisonFeature":false,"keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_emit":{"id":"sc_iss_emit","iauName":"EMIT","category":"Instrument","cameraOptions":{"forwardVector":"y-axis","distance":0.006},"comparisonFeature":false,"altName":"Earth Surface Mineral Dust Source Investigation","keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_oco_3":{"id":"sc_iss_oco_3","iauName":"OCO-3","category":"Instrument","cameraOptions":{"forwardVector":"-y-axis"},"comparisonFeature":false,"altName":"Orbiting Carbon Observatory 3","keywords":["spacecraft","earth","iss","orbiter"]},"sc_iss_rapidscat":{"id":"sc_iss_rapidscat","iauName":"RapidScat","category":"Instrument","cameraOptions":{"upVector":"-y-axis","forwardVector":"x-axis","distance":0.007},"comparisonFeature":false,"keywords":["spacecraft","earth","iss","orbiter"]},"sc_ixpe":{"id":"sc_ixpe","iauName":"IXPE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope","2021","x-ray","imaging x-ray polarimetry explorer","cosmic x-rays"]},"sc_jason_1":{"id":"sc_jason_1","iauName":"Jason-1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_jason_2":{"id":"sc_jason_2","iauName":"Jason-2/OSTM","category":"Spacecraft","subcategory":"Orbiter","altName":"OSTM","keywords":["spacecraft","earth","orbiter","jason-2"]},"sc_jason_3":{"id":"sc_jason_3","iauName":"Jason-3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_juice":{"id":"sc_juice","iauName":"Juice","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","jupiter","orbiter"]},"sc_juno":{"id":"sc_juno","iauName":"Juno","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","jupiter","orbiter","gravity","magnetic field","atmosphere","junocam","bruh","2011"],"customDistance":0.04,"hasEvents":true},"sc_jwst":{"id":"sc_jwst","iauName":"James Webb Space Telescope","category":"Spacecraft","subcategory":"Orbiter","altName":"James Webb Space Telescope","keywords":["spacecraft","earth","orbiter","telescope","jwst"],"hasEvents":true},"sc_kepler_space_telescope":{"id":"sc_kepler_space_telescope","iauName":"Kepler","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","telescope"]},"sc_ladee":{"id":"sc_ladee","iauName":"LADEE","category":"Spacecraft","subcategory":"Orbiter","altName":"Lunar Atmosphere and Dust Environment Explorer","keywords":["spacecraft","moon","orbiter"]},"sc_landsat_7":{"id":"sc_landsat_7","iauName":"Landsat 7","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_landsat_8":{"id":"sc_landsat_8","iauName":"Landsat 8","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_landsat_9":{"id":"sc_landsat_9","iauName":"Landsat 9","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_lcross":{"id":"sc_lcross","iauName":"LCROSS","category":"Spacecraft","subcategory":"Orbiter","altName":"Lunar Crater Observation and Sensing Satellite","keywords":["spacecraft","moon","orbiter"],"hasEvents":true},"sc_lucy":{"id":"sc_lucy","iauName":"Lucy","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"],"hasEvents":true},"sc_lunar_flashlight":{"id":"sc_lunar_flashlight","iauName":"Lunar Flashlight","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_lunar_icecube":{"id":"sc_lunar_icecube","iauName":"Lunar IceCube","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_lunar_prospector":{"id":"sc_lunar_prospector","iauName":"Lunar Prospector","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_lunar_reconnaissance_orbiter":{"id":"sc_lunar_reconnaissance_orbiter","iauName":"Lunar Reconnaissance Orbiter","category":"Spacecraft","subcategory":"Orbiter","altName":"LRO","keywords":["spacecraft","moon","orbiter","lro","temperature","imaging","albedo","polar","2009"]},"sc_lunar_trailblazer":{"id":"sc_lunar_trailblazer","iauName":"Lunar Trailblazer","category":"Spacecraft","subcategory":"Orbiter","altName":"","keywords":["spacecraft","moon","orbiter","lunar","trailblazer","water"],"disabled":true},"sc_lunir":{"id":"sc_lunir","iauName":"Lunar Reconnaissance Orbiter","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter","artemis"],"disabled":true},"sc_magellan":{"id":"sc_magellan","iauName":"Magellan","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","inner planet mission","venus"]},"sc_marco_a":{"id":"sc_marco_a","iauName":"MarCO A","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","insight","cubesat"]},"sc_marco_b":{"id":"sc_marco_b","iauName":"MarCO B","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","insight","cubesat"]},"sc_mars_2020":{"id":"sc_mars_2020","iauName":"Mars 2020 (Perseverance)","category":"Spacecraft","subcategory":"Rover","altName":"Percy","keywords":["spacecraft","mars","lander","rover","perseverance","mars 2020","mars2020","m2020"],"landingDate":"2021-02-18T20:55:00"},"sc_mars_2020_landing_site":{"id":"sc_mars_2020_landing_site","displayName":"Perseverance Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_exploration_rover_1_landing_site":{"id":"sc_mars_exploration_rover_1_landing_site","displayName":"Opportunity Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_exploration_rover_1":{"id":"sc_mars_exploration_rover_1","iauName":"Mars Exploration Rover B (Opportunity)","displayName":"Opportunity","category":"Spacecraft","subcategory":"Rover","keywords":["spacecraft","mars","lander","rover","opportunity","meridiani planum","2003","MER-B","MER-1","mer b"],"landingDate":"2004-01-25T04:54:00"},"sc_mars_exploration_rover_2_landing_site":{"id":"sc_mars_exploration_rover_2_landing_site","displayName":"Spirit Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_exploration_rover_2":{"id":"sc_mars_exploration_rover_2","iauName":"Mars Exploration Rover A (Spirit)","displayName":"Spirit","category":"Spacecraft","subcategory":"Rover","keywords":["spacecraft","mars","lander","rover","spirit","MER-A","MER-2","mer a"],"landingDate":"2004-01-25T04:54:00"},"sc_mars_express":{"id":"sc_mars_express","iauName":"Mars Express","category":"Spacecraft","subcategory":"Orbiter","altName":"MEX","keywords":["spacecraft","mars","orbiter","water","geology","atmosphere","surface","relay","2003"]},"sc_mars_global_surveyor":{"id":"sc_mars_global_surveyor","iauName":"Mars Global Surveyor","category":"Spacecraft","subcategory":"Orbiter","altName":"MGS","keywords":["spacecraft","mars","MGS"]},"sc_mars_odyssey":{"id":"sc_mars_odyssey","iauName":"Mars Odyssey","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","mars","orbiter","elements","minerals","hydrogen","water","polar","radiation","relay","2001"]},"sc_mars_reconnaissance_orbiter":{"id":"sc_mars_reconnaissance_orbiter","iauName":"Mars Reconnaissance Orbiter","category":"Spacecraft","subcategory":"Orbiter","altName":"MRO","keywords":["spacecraft","mars","orbiter","mro","water","dust","atmosphere","relay","2005"]},"sc_mars_science_laboratory_landing_site":{"id":"sc_mars_science_laboratory_landing_site","displayName":"Curiosity Rover landing site","category":"Landing site","comparisonFeature":false},"sc_mars_science_laboratory":{"id":"sc_mars_science_laboratory","iauName":"Mars Science Laboratory (Curiosity)","displayName":"Mars Science Laboratory (Curiosity)","category":"Spacecraft","subcategory":"Rover","altName":"MSL","keywords":["spacecraft","mars","lander","rover","msl","curiosity","microbes","habitability","2011"],"landingDate":"2012-08-06T05:32:00"},"sc_maven":{"id":"sc_maven","iauName":"MAVEN","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","mars","orbiter","atmosphere","ionosphere","solar wind","relay","2013"]},"sc_messenger":{"id":"sc_messenger","iauName":"MESSENGER","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","mercury","orbiter"]},"sc_messenger_impact_site":{"id":"sc_messenger_impact_site","displayName":"MESSENGER Impact Site","category":"Landing site","comparisonFeature":false},"sc_mcubed_2":{"id":"sc_mcubed_2","iauName":"M-Cubed 2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_1":{"id":"sc_mms_1","iauName":"MMS 1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_2":{"id":"sc_mms_2","iauName":"MMS 2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_3":{"id":"sc_mms_3","iauName":"MMS 3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_mms_4":{"id":"sc_mms_4","iauName":"MMS 4","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_near_shoemaker":{"id":"sc_near_shoemaker","iauName":"NEAR Shoemaker","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","eros","orbiter"],"related":{"asteroid":["433_eros"]},"hasEvents":true},"sc_new_horizons":{"id":"sc_new_horizons","iauName":"New Horizons","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","pluto","flyby","imager","spectrometer","ultraviolet","solar wind","extended mission","2006"],"hasEvents":true},"sc_nustar":{"id":"sc_nustar","iauName":"NuSTAR","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","telescope","X-ray","astrophysics"]},"sc_oco_2":{"id":"sc_oco_2","iauName":"OCO-2","category":"Spacecraft","subcategory":"Orbiter","altName":"Orbiting Carbon Observatory 2","keywords":["spacecraft","earth","orbiter"]},"sc_osiris_rex":{"id":"sc_osiris_rex","iauName":"OSIRIS-APEX","category":"Spacecraft","subcategory":"Orbiter","altName":"ORX","keywords":["spacecraft","bennu","apex","osiris-apex","lander","sample return","asteroids","chemistry","mineralogy","2016"],"related":{"asteroid":["101955_bennu","99942_apophis"]},"hasEvents":true},"sc_osiris_rex_src":{"id":"sc_osiris_rex_src","iauName":"OSIRIS-REx Sample Return Capsule","category":"Spacecraft","subcategory":"Flyby","altName":"ORX SRC","keywords":["spacecraft","Bennu","orbiter","sc_osiris_rex","SRC","sample return"],"related":{"asteroid":["101955_bennu"]},"hasEvents":true},"sc_pace":{"id":"sc_pace","iauName":"PACE","altName":"Plankton, Aerosol, Cloud, ocean Ecosystem","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_parker_solar_probe":{"id":"sc_parker_solar_probe","iauName":"Parker Solar Probe","category":"Spacecraft","subcategory":"Orbiter","altName":"PSP","keywords":["spacecraft","psp"]},"sc_philae":{"id":"sc_philae","iauName":"Philae","category":"Spacecraft","subcategory":"Lander","keywords":["spacecraft","67P/Churyumov-Gerasimenko","lander","Rosetta"],"related":{"comet":["67p_churyumov_gerasimenko"]},"hasEvents":true},"sc_phoenix":{"id":"sc_phoenix","iauName":"Phoenix","category":"Spacecraft","subcategory":"Lander","altName":"PHX","keywords":["spacecraft","mars","lander"],"landingDate":"2008-05-25T23:53:44"},"sc_phoenix_landing_site":{"id":"sc_phoenix_landing_site","displayName":"Phoenix landing site","category":"Landing site","comparisonFeature":false},"sc_pioneer_10":{"id":"sc_pioneer_10","iauName":"Pioneer 10","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","callisto","ganymede","europa","io","flyby","outer planets","interstellar","1972"],"hasEvents":true},"sc_pioneer_11":{"id":"sc_pioneer_11","iauName":"Pioneer 11","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","callisto","ganymede","io","europa","amalthea","saturn","iapetus","phoebe","hyperion","epimetheus","atlas","dione","mimas","janus","tethys","enceladus","calypso","rhea","titan","flyby","magnetic field","solar wind","outer planets","interstellar","1973"],"hasEvents":true},"sc_polar":{"id":"sc_polar","iauName":"Polar","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_prefire_1":{"id":"sc_prefire_1","iauName":"PREFIRE-1","category":"Spacecraft","subcategory":"Orbiter","constellation":"PREFIRE","keywords":["spacecraft","earth","orbiter"]},"sc_prefire_2":{"id":"sc_prefire_2","iauName":"PREFIRE-2","category":"Spacecraft","subcategory":"Orbiter","constellation":"PREFIRE","keywords":["spacecraft","earth","orbiter"]},"sc_psyche":{"id":"sc_psyche","iauName":"Psyche","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","16 Psyche","orbiter"],"related":{"asteroid":["16_psyche"]},"hasEvents":true},"sc_quikscat":{"id":"sc_quikscat","iauName":"QuikSCAT","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_raincube":{"id":"sc_raincube","iauName":"RainCube","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","cubesat"]},"sc_rbsp_a":{"id":"sc_rbsp_a","iauName":"Van Allen Probe A","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_rbsp_b":{"id":"sc_rbsp_b","iauName":"Van Allen Probe B","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_sac_d":{"id":"sc_sac_d","iauName":"Aquarius","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_rosetta":{"id":"sc_rosetta","iauName":"Rosetta","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","small body mission","67P/Churyumov-Gerasimenko"],"related":{"comet":["67p_churyumov_gerasimenko"]},"hasEvents":true},"sc_sdo":{"id":"sc_sdo","iauName":"Solar Dynamics Observatory","category":"Spacecraft","subcategory":"Orbiter","altName":"SDO","keywords":["spacecraft","earth","orbiter"]},"sc_sentinel_6":{"id":"sc_sentinel_6","iauName":"Sentinel-6 Michael Freilich","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter","2020","sea level","jason","jason-cs","copernicus","topex/poseidon"]},"sc_smap":{"id":"sc_smap","iauName":"SMAP","category":"Spacecraft","subcategory":"Orbiter","altName":"Soil Moisture Active Passive","keywords":["spacecraft","earth","orbiter"]},"sc_soho":{"id":"sc_soho","iauName":"SOHO","category":"Spacecraft","subcategory":"Orbiter","altName":"Solar and Heliospheric Observatory","keywords":["spacecraft","sun","orbiter"]},"sc_sorce":{"id":"sc_sorce","iauName":"SORCE","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_spitzer":{"id":"sc_spitzer","iauName":"Spitzer Space Telescope","category":"Spacecraft","subcategory":"Orbiter","altName":"SIRTF","keywords":["spacecraft","sun","orbiter","sirtf","space infrared telescope facility","spitzer space telescope","2003"]},"sc_stardust":{"id":"sc_stardust","iauName":"Stardust","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","Wild-2","orbiter"],"related":{"comet":["81p_wild_2"]},"hasEvents":true},"sc_stardust_src":{"id":"sc_stardust_src","iauName":"Stardust Sample Return Capsule","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","Wild-2","orbiter"],"related":{"comet":["81p_wild_2"]}},"sc_starling_1":{"id":"sc_starling_1","iauName":"Starling-1","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_starling_2":{"id":"sc_starling_2","iauName":"Starling-2","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_starling_3":{"id":"sc_starling_3","iauName":"Starling-3","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_starling_4":{"id":"sc_starling_4","iauName":"Starling-4","category":"Spacecraft","subcategory":"Orbiter","constellation":"STARLING","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_stereo_ahead":{"id":"sc_stereo_ahead","iauName":"STEREO Ahead","category":"Spacecraft","subcategory":"Orbiter","altName":"STA","keywords":["spacecraft","sun","orbiter","solar terrestrial relations observatory","stereoscopic","coronal mass ejections","cme","2006"]},"sc_stereo_behind":{"id":"sc_stereo_behind","iauName":"STEREO Behind","category":"Spacecraft","subcategory":"Orbiter","altName":"STB","keywords":["spacecraft","sun","orbiter","solar terrestrial relations observatory","stereoscopic","coronal mass ejections","cme","2006"]},"sc_tdrs_3":{"id":"sc_tdrs_3","iauName":"TDRS-3","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_5":{"id":"sc_tdrs_5","iauName":"TDRS-5","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_6":{"id":"sc_tdrs_6","iauName":"TDRS-6","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_7":{"id":"sc_tdrs_7","iauName":"TDRS-7","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_8":{"id":"sc_tdrs_8","iauName":"TDRS-8","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_9":{"id":"sc_tdrs_9","iauName":"TDRS-9","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_10":{"id":"sc_tdrs_10","iauName":"TDRS-10","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_11":{"id":"sc_tdrs_11","iauName":"TDRS-11","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_12":{"id":"sc_tdrs_12","iauName":"TDRS-12","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_tdrs_13":{"id":"sc_tdrs_13","iauName":"TDRS-13","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","orbiter"]},"sc_suomi_npp":{"id":"sc_suomi_npp","iauName":"Suomi NPP","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_swot":{"id":"sc_swot","iauName":"SWOT","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_tempo":{"id":"sc_tempo","iauName":"TEMPO","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_terra":{"id":"sc_terra","iauName":"Terra","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_tess":{"id":"sc_tess","iauName":"TESS","category":"Spacecraft","subcategory":"Orbiter","altName":"Transiting Exoplanet Survey Satellite","keywords":["spacecraft","earth","telescope","transiting exoplanet survey satellite","orbiter","2018","exoplanets"]},"sc_themis_a":{"id":"sc_themis_a","iauName":"THEMIS-A","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_themis_b":{"id":"sc_themis_b","iauName":"ARTEMIS P1","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_themis_c":{"id":"sc_themis_c","iauName":"ARTEMIS P2","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","moon","orbiter"]},"sc_themis_d":{"id":"sc_themis_d","iauName":"THEMIS-D","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_themis_e":{"id":"sc_themis_e","iauName":"THEMIS-E","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_trace_gas_orbiter":{"id":"sc_trace_gas_orbiter","iauName":"Trace Gas Orbiter","category":"Spacecraft","subcategory":"Orbiter","altName":"TGO","keywords":["spacecraft","mars","orbiter","tgo","atmosphere","relay","2016"]},"sc_trmm":{"id":"sc_trmm","iauName":"TRMM","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","earth","orbiter"]},"sc_tropics_03":{"id":"sc_tropics_03","iauName":"TROPICS-03","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_05":{"id":"sc_tropics_05","iauName":"TROPICS-05","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_06":{"id":"sc_tropics_06","iauName":"TROPICS-06","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_07":{"id":"sc_tropics_07","iauName":"TROPICS-07","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter"],"disabled":false},"sc_tropics_01":{"id":"sc_tropics_01","iauName":"TROPICS-01","category":"Spacecraft","subcategory":"Orbiter","constellation":"TROPICS","keywords":["spacecraft","earth","orbiter","tropics pathfinder","pathfinder"],"disabled":false},"sc_ulysses":{"id":"sc_ulysses","iauName":"Ulysses","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","sun","orbiter"]},"sc_voyager_1":{"id":"sc_voyager_1","iauName":"Voyager 1","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","saturn","flyby","imaging","vger","radio science","infrared","ultraviolet","magnetometer","plasma","1977"],"hasEvents":true},"sc_voyager_2":{"id":"sc_voyager_2","iauName":"Voyager 2","category":"Spacecraft","subcategory":"Flyby","keywords":["spacecraft","jupiter","saturn","uranus","vger","neptune","flyby","imaging","radio science","infrared","ultraviolet","magnetometer","plasma","1977"],"hasEvents":true},"sc_wind":{"id":"sc_wind","iauName":"WIND","category":"Spacecraft","subcategory":"Orbiter","keywords":["spacecraft","solar wind","earth","orbiter"]},"valetudo":{"id":"valetudo","iauName":"Valetudo","category":"Moon","subcategory":"Minor Moon","keywords":["minor moon","solar system","jupiter","moons"]},"scientist":{"id":"scientist","displayName":"Scientist","category":"Human","searchable":false},"school_bus":{"id":"school_bus","displayName":"School Bus","category":"Vehicle","searchable":false},"rose_bowl":{"id":"rose_bowl","displayName":"Stadium","category":"Building","searchable":false}}');

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	!function() {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = function(result, chunkIds, fn, priority) {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var chunkIds = deferred[i][0];
/******/ 				var fn = deferred[i][1];
/******/ 				var priority = deferred[i][2];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	!function() {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = function(module) {
/******/ 			var getter = module && module.__esModule ?
/******/ 				function() { return module['default']; } :
/******/ 				function() { return module; };
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	!function() {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = function(exports, definition) {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	!function() {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	!function() {
/******/ 		__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	!function() {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = function(exports) {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	!function() {
/******/ 		__webpack_require__.nmd = function(module) {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	}();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	!function() {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = function(chunkId) { return installedChunks[chunkId] === 0; };
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = function(parentChunkLoadingFunction, data) {
/******/ 			var chunkIds = data[0];
/******/ 			var moreModules = data[1];
/******/ 			var runtime = data[2];
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some(function(id) { return installedChunks[id] !== 0; })) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkasteroids"] = self["webpackChunkasteroids"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	}();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["vendors"], function() { return __webpack_require__("./src/app.js"); })
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;
//# sourceMappingURL=app.js.map