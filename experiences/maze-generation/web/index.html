<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Maze Generation</title>

    <link rel="stylesheet" type="text/css" href="./style.css" />
    <script
      type="text/javascript"
      src="./footron-messaging.development.js"
    ></script>
    <script>
      if (typeof module === "object") {
        window.module = module
        module = undefined
      }
    </script>
    <script src="./p5.min.js" type="text/javascript"></script>
    <link
      rel="preload"
      href="./Urbanist-Medium.ttf"
      as="font"
      type="font/ttf"
      crossorigin
    />
  </head>
  <body>
    <div id="sidebar">
      <div id="sidebar-title">Generating Mazes</div>

      <div id="sidebar-content">
        In math terms, a maze can be described as a "spanning tree" â€” a graph
        where all vertices are connected together without looping.
        <br /><br />

        There are multiple different algorithms to generate random spanning
        trees, and each exhibits different behavior. By coloring maze cells
        according to distance from the maze origin, we can see different
        patterns in the algorithms.
        <br /><br />

        Each maze starts in the upper-left corner and finishes in the
        bottom-right corner. The solution is calculated and drawn in red once
        the maze is finished.
        <br /><br />
      </div>
    </div>
    <div class="container show-three">
      <div id="recursive-backtracker-description">
        The <strong>Recursive Backtracker</strong> algorithm works by "walking"
        randomly across the grid and adding unvisited cells to the maze. If it
        hits a cell that's part of the maze, it backtracks until it finds an
        adjacent unvisited cell.
      </div>
      <div id="prims-description">
        <strong>Prim's Algorithm</strong> initializes each possible connection
        between vertices with a random weight. It chooses the next cell to add
        by getting all of the adjacent cells to the current grid and picking the
        one with the smallest weight.
      </div>
      <div id="wilsons-description">
        <strong>Wilson's Algorithm</strong> picks a random unvisited cell, then
        performs a loop-erased random walk until it collides with the grid. It
        becomes inefficient with large maze sizes.
      </div>
      <div id="random-traversal-description">
        The <strong>Random Traversal</strong> algorithm chooses the next cell by
        picking a random cell out of all the adjacent cells to the current grid.
      </div>
    </div>
    <script type="module" src="/main.js"></script>
  </body>
</html>
